{"meta":{"title":"Bezhuang's Blog","subtitle":"庄之皓的博客网站","description":"Bezhuang's Blog","author":"Bezhuang","url":"http://blog.zhuangzhihao.top","root":"/"},"pages":[{"title":"","date":"2022-03-11T06:57:36.014Z","updated":"2022-03-05T09:02:25.837Z","comments":true,"path":"404.html","permalink":"http://blog.zhuangzhihao.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2022-03-11T06:57:36.014Z","updated":"2022-03-05T09:02:25.846Z","comments":true,"path":"categories/index.html","permalink":"http://blog.zhuangzhihao.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-09T07:49:18.740Z","updated":"2022-06-09T07:49:18.730Z","comments":true,"path":"about/index.html","permalink":"http://blog.zhuangzhihao.top/about/index.html","excerpt":"","text":"关于我 庄之皓，Bezhuang 手机：13818993049 邮箱：bezhuang@outlook.com 兴趣爱好：篮球、足球、F1 …"},{"title":"","date":"2022-03-11T06:57:36.012Z","updated":"2022-03-05T09:02:25.862Z","comments":false,"path":"projects/index.html","permalink":"http://blog.zhuangzhihao.top/projects/index.html","excerpt":"","text":"项目内容索引 开源贡献 项目仓库"},{"title":"所有标签","date":"2022-03-11T06:57:36.014Z","updated":"2022-03-05T09:02:25.862Z","comments":true,"path":"tags/index.html","permalink":"http://blog.zhuangzhihao.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 基础数据结构","slug":"JS数据结构和算法","date":"2022-07-06T16:00:00.000Z","updated":"2022-07-07T13:26:52.088Z","comments":true,"path":"JS数据结构和算法/","link":"","permalink":"http://blog.zhuangzhihao.top/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","excerpt":"freeCodeCamp JavaScript 算法和数据结构第五章。我们可以通过多种方式存储和访问数据，例如数组和对象，都是常见的 JavaScript 数据结构。在基础数据结构课程中，更深入地了解数组和对象之间的差异，以及在不同情况下应该使用哪个，学习一些好用的 JS 方法，例如 splice()，以及使用 Object.keys() 来访问和操作数据。","text":"freeCodeCamp JavaScript 算法和数据结构第五章。我们可以通过多种方式存储和访问数据，例如数组和对象，都是常见的 JavaScript 数据结构。在基础数据结构课程中，更深入地了解数组和对象之间的差异，以及在不同情况下应该使用哪个，学习一些好用的 JS 方法，例如 splice()，以及使用 Object.keys() 来访问和操作数据。 一、数组一维数组（one-dimensional array）只有一层，只包含布尔值（booleans）、字符串（strings）、数字（numbers）以及 JavaScript 中的其他数据类型，所有数组都有一个表示长度的属性，我们可以通过 Array.length 来访问它。： 12let simpleArray = [&#x27;one&#x27;, 2, &#x27;three&#x27;, true, false, undefined, null];console.log(simpleArray.length); // 7 多维数组 （multi-dimensional Array）或嵌套（nested）数组是一个包含了其他数组的数组，在它的内部还包含了 JavaScript 中的对象（objects）结构： 12345678910111213141516171819202122let complexArray = [ [ &#123; one: 1, two: 2 &#125;, &#123; three: 3, four: 4 &#125; ], [ &#123; a: &quot;a&quot;, b: &quot;b&quot; &#125;, &#123; c: &quot;c&quot;, d: &quot;d&quot; &#125; ]]; 在数组中，内部的每个元素都有一个与之对应的索引（index）。 索引既是该元素在数组中的位置，也是我们访问该元素的引用。 JavaScript 数组的索引是从 0 开始的（这种从 0 开始的规则叫做 zero-indexed），即数组的第一个元素是在数组中的第 0 个位置，而不是第 1 个位置。 要从数组中获取一个元素，我们可以在数组字面量后面加一个用方括号括起来的索引。不过习惯上，我们会通过表示数组的变量名来访问，而不是直接通过字面量。 这种从数组中读取元素的方式叫做方括号表示法（bracket notation）。 如果我们要从数组 ourArray 中取出数据 a 并将其赋值给另一个变量，可以这样写： 1let ourVariable = ourArray[0]; 通过索引，我们不仅可以获取某个元素值，还可以用类似的写法来设置一个索引位置的元素值： 1ourArray[1] = &quot;not b anymore&quot;; 二、添加、删除元素数组的长度与数组能包含的数据类型一样，都是不固定的。 数组可以包含任意数量的元素，可以不限次数地往数组中添加元素或者从中移除元素。 总之，数组是可变的（mutable）。 push() 方法会将元素插入到数组的末尾，而 unshift() 方法会将元素插入到数组的开头： 1234let twentyThree = &#x27;XXIII&#x27;;let romanNumerals = [&#x27;XXI&#x27;, &#x27;XXII&#x27;];romanNumerals.unshift(&#x27;XIX&#x27;, &#x27;XX&#x27;);romanNumerals.push(twentyThree); push() 和 unshift() 都有一个与它们作用相反的函数：pop() 和 shift()。 与插入元素相反，pop() 会从数组的末尾移除一个元素，而 shift() 会从数组的开头移除一个元素。 pop() 和 shift() 与 push() 和 unshift() 的关键区别在于，用于删除元素的方法不接收参数，而且每次只能删除数组中的一个元素。 123let greetings = [&#x27;whats up?&#x27;, &#x27;hello&#x27;, &#x27;see ya!&#x27;];let popped = greetings.pop(); // greetings 值为 [&#x27;whats up?&#x27;, &#x27;hello&#x27;]，popped 值为 see ya!greetings.shift(); //greetings 值为 [&#x27;hello&#x27;] splice() 可以让我们从数组中的任意位置连续删除任意数量的元素。splice() 最多可以接受 3 个参数。 splice() 的前两个参数是整数，表示数组中调用 splice() 的项的索引或位置，第一个参数代表从数组中的哪个索引开始移除元素，而第二个参数表示要从数组中的这个位置开始删除多少个元素。 splice() 不仅会修改调用该方法的数组，还会返回一个包含被移除元素的数组： 12let array = [&#x27;I&#x27;, &#x27;am&#x27;, &#x27;feeling&#x27;, &#x27;really&#x27;, &#x27;happy&#x27;];let newArray = array.splice(3, 2); // [&#x27;really&#x27;, &#x27;happy&#x27;] splice() 方法的第三个参数可以是一个或多个元素，这些元素会被添加到数组中。 这样，我们能够便捷地将数组中的一个或多个连续元素换成其他的元素。 12345const numbers = [10, 11, 12, 12, 15];const startIndex = 3;const amountToDelete = 1;numbers.splice(startIndex, amountToDelete, 13, 14);console.log(numbers); // [ 10, 11, 12, 13, 14, 15 ] slice() 不会修改数组，而是会复制，或者说提取（extract）给定数量的元素到一个新数组。 slice() 只接收 2 个输入参数：第一个是开始提取元素的位置（索引），第二个是提取元素的结束位置（索引）。 提取的元素中不包括第二个参数所对应的元素： 12let weatherConditions = [&#x27;rain&#x27;, &#x27;snow&#x27;, &#x27;sleet&#x27;, &#x27;hail&#x27;, &#x27;clear&#x27;];let todaysWeather = weatherConditions.slice(1, 3); // [&#x27;snow&#x27;, &#x27;sleet&#x27;] 三、展开运算符slice() 可以让我们从一个数组中选择一些元素来复制到新数组中，而 ES6 中又引入了一个简洁且可读性强的语法：展开运算符（spread operator），它能让我们方便地复制数组中的所有元素。 展开语法写出来是这样：...。 12let thisArray = [true, true, undefined, false, null];let thatArray = [...thisArray]; // thisArray 保持不变， thatArray 包含与 thisArray 相同的元素。 展开语法（spread）的另一个重要用途是合并数组，或者将某个数组的所有元素插入到另一个数组的任意位置。 我们也可以使用 ES5 的语法连接两个数组，但只能让它们首尾相接。 而展开语法可以让这样的操作变得极其简单： 12let thisArray = [&#x27;sage&#x27;, &#x27;rosemary&#x27;, &#x27;parsley&#x27;, &#x27;thyme&#x27;];let thatArray = [&#x27;basil&#x27;, &#x27;cilantro&#x27;, ...thisArray, &#x27;coriander&#x27;]; // [&#x27;basil&#x27;, &#x27;cilantro&#x27;, &#x27;sage&#x27;, &#x27;rosemary&#x27;, &#x27;parsley&#x27;, &#x27;thyme&#x27;, &#x27;coriander&#x27;] 使用展开语法，我们就可以很方便的实现一个用传统方法会写得很复杂且冗长的操作。 四、查询、遍历元素由于数组随时都可以修改或发生 mutated，我们很难保证某个数据始终处于数组中的特定位置，甚至不能保证该元素是否还存在于该数组中。 好消息是，JavaScript 为我们提供了内置方法 indexOf()。 这个方法让我们可以方便地检查某个元素是否存在于数组中。 indexOf() 方法接受一个元素作为输入参数，并返回该元素在数组中的位置（索引）；若该元素不存在于数组中则返回 -1。 1234et fruits = [&#x27;apples&#x27;, &#x27;pears&#x27;, &#x27;oranges&#x27;, &#x27;peaches&#x27;, &#x27;pears&#x27;];fruits.indexOf(&#x27;dates&#x27;); // -1fruits.indexOf(&#x27;oranges&#x27;); // 2fruits.indexOf(&#x27;pears&#x27;); // 1 (每个元素存在的第一个索引) 使用数组时，我们经常需要遍历数组的所有元素来找出我们需要的一个或多个元素，抑或是对数组执行一些特定的操作。 JavaScript 为我们提供了几个内置的方法，它们以不同的方式遍历数组，以便我们可以用于不同的场景（如 every()、forEach()、map() 等等）。 然而，最简单的 for 循环不仅能实现上述这些方法的功能，而且相比之下也会更加灵活： 12345678910function greaterThanTen(arr) &#123; let newArr = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; 10) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;greaterThanTen([2, 12, 8, 14, 80, 0, 1]); 五、对象对象（object）本质上是键值对（key-value pair）的集合。 或者说，一系列被映射到唯一标识符的数据就是对象；习惯上，唯一标识符叫做属性（property）或者键（key）；数据叫做值（value）： 12345const tekkenCharacter = &#123; player: &#x27;Hwoarang&#x27;, fightingStyle: &#x27;Tae Kwon Doe&#x27;, human: true&#125;; 如果我们想为它再添加一个叫做 origin 的属性，可以这样写： 1tekkenCharacter.origin = &#x27;South Korea&#x27;; 也可以通过方括号表示法来为它添加这个属性，像这样： 1tekkenCharacter[&#x27;hair color&#x27;] = &#x27;dyed orange&#x27;; 把属性（hair color）放到引号里，以此来表示整个字符串都是需要设置的属性。 如果不加上引号，那么中括号里的内容会被当作一个变量来解析，这个变量对应的值就会作为要设置的属性： 12const eyes = &#x27;eye color&#x27;;tekkenCharacter[eyes] = &#x27;brown&#x27;; 修改嵌套在对象中的对象： 1234567891011121314let nestedObject = &#123; id: 28802695164, date: &#x27;December 31, 2016&#x27;, data: &#123; totalUsers: 99, online: 80, onlineStatus: &#123; active: 67, away: 13, busy: 8 // 10 &#125; &#125;&#125;;nestedObject.data.onlineStatus.busy = 10; 使用方括号访问属性名称： 123let selectedFood = getCurrentFood(scannedItem);let inventory = foods[selectedFood];// 上述代码会先读取 selectedFood 变量的值，并返回 foods 对象中以该值命名的属性所对应的属性值。 若没有以该值命名的属性，则会返回 undefined。 对象是以键值对的形式，灵活、直观地存储结构化数据的一种方式，而且，通过对象的属性查找属性值是速度很快的操作。 从一个对象中移除一个键值对，可以像这样使用 delete 关键字： 1delete foods.apples; 如果我们想知道一个对象中是否包含某个属性呢，JavaScript 为我们提供了两种不同的方式来实现这个功能： 一个是通过 hasOwnProperty() 方法，另一个是使用 in 关键字。 12users.hasOwnProperty(&#x27;Alan&#x27;); // true&#x27;Alan&#x27; in users; // true 如果我们想要遍历对象中的所有属性， 只需要使用 JavaScript 中的 for...in 语句即可： 123for (let user in users) &#123; console.log(user);&#125; // 在上面的代码中，我们定义了一个 user 变量。 可以观察到，这个变量在遍历对象的语句执行过程中会一直被重置并赋予新值，结果就是不同的用户名打印到了 console 中。 对象中的键是无序的，这与数组不同。 因此，一个对象中某个属性的位置，或者说它出现的相对顺序，在引用或访问该属性时是不确定的。 可以给 Object.keys() 方法传入一个对象作为参数，来生成包含对象所有键的数组。 这会返回一个由对象中所有属性（字符串）组成的数组。 需要注意的是，数组中元素的顺序是不确定的。 123function getArrayOfUsers(obj) &#123; return Object.keys(obj); &#125; // 返回一个由输入对象中的所有属性所组成的数组。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.zhuangzhihao.top/tags/JavaScript/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2022-07-02T16:00:00.000Z","updated":"2022-07-03T07:41:27.063Z","comments":true,"path":"正则表达式/","link":"","permalink":"http://blog.zhuangzhihao.top/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"freeCodeCamp JavaScript 算法和数据结构第三章。正则表达式，常常缩写为 “regex” 或 “regexp”，是帮助程序员匹配、搜索和替换文本的模式。正则表达式非常强大，但可能难以阅读，因为它们使用特殊字符来做更复杂更灵活的匹配。在正则表达式的课程中，学习如何使用特殊字符、捕获组、正向或负向先行断言以及其他技巧来匹配你想要的文本。","text":"freeCodeCamp JavaScript 算法和数据结构第三章。正则表达式，常常缩写为 “regex” 或 “regexp”，是帮助程序员匹配、搜索和替换文本的模式。正则表达式非常强大，但可能难以阅读，因为它们使用特殊字符来做更复杂更灵活的匹配。在正则表达式的课程中，学习如何使用特殊字符、捕获组、正向或负向先行断言以及其他技巧来匹配你想要的文本。 一、文字匹配在编程语言中，正则表达式用于匹配指定的字符串。 通过正则表达式创建匹配模式（规则）可以帮你完成指定匹配。 正则表达式中不需要引号。如果想要在字符串 The dog chased the cat 中匹配到 the 这个单词，可以使用如下正则表达式：/the/。 测试正则表达式的一种方法是使用 .test() 方法。 .test() 方法会把编写的正则表达式和字符串（即括号内的内容）匹配，如果成功匹配到字符，则返回 true，反之，返回 false： 123let testStr = &quot;freeCodeCamp&quot;;let testRegex = /Code/;testRegex.test(testStr); // true 可以使用 alternation 或 OR 操作符搜索多个模式：使用 | 操作符匹配操作符前面或后面的字符。 例如，如果你想匹配 yes 或 no，你需要的正则表达式是 /yes|no/。 你还可以匹配多个规则，这可以通过添加更多的匹配模式来实现。 这些匹配模式将包含更多的 OR 操作符来分隔它们，比如/yes|no|maybe/。 123let petString = &quot;James has a pet cat.&quot;;let petRegex = /dog|cat|bird|fish/; // 使用正则表达式 petRegex 以匹配 dog、cat、bird 或者 fishlet result = petRegex.test(petString); 可以使用标志（flag）来匹配字母大小写两种情况。 可以通过将忽略大小写的标志 i 附加到正则表达式之后来使用它。 这里给出使用该标志的一个实例 /ignorecase/i， 这个字符串可以匹配字符串 ignorecase、igNoreCase 和 IgnoreCase。 123let myString = &quot;freeCodeCamp&quot;;let fccRegex = /freecodecamp/i; // 忽略大小写let result = fccRegex.test(myString); 可以使用 .match() 方法来提取找到的实际匹配项。可以使用字符串来调用 .match() 方法，并在括号内传入正则表达式。 1234&quot;Hello, World!&quot;.match(/Hello/); // 返回 [&quot;Hello&quot;]let ourStr = &quot;Regular expressions&quot;;let ourRegex = /expressions/;ourStr.match(ourRegex); // 返回 [&quot;expressions&quot;] 全局匹配：若要多次搜寻或提取模式匹配，可以使用 g 标志。在正则表达式上可以有多个标志，比如 /search/gi。 123let testStr = &quot;Repeat, Repeat, Repeat&quot;;let repeatRegex = /Repeat/g;testStr.match(repeatRegex); // 返回值 [&quot;Repeat&quot;, &quot;Repeat&quot;, &quot;Repeat&quot;] 通配符 . 将匹配任何一个字符。 通配符也叫 dot 或 period。 可以像使用正则表达式中任何其他字符一样使用通配符。 例如，如果想匹配 hug、huh、hut 和 hum，可以使用正则表达式 /hu./ 匹配以上四个单词。 12345let humStr = &quot;I&#x27;ll hum a song&quot;;let hugStr = &quot;Bear hug&quot;;let huRegex = /hu./;huRegex.test(humStr); // truehuRegex.test(hugStr); // true 二、字符集匹配文字匹配模式（/literal/）和通配符（/./）是正则表达式的两种极端情况，一种是精确匹配，而另一种则是匹配所有。 在这两种极端情况之间有一个平衡选项。 可以使用字符集 （character classes）更灵活的匹配字符。 可以把字符集放在方括号（[ 和 ]）之间来定义一组需要匹配的字符串。例如，如果想要匹配 bag、big 和 bug，但是不想匹配 bog。 可以创建正则表达式 /b[aiu]g/ 来执行此操作。 [aiu] 是只匹配字符 a、i 或者 u 的字符集。 123let quoteSample = &quot;Beware of bugs in the above code; I have only proved it correct, not tried it.&quot;;let vowelRegex = /[aeiou]/ig; // 使用元音字符集（a、e、i、o、u）在正则表达式 vowelRegex 中匹配到字符串 quoteSample 中的所有元音。let result = quoteSample.match(vowelRegex); 在字符集中，可以使用连字符（-）来定义要匹配的字符范围。例如，要匹配小写字母 a 到 e，你可以使用 [a-e]。 123let quoteSample = &quot;The quick brown fox jumps over the lazy dog.&quot;;let alphabetRegex = /[a-z]/ig; // 匹配字符串 quoteSample 中的所有字母。 let result = quoteSample.match(alphabetRegex); 使用连字符（-）匹配字符范围并不仅限于字母。 它还可以匹配一系列数字。例如，/[0-5]/ 匹配 0 和 5 之间的任意数字，包含 0 和 5。此外，还可以在单个字符集中组合一系列字母和数字。 123let jennyStr = &quot;Jenny8675309&quot;;let myRegex = /[a-z0-9]/ig;jennyStr.match(myRegex); 也可以创建一个不想匹配的字符集合。 这些类型的字符集称为否定字符集（ negated character sets）。 要创建否定字符集，需要在开始括号后面和不想匹配的字符前面放置脱字符（即^）。例如，/[^aeiou]/gi 匹配所有非元音字符。 注意，字符 .、!、[、@、/ 和空白字符等也会被匹配，该否定字符集仅排除元音字符。 123let quoteSample = &quot;3 blind mice.&quot;;let myRegex = /[^aeiou0-9]/ig; // 创建一个匹配所有非数字或元音字符的正则表达式。 let result = quoteSample.match(myRegex); 有时，需要匹配出现一次或者连续多次的的字符（或字符组）。 这意味着它至少出现一次，并且可能重复出现。 可以使用 + 符号来检查情况是否如此。 记住，字符或匹配模式必须一个接一个地连续出现。 这就是说，字符必须一个接一个地重复。 例如，/a+/g 会在 abc 中匹配到一个匹配项，并且返回 [&quot;a&quot;]。 因为 + 的存在，它也会在 aabc 中匹配到一个匹配项，然后返回 [&quot;aa&quot;]。如果它是检查字符串 abab，它将匹配到两个匹配项并且返回[&quot;a&quot;, &quot;a&quot;]，因为a字符不连续，在它们之间有一个b字符。 最后，因为在字符串 bcd 中没有 a，因此找不到匹配项。 123let difficultSpelling = &quot;Mississippi&quot;;let myRegex = /s+/g; // 在字符串 Mississippi 中匹配到出现一次或多次的字母 s 的匹配项。 let result = difficultSpelling.match(myRegex); 有一个选项可以匹配出现零次或多次的字符。执行该操作的字符叫做星号，即*。 123// chewieQuote 已经被初始化为 Aaaaaaaaaaaaaaaarrrgh!let chewieRegex = /Aa*/; // 使用 * 在 chewieQuote 中匹配 A 及其之后出现的零个或多个a。let result = chewieQuote.match(chewieRegex); 贪婪（greedy）匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。 另一种方案称为懒惰（lazy）匹配，它会匹配到满足正则表达式的字符串的最小可能部分。 可以将正则表达式 /t[a-z]*i/ 应用于字符串 &quot;titanic&quot;。 这个正则表达式是一个以 t 开始，以 i 结束，并且中间有一些字母的匹配模式。正则表达式默认是贪婪匹配，因此匹配返回为 [&quot;titani&quot;]。 它会匹配到适合该匹配模式的最大子字符串。 但是，你可以使用 ? 字符来将其变成懒惰匹配。 调整后的正则表达式 /t[a-z]*?i/ 匹配字符串 &quot;titanic&quot; 返回 [&quot;ti&quot;]。 应该避免使用正则表达式解析 HTML，但是可以用正则表达式匹配 HTML 字符串。 123let text = &quot;&lt;h1&gt;Winter is coming&lt;/h1&gt;&quot;;let myRegex = /&lt;h.*?1&gt;/; // 让正则表达式返回 HTML 标签 &lt;h1&gt;，而不是文本 &quot;&lt;h1&gt;Winter is coming&lt;/h1&gt;&quot;。let result = text.match(myRegex); 三、字符串匹配 除了在字符集中使用之外，插入符号（^）用于匹配文本是否在字符串的开始位置。 12345let firstString = &quot;Ricky is first and can be found.&quot;; let firstRegex = /^Ricky/; // truefirstRegex.test(firstString);let notFirst = &quot;You can&#x27;t find Ricky now.&quot;;firstRegex.test(notFirst); // false 可以使用正则表达式的美元符号 $ 来搜寻字符串的结尾。 12345let theEnding = &quot;This is a never ending story&quot;;let storyRegex = /story$/;storyRegex.test(theEnding); // truelet noEnding = &quot;Sometimes a story will have to end&quot;;storyRegex.test(noEnding); // false 使用元字符，可以使用 [a-z] 搜寻字母表中的所有字母。 这种元字符是很常见的，它有一个缩写，但这个缩写也包含额外的字符。这些元字符缩写也被称为短语元字符 shorthand character classes。 JavaScript 中与字母表匹配的最接近的元字符是\\w。 这个缩写等同于[A-Za-z0-9_]。 此字符类匹配大写字母和小写字母以及数字。 注意，这个字符类也包含下划线字符 (_)。 12345678let longHand = /[A-Za-z0-9_]+/;let shortHand = /\\w+/;let numbers = &quot;42&quot;;let varNames = &quot;important_var&quot;;longHand.test(numbers); // trueshortHand.test(numbers); // truelongHand.test(varNames); // trueshortHand.test(varNames); // true 匹配除了字母和数字的所有符号可以使用 \\W 搜寻和 \\w 相反的匹配模式。 注意，相反匹配模式使用大写字母。 此缩写与 [^A-Za-z0-9_] 是一样的。 12345let shortHand = /\\W/;let numbers = &quot;42%&quot;;let sentence = &quot;Coding!&quot;;numbers.match(shortHand); // [&quot;%&quot;]sentence.match(shortHand); // [&quot;!&quot;] 另一个常见的匹配模式是只寻找数字。查找数字字符的缩写是 \\d，注意是小写的 d。 这等同于元字符 [0-9]，它查找 0 到 9 之间任意数字的单个字符。 也可以使用类似的缩写来搜寻非数字，该缩写使用大写的 D。查找非数字字符的缩写是 \\D。 这等同于字符串 [^0-9]，它查找不是 0 - 9 之间数字的单个字符。 123let movieName = &quot;2001: A Space Odyssey&quot;;let noNumRegex = /\\D/g; // 使用非数字缩写 \\D 来计算电影标题中有多少非数字。let result = movieName.match(noNumRegex).length; 可以使用 \\s 搜寻空格，其中 s 是小写。 此匹配模式将匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 [ \\r\\t\\f\\n\\v]。 123let whiteSpace = &quot;Whitespace. Whitespace everywhere!&quot;let spaceRegex = /\\s/g; whiteSpace.match(spaceRegex); // 返回 [&quot; &quot;, &quot; &quot;] 使用 \\S 搜寻非空白字符，其中 s 是大写。 此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 [^ \\r\\t\\f\\n\\v]。 123let whiteSpace = &quot;Whitespace. Whitespace everywhere!&quot;let nonSpaceRegex = /\\S/g;whiteSpace.match(nonSpaceRegex).length; // 32 使用数量说明符（quantity specifiers）指定匹配模式的上下限。 数量说明符与花括号（&#123; 和 &#125;）一起使用。 可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。例如，要匹配出现 3 到 5 次字母 a 的在字符串 ah，正则表达式应为/a&#123;3,5&#125;h/。 12345let A4 = &quot;aaaah&quot;;let A2 = &quot;aah&quot;;let multipleA = /a&#123;3,5&#125;h/;multipleA.test(A4); // truemultipleA.test(A2); // false 但有时候只想指定匹配模式的下限而不需要指定上限，在第一个数字后面跟一个逗号即可。 要指定一定数量的匹配模式，只需在大括号之间放置一个数字。例如，要只匹配字母 a 出现 3 次的单词hah，正则表达式应为/ha&#123;3&#125;h/。 1234567let A4 = &quot;haaaah&quot;;let A3 = &quot;haaah&quot;;let A100 = &quot;h&quot; + &quot;a&quot;.repeat(100) + &quot;h&quot;;let multipleHA = /ha&#123;3&#125;h/;multipleHA.test(A4); // truemultipleHA.test(A3); // falsemultipleHA.test(A100); // true 可以使用问号 ? 指定可能存在的元素。 这将检查前面的零个或一个元素。 可以将此符号视为前面的元素是可选的。 例如，美式英语和英式英语略有不同，可以使用问号来匹配两种拼写。 12345let american = &quot;color&quot;;let british = &quot;colour&quot;;let rainbowRegex= /colou?r/;rainbowRegex.test(american); // truerainbowRegex.test(british); // true 先行断言 （Lookaheads）是告诉 JavaScript 在字符串中向前查找的匹配模式。 当想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。 有两种先行断言：正向先行断言（positive lookahead）和负向先行断言（negative lookahead）。 正向先行断言会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。 正向先行断言的用法是 (?=...)，其中 ... 就是需要存在但不会被匹配的部分。 另一方面，负向先行断言会查看并确保搜索匹配模式中的元素不存在。 负向先行断言的用法是 (?!...)，其中 ... 是希望不存在的匹配模式。 如果负向先行断言部分不存在，将返回匹配模式的其余部分。 先行断言的更实际用途是检查一个字符串中的两个或更多匹配模式。 这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字： 123let password = &quot;abc123&quot;;let checkPass = /(?=\\w&#123;3,6&#125;)(?=\\D*\\d)/;checkPass.test(password); 有时候我们想使用正则表达式里的括号 () 来检查字符组。 如果想在字符串找到 Penguin 或 Pumpkin，可以用这个正则表达式：/P(engu|umpk)in/g。然后使用 test() 方法检查 test 字符串里面是否包含字符组。 123let testStr = &quot;Pumpkin&quot;;let testRegex = /P(engu|umpk)in/; testRegex.test(testStr); // true 捕获组可以用于找到重复的子字符串。捕获组是通过把要捕获的正则表达式放在括号中来构建的。 例子：捕获一个包含字母数字字符的词，所以捕获组是将 \\w+ 放在括号中：/(\\w+)/。 分组匹配的子字符串被保存到一个临时的“变量”， 可以使用同一正则表达式和反斜线及捕获组的编号来访问它（例如：\\1）。 捕获组按其开头括号的位置自动编号（从左到右），从 1 开始。 1234// 匹配被空格隔开的两个相同单词let repeatRegex = /(\\w+) \\1 \\1/;repeatRegex.test(repeatStr); // Returns truerepeatStr.match(repeatRegex); // Returns [&quot;row row row&quot;, &quot;row&quot;] 搜索功能是很有用的。 但是，当搜索同时也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。 可以在字符串上使用 .replace() 方法来搜索并替换字符串中的文本。 .replace() 的输入首先是想要搜索的正则表达式匹配模式。 第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。 123let wrongText = &quot;The sky is silver.&quot;;let silverRegex = /silver/;wrongText.replace(silverRegex, &quot;blue&quot;); // 返回 The sky is blue. 还可以使用美元符号（$）访问替换字符串中的捕获组。 1&quot;Code Camp&quot;.replace(/(\\w+)\\s(\\w+)/, &#x27;$2 $1&#x27;); // 返回字符串 Camp Code 有时字符串周围存在的空白字符并不是必需的。 字符串的典型处理是删除字符串开头和结尾处的空格。 123let hello = &quot; Hello, World! &quot;;let wsRegex = /^\\s+|\\s+$/g; let result = hello.replace(wsRegex, &quot;&quot;); 在 JavaScript 中 String.prototype.trim() 方法也可以实现同样的效果。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.zhuangzhihao.top/tags/JavaScript/"}]},{"title":"JavaScript 调试","slug":"JS调试","date":"2022-06-26T16:00:00.000Z","updated":"2022-06-27T13:47:59.614Z","comments":true,"path":"JS调试/","link":"","permalink":"http://blog.zhuangzhihao.top/JS%E8%B0%83%E8%AF%95/","excerpt":"freeCodeCamp JavaScript 算法和数据结构第四章。调试是检查代码、发现并修复问题的过程。代码中的问题通常有三种形式：1）语法错误导致程序停止运行， 2）代码无法执行或具有意外行为导致运行时错误，3）代码有语义（逻辑）错误，没有实现原来的意图。在 JavaScript 调试的课程中，学习如何使用 JavaScript 控制台来调试程序，防止出现常见问题。","text":"freeCodeCamp JavaScript 算法和数据结构第四章。调试是检查代码、发现并修复问题的过程。代码中的问题通常有三种形式：1）语法错误导致程序停止运行， 2）代码无法执行或具有意外行为导致运行时错误，3）代码有语义（逻辑）错误，没有实现原来的意图。在 JavaScript 调试的课程中，学习如何使用 JavaScript 控制台来调试程序，防止出现常见问题。 一、检查变量Chrome 和 Safari 都有出色的 JavaScript 控制台（也称为 DevTools），可以用来调试 JavaScript 代码。 console.log() 方法可能是最有用的调试工具，它可以将括号中的内容输出到控制台。 将它放在代码中的关键点可以显示变量在当时的值： 123456let a = 5;let b = 1;a++;console.log(a);let sumAB = a + b;console.log(sumAB); 有许多方法可以与 console 一起使用来输出消息，log、warn 和 clear 就是几个例子。 使用 console.log 记录变量，使用 console.clear() 来清除浏览器控制台： 123let output = &quot;Get this to show once in the freeCodeCamp console and not at all in the browser console&quot;;console.log(output);console.clear(); 可以使用 typeof 检查变量的数据结构或类型。 在处理多种数据类型时，这会对调试很有帮助。 类型错误可能隐藏在计算或函数调用中。 如果想计算两数之和，但实际传入了一个字符串参数，则结果可能是错误的。当你以 JavaScript 对象（JSON）的形式访问和使用外部数据时尤其要小心。 1234console.log(typeof &quot;&quot;); //stringconsole.log(typeof 0); //numberconsole.log(typeof []); //objectconsole.log(typeof &#123;&#125;); //object JavaScript 有七种原始（不可变）数据类型： Boolean，Null，Undefined，Number，String，Symbol （new with ES6），BigInt （new with ES2020）和一种可变数据类型：Object。 注意：在 JavaScript 中，数组在本质上是一种对象。 二、捕获错误JavaScript 变量和函数名称区分大小写。变量或函数名的错写、漏写或大小写弄混都会让浏览器尝试查找并不存在的东西，并报出“引用错误”。 要注意的另一个语法错误是所有的小括号、方括号、花括号和引号都必须配对。 当你编辑代码并插入新代码其中带有括号时，很容易忘记括号闭合。 此外，在将代码块嵌套到其他代码块时要小心，例如将回调函数作为参数添加到方法中。避免这种错误的一种方法是，一次性输入完这些符号，然后将光标移回它们之间继续编写。 好在现在大部分编辑器都会帮你自动补全。 JavaScript 允许使用单引号（&#39;）和双引号（&quot;）声明字符串。 但如果字符串中有缩写或存在一段带引号的文本，可以使用反斜杠（\\）来转义字符串内的引号： 1const allSameQuotes = &#x27;I\\&#x27;ve had a perfectly wonderful evening, but this wasn\\&#x27;t it.&#x27;; JavaScript 中的赋值运算符 (=) 是用来为变量名赋值的。 并且 == 和 === 运算符检查相等性（三等号 === 是用来测试是否严格相等的，严格相等的意思是值和类型都必须相同）。 JavaScript 会把大部分的值都视为 true，除了所谓的 falsy 值，即：false、0、&quot;&quot;（空字符串）、NaN、undefined 和 null： 12345let x = 1;let y = 2;if (x = y) &#123;&#125; else &#123;&#125; //在这个示例中，除非 y 值是假值，否则当 y 为任何值时，if 语句中的代码块都会运行。 当函数或方法不接受任何参数时，你可能忘记在调用它时加上空的左括号和右括号。 通常，函数调用的结果会保存在变量中，供其他代码使用。 可以通过将变量值（或其类型）打印到控制台，查看输出究竟是一个函数引用还是函数调用的返回值来检测这类错误。 12345function myFunction() &#123; return &quot;You rock!&quot;;&#125;let varOne = myFunction; //myFunctionlet varTwo = myFunction(); //You rock! 需要注意的下一个 bug 是函数的参数传递顺序错误。 如果参数分别是不同的类型，例如接受数组和整数两个参数的函数，参数顺序传错就可能会引发运行时错误。 对于接受相同类型参数的函数，传错参数也会导致逻辑错误或运行结果错误。 确保以正确的顺序提供所有必需的参数以避免这些问题。 当试图访问字符串或数组的特定索引（分割或访问一个片段）或循环索引时，有时会出现 Off by one errors 错误（有时称为 OBOE）。 JavaScript 索引从 0 开始，而不是 1，这意味着最后一个索引总会比字符串或数组的长度少 1。 如果尝试访问等于长度的索引，程序可能会抛出“索引超出范围”引用错误或打印出 undefined。当使用将索引范围作为参数的字符串或数组方法时，阅读相关的文档并了解参数中的索引的包含性（即是否考虑进返回值中）很重要。 1234567891011let alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot;;let len = alphabet.length;for (let i = 0; i &lt;= len; i++) &#123; console.log(alphabet[i]);&#125; //多了一次循环for (let j = 1; j &lt; len; j++) &#123; console.log(alphabet[j]);&#125; //少了一次循环（漏掉了索引 0 处的字符）for (let k = 0; k &lt; len; k++) &#123; console.log(alphabet[k]);&#125; //正确 三、循环错误有时需要在循环中保存信息以增加计数器或重置变量。 一个潜在的问题是变量什么时候该重新初始化，什么时候不该重新初始化，反之亦然。 如果你不小心重置了用于终止条件的变量，导致无限循环，这将特别危险。 使用console.log()在每个循环中打印变量值可以发现与重置相关的错误或者重置变量失败。 123456789101112131415function zeroArray(m, n) &#123; let newArray = []; for (let i = 0; i &lt; m; i++) &#123; let row = []; /* &lt;----- row has been declared inside the outer loop. Now a new row will be initialised during each iteration of the outer loop allowing for the desired matrix. */ for (let j = 0; j &lt; n; j++) &#123; row.push(0); &#125; newArray.push(row); &#125; return newArray;&#125;let matrix = zeroArray(3, 2);console.log(matrix); 当需要程序运行代码块一定次数或满足条件时，循环是很好的工具，但是它们需要终止条件来结束循环。 无限循环可能会使浏览器冻结或崩溃，并导致程序执行混乱，没有人想要这样的结果。 12345function loopy() &#123; while(true) &#123; console.log(&quot;Hello, world!&quot;); &#125;&#125; //没有终止条件来摆脱loopy()内的while循环。 不要调用这个函数！ 程序员的工作是确保最终达到终止条件，该条件告诉程序何时跳出循环。 有一种错误是从终端条件向错误方向递增或递减计数器变量。 另一种是在循环代码中意外重置计数器或索引变量，而不是递增或递减它。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.zhuangzhihao.top/tags/JavaScript/"}]},{"title":"线性表的顺序存储原理及实现","slug":"线性表的顺序存储","date":"2022-06-23T16:00:00.000Z","updated":"2022-06-27T05:25:05.008Z","comments":true,"path":"线性表的顺序存储/","link":"","permalink":"http://blog.zhuangzhihao.top/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/","excerpt":"线性表是由 n（n \\geq 0）个相同类型的元素组成的有序集合L =\\left( a_{1},a_{2},\\ldots ,a_{i-1},a_{i},a_{i+1},\\ldots ,a_{n}\\right)。线性表中元素个数 n 称为线性表的长度，当n = 0时为空表。a_{1}是第一个数据元素，a_{n}是最后一个数据元素，a_{i-1}是a_{i}的直接前驱，a_{i+1}是a_{i}的直接后驱。","text":"线性表是由 n（n \\geq 0）个相同类型的元素组成的有序集合L =\\left( a_{1},a_{2},\\ldots ,a_{i-1},a_{i},a_{i+1},\\ldots ,a_{n}\\right)。线性表中元素个数 n 称为线性表的长度，当n = 0时为空表。a_{1}是第一个数据元素，a_{n}是最后一个数据元素，a_{i-1}是a_{i}的直接前驱，a_{i+1}是a_{i}的直接后驱。 一、线性表的特点 表中元素的个数是有限的。 表中元素的数据类型都相同，意味着每一个元素占用相同大小的空间。 表中元素具有逻辑上的顺序性，在序列中各元素排序有其先后顺序。 二、线性表的顺序表示逻辑上相邻的两个元素在物理位置上也相邻。 1234567891011121314151617181920212223242526272829303132333435#define MaxSize 50; //定义线性表的长度typedef int ElemType; //顺序表中元素的类型typedef struct &#123; ElemType data[MaxSize]; //顺序表的元素 int length; //顺序表的当前长度&#125;SqList; //顺序表的类型定义int main()&#123; SqList L; //顺序表的名称 bool ret; //查看返回值 ElemType del; //用来存要删除的元素 L.data[0] = 1; L.data[1] = 2; L.data[2] = 3; //手动赋值 L.len = 3; //总共 3 个元素 ret = ListInsert(L, 2, 60); //在 L 的第 2 个位置插入元素 60 if(ret) PrintList(L); else printf(&quot;插入失败\\n&quot;); ret = ListDelete(L, 1, del); //删除 L 第 1 个位置元素 if(ret) PrintList(L); else printf(&quot;删除失败\\n&quot;); int pos; pos = LocateElem(L, 60); //查找值为 60 的元素位置 printf(&quot;%4d\\n&quot;, pos);&#125;void PrintList(SqList &amp;L)&#123; for(int i = 0; i &lt; L.length; i ++) printf(&quot;%4d&quot;, L.data[i]); //所有元素打印到一排，一个元素占4个空间 printf(&quot;\\n&quot;);&#125; 优点 可以随机存取（根据表头元素地址和元素序号）表中任意一个元素。 存储密度高，每个结点只存储数据元素。 缺点 插入和删除操作需要移动大量元素。 线性表变化较大时，难以确定存储空间的容量。 存储分配需要一整段连续的存储空间，不够灵活。 三、插入操作 最好情况：在表尾插入元素，不需要移动元素，时间复杂度为O(1)。 最坏情况：在表头插入元素，所有元素依次后移，时间复杂度为O(n)。 平均情况：在插入位置概率均等的情况下，平均移动元素的次数为n/2，复杂度为O(n)。 123456789101112bool ListInsert(SqList &amp;L, int i, ElemType e)&#123; if(i&lt;1 || i&gt; L.length+1) //判断插入位置 i 是否合法（满足 1 &lt;= i &lt;= len+1） return false; if(L.length &gt;= MaxSize) //判断存储空间是否已满（插入 x 后是否会超出数组长度） return false; for (int j = L.length; j &gt;= i; j--) //将最后一个元素到第 i 个元素依次后移一位 L.data[j] = L.data[j - 1]; L.data[i - 1] = e; //空出位置 i 放入元素 x L.length++; //线性表长度 + 1 return true;&#125; 四、删除操作 最好情况：删除表尾元素，不需要移动元素，时间复杂度为O(1)。 最坏情况：删除表头元素，之后的所有元素依次前移，时间复杂度为O(n)。 平均情况：在删除位置概率均等的情况下，平均移动元素的次数为(n-1)/2，时间复杂度为O(n)。 12345678910bool ListDelete(SqList &amp;L, int i, ElemType e)&#123; if(i&lt;=1 || i&gt; L.length || L.length == 0) //判断删除位置 i 是否合法（满足 1 &lt;= i &lt;= len），且顺序表不能为0 return false; //插入和删除时，i 的合法范围是不一样的 e = L.data[i - 1]; //将被删除的元素赋值给 e for (int j = i; j &lt; L.length; j++) L.data[j - 1] = L.data[j]; //将删除后的元素依次前移 L.length--; //线性表长度 - 1 return true;&#125; 五、查找元素查找成功，返回位置。位置从 1 开始，查找失败，返回 0： 1234567int LocateElem(SqList L, ElemType e)&#123; for(int i = 0; i &lt; L.length; i ++) //遍历顺序表 if(L.data[i] == e) return i + 1; //i + 1 是元素在顺序表中的位置 return 0;&#125; 六、动态分配C 语言的初始动态分配语句： 1L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize); C++ 的初始动态分配语句： 1L.data = new ElemType[InitSize]; 动态分配数组的类型定义： 12345#define MaxSize 100; //定义线性表的长度typedef struct &#123; ElemType *data; //指示动态分配数组的指针 int MaxSize, length; //数组的当前容量和最大个数&#125;SeqList;","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://blog.zhuangzhihao.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"ECMAScript 6","slug":"ES6","date":"2022-06-21T16:00:00.000Z","updated":"2022-06-22T09:39:24.352Z","comments":true,"path":"ES6/","link":"","permalink":"http://blog.zhuangzhihao.top/ES6/","excerpt":"freeCodeCamp JavaScript 算法和数据结构第二章。ECMAScript（ES）是 JavaScript 的标准。因为所有主流浏览器都遵循此规范，所以 ECMAScript 和 JavaScript 是可以互换的。JavaScript 在不断迭代，每年都会发布新功能。2015 年发布的 ES6（ECMAScript6）为该语言添加了许多强大的新功能，在 ES6 点课程中，学习这些新特性，包括箭头函数、解构、类、promise 和模块。","text":"freeCodeCamp JavaScript 算法和数据结构第二章。ECMAScript（ES）是 JavaScript 的标准。因为所有主流浏览器都遵循此规范，所以 ECMAScript 和 JavaScript 是可以互换的。JavaScript 在不断迭代，每年都会发布新功能。2015 年发布的 ES6（ECMAScript6）为该语言添加了许多强大的新功能，在 ES6 点课程中，学习这些新特性，包括箭头函数、解构、类、promise 和模块。 一、var、let 和 const 关键字使用 var 关键字声明变量时，它是全局声明的，如果在函数内部声明则是局部声明的。 1234567var numArray = [];var i;for (i = 0; i &lt; 3; i++) &#123; numArray.push(i);&#125;console.log(numArray); // [0, 1, 2]console.log(i); // 3 let 关键字的行为类似，但有一些额外的功能。 在代码块、语句或表达式中使用 let 关键字声明变量时，其作用域仅限于该代码块、语句或表达式。 12345678910let printNumTwo;for (let i = 0; i &lt; 3; i++) &#123; if (i === 2) &#123; printNumTwo = function() &#123; return i; &#125;; &#125;&#125;console.log(printNumTwo()); // 2console.log(i); // error: i is not defined 默认情况下，一些开发人员更喜欢使用 const 分配所有变量，除非他们知道需要重新分配值，他们才使用 let。 但是，重要的是要了解使用 const 分配给变量的对象（包括数组和函数）仍然是可变的。 使用 const 声明只能防止变量标识符的重新分配： 1234const s = [5, 6, 7];s = [1, 2, 3]; //error: 不能分配s[2] = 45; // [5, 6, 45]console.log(s); // [5, 6, 45] const 声明并不会真的保护数据不被改变。 为了确保数据不被改变，JavaScript 提供了一个函数 Object.freeze： 12345678let obj = &#123; name:&quot;FreeCodeCamp&quot;, review:&quot;Awesome&quot;&#125;;Object.freeze(obj);obj.review = &quot;bad&quot;; //赋值错误obj.newProp = &quot;Test&quot;; //赋值错误console.log(obj); 二、函数和操作符在 JavaScript 里，我们会经常遇到不需要给函数命名的情况，尤其是在需要将一个函数作为参数传给另外一个函数的时候。 这时，我们会创建匿名函数： 1234const myFunc = function() &#123; const myVar = &quot;value&quot;; return myVar;&#125; ES6 提供了其他写匿名函数的方式的语法糖。 你可以使用箭头函数： 1234567const myFunc = () =&gt; &#123; const myVar = &quot;value&quot;; return myVar;&#125;// 当不需要函数体，只返回一个值的时候，箭头函数允许你省略 return 关键字和外面的大括号const myFunc = () =&gt; &quot;value&quot;;// 这段代码默认会返回字符串 value 和一般的函数一样，你也可以给箭头函数传递参数： 12const doubler = (item) =&gt; item * 2;doubler(4); //8 如果箭头函数只有一个参数，则可以省略参数外面的括号： 1const doubler = item =&gt; item * 2; 可以给箭头函数传递多个参数： 12const multiplier = (item, multi) =&gt; item * multi;multiplier(4, 2); //8 ES6 里允许给函数传入默认参数，来构建更加灵活的函数： 123const greeting = (name = &quot;Anonymous&quot;) =&gt; &quot;Hello &quot; + name;console.log(greeting(&quot;John&quot;)); // Hello Johnconsole.log(greeting()); // Hello Anonymous ES6 推出了用于函数参数的 rest 操作符帮助我们创建更加灵活的函数。 rest 操作符可以用于创建有一个变量来接受多个参数的函数。 这些参数被储存在一个可以在函数内部读取的数组中： 123456function howMany(...args) &#123; return &quot;You have passed &quot; + args.length + &quot; arguments.&quot;;&#125;console.log(howMany(0, 1, 2)); //You have passed 3 arguments.console.log(howMany(&quot;string&quot;, null, [1, 2, 3], &#123; &#125;)); //You have passed 4 arguments.// 使用 rest 参数，就不需要查看 args 数组，并且允许我们在参数数组上使用 map()、filter() 和 reduce() ES6 引入了展开操作符，可以展开数组以及需要多个参数或元素的表达式： 12const arr = [6, 89, 3, 45];const maximus = Math.max(...arr); //89 ...arr 返回一个解压的数组。 也就是说，它展开数组。 然而，展开操作符只能够在函数的参数中或者数组中使用。 用 ES6 的语法在对象中定义函数的时候，可以删除 function 关键词和冒号，用 ES6 编写简洁的函数声明： 123456const person = &#123; name: &quot;Taylor&quot;, sayHello() &#123; return `Hello! My name is $&#123;this.name&#125;.`; &#125;&#125;; 三、解构赋值解构赋值是 ES6 引入的新语法，用来从数组和对象中提取值，并优雅地对变量进行赋值。 12345678// ES5 代码const user = &#123; name: &#x27;John Doe&#x27;, age: 34 &#125;;const name = user.name;const age = user.age;// ES6 代码const &#123; name, age &#125; = user;//在这里，自动创建 name 和 age 变量，并将 user 对象相应属性的值赋值给它们。 这个方法简洁多了。 可以给解构的值赋予一个新的变量名， 通过在赋值的时候将新的变量名放在冒号后面来实现： 12const &#123; name: userName, age: userAge &#125; = user;// 获取 user.name 的值，将它赋给一个新的变量 userName，等等。 将对象的属性值赋值给具有不同名字的变量： 1234567const user = &#123; johnDoe: &#123; age: 34, email: &#x27;johnDoe@freeCodeCamp.com&#x27; &#125;&#125;;const &#123; johnDoe: &#123; age: userAge, email: userEmail &#125;&#125; = user; 在 ES6 里面，解构数组可以如同解构对象一样简单。与数组解构不同，数组的扩展运算会将数组里的所有内容分解成一个由逗号分隔的列表。 所以，你不能选择哪个元素来给变量赋值，而对数组进行解构却可以让我们做到这一点： 12const [a, b,,, c] = [1, 2, 3, 4, 5, 6];console.log(a, b, c); // a = 1, b = 2, c = 5 使用解构赋值交换两数的值： 12let a = 8, b = 6;[a, b] = [b, a]; 在解构数组的某些情况下，我们可能希望将剩下的元素放进另一个数组里面。以下代码的结果与使用 Array.prototype.slice() 类似： 123const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];console.log(a, b); // 1, 2console.log(arr); // [3,4,5,7] 在某些情况下，你可以在函数的参数里直接解构对象： 123456const profileUpdate = (profileData) =&gt; &#123; const &#123; name, age, nationality, location &#125; = profileData;&#125;// 上面的操作解构了传给函数的对象。 这样的操作也可以直接在参数里完成：const profileUpdate = (&#123; name, age, nationality, location &#125;) =&gt; &#123;&#125; // 当 profileData 被传递到上面的函数时，从函数参数中解构出值以在函数内使用 三、模板字符串模板字符串是 ES6 的另外一项新的功能。 这是一种可以轻松构建复杂字符串的方法，模板字符串可以使用多行字符串和字符串插值功能。 12345678onst person = &#123; name: &quot;Zodiac Hasbro&quot;, age: 56&#125;;const greeting = `Hello, my name is $&#123;person.name&#125;!I am $&#123;person.age&#125; years old.`;console.log(greeting); 这里发生了许多事情。 首先，使用反引号，而不是引号（&#39; 或者 &quot;）将字符串括起来。 其次，注意代码和输出中的字符串都是多行的。 不需要在字符串中插入 \\n。 上面使用的 $&#123;variable&#125; 语法是一个占位符。 这样一来，你将不再需要使用 + 运算符来连接字符串。 当需要在字符串里增加变量的时候，你只需要在变量的外面括上 $&#123; 和 &#125;，并将其放在模板字符串里就可以了。 同样，你可以在字符串中包含其他表达式，例如 $&#123;a + b&#125;。 这个新的方式使你可以更灵活地创建复杂的字符串。 四、构造函数ES6 提供了一个新的创建对象的语法，使用关键字 class。值得注意的是，class 只是一个语法糖，它并不像 Java、Python 或者 Ruby 这一类的语言一样，严格履行了面向对象的开发规范。 在 ES5 里面，我们通常会定义一个构造函数 constructor，然后使用 new 关键字来实例化一个对象： 1234var SpaceShuttle = function(targetPlanet)&#123; this.targetPlanet = targetPlanet;&#125;var zeus = new SpaceShuttle(&#x27;Jupiter&#x27;); class 语法只是简单地替换了构造函数 constructor 的写法： 123456class SpaceShuttle &#123; constructor(targetPlanet) &#123; this.targetPlanet = targetPlanet; &#125;&#125;const zeus = new SpaceShuttle(&#x27;Jupiter&#x27;); 应该注意 class 关键字声明了一个新的函数，里面添加了一个构造函数。 当用 new 创建一个新的对象时，构造函数会被调用。 你可以从对象中获得一个值，也可以给对象的属性赋值。这些操作通常被称为 getters 以及 setters。 Getter 函数的作用是可以让对象返回一个私有变量，而不需要直接去访问私有变量。Setter 函数的作用是可以基于传进的参数来修改对象中私有变量。 这些修改可以是计算，或者是直接替换之前的值： 123456789101112131415161718class Book &#123; constructor(author) &#123; this._author = author; &#125; // getter get writer() &#123; return this._author; &#125; // setter set writer(updatedAuthor) &#123; this._author = updatedAuthor; &#125;&#125;const novel = new Book(&#x27;anonymous&#x27;);console.log(novel.writer);novel.writer = &#x27;newAuthor&#x27;;console.log(novel.writer);// 通常会在私有变量前添加下划线（_）。 然而，这种做法本身并不是将变量变成私有的。 五、模块脚本起初，JavaScript 几乎只在 HTML web 扮演一个很小的角色。 今天，一切不同了，很多网站几乎全是用 JavaScript 所写。 为了让 JavaScript 更模块化、更整洁以及更易于维护，ES6 引入了在多个 JavaScript 文件之间共享代码的机制。 它可以导出文件的一部分供其它文件使用，然后在需要它的地方按需导入。 如需要在 HTML 文档里创建一个 type 为 module 的脚本： 1&lt;script type=&quot;module&quot; src=&quot;filename.js&quot;&gt;&lt;/script&gt; 假设有一个文件 math_functions.js，该文件包含了数学运算相关的一些函数。 其中一个存储在变量 add 里，该函数接受两个数字作为参数返回它们的和。 你想在几个不同的 JavaScript 文件中使用这个函数。 要实现这个目的，就需要 export 它： 123export const add = (x, y) =&gt; &#123; return x + y;&#125; 导出变量和函数后，就可以在其它文件里导入使用从而避免了代码冗余。 当然还可以这样导出： 1234const add = (x, y) =&gt; &#123; return x + y;&#125;export &#123; add &#125;; 导出语句中添加更多值也可以导出多项： 1export &#123; add, subtract &#125;; import 可以导入文件或模块的一部分： 12// 从 math_functions.js 文件里导入多个项目import &#123; add, subtract &#125; from &#x27;./math_functions.js&#x27;; 假设你有一个文件，你希望将其所有内容导入到当前文件中，可以用 import * as 语法来实现： 1234import * as myMathModule from &quot;./math_functions.js&quot;;// 然后可以像访问对象的属性那样访问里面的函数。myMathModule.add(2,3);myMathModule.subtract(5,3); 在文件中只有一个值需要导出的时候，通常会使用默认导出的 export 的语法。 它也常常用于给文件或者模块创建返回值： 12345678// 命名函数export default function add(x, y) &#123; return x + y;&#125;// 匿名函数export default function(x, y) &#123; return x + y;&#125; export default 用于为模块或文件声明一个返回值，在每个文件或者模块中应当只默认导出一个值。 此外，你不能将 export default 与 var、let 或 const 同时使用。 export default 需要一种 import 的语法来导入默认的导出： 1import add from &quot;./math_functions.js&quot;; 六、JavaScript PromisePromise 是异步编程的一种解决方案 - 它在未来的某时会生成一个值。 任务完成，分执行成功和执行失败两种情况。 Promise 是构造器函数，需要通过 new 关键字来创建。 构造器参数是一个函数，该函数有两个参数 - resolve 和 reject。 通过它们来判断 promise 的执行结果： 12const myPromise = new Promise((resolve, reject) =&gt; &#123;&#125;); Promise 有三个状态：pending、fulfilled 和 rejected。 没有调用 promise 的完成方法，promise 会一直阻塞在 pending 状态里，Promise 提供的 resolve 和 reject 参数就是用来结束 promise 的。 Promise 成功时调用 resolve，promise 执行失败时调用 reject， 如下文所述，这些方法需要有一个参数： 12345678const myPromise = new Promise((resolve, reject) =&gt; &#123; if(condition here) &#123; resolve(&quot;Promise was fulfilled&quot;); &#125; else &#123; reject(&quot;Promise was rejected&quot;); &#125;&#125;);// 上面的示例使用字符串作为这些函数的参数，但参数实际上可以是任何格式。 通常，它可能是一个包含数据的对象，你可以将它放在网站或其他地方。 当程序需要花费未知的时间才能完成时（比如一些异步操作），一般是服务器请求，promise 很有用。 服务器请求会花费一些时间，当结束时，需要根据服务器的响应执行一些操作。 这可以用 then 方法来实现， 当 promise 完成 resolve 时会触发 then 方法： 1234myPromise.then(result =&gt; &#123; console.log(result);&#125;);// result 即传入 resolve 方法的参数 当 promise 失败时会调用 catch 方法。 当 promise 的 reject 方法执行时会直接调用： 123myPromise.catch(error =&gt; &#123; console.log(error);&#125;);","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.zhuangzhihao.top/tags/JavaScript/"}]},{"title":"通过构建摩天轮学习 CSS 动画","slug":"CSS构建摩天轮","date":"2022-06-18T16:00:00.000Z","updated":"2022-06-18T06:44:41.734Z","comments":true,"path":"CSS构建摩天轮/","link":"","permalink":"http://blog.zhuangzhihao.top/CSS%E6%9E%84%E5%BB%BA%E6%91%A9%E5%A4%A9%E8%BD%AE/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第十五章。你可以使用 CSS 动画将注意力吸引到网页的特定部分并使其更具吸引力。在通过构建摩天轮学习 CSS 动画的课程中，建造一个摩天轮，学习如何使用 CSS 为元素设置动画、转换它们并调整它们的速度。","text":"freeCodeCamp 响应式网页设计的认证课程第十五章。你可以使用 CSS 动画将注意力吸引到网页的特定部分并使其更具吸引力。在通过构建摩天轮学习 CSS 动画的课程中，建造一个摩天轮，学习如何使用 CSS 为元素设置动画、转换它们并调整它们的速度。 一、重点 CSS 代码Draw a wheel： 12345678910.wheel &#123; border: 2px solid black; border-radius: 50%; margin-left: 50px; position: absolute; height: 55vw; width: 55vw; max-width: 500px; max-height: 500px;&#125; The transform-origin property is used to set the point around which a CSS transformation is applied： 123456789.line &#123; background-color: black; width: 50%; height: 2px; position: absolute; top: 50%; left: 50%; transform-origin: 0% 0%;&#125; The transform property allows you to manipulate the shape of an element： 123456789101112131415.line:nth-of-type(2) &#123; transform: rotate(60deg);&#125;.line:nth-of-type(3) &#123; transform: rotate(120deg);&#125;.line:nth-of-type(4) &#123; transform: rotate(180deg);&#125;.line:nth-of-type(5) &#123; transform: rotate(240deg);&#125;.line:nth-of-type(6) &#123; transform: rotate(300deg);&#125; Set the origin point to be offset 50% from the left and 0% from the top, placing it in the middle of the top edge of the element： 12345678.cabin &#123; background-color: red; width: 20%; height: 20%; position: absolute; border: 2px solid; transform-origin: 50% 0%;&#125; The @keyframes at-rule is used to define the flow of a CSS animation. Within the @keyframes rule, you can create selectors for specific points in the animation sequence, such as 0% or 25%, or use from and to to define the start and end of the sequence； @keyframes rules require a name to be assigned to them, which you use in other rules to reference. For example, the @keyframes freeCodeCamp &#123; &#125; rule would be named freeCodeCamp： 12345678@keyframes wheel &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125; The animation-name property is used to link a @keyframes rule to a CSS selector； The animation-duration property is used to set how long the animation should sequence to complete； The animation-iteration-count property sets how many times your animation should repeat； The animation-timing-function property sets how the animation should progress over time： 1234567891011121314.wheel &#123; border: 2px solid black; border-radius: 50%; margin-left: 50px; position: absolute; height: 55vw; width: 55vw; max-width: 500px; max-height: 500px; animation-name: wheel; animation-duration: 10s; animation-iteration-count: infinite; animation-timing-function: linear;&#125; Use the animation property to set these all at once： 123456789.cabin &#123; background-color: red; width: 20%; height: 20%; position: absolute; border: 2px solid; transform-origin: 50% 0%; animation: cabins 10s ease-in-out infinite;&#125; @keyframes cabins： 1234567891011121314151617@keyframes cabins &#123; 0% &#123; transform: rotate(0deg); &#125; 25% &#123; background-color: yellow; &#125; 50% &#123; background-color: purple; &#125; 75% &#123; background-color: yellow; &#125; 100% &#123; transform: rotate(-360deg); &#125;&#125; 二、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"}]},{"title":"通过构建企鹅来学习 CSS 变换","slug":"CSS构建企鹅","date":"2022-06-17T16:00:00.000Z","updated":"2022-06-18T06:18:40.184Z","comments":true,"path":"CSS构建企鹅/","link":"","permalink":"http://blog.zhuangzhihao.top/CSS%E6%9E%84%E5%BB%BA%E4%BC%81%E9%B9%85/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第十四章。你可以转换 HTML 元素以创建吸引读者眼球的吸引人的设计，使用变换来旋转元素、缩放它们等等。在通过构建企鹅来学习 CSS 变换的课程中，构建一只企鹅，使用 CSS 变换来定位企鹅的各个部分并调整其大小、创建背景并为你的作品设置动画。","text":"freeCodeCamp 响应式网页设计的认证课程第十四章。你可以转换 HTML 元素以创建吸引读者眼球的吸引人的设计，使用变换来旋转元素、缩放它们等等。在通过构建企鹅来学习 CSS 变换的课程中，构建一只企鹅，使用 CSS 变换来定位企鹅的各个部分并调整其大小、创建背景并为你的作品设置动画。 一、重点 CSS 代码Normalize the page, add background： 12345678910111213141516body &#123; background: linear-gradient(45deg, rgb(118, 201, 255), rgb(247, 255, 222)); margin: 0; padding: 0; width: 100%; height: 100vh; overflow: clip;&#125;.ground &#123; width: 100vw; height: calc(100vh - 300px); background: linear-gradient(90deg, rgb(88, 175, 236), rgb(182, 255, 255)); z-index: 3; position: absolute; margin-top: -58px;&#125; Use the transform property to skew the mountain by 0deg in the x-axis and 44deg in the y-axis： 12345678910111213141516171819.left-mountain &#123; width: 300px; height: 300px; background: linear-gradient(rgb(203, 241, 228), rgb(80, 183, 255)); position: absolute; transform: skew(0deg, 44deg); z-index: 2; margin-top: 100px;&#125;.back-mountain &#123; width: 300px; height: 300px; background: linear-gradient(rgb(203, 241, 228), rgb(47, 170, 255)); position: absolute; z-index: 1; transform: rotate(45deg); left: 110px; top: 225px;&#125; Draw the sun： 123456789.sun &#123; width: 200px; height: 200px; background-color: yellow; position: absolute; border-radius: 50%; top: -75px; right: -75px;&#125; Draw the penguin： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168.penguin &#123; width: 300px; height: 300px; margin: auto; margin-top: 75px; z-index: 4; position: relative;&#125;.penguin * &#123; position: absolute;&#125;.penguin-head &#123; width: 50%; height: 45%; background: linear-gradient( 45deg, var(--penguin-skin), rgb(239, 240, 228) ); border-radius: 70% 70% 65% 65%; top: 10%; left: 25%; z-index: 1;&#125;.face &#123; width: 60%; height: 70%; background-color: var(--penguin-face); border-radius: 70% 70% 60% 60%; top: 15%;&#125;.face.left &#123; left: 5%;&#125;.face.right &#123; right: 5%;&#125;.chin &#123; width: 90%; height: 70%; background-color: var(--penguin-face); top: 25%; left: 5%; border-radius: 70% 70% 100% 100%;&#125;.eye &#123; width: 15%; height: 17%; background-color: black; top: 45%; border-radius: 50%;&#125;.eye.left &#123; left: 25%;&#125;.eye.right &#123; right: 25%;&#125;.eye-lid &#123; width: 150%; height: 100%; background-color: var(--penguin-face); top: 25%; left: -23%; border-radius: 50%;&#125;.blush &#123; width: 15%; height: 10%; background-color: pink; top: 65%; border-radius: 50%;&#125;.blush.left &#123; left: 15%;&#125;.blush.right &#123; right: 15%;&#125;.beak &#123; height: 10%; background-color: var(--penguin-picorna); border-radius: 50%;&#125;.beak.top &#123; width: 20%; top: 60%; left: 40%;&#125;.beak.bottom &#123; width: 16%; top: 65%; left: 42%;&#125;.shirt &#123; font: bold 25px Helvetica, sans-serif; top: 165px; left: 127.5px; z-index: 1; color: #6a6969;&#125;.shirt div &#123; font-weight: initial; top: 22.5px; left: 12px;&#125;.penguin-body &#123; width: 53%; height: 45%; background: linear-gradient( 45deg, rgb(134, 133, 133) 0%, rgb(234, 231, 231) 25%, white 67% ); border-radius: 80% 80% 100% 100%; top: 40%; left: 23.5%;&#125;.penguin-body::before &#123; content: &quot;&quot;; position: absolute; width: 50%; height: 45%; background-color: var(--penguin-skin); top: 10%; left: 25%; border-radius: 0% 0% 100% 100%; opacity: 70%;&#125;.arm &#123; width: 30%; height: 60%; background: linear-gradient( 90deg, var(--penguin-skin), rgb(209, 210, 199) ); border-radius: 30% 30% 30% 120%; z-index: -1;&#125;.arm.left &#123; top: 35%; left: 5%; transform-origin: top left; transform: rotate(130deg) scaleX(-1);&#125;.arm.right &#123; top: 0%; right: -5%; transform: rotate(-45deg);&#125;.foot &#123; width: 15%; height: 30%; background-color: var(--penguin-picorna); top: 85%; border-radius: 50%; z-index: -1;&#125;.foot.left &#123; left: 25%; transform: rotate(80deg);&#125;.foot.right &#123; right: 25%; transform: rotate(-80deg);&#125; CSS animations make the penguin wave： 1234567891011121314@keyframes wave &#123; 10% &#123; transform: rotate(110deg) scaleX(-1); &#125; 20% &#123; transform: rotate(130deg) scaleX(-1); &#125; 30% &#123; transform: rotate(110deg) scaleX(-1); &#125; 40% &#123; transform: rotate(130deg) scaleX(-1); &#125;&#125; Apply animations： 12345678910.arm.left &#123; top: 35%; left: 5%; transform-origin: top left; transform: rotate(130deg) scaleX(-1); animation-name: wave; animation-duration: 3s; animation-iteration-count: infinite; animation-timing-function: linear;&#125; Target the .penguin element when it is active, and increase its size by 50% in both dimensions： 123456789101112131415.penguin:active &#123; transform: scale(1.5); cursor: not-allowed;&#125;.penguin &#123; width: 300px; height: 300px; margin: auto; margin-top: 75px; z-index: 4; position: relative; transition-duration: 1s; transition-timing-function: ease-in-out; transition-delay: 0ms;&#125; 二、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"}]},{"title":"通过创建杂志学习 CSS 网格布局","slug":"CSS创建杂志","date":"2022-06-16T16:00:00.000Z","updated":"2022-06-18T06:21:51.161Z","comments":true,"path":"CSS创建杂志/","link":"","permalink":"http://blog.zhuangzhihao.top/CSS%E5%88%9B%E5%BB%BA%E6%9D%82%E5%BF%97/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第十三章。在网页设计时，CSS 网格布局使你能够控制网页的行、列。在通过创建杂志学习 CSS 网格布局的课程中，编写一篇杂志文章。你将学习如何使用 CSS Grid，其中包括了像网格行和网格列这样的概念。","text":"freeCodeCamp 响应式网页设计的认证课程第十三章。在网页设计时，CSS 网格布局使你能够控制网页的行、列。在通过创建杂志学习 CSS 网格布局的课程中，编写一篇杂志文章。你将学习如何使用 CSS Grid，其中包括了像网格行和网格列这样的概念。 一、重点 HTML 代码Image lazyload： 1234567&lt;img src=&quot;https://cdn.freecodecamp.org/platform/universal/fcc_meta_1920X1080-indigo.png&quot; alt=&quot;freecodecamp logo&quot; loading=&quot;lazy&quot; class=&quot;hero-img&quot; width=&quot;400&quot; /&gt; The Referer HTTP header contains information about the address or URL of a page that a user might be visiting from. This information can be used in analytics to track how many users from your page visit freecodecamp.org; For example. Setting the rel attribute to noreferrer omits this information from the HTTP request： 12&lt;a href=&quot;https://freecodecamp.org&quot; target=&quot;_blank&quot; rel=&quot;noreferrer&quot; &gt;freeCodeCamp&lt;/a&gt; 二、重点 CSS 代码Text decoration： 12345678html &#123; font-size: 62.5%; box-sizing: border-box;&#125;a &#123; text-decoration: none; color: linen;&#125; CSS Grid offers a two-dimensional grid-based layout, allowing you to center items horizontally and vertically while still retaining control to do things like overlap elements； Use the minmax function to make your columns responsive on any device： 12345main &#123; display: grid; grid-template-columns: minmax(2rem, 1fr) minmax(min-content, 94rem) minmax(2rem, 1fr); /* fr = fraction*/ row-gap: 3rem;&#125; Use the grid-column property to tell the .heading element to start at grid line 2 and end at grid line 3； The CSS repeat() function is used to repeat a value, setting the grid-template-columns property to repeat(20, 200px) would create 20 columns each 200px wide： 123456.heading &#123; grid-column: 2 / 3; display: grid; grid-template-columns: repeat(2, 1fr); row-gap: 1.5rem;&#125; Use -1 for the end column.： 1234.hero &#123; grid-column: 1 / -1; position: relative;&#125; The object-fit property tells the browser how to position the element within its container. In this case, cover will set the image to fill the container, cropping as needed to avoid changing the aspect ratio： 1234img &#123; width: 100%; object-fit: cover;&#125; The default settings for CSS Grid will create additional rows as needed, unlike Flexbox；Give the .social-icons selector a grid-template-columns property set to repeat(5, 1fr) to arrange the icons in a single row： 12345.social-icons &#123; display: grid; font-size: 3rem; grid-template-columns: repeat(5, 1fr);&#125; grid-auto-flow property takes either row or column as the first value, with an optional second value of dense；The dense value allows the algorithm to backtrack and fill holes in the grid with smaller items, which can result in items appearing out of order； align-items will align child elements along the column axis, and justify-items will align child elements along the row axis： 12345678.social-icons &#123; display: grid; font-size: 3rem; grid-template-columns: repeat(5, 1fr); grid-auto-flow: column; grid-auto-columns: 1fr; align-items: center;&#125; Create columns within an element without using Grid by using the column-width property： 1234567.text &#123; grid-column: 2 / 3; font-size: 1.8rem; letter-spacing: 0.6px; column-width: 25rem; text-align: justify;&#125; The ::first-letter pseudo-selector allows you to target the first letter in the text content of an element： 123456.first-paragraph::first-letter &#123; float: left; margin-right: 1rem; font-size: 6rem; color: orangered;&#125; Use list-style-type to get rid of the bullet points on the list items： 1234.lists &#123; list-style-type: none; margin-top: 2rem;&#125; The gap property is a shorthand way to set the value of row-gap andcolumn-gap at the same time； The place-items property can be used to set the align-items and justify-items values at the same time： 123456.image-wrapper &#123; display: grid; grid-template-columns: 2fr 1fr; grid-template-rows: repeat(3, min-content); gap: 2rem;&#125; 三、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"}]},{"title":"通过建立城市轮廓学习 CSS 变量","slug":"CSS建立城市轮廓","date":"2022-06-15T16:00:00.000Z","updated":"2022-06-18T05:01:33.052Z","comments":true,"path":"CSS建立城市轮廓/","link":"","permalink":"http://blog.zhuangzhihao.top/CSS%E5%BB%BA%E7%AB%8B%E5%9F%8E%E5%B8%82%E8%BD%AE%E5%BB%93/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第十二章。CSS 变量负责帮助组织你的样式和重复使用它们。在通过建立城市轮廓学习 CSS 变量的课程中，建立一座城市的轮廓，学习如何配置 CSS 变量，以便可以随时重复使用它们。","text":"freeCodeCamp 响应式网页设计的认证课程第十二章。CSS 变量负责帮助组织你的样式和重复使用它们。在通过建立城市轮廓学习 CSS 变量的课程中，建立一座城市的轮廓，学习如何配置 CSS 变量，以便可以随时重复使用它们。 一、重点 CSS 代码In CSS, you can target everything with an asterisk： 1234* &#123; border: 1px solid black; box-sizing: border-box;&#125; Center the parts of the building using “flex” or “flexbox”; 1234567.bb1 &#123; width: 10%; height: 70%; display: flex; flex-direction: column; align-items: center;&#125; Variable declarations begin with two dashes (-) and are given a name and a value like this: --variable-name: value;, variables are often declared in the :root selector： 12345:root &#123; --building-color1: #aa80ff; --building-color2: #66cc99; --building-color3: #cc6699;&#125; To use a variable, put the variable name in parentheses with var in front of them like this: var(--variable-name)： 12345.bb1a &#123; width: 70%; height: 10%; background-color: var(--building-color1, purple); /* purple is the fallback value */&#125; Use flexbox again to evenly space the buildings across the bottom of the element： 1234567.background-buildings &#123; display: flex; align-items: flex-end; justify-content: space-evenly; width: 100%; height: 100%;&#125; Gradients in CSS are a way to transition between colors across the distance of an element, they are applied to the background property： 123456789.bb1d &#123; width: 100%; height: 70%; background: linear-gradient( orange, var(--building-color1) 80%, var(--window-color1) );&#125; Make the four colors of your gradient repeat until it gets to the bottom of the element; giving you some stripes： 12345678910.bb2b &#123; width: 100%; height: 100%; background: repeating-linear-gradient( var(--building-color2), var(--building-color2) 6%, var(--window-color2) 6%, var(--window-color2) 9% );&#125; You can add multiple gradients to an element by separating them with a comma (,)： 1234567891011121314151617.fb6 &#123; width: 9%; height: 38%; background: repeating-linear-gradient( 90deg, var(--building-color3), var(--building-color3) 10%, transparent 10%, transparent 30% ), repeating-linear-gradient( var(--building-color3), var(--building-color3) 10%, var(--window-color3) 10%, var(--window-color3) 30% );&#125; Sky background： 123456789.sky &#123; background: radial-gradient( circle closest-corner at 15% 15%, #ffcf33, #ffcf33 20%, #ffff66 21%, #bbeeff 100% );&#125; A media query can be used to change styles based on certain conditions： 123456789101112131415161718192021@media (max-width: 1000px) &#123; :root &#123; --building-color1: #000; --building-color2: #000; --building-color3: #000; --building-color4: #000; --window-color1: #777; --window-color2: #777; --window-color3: #777; --window-color4: #777;&#125; .sky &#123; background: radial-gradient( closest-corner circle at 15% 15%, #ccc, #ccc 20%, #445 21%, #223 100% ); &#125;&#125; 二、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"}]},{"title":"通过创建一架钢琴来学习响应式网页设计","slug":"响应式网页创建一架钢琴","date":"2022-06-11T16:00:00.000Z","updated":"2022-06-11T09:44:58.674Z","comments":true,"path":"响应式网页创建一架钢琴/","link":"","permalink":"http://blog.zhuangzhihao.top/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E5%88%9B%E5%BB%BA%E4%B8%80%E6%9E%B6%E9%92%A2%E7%90%B4/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第十一章。响应式设计使得你的网页适应不同屏幕尺寸的显示。在通过创建一架钢琴来学习响应式网页设计的课程中，围绕一架钢琴编写代码学习 CSS 响应式设计，同时学会媒体条件和伪选择器的知识。","text":"freeCodeCamp 响应式网页设计的认证课程第十一章。响应式设计使得你的网页适应不同屏幕尺寸的显示。在通过创建一架钢琴来学习响应式网页设计的课程中，围绕一架钢琴编写代码学习 CSS 响应式设计，同时学会媒体条件和伪选择器的知识。 一、重点 CSS 代码Browsers can apply default margin and padding values to specific elements. To make sure your piano looks correct, you need to reset the box model： 123html &#123; box-sizing: border-box;&#125; You have reset the html box model, you need to pass that on to the elements within as well. The ::before selector creates a pseudo-element which is the first child of the selected element, while the ::after selector creates a pseudo-element which is the last child of the selected element： 123*, ::before, ::after &#123; box-sizing: inherit;&#125; 钢琴、琴键轮廓 🎹： 123456789101112131415161718192021222324252627#piano &#123; background-color: #00471b; width: 992px; height: 290px; margin: 80px auto; padding: 90px 20px 0 20px; position: relative; border-radius: 10px;&#125;.keys &#123; background-color: #040404; width: 949px; height: 180px; padding-left: 2px; overflow: hidden; /* hide any element that is pushed outside the set width value of .keys */&#125;.key &#123; background-color: #ffffff; position: relative; width: 41px; height: 175px; margin: 2px; float: left; border-radius: 0 0 3px 3px;&#125; To create the black keys, add a new .key.black--key::after selector. This will target the elements with the class key black--key, and select the pseudo-element after these elements in the HTML. The content property is used to set or override the content of the element. By default, the pseudo-elements created by the ::before and ::after pseudo-selectors are empty, and the elements will not be rendered to the page： 123456789.key.black--key::after &#123; background-color: #1d1e22; content: &quot;&quot;; /* make the pseudo-elements empty */ position: absolute; left: -18px; width: 32px; height: 100px; border-radius: 0 0 3px 3px;&#125; Styling the logo： 12345.logo &#123; width: 200px; position: absolute; top: 23px;&#125; @media 属性 Make it responsive： 1234567891011121314151617181920@media (max-width: 768px) &#123; #piano &#123; width: 358px; &#125; .keys &#123; width: 318px; &#125; .logo &#123; width: 150px; &#125;&#125;@media (max-width: 1199px) and (min-width: 769px) &#123; #piano &#123; width: 675px; &#125; .keys &#123; width: 633px; &#125;&#125; 二、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"}]},{"title":"创建一副毕加索绘画来学习中级 CSS","slug":"CSS创建一幅毕加索画","date":"2022-06-10T16:00:00.000Z","updated":"2022-06-11T08:59:27.966Z","comments":true,"path":"CSS创建一幅毕加索画/","link":"","permalink":"http://blog.zhuangzhihao.top/CSS%E5%88%9B%E5%BB%BA%E4%B8%80%E5%B9%85%E6%AF%95%E5%8A%A0%E7%B4%A2%E7%94%BB/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第十章。在创建一副毕加索绘画来学习中级 CSS 的课程中，通过代码创建一幅自己的毕加索绘画网页来掌握中级 CSS 技术。课程涉及 SVG 图标、CSS 定位和对已学 CSS 知识的回顾。","text":"freeCodeCamp 响应式网页设计的认证课程第十章。在创建一副毕加索绘画来学习中级 CSS 的课程中，通过代码创建一幅自己的毕加索绘画网页来掌握中级 CSS 技术。课程涉及 SVG 图标、CSS 定位和对已学 CSS 知识的回顾。 一、重点 HTML 代码FontAwesome is a library of SVG-powered icons, many of which are freely available to use： 123456&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Picasso Painting&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./styles.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://use.fontawesome.com/releases/v5.8.2/css/all.css&quot;&gt; &lt;!--FontAwesome--&gt;&lt;/head&gt; The i element is used for idiomatic text, or text that is separate from the “normal” text content. This could be for italic text, such as scientific terms, or for icons like those provided by FontAwesome： 123456789&lt;div id=&quot;guitar&quot;&gt; &lt;div class=&quot;guitar&quot; id=&quot;guitar-left&quot;&gt; &lt;i class=&quot;fas fa-bars&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;guitar&quot; id=&quot;guitar-right&quot;&gt; &lt;i class=&quot;fas fa-bars&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div id=&quot;guitar-neck&quot;&gt;&lt;/div&gt;&lt;/div&gt; 二、重点 CSS 代码An absolute position takes the element out of that top-down document flow and allows you to adjust it relative to its container. When an element is manually positioned, you can shift its layout with top, left, right, and bottom： 12345678#offwhite-character &#123; width: 300px; height: 550px; background-color: GhostWhite; position: absolute; top: 20%; left: 17.5%;&#125; The z-index property is used to create “layers” for your HTML elements. Elements with a higher z-index value will appear to be layered on top of elements with a lower z-index value： 123456789#back-wall &#123; background-color: #8B4513; width: 100%; height: 60%; position: absolute; top: 0; left: 0; z-index: -1;&#125; border-style、border-width 属性： 12345678910111213#white-hat &#123; width: 0; height: 0; border-style: solid; border-width: 0 120px 140px 180px; border-top-color: transparent; border-right-color: transparent; border-bottom-color: GhostWhite; border-left-color: transparent; position: absolute; top: -140px; left: 0;&#125; display: block 属性： 123456789.black-dot &#123; width: 10px; height: 10px; background-color: rgb(45, 31, 19); border-radius: 50%; display: block; margin: auto; margin-top: 65%;&#125; display: inline-block 属性： 12345.fa-music &#123; display: inline-block; margin-top: 8%; margin-left: 13%;&#125; border-radius 属性： 12345678910#black-round-hat &#123; width: 180px; height: 150px; background-color: rgb(45, 31, 19); border-radius: 50%; position: absolute; top: -100px; left: 5px; z-index: -1;&#125; 更改 FontAwesome 大小： 123.fas &#123; font-size: 30px;&#125; 三、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://blog.zhuangzhihao.top/tags/HTML/"}]},{"title":"C++ 的引用","slug":"Cpp引用","date":"2022-06-05T16:00:00.000Z","updated":"2022-06-09T07:26:46.702Z","comments":true,"path":"Cpp引用/","link":"","permalink":"http://blog.zhuangzhihao.top/Cpp%E5%BC%95%E7%94%A8/","excerpt":"严老师的数据结构和王道数据结构都是用的 C 语言语法，但是额外使用了 C++的引用。引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。相对于 C 指针来说，C++ 引用会便捷许多。","text":"严老师的数据结构和王道数据结构都是用的 C 语言语法，但是额外使用了 C++的引用。引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。相对于 C 指针来说，C++ 引用会便捷许多。 一、引用的使用通过原始变量名称或引用来访问变量的内容。我们在修改函数外的某一变量时，使用了引用后，在子函数内的操作和函数外操作手法一致，这样编程效率较高，对于初学者理解也非常方便。 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; // 声明简单的变量 int i; double d; // 声明引用变量 int &amp;r = i; double &amp;s = d; i = 5; cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r &lt;&lt; endl; d = 11.7; cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s &lt;&lt; endl; return 0;&#125; 二、C 指针 vs C++ 引用引用必须连接到一块合法的内存，不存在空引用；一旦引用被初始化为一个对象，就不能被指向到另一个对象，指针可以在任何时候指向到另一个对象；引用必须在创建时被初始化，指针可以在任何时间被初始化。 在子函数内修改主函数的普通变量C 指针： 12345678910void modify_num(int *b)&#123; ++(*b);&#125;int main()&#123; int a = 10; modify_num(&amp;a)&#125; C ++ 引用： 123456789void modify_num(int &amp;b)&#123; ++b;&#125;int main()&#123; int a = 10; modify_num(a)&#125; 在子函数内修改主函数的一级指针C 指针： 12345678910void modify_pointer(int **p)&#123; *p = q;&#125;int main()&#123; int *p = NULL; modify_pointer(&amp;p)&#125; C ++ 引用： 12345678910void modify_pointer(int *&amp;p)&#123; p = q;&#125;int main()&#123; int *p = NULL; modify_pointer(p)&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://blog.zhuangzhihao.top/categories/C-C/"}],"tags":[]},{"title":"如何说话 - How to Speak","slug":"如何说话","date":"2022-05-31T16:00:00.000Z","updated":"2022-06-05T07:50:12.404Z","comments":true,"path":"如何说话/","link":"","permalink":"http://blog.zhuangzhihao.top/%E5%A6%82%E4%BD%95%E8%AF%B4%E8%AF%9D/","excerpt":"大约40年前，Patrick Henry Winston 教授发表了他的第一次“如何说话”的演讲。正如他在 2010 年的这篇文章中所写的那样：“Robert Sjoberg 让我这样做，我们坐在办公室里，抱怨某人的可怕讲座，当他说：‘你应该做一个关于如何说话的IAP课程。’‘不，’我说，‘我从来没有讲过比 B+ 更好的演讲，之后我会抑郁一个月，需要一个星期的时间来准备，而且，没有人会来。’‘我会来的，’他说。” 如今，How to Speak 已经成为 MIT 深受欢迎的热门课，听完这门课也是让我受益匪浅。","text":"大约40年前，Patrick Henry Winston 教授发表了他的第一次“如何说话”的演讲。正如他在 2010 年的这篇文章中所写的那样：“Robert Sjoberg 让我这样做，我们坐在办公室里，抱怨某人的可怕讲座，当他说：‘你应该做一个关于如何说话的IAP课程。’‘不，’我说，‘我从来没有讲过比 B+ 更好的演讲，之后我会抑郁一个月，需要一个星期的时间来准备，而且，没有人会来。’‘我会来的，’他说。” 如今，How to Speak 已经成为 MIT 深受欢迎的热门课，听完这门课也是让我受益匪浅。 一、How to Speak 公开课 二、开场白《军法法典》规定任何军官在没有武器的情况下派遣士兵参加战斗，都要接受军事法庭的审判。同理学生不应该没有交流能力就走进生活。因为你的人生的成功，在很大程度上取决于你说话的能力、写作能力和思想的质量。在 Winston 教授看来，表达能力的好坏可以用一个公式表示出来： Quality=\\int \\left( K,P,t\\right)其中，知识（Knowledge）的权重大于练习（Practice）的权重更远大于天赋（Talent）的权重。我们或许不具有超乎常人的表达天赋，但是了解表达的技巧知识，加上反复的练习，也能具有优秀的表达能力。 最有效的开场，是从承诺（Empowerment promise）开始。尽管许多人建议用笑话来作为开场白，但其实这是不合理的。因为这个时候听众都还在尝试去适应你的声音，音量，说话节奏等等，他们还没有做好听一个笑话的准备。当然，也可以提一个问题，如“宇宙中有多少行星是可以居住的？” 或者可以阐述一个带点震撼力的事实或数据，如“宇宙中有一百万亿颗可居住的行星。” 给观众一个预期，可以了解接下来要听什么，那些地方可能是重点，哪些地方可以少许放松。 三、演讲的过程首先，我们常说：重要的事情说三遍，演讲也是如此，对每一个重要的标题要重复至少三次（Cycle on subject）。因为听众很有可能会走神，如果重点只说一遍的话，听众会没有注意到，容易忘记。新近的研究发现，当代人们的注意力时长大概只有 5 分钟，因为听众的注意力有限，如果一口气吧内容全讲下去的话，听众很容易逐渐丢失你所要表达的重点，需要利用一些表达上的技巧帮助听众回到你的话题和内容上来，你可以每五分钟停顿片刻，插入一个小故事，说个笑话，总结一下你刚说的。 其次需要把自己的观点和他人的观点之间建立边界（Build a fence）阐明自己的观点和别人的观点在哪里不同。观点相似，听众没必要听你，只有把你的观点跟别人的观点区分开来，就像扎一道篱笆，才不会让人混淆，同样一个问题，你换个角度来看，别人才会有兴趣听。 最后，Winston教授认为，善于提问对演讲者来说也是一个需要学习的技巧。提问有许多作用：引起听众注意，引进新话题，温习讲过的内容。你需要掌控局面，就必须避免泛泛的、无方向和无重点的问题。提出的问题不能太难，不然没人能回答，也不能太简单，不然大家会因为过于简单而羞于作答。在提出问题之后，等待一会儿（7 seconds）再公布答案。 四、演讲的环境关于演讲的时间和地点，不同听众数量的演讲应该选择的不同的演讲地点，一个小型演讲就不应该选择一个过大的演讲场地，低上座率会影响到你的心情，从而影响你的演讲效果。场地一定要光线充足，因为光线不好，人们的潜意识充满困意。曾有演讲地点准备的工作人员跟 Winston 教授讲过如果房间太亮堂的话听众会没办法看幻灯片，Winston 教授则说：“听众在睡着的时候也没办法看幻灯片。”而时间上最好是上午11点，这个时候大家都是醒着的。 多一点板书，少一点幻灯片。Winston 教授认为演讲者通过黑板和小道具，可以让听众进行同理性镜像模拟（Empathetic mirroring），即听众会形成自己也做了跟演讲者相同的事情的感觉，这样会让听众留下更加深刻的印象，当你坐在那里看着我在黑板上写字的时候，你头脑中所有那些小小的镜像神经元都被激活了，你可以感觉到是自己在黑板上写字，但是幻灯片无法做到这一点。 幻灯片上字不要太多了，也不要太小。谨记幻灯片只是锦上添花，而不是主角。保持幻灯片的整洁和整齐，呈现的图片也要尽可能地简单直观，不用写标题，因为标题应该是由演讲者讲出来的。演讲的时候不要用激光笔，不要双手插兜，也不要去读幻灯片。 五、如何准备演讲多讲故事，打动听众的心，人类是讲故事（Storytelling）的动物，我们从小就通过各种童话故事来理解世界，借助这故事我们逐渐建构自己的知识体系，学习更加专业的知识，因此我们应该以讲故事的方式去构建我们的演讲，不仅要捕捉住听众的思想，还要在情感上打动他们，捕捉住他们的心。 演讲的技巧很重要，用 5S（⭐️）代表五角星的五个点。用一个独特的符号来代表你的想法（Symbol）；用一句口号，把要说的内容全都塞进去（Slogan）；用一个令人惊讶的例子提起听众的兴趣（Surprise）；用一个众多好的想法中脱颖而出（stick out）的想法强调你跟他人的不一样（Salient ideas）；讲一个故事（How you did it，How it work，Why it’s important）（Story）。 在口语考试（Oral test）中，要思考如何让没有背景知识的听众听懂，明白你在做什么，你想要表达什么。事先最好找一个不太了解你演讲内容的朋友帮你预先模拟练习是否能让他听懂。在工作面试（Job Interview）中，快速（in 5 minute）表明你的远见（Vision）和你所做过的事情（Done Something）。远见中包括可能遇到的问题（Problem）和你的方法中新颖的部分（Approach）。做过的事情可以分步描述为了解决某个问题所需要的步骤，你不需要把所有步骤都做掉，没做过的地方就可以说是接下来需要做的。 六、最后的结尾最后一张幻灯片是一个你向别人介绍自己是谁的机会。把你合作的人放到第一张幻灯片去，在最后一张幻灯片上应该放的是你在其中做的贡献（Contributions），省略具体细节，没人会真的记录下来。 About final words，用笑话来结束一场演讲是不错的选择，也可以简单总结你的核心观点，简单表现你的心情（It’s being great fun being here），不用在结尾太过谦卑，“谢谢”、“对不起”、“还有问题吗”这些结束语并不好，白白浪费了讲话的最后几分钟。 “By the end of the next 60 minutes you will have been exposed to a lot of ideas, some of which you will incorporate into your own repertoire, and they will ensure that you get the maximum opportunity to have your ideas valued and accepted by the people you speak with.”，这是 Patrick Winston 教授写在课程前的话，这门课程也真的让我受益很多，其中有许多细节正是我们自己在 Presentation 或者 Interview 中所没注意到的，在 Medium 上也有人总结了更多细节要点：What I learned from “How To Speak” by Patrick Winston (MIT)，这篇演讲也值得一看再看。","categories":[{"name":"观点与感想","slug":"观点与感想","permalink":"http://blog.zhuangzhihao.top/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"}],"tags":[]},{"title":"通过构建资产负债表了解有关 CSS 伪选择器的更多信息","slug":"CSS构建资产负债表","date":"2022-05-30T16:00:00.000Z","updated":"2022-05-31T06:25:39.860Z","comments":true,"path":"CSS构建资产负债表/","link":"","permalink":"http://blog.zhuangzhihao.top/CSS%E6%9E%84%E5%BB%BA%E8%B5%84%E4%BA%A7%E8%B4%9F%E5%80%BA%E8%A1%A8/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第九章。可以使用 CSS 伪选择器来更改特定的 HTML 元素。在通过构建资产负债表了解有关 CSS 伪选择器的更多信息的课程中，使用伪选择器构建资产负债表，学习如何在将鼠标悬停在元素上时更改其样式，并触发网页上的其他事件。","text":"freeCodeCamp 响应式网页设计的认证课程第九章。可以使用 CSS 伪选择器来更改特定的 HTML 元素。在通过构建资产负债表了解有关 CSS 伪选择器的更多信息的课程中，使用伪选择器构建资产负债表，学习如何在将鼠标悬停在元素上时更改其样式，并触发网页上的其他事件。 一、重点 HTML 代码flex class： 123456&lt;h1&gt; &lt;span class=&quot;flex&quot;&gt; &lt;span&gt;AcmeWidgetCorp&lt;/span&gt; &lt;span&gt;Balance Sheet&lt;/span&gt; &lt;/span&gt;&lt;/h1&gt; aria-hidden 属性： 12345&lt;div id=&quot;years&quot; aria-hidden=&quot;true&quot;&gt; &lt;span class=&quot;year&quot;&gt;2019&lt;/span&gt; &lt;span class=&quot;year&quot;&gt;2020&lt;/span&gt; &lt;span class=&quot;year&quot;&gt;2021&lt;/span&gt;&lt;/div&gt; HTML table 标签: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class=&quot;table-wrap&quot;&gt; &lt;table&gt; &lt;caption&gt;Assets&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;th&gt;&lt;span class=&quot;sr-only year&quot;&gt;2019&lt;/span&gt;&lt;/th&gt; &lt;th&gt;&lt;span class=&quot;sr-only year&quot;&gt;2020&lt;/span&gt;&lt;/th&gt; &lt;th class=&quot;current&quot;&gt;&lt;span class=&quot;sr-only year&quot;&gt;2021&lt;/span&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=&quot;data&quot;&gt; &lt;th&gt;Cash &lt;span class=&quot;description&quot;&gt;This is the cash we currently have on hand.&lt;/span&gt;&lt;/th&gt; &lt;td&gt;$25&lt;/td&gt; &lt;td&gt;$30&lt;/td&gt; &lt;td class=&quot;current&quot;&gt;$28&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;data&quot;&gt; &lt;th&gt;Checking &lt;span class=&quot;description&quot;&gt;Our primary transactional account.&lt;/span&gt;&lt;/th&gt; &lt;td&gt;$54&lt;/td&gt; &lt;td&gt;$56&lt;/td&gt; &lt;td class=&quot;current&quot;&gt;$53&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;data&quot;&gt; &lt;th&gt;Savings &lt;span class=&quot;description&quot;&gt;Funds set aside for emergencies.&lt;/span&gt;&lt;/th&gt; &lt;td&gt;$500&lt;/td&gt; &lt;td&gt;$650&lt;/td&gt; &lt;td class=&quot;current&quot;&gt;$728&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;total&quot;&gt; &lt;th&gt;Total &lt;span class=&quot;sr-only&quot;&gt;Assets&lt;/span&gt;&lt;/th&gt; &lt;td&gt;$579&lt;/td&gt; &lt;td&gt;$736&lt;/td&gt; &lt;td class=&quot;current&quot;&gt;$809&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;!--同理多个&lt;table&gt;&lt;/table&gt;--&gt;&lt;/div&gt; 二、重点 CSS 代码box-sizing 属性： 1234567html &#123; box-sizing: border-box;&#125;body &#123; font-family: sans-serif; color: #0a0a23;&#125; The span[class~=&quot;sr-only&quot;] selector will select any span element whose class includes sr-only： 123456789101112131415161718span[class~=&quot;sr-only&quot;] &#123; border: 0 !important; clip: rect(1px, 1px, 1px, 1px) !important; clip-path: inset(50%) !important; -webkit-clip-path: inset(50%) !important; height: 1px !important ; width: 1px !important; position: absolute !important; overflow: hidden !important; white-space: nowrap !important; padding: 0 !important; margin: -1px !important;&#125;/*The CSS clip property is used to define the visible portions of an element.The clip-path property determines the shape the clip property should take.use the !important keyword to ensure these properties are always applied, regardless of order or specificity.*/ flex-direction 属性： 12345678910h1 &#123; max-width: 37.25rem; margin: 0 auto; padding: 1.5rem 1.25rem;&#125;h1 .flex &#123; display: flex; flex-direction: column-reverse; gap: 1rem;&#125; The :first-of-type pseudo-selector is used to target the first element that matches the selector： 1234567h1 .flex span:first-of-type &#123; font-size: 0.7em;&#125;/* The :last-of-type pseudo-selector does the exact opposite - it targets the last element that matches the selector. */h1 .flex span:last-of-type &#123; font-size: 1.2em;&#125; section、.table-wrap selector： 12345678section &#123; max-width: 40rem; margin: 0 auto; border: 2px solid #d0d0d5;&#125;.table-wrap &#123; padding: 0 0.75rem 1.5rem 0.75rem;&#125; The calc() function is a CSS function that allows you to calculate a value based on other values： 1234567891011#years &#123; display: flex; justify-content: flex-end; position: sticky; top: 0; background: #0a0a23; color: #fff; z-index: 999; margin: 0 -2px; padding: 0.5rem calc(1.25rem + 2px) 0.5rem 0;&#125; The span[class] syntax will target any spanelement that has a class attribute set, regardless of the attribute’s value： 12345#years span[class] &#123; font-weight: bold; width: 4.5rem; text-align: right;&#125; The :not() pseudo-selector is used to target all elements that do not match the selector： 123span:not(.sr-only) &#123; font-weight: normal;&#125; table selector： 1234567table &#123; border-collapse: collapse; /* allow cell borders to collapse into a single border */ border: 0; width: 100%; position: relative; margin-top: 3rem;&#125; caption selector： 12345678table caption &#123; color: #356eaf; font-size: 1.3em; font-weight: normal; position: absolute; top: -2.25rem; left: 0.5rem;&#125; tbody selector： 12345678tbody td &#123; width: 100vw; /* fill the viewport */ min-width: 4rem; max-width: 4rem;&#125;tbody th &#123; width: calc(100% - 12rem);&#125; The [attribute=&quot;value&quot;] selector targets any element that has an attribute with a specific value： 1234tr[class=&quot;total&quot;] th &#123; text-align: left; padding: 0.5rem 0 0.25rem 0.5rem;&#125; The key difference between tr[class=&quot;total&quot;] and tr.total is that the first will select tr elements where the only class is total. The second will select tr elements where the class includes total： 1234tr.total td &#123; text-align: right; padding: 0 0.25rem;&#125; The :nth-of-type() pseudo-selector is used to target specific elements based on their order among siblings of the same type： 123tr.total td:nth-of-type(3) &#123; padding-right: 0.5rem;&#125; 其他 table 行/列属性： 1234567891011121314tr.total:hover &#123; background-color: #99c9ff;&#125;td.current &#123; font-style: italic;&#125;tr.data &#123; background-image: linear-gradient(to bottom, #dfdfe2 1.845rem, white 1.845rem);&#125;tr.data th &#123; text-align: left; padding-top: 0.3rem; padding-left: 0.5rem;&#125; tr.data th .description selector target the elements with the class set to description that are within your th elements in your .data table rows： 123tr.total:hover &#123; background-color: #99c9ff;&#125; block display： 1234567tr.data th .description &#123; display: block; font-weight: normal; font-style: italic; padding: 1rem 0 0.75rem; margin-right: -13.5rem;&#125; Vertically align the text to the top, horizontally align the text to the right： 12345678tr.data td &#123; vertical-align: top; padding: 0.3rem 0.25rem 0; text-align: right;&#125;tr.data td:last-of-type &#123; padding-right: 0.5rem;&#125; 三、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://blog.zhuangzhihao.top/tags/HTML/"}]},{"title":"通过编写小测验学习无障碍","slug":"编写小测验学习无障碍","date":"2022-05-25T16:00:00.000Z","updated":"2022-05-26T06:53:39.674Z","comments":true,"path":"编写小测验学习无障碍/","link":"","permalink":"http://blog.zhuangzhihao.top/%E7%BC%96%E5%86%99%E5%B0%8F%E6%B5%8B%E9%AA%8C%E5%AD%A6%E4%B9%A0%E6%97%A0%E9%9A%9C%E7%A2%8D/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第八章。无障碍环境使你的网页便于所有人使用，甚至是残疾人。在通过编写小测验学习无障碍的课程中，建立一个测验网页，学习诸如键盘快捷键、ARIA 属性和设计最佳实践等无障碍工具。","text":"freeCodeCamp 响应式网页设计的认证课程第八章。无障碍环境使你的网页便于所有人使用，甚至是残疾人。在通过编写小测验学习无障碍的课程中，建立一个测验网页，学习诸如键盘快捷键、ARIA 属性和设计最佳实践等无障碍工具。 一、重点 HTML 代码head： 1234567&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;freeCodeCamp Accessibility Quiz practice project&quot; /&gt; &lt;title&gt;Accessibility Quiz&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; /&gt;&lt;/head&gt; header： 1234567891011&lt;header&gt; &lt;img id=&quot;logo&quot; src=&quot;https://cdn.freecodecamp.org/platform/universal/fcc_primary.svg&quot;&gt; &lt;h1&gt;HTML/CSS Quiz&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#student-info&quot; accesskey=&quot;i&quot;&gt;INFO&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#html-questions&quot; accesskey=&quot;h&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#css-questions&quot; accesskey=&quot;c&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt; student-info: 123456789101112131415&lt;section role=&quot;region&quot; aria-labelledby=&quot;student-info&quot;&gt; &lt;h2 id=&quot;student-info&quot;&gt;Student Info&lt;/h2&gt; &lt;div class=&quot;info&quot;&gt; &lt;label for=&quot;student-name&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;student-name&quot; id=&quot;student-name&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;label for=&quot;student-email&quot;&gt;Email:&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;student-email&quot; id=&quot;student-email&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;label for=&quot;birth-date&quot;&gt;D.O.B.&lt;span class=&quot;sr-only&quot;&gt;(Date of Birth)&lt;/span&gt;&lt;/label&gt; &lt;input type=&quot;date&quot; name=&quot;birth-date&quot; id=&quot;birth-date&quot; /&gt; &lt;/div&gt;&lt;/section&gt; html-questions： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;section role=&quot;region&quot; aria-labelledby=&quot;html-questions&quot;&gt; &lt;h2 id=&quot;html-questions&quot;&gt;HTML&lt;/h2&gt; &lt;div class=&quot;question-block&quot;&gt; &lt;p&gt;1&lt;/p&gt; &lt;fieldset class=&quot;question&quot; name=&quot;html-question-one&quot;&gt; &lt;legend&gt; The legend element represents a caption for the content of its parent fieldset element &lt;/legend&gt; &lt;ul class=&quot;answers-list&quot;&gt; &lt;li&gt; &lt;label for=&quot;q1-a1&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;q1-a1&quot; name=&quot;q1&quot; value=&quot;true&quot; /&gt; True &lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=&quot;q1-a2&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;q1-a2&quot; name=&quot;q1&quot; value=&quot;false&quot; /&gt; False &lt;/label&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/fieldset&gt; &lt;/div&gt; &lt;div class=&quot;question-block&quot;&gt; &lt;p&gt;2&lt;/p&gt; &lt;fieldset class=&quot;question&quot; name=&quot;html-question-two&quot;&gt; &lt;legend&gt; A label element nesting an input element is required to have a for attribute with the same value as the input&#x27;s id &lt;/legend&gt; &lt;ul class=&quot;answers-list&quot;&gt; &lt;li&gt; &lt;label for=&quot;q2-a1&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;q2-a1&quot; name=&quot;q2&quot; value=&quot;true&quot; /&gt; True &lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=&quot;q2-a2&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;q2-a2&quot; name=&quot;q2&quot; value=&quot;false&quot; /&gt; False &lt;/label&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/fieldset&gt; &lt;/div&gt;&lt;/section&gt; css-questions： 12345678910111213141516171819202122&lt;section role=&quot;region&quot; aria-labelledby=&quot;css-questions&quot;&gt; &lt;h2 id=&quot;css-questions&quot;&gt;CSS&lt;/h2&gt; &lt;div class=&quot;formrow&quot;&gt; &lt;div class=&quot;question-block&quot;&gt; &lt;label for=&quot;customer&quot;&gt;Are you a frontend developer?&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;answer&quot;&gt; &lt;select name=&quot;customer&quot; id=&quot;customer&quot; required&gt; &lt;option value=&quot;&quot;&gt;Select an option&lt;/option&gt; &lt;option value=&quot;yes&quot;&gt;Yes&lt;/option&gt; &lt;option value=&quot;no&quot;&gt;No&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;question-block&quot;&gt; &lt;label for=&quot;css-questions&quot;&gt;Do you have any questions:&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;answer&quot;&gt; &lt;textarea id=&quot;css-questions&quot; name=&quot;css-questions&quot; rows=&quot;5&quot; cols=&quot;24&quot; placeholder=&quot;Who is flexbox...&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; footer： 12345678&lt;footer&gt; &lt;address&gt; &lt;a href=&quot;https://freecodecamp.org&quot;&gt;freeCodeCamp&lt;/a&gt;&lt;br /&gt; San Francisco&lt;br /&gt; California&lt;br /&gt; USA &lt;/address&gt;&lt;/footer&gt; 二、重点 CSS 代码@media 属性： 12345@media (prefers-reduced-motion: no-preference) &#123; * &#123; scroll-behavior: smooth; &#125;&#125; body，header： 12345678910111213141516body &#123; background: #f5f6f7; color: #1b1b32; font-family: Helvetica; margin: 0;&#125;header &#123; width: 100%; height: 50px; background-color: #1b1b32; display: flex; justify-content: space-between; align-items: center; position: fixed; top: 0;&#125; logo，nav： 12345678910111213141516171819202122232425262728293031323334353637383940#logo &#123; width: max(100px, 18vw); background-color: #0a0a23; aspect-ratio: 35 / 4; padding: 0.4rem;&#125;h1 &#123; color: #f1be32; font-size: min(5vw, 1.2em); text-align: center;&#125;nav &#123; width: 50%; max-width: 300px; height: 50px;&#125;nav&gt;ul &#123; display: flex; justify-content: space-evenly; flex-wrap: wrap; align-items: center; padding-inline-start: 0; margin-block: 0; height: 100%;&#125;nav&gt;ul&gt;li &#123; color: #dfdfe2; margin: 0 0.2rem; padding: 0.2rem; display: block;&#125;nav&gt;ul&gt;li:hover &#123; background-color: #dfdfe2; color: #1b1b32; cursor: pointer;&#125;li&gt;a &#123; color: inherit; text-decoration: none;&#125; 表单 1： 12345678910111213141516171819202122232425262728293031323334353637383940main &#123; padding-top: 50px;&#125;section &#123; width: 80%; margin: 0 auto 10px auto; max-width: 600px;&#125;h1,h2 &#123; font-family: Verdana, Tahoma;&#125;h2 &#123; border-bottom: 4px solid #dfdfe2; margin-top: 0px; padding-top: 60px;&#125;.info &#123; padding: 10px 0 0 5px;&#125;.formrow &#123; margin-top: 30px; padding: 0px 15px;&#125;input &#123; font-size: 16px;&#125;.info label,.info input &#123; display: inline-block; text-align: right;&#125;.info input &#123; width: 50%; text-align: left;&#125;.info label &#123; width: 10%; min-width: 55px;&#125; 表单 2、3： 1234567891011121314151617181920212223242526272829303132.question-block &#123; text-align: left; display: block; width: 100%; margin-top: 20px; padding-top: 5px;&#125;p &#123; margin-top: 5px; padding-left: 15px; font-size: 20px;&#125;p::before &#123; content: &quot;Question #&quot;;&#125;.question &#123; border: none; padding-bottom: 0;&#125;.answers-list &#123; list-style: none; padding: 0;&#125;button &#123; display: block; margin: 40px auto; width: 40%; padding: 15px; font-size: 23px; background: #d0d0d5; border: 3px solid #3b3b4f;&#125; .sr-only selector： 1234567891011.sr-only &#123; position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0;&#125; 三、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://blog.zhuangzhihao.top/tags/HTML/"}]},{"title":"通过建立营养标签来学习排版","slug":"建立营养标签来学习排版","date":"2022-05-24T16:00:00.000Z","updated":"2022-05-26T06:53:53.636Z","comments":true,"path":"建立营养标签来学习排版/","link":"","permalink":"http://blog.zhuangzhihao.top/%E5%BB%BA%E7%AB%8B%E8%90%A5%E5%85%BB%E6%A0%87%E7%AD%BE%E6%9D%A5%E5%AD%A6%E4%B9%A0%E6%8E%92%E7%89%88/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第七章。排版是将文本样式设置为易于阅读并适合其目的的艺术。在通过建立营养标签来学习排版的课程中，你将使用排版来构建营养标签网页。你将学习如何使用 CSS 设置文本样式、调整行高和定位文本。","text":"freeCodeCamp 响应式网页设计的认证课程第七章。排版是将文本样式设置为易于阅读并适合其目的的艺术。在通过建立营养标签来学习排版的课程中，你将使用排版来构建营养标签网页。你将学习如何使用 CSS 设置文本样式、调整行高和定位文本。 一、重点 HTML 代码head： 123456&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Nutrition Label&lt;/title&gt; &lt;link href=&quot;https://fonts.googleapis.com/css?family=Open+Sans:400,700,800&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;styles.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt; body： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div class=&quot;label&quot;&gt; &lt;header&gt; &lt;h1 class=&quot;bold&quot;&gt;Nutrition Facts&lt;/h1&gt; &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt; &lt;p&gt;8 servings per container&lt;/p&gt; &lt;p class=&quot;bold&quot;&gt;Serving size &lt;span class=&quot;right&quot;&gt;2/3 cup (55g)&lt;/span&gt;&lt;/p&gt; &lt;/header&gt; &lt;div class=&quot;divider lg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;calories-info&quot;&gt; &lt;p class=&quot;bold sm-text&quot;&gt;Amount per serving&lt;/p&gt; &lt;h1&gt;Calories &lt;span class=&quot;right&quot;&gt;230&lt;/span&gt;&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;divider md&quot;&gt;&lt;/div&gt; &lt;div class=&quot;daily-value sm-text&quot;&gt; &lt;p class=&quot;right bold no-divider&quot;&gt;% Daily Value *&lt;/p&gt; &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt; &lt;p&gt;&lt;span class=&quot;bold&quot;&gt;Total Fat&lt;/span&gt; 8g &lt;span class=&quot;bold right&quot;&gt;10%&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;indent no-divider&quot;&gt;Saturated Fat 1g &lt;span class=&quot;bold right&quot;&gt;5%&lt;/span&gt;&lt;/p&gt; &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt; &lt;p class=&quot;indent no-divider&quot;&gt;&lt;i&gt;Trans&lt;/i&gt; Fat 0g&lt;/p&gt; &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt; &lt;p&gt;&lt;span class=&quot;bold&quot;&gt;Cholesterol&lt;/span&gt; 0mg &lt;span class=&quot;right bold&quot;&gt;0%&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span class=&quot;bold&quot;&gt;Sodium&lt;/span&gt; 160mg &lt;span class=&quot;right bold&quot;&gt;7%&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span class=&quot;bold&quot;&gt;Total Carbohydrate&lt;/span&gt; 37g &lt;span class=&quot;right bold&quot;&gt;13%&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;indent no-divider&quot;&gt;Dietary Fiber 4g&lt;/p&gt; &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt; &lt;p class=&quot;indent no-divider&quot;&gt;Total Sugars 12g&lt;/p&gt; &lt;div class=&quot;divider dbl-indent&quot;&gt;&lt;/div&gt; &lt;p class=&quot;dbl-indent no-divider&quot;&gt;Includes 10g Added Sugars &lt;span class=&quot;right bold&quot;&gt;20%&lt;/span&gt; &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt; &lt;p class=&quot;no-divider&quot;&gt;&lt;span class=&quot;bold&quot;&gt;Protein&lt;/span&gt; 3g&lt;/p&gt; &lt;div class=&quot;divider lg&quot;&gt;&lt;/div&gt; &lt;p&gt;Vitamin D 2mcg &lt;span class=&quot;right&quot;&gt;10%&lt;/span&gt;&lt;/p&gt; &lt;p&gt;Calcium 260mg &lt;span class=&quot;right&quot;&gt;20%&lt;/span&gt;&lt;/p&gt; &lt;p&gt;Iron 8mg &lt;span class=&quot;right&quot;&gt;45%&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;no-divider&quot;&gt;Potassium 235mg &lt;span class=&quot;right&quot;&gt;6%&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;divider md&quot;&gt;&lt;/div&gt; &lt;p class=&quot;note&quot;&gt;* The % Daily Value (DV) tells you how much a nutrient in a serving of food contributes to a daily diet. 2,000 calories a day is used for general nutrition advice.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 二、重点 CSS 代码box-sizing 属性： 1234567891011* &#123; box-sizing: border-box;&#125;html &#123; font-size: 16px;&#125;body &#123; font-family: &#x27;Open Sans&#x27;, sans-serif;&#125; letter-spacing 属性： 1234567891011121314.label &#123; border: 2px solid black; width: 270px; margin: 20px auto; padding: 0 7px;&#125;header h1 &#123; text-align: center; margin: -4px 0; letter-spacing: 0.15px&#125;p &#123; margin: 0;&#125; divider 分隔栏： 12345678910111213141516171819202122.divider &#123; border-bottom: 1px solid #888989; margin: 2px 0; clear: right;&#125;.bold &#123; font-weight: 800;&#125;.right &#123; float: right;&#125;.lg &#123; height: 10px;&#125;.lg,.md &#123; background-color: black; border: 0;&#125;.md &#123; height: 5px;&#125; calories-info： 1234567891011.sm-text &#123; font-size: 0.85rem;&#125;.calories-info h1 &#123; margin: -5px -2px; overflow: hidden;&#125;.calories-info span &#123; font-size: 1.2em; margin-top: -7px;&#125; indent 缩进： 123456789101112.indent &#123; margin-left: 1em;&#125;.dbl-indent &#123; margin-left: 2em;&#125;.note &#123; font-size: 0.6rem; margin: 5px 0; padding: 0 8px; text-indent: -8px;&#125; :not pseudo-selector： 123.daily-value p:not(.no-divider) &#123; border-bottom: 1px solid #888989;&#125; 三、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"}]},{"title":"通过创建照片集来学习 CSS 弹性盒子","slug":"CSS创建照片集","date":"2022-05-23T16:00:00.000Z","updated":"2022-05-25T01:16:02.912Z","comments":true,"path":"CSS创建照片集/","link":"","permalink":"http://blog.zhuangzhihao.top/CSS%E5%88%9B%E5%BB%BA%E7%85%A7%E7%89%87%E9%9B%86/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第六章。通过弹性盒子你可以设计适应不同屏幕大小的网页。在通过创建照片集来学习 CSS 弹性盒子的课程中，使用弹性盒子创建一个响应式的照片集网页。","text":"freeCodeCamp 响应式网页设计的认证课程第六章。通过弹性盒子你可以设计适应不同屏幕大小的网页。在通过创建照片集来学习 CSS 弹性盒子的课程中，使用弹性盒子创建一个响应式的照片集网页。 一、重点 CSS 代码* selector： 12345678910111213* &#123; box-sizing: border-box;&#125;body &#123; margin: 0; font-family: Arial; background: #EBE7E7;&#125;.header &#123; text-align: center; padding: 32px; background: #E0DDDD;&#125; id selector： 12345678#gallery img &#123; width: 25%; height: 300px; object-fit: cover; margin-top: 8px; padding: 0 4px; border-radius: 10px;&#125; CSS Flexbox： 12345678#gallery &#123; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: center; align-items: center; padding: 0 4px;&#125; media query： 12345678910@media (max-width: 800px) &#123; #gallery img &#123; width: 50%; &#125;&#125;@media (max-width: 600px) &#123; #gallery img &#123; width: 100%; &#125;&#125; 二、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"}]},{"title":"通过创作罗斯科绘画学习 CSS 盒子模型","slug":"CSS创作罗斯科绘画","date":"2022-05-22T16:00:00.000Z","updated":"2022-06-07T13:40:19.468Z","comments":true,"path":"CSS创作罗斯科绘画/","link":"","permalink":"http://blog.zhuangzhihao.top/CSS%E5%88%9B%E4%BD%9C%E7%BD%97%E6%96%AF%E7%A7%91%E7%BB%98%E7%94%BB/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第五章。每个 HTML 元素都是一个盒子，它拥有着自己的间距和边框，这叫作盒子模型。在通过创作罗斯科绘画学习 CSS 盒子模型的课程中，使用 CSS 和盒子模型，创作属于自己的罗斯科风格的矩形艺术作品。","text":"freeCodeCamp 响应式网页设计的认证课程第五章。每个 HTML 元素都是一个盒子，它拥有着自己的间距和边框，这叫作盒子模型。在通过创作罗斯科绘画学习 CSS 盒子模型的课程中，使用 CSS 和盒子模型，创作属于自己的罗斯科风格的矩形艺术作品。 一、CSS box model 二、重点 CSS 代码Use padding to adjust the spacing within an element： 123456.frame &#123; border: 50px solid black; width: 500px; padding: 50px; margin: 20px auto;&#125; Use margins to adjust the spacing outside of an element： 123456789.one &#123; width: 425px; height: 150px; background-color: #efb762; margin: 20px auto; box-shadow: 0 0 3px 3px #efb762; border-radius: 9px; transform: rotate(-0.6deg);&#125; overflow:hidden 溢出隐藏、清除浮动、解决外边距塌陷： 1234567.canvas &#123; width: 500px; height: 600px; background-color: #4d0f00; overflow: hidden; filter: blur(2px);&#125; filter 属性；box-shadow 属性；border-radius 属性；transform 属性： 1234567891011121314151617181920212223.two &#123; width: 475px; height: 200px; background-color: #8f0401; margin: 0 auto 20px; box-shadow: 0 0 3px 3px #8f0401; border-radius: 8px 10px; transform: rotate(0.4deg);&#125;.one,.two &#123; filter: blur(1px);&#125;.three &#123; width: 91%; height: 28%; background-color: #b20403; margin: auto; filter: blur(2px); box-shadow: 0 0 5px 5px #b20403; border-radius: 30px 25px 60px 12px; transform: rotate(-0.2deg);&#125; 三、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"}]},{"title":"通过编写注册表单学习 HTML 表单","slug":"HTML编写注册表单","date":"2022-05-19T16:00:00.000Z","updated":"2022-05-23T10:38:15.503Z","comments":true,"path":"HTML编写注册表单/","link":"","permalink":"http://blog.zhuangzhihao.top/HTML%E7%BC%96%E5%86%99%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%95/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第四章。你可以使用 HTML 表单收集访问网页的用户的信息。在通过编写注册表单学习 HTML 表单的课程中，通过编写一个注册页学习 HTML 表单，学习如何控制人们在表单中可以输入的数据类型，以及使用一些新的 CSS 工具装饰你的页面。","text":"freeCodeCamp 响应式网页设计的认证课程第四章。你可以使用 HTML 表单收集访问网页的用户的信息。在通过编写注册表单学习 HTML 表单的课程中，通过编写一个注册页学习 HTML 表单，学习如何控制人们在表单中可以输入的数据类型，以及使用一些新的 CSS 工具装饰你的页面。 一、重点 HTML 代码表格页面格式： 12345678&lt;body&gt; &lt;h1&gt;Registration Form&lt;/h1&gt; &lt;p&gt;Please fill out this form with the required information&lt;/p&gt; &lt;form action=&#x27;https://register-demo.freecodecamp.org&#x27;&gt; &lt;!--表格内容--&gt; &lt;/form&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/body&gt; 输入框： 123456&lt;fieldset&gt; &lt;label&gt;Enter Your First Name: &lt;input type=&quot;text&quot; name=&quot;first-name&quot; required /&gt;&lt;/label&gt; &lt;label&gt;Enter Your Last Name: &lt;input type=&quot;text&quot; name=&quot;last-name&quot; required /&gt;&lt;/label&gt; &lt;label&gt;Enter Your Email: &lt;input type=&quot;email&quot; name=&quot;email&quot; required /&gt;&lt;/label&gt; &lt;label&gt;Create a New Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; minlen=&quot;8&quot; pattern=&quot;[a-z0-5]&#123;8,&#125;&quot; required /&gt;&lt;/label&gt;&lt;/fieldset&gt; 单选&amp;复选框： 1234567&lt;fieldset&gt; &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;account-type&quot; class=&quot;inline&quot; /&gt; Personal Account&lt;/label&gt; &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;account-type&quot; class=&quot;inline&quot; /&gt; Business Account&lt;/label&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;terms&quot; class=&quot;inline&quot; required /&gt; I accept the &lt;a href=&quot;https://www.freecodecamp.org/news/terms-of-service/&quot;&gt;terms and conditions&lt;/a&gt; &lt;/label&gt;&lt;/fieldset&gt; 文件、数字、下拉栏、文本框输入： 12345678910111213141516&lt;fieldset&gt; &lt;label&gt;Upload a profile picture: &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;/label&gt; &lt;label&gt;Input your age (years): &lt;input type=&quot;number&quot; name=&quot;age&quot; min=&quot;13&quot; max=&quot;120&quot; /&gt;&lt;/label&gt; &lt;label&gt;How did you hear about us? &lt;select name=&quot;referrer&quot;&gt; &lt;option value=&quot;&quot;&gt;(select one)&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;freeCodeCamp News&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;freeCodeCamp YouTube Channel&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;freeCodeCamp Forum&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;Other&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;label&gt;Provide a bio: &lt;textarea name=&quot;bio&quot; rows=&quot;3&quot; cols=&quot;30&quot; placeholder=&quot;I like coding on the beach...&quot;&gt;&lt;/textarea&gt; &lt;/label&gt;&lt;/fieldset&gt; 二、重点 CSS 代码pseudo-class（:not(:last-of-type)）： 1234567fieldset &#123; border: none; padding: 2rem 0;&#125;fieldset:not(:last-of-type) &#123; border-bottom: 3px solid #3b3b4f;&#125; unset 属性： 12345.inline &#123; width: unset; margin: 0 0.5em 0 0; vertical-align: middle;&#125; CSS attribute selector： 12345678910111213input[type=&quot;submit&quot;] &#123; display: block; width: 60%; margin: 1em auto; height: 2em; font-size: 1.1rem; background-color: #3b3b4f; border-color: white; min-width: 300px;&#125;input[type=&quot;file&quot;] &#123; padding: 1px 2px;&#125; 其他表单设置： 123456789101112131415161718192021222324252627282930313233343536373839body &#123; width: 100%; height: 100vh; margin: 0; background-color: #1b1b32; color: #f5f6f7; font-family: Tahoma; font-size: 16px;&#125;h1, p &#123; margin: 1em auto; text-align: center;&#125;form &#123; width: 60vw; max-width: 500px; min-width: 300px; margin: 0 auto; padding-bottom: 2em;&#125;label &#123; display: block; margin: 0.5rem 0;&#125;input,textarea,select &#123; margin: 10px 0 0 0; width: 100%; min-height: 2em;&#125;input, textarea &#123; background-color: #0a0a23; border: 1px solid #0a0a23; color: #ffffff;&#125;a&#123; color: #dfdfe2;&#125; 三、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.zhuangzhihao.top/tags/HTML/"}]},{"title":"通过构建一组彩色标记来学习 CSS 颜色","slug":"CSS构建一组彩色标记","date":"2022-05-18T16:00:00.000Z","updated":"2022-05-23T10:38:23.142Z","comments":true,"path":"CSS构建一组彩色标记/","link":"","permalink":"http://blog.zhuangzhihao.top/CSS%E6%9E%84%E5%BB%BA%E4%B8%80%E7%BB%84%E5%BD%A9%E8%89%B2%E6%A0%87%E8%AE%B0/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第三章。为你的网页选择正确的颜色可以大大提高对读者的审美吸引力。在通过构建一组彩色标记来学习 CSS 颜色的课程中，构建一组彩色标记，学习设置颜色值的不同方法以及如何将颜色相互配对。","text":"freeCodeCamp 响应式网页设计的认证课程第三章。为你的网页选择正确的颜色可以大大提高对读者的审美吸引力。在通过构建一组彩色标记来学习 CSS 颜色的课程中，构建一组彩色标记，学习设置颜色值的不同方法以及如何将颜色相互配对。 一、重点 HTML 代码head 标签： 123456&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Colored Markers&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;&lt;/head&gt; 含多个 CSS class 的 div 标签： 1234567891011121314151617&lt;body&gt; &lt;h1&gt;CSS Color Markers&lt;/h1&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;marker red&quot;&gt; &lt;div class=&quot;cap&quot;&gt;&lt;/div&gt; &lt;div class=&quot;sleeve&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;marker green&quot;&gt; &lt;div class=&quot;cap&quot;&gt;&lt;/div&gt; &lt;div class=&quot;sleeve&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;marker blue&quot;&gt; &lt;div class=&quot;cap&quot;&gt;&lt;/div&gt; &lt;div class=&quot;sleeve&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 二、重点 CSS 代码padding 属性： 123456789.container &#123; background-color: rgb(255, 255, 255); padding: 10px 0;&#125;.marker &#123; width: 200px; height: 25px; margin: 10px auto;&#125; opacity 属性： 123456.sleeve &#123; opacity: 0.5; width: 110px; height: 25px; background-color: white;&#125; border-left 属性： 12345678910.cap &#123; width: 60px; height: 25px;&#125;.sleeve &#123; width: 110px; height: 25px; background-color: rgba(255, 255, 255, 0.5); border-left: 10px double rgba(0, 0, 0, 0.75);&#125; 多层 CSS class selector： 1234.cap,.sleeve &#123; display: inline-block;&#125; linear-gradient 属性： 1234.red &#123; background: linear-gradient(rgb(122, 74, 14), rgb(245, 62, 113), rgb(162, 27, 27)); box-shadow: 0 0 20px 0 rgba(83, 14, 14, 0.8);&#125; box-shadow 属性： 1234.green &#123; background: linear-gradient(#55680D, #71F53E, #116C31); box-shadow: 0 0 20px 0 #3B7E20CC;&#125; HSL color model： 1234.blue &#123; background: linear-gradient(hsl(186, 76%, 16%), hsl(223, 90%, 60%), hsl(240, 56%, 42%)); box-shadow: 0 0 20px 0 hsla(223, 59%, 31%, 0.8);&#125; 三、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"}]},{"title":"通过编写咖啡店菜单学习基础 CSS","slug":"CSS咖啡店菜单","date":"2022-05-16T16:00:00.000Z","updated":"2022-05-23T10:38:37.523Z","comments":true,"path":"CSS咖啡店菜单/","link":"","permalink":"http://blog.zhuangzhihao.top/CSS%E5%92%96%E5%95%A1%E5%BA%97%E8%8F%9C%E5%8D%95/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第二章。CSS 负责告诉浏览器如何展示你的网页。你可以使用 CSS 设置 HTML 元素的颜色、字体、大小等属性。在通过编写咖啡店菜单学习基础 CSS 课程中，通过为一个咖啡店网站设计菜单页来学习 CSS。","text":"freeCodeCamp 响应式网页设计的认证课程第二章。CSS 负责告诉浏览器如何展示你的网页。你可以使用 CSS 设置 HTML 元素的颜色、字体、大小等属性。在通过编写咖啡店菜单学习基础 CSS 课程中，通过为一个咖啡店网站设计菜单页来学习 CSS。 一、重点 HTML 代码meta 标签（自闭和）： 1234&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;/head&gt; head 中 link CSS 文件 styles.css： 1&lt;link href=&quot;styles.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; header 标签： 1234567&lt;body&gt; &lt;header&gt; &lt;h1&gt;CAMPER CAFE&lt;/h1&gt; &lt;p class=&quot;established&quot;&gt;Est. 2020&lt;/p&gt; &lt;/header&gt; &lt;hr&gt;&lt;/body&gt; div 标签： 123&lt;div class=&quot;menu&quot;&gt; &lt;!--header + main + footer--&gt;&lt;/div&gt; article 标签： 1234567&lt;section&gt; &lt;h2&gt;Coffee&lt;/h2&gt; &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/css-cafe/coffee.jpg&quot; alt=&quot;coffee icon&quot;/&gt; &lt;article class=&quot;item&quot;&gt; &lt;p class=&quot;flavor&quot;&gt;French Vanilla&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;3.00&lt;/p&gt; &lt;/article&gt;&lt;section&gt; footer 标签： 1234567&lt;hr class=&quot;bottom-line&quot;&gt;&lt;footer&gt; &lt;p&gt; &lt;a href=&quot;https://www.freecodecamp.org&quot; target=&quot;_blank&quot;&gt;Visit our website&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;address&quot;&gt;123 Free Code Camp Drive&lt;/p&gt;&lt;/footer&gt; CSS type selector： 1234567&lt;head&gt; &lt;style&gt; h1, h2, p &#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt; 二、重点 CSS 代码CSS 注释： 1/* FOOTER */ background-image 属性： 12345body &#123; background-image: url(https://cdn.freecodecamp.org/curriculum/css-cafe/beans.jpg); font-family: sans-serif; padding: 20px;&#125; CSS class selector： 12345678.menu &#123; width: 80%; background-color: burlywood; margin-left: auto; margin-right: auto; padding: 20px; max-width: 500px;&#125; 多层 CSS style selector： 123456h1, h2, p &#123; text-align: center;&#125;h1, h2 &#123; font-family: Impact, serif;&#125; 多层 CSS class selector： 1234.flavor, .dessert &#123; text-align: left; width: 75%;&#125; display 属性： 123456.item p &#123; display: inline-block; margin-top: 5px; margin-bottom: 5px; font-size: 18px;&#125; CSS pseudo-selector： 123456789101112a &#123; color: black;&#125;a:visited &#123; color: black;&#125;a:hover &#123; color: brown;&#125;a:active &#123; color: brown;&#125; 给 img 和 hr 设置属性： 1234567891011img &#123; margin: -25px; display: block; margin-left: auto; margin-right: auto;&#125;hr &#123; height: 2px; background-color: brown; border-color: brown;&#125; font-size 属性： 123footer &#123; font-size: 14px;&#125; 三、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"}]},{"title":"通过编写猫咪相册应用学习 HTML","slug":"HTML猫咪相册应用","date":"2022-05-14T16:00:00.000Z","updated":"2022-05-23T10:38:08.466Z","comments":true,"path":"HTML猫咪相册应用/","link":"","permalink":"http://blog.zhuangzhihao.top/HTML%E7%8C%AB%E5%92%AA%E7%9B%B8%E5%86%8C%E5%BA%94%E7%94%A8/","excerpt":"freeCodeCamp 响应式网页设计的认证课程第一章。HTML 标签赋予了网页结构。你可以使用 HTML 标签添加照片、按钮和其它元素到你的网页。在通过编写猫咪相册应用学习 HTML 的课程中，通过编写一个猫咪相册应用，学习最常见的 HTML 标签。","text":"freeCodeCamp 响应式网页设计的认证课程第一章。HTML 标签赋予了网页结构。你可以使用 HTML 标签添加照片、按钮和其它元素到你的网页。在通过编写猫咪相册应用学习 HTML 的课程中，通过编写一个猫咪相册应用，学习最常见的 HTML 标签。 一、重点代码页面格式： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;header&gt;&lt;title&gt;CatPhotoApp&lt;/title&gt;&lt;/header&gt; &lt;body&gt; &lt;main&gt; &lt;section&gt;&lt;/section&gt; &lt;!--多个分块--&gt; &lt;/main&gt; &lt;footer&gt;&lt;p&gt;Copyright&lt;/p&gt;&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; figure 标签，用于规定独立的流内容（图像、图表、照片、代码等）： 1234&lt;figure&gt; &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/lasagna.jpg&quot; alt=&quot;A slice of lasagna on a plate.&quot;&gt; &lt;!--img 标签自闭和--&gt; &lt;figcaption&gt;Cats &lt;em&gt;love&lt;/em&gt; lasagna.&lt;/figcaption&gt;&lt;/figure&gt; form 表单提交： 1234&lt;form action=&quot;https://freecatphotoapp.com/submit-cat-photo&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;catphotourl&quot; placeholder=&quot;cat photo URL&quot; required&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; 用 fieldset 标签对表单进行分组，一个表单可以有多个 fieldset： 1234567891011&lt;fieldset&gt; &lt;legend&gt;Is your cat an indoor or outdoor cat?&lt;/legend&gt; &lt;label&gt;&lt;input id=&quot;indoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;indoor&quot; checked&gt; Indoor&lt;/label&gt; &lt;label&gt;&lt;input id=&quot;outdoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;outdoor&quot;&gt; Outdoor&lt;/label&gt;&lt;/fieldset&gt;&lt;fieldset&gt; &lt;legend&gt;What&#x27;s your cat&#x27;s personality?&lt;/legend&gt; &lt;input id=&quot;loving&quot; type=&quot;checkbox&quot; name=&quot;personality&quot; value=&quot;loving&quot; checked&gt; &lt;label for=&quot;loving&quot;&gt;Loving&lt;/label&gt; &lt;input id=&quot;lazy&quot; type=&quot;checkbox&quot; name=&quot;personality&quot; value=&quot;lazy&quot;&gt; &lt;label for=&quot;lazy&quot;&gt;Lazy&lt;/label&gt; &lt;input id=&quot;energetic&quot; type=&quot;checkbox&quot; name=&quot;personality&quot; value=&quot;energetic&quot;&gt; &lt;label for=&quot;energetic&quot;&gt;Energetic&lt;/label&gt;&lt;/fieldset&gt; 二、页面展示","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.zhuangzhihao.top/tags/HTML/"}]},{"title":"结构体与 typedef 的使用","slug":"结构体与 typedef","date":"2022-05-10T16:00:00.000Z","updated":"2022-06-09T07:07:30.752Z","comments":true,"path":"结构体与 typedef/","link":"","permalink":"http://blog.zhuangzhihao.top/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%20typedef/","excerpt":"在我们编写程序时，有时候需要将不同类型的数据组合为一个整体，以便于引用。例如，一名学生有学号、姓名、性别、年龄、地址等属性，如果针对学生的学号、姓名、年龄等都单独定义一个变量，那么在有多名学生时，变量就难以分清。为此，C 语言提供结构体来管理不同类型的数据组合。","text":"在我们编写程序时，有时候需要将不同类型的数据组合为一个整体，以便于引用。例如，一名学生有学号、姓名、性别、年龄、地址等属性，如果针对学生的学号、姓名、年龄等都单独定义一个变量，那么在有多名学生时，变量就难以分清。为此，C 语言提供结构体来管理不同类型的数据组合。 一、结构体的定义先声明一个结构体类型，再定义变量名。结构体类型声明要放在 main 函数之前，这样 main 函数中才可以使用这个结构体，工作中往往把结构体声明放在头文件中。 注意，结构体类型声明最后一定要加分号，否则会编译不通。另外，定义结构体变量时，使用 struct student 来定义，不能只有 struct 或 student，否则也会编译不通。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct student&#123; int num; char name[20]; char sex; int age; float score; char addr[30];&#125;; //结构体类型声明，注意最后一定要加分号int main()&#123; struct student s = &#123;1001, &quot;lele&quot;, &#x27;M&#x27;, 20, 85.4, &quot;Shenzhen&quot;&#125;; //定义及初始化 struct student sarr[3]; int i; printf(&quot;%d%s %c %d %f %s\\n&quot;, s.num, s.name, s.sex, s.age, s.score, s.addr); for (i = 0; i &lt; 3; i++) &#123; scanf(&quot;%d%s %c%d%f%s&quot;, &amp;sarr[i].num, sarr[i].name, &amp;sarr[i].sex, &amp;sarr[i].age, &amp;sarr[i].score, sarr[i].addr); &#125; for (i = 0; i &lt; 3; i++) &#123; printf(&quot;%d %s %c %d %f %s\\n&quot;, sarr[i].num, sarr[i].name, sarr[i].sex, sarr[i].age, sarr[i].score, sarr[i].addr); &#125; system(&quot;pause&quot;); return 0;&#125; sarr 是结构体数组变量。结构体的初始化只能在一开始定义，如果 struct student s=&#123;1001,&quot;lele&quot;,&#39;M&#39;,20,85.4,&quot;Shenzhen&quot;&#125; 已经执行，即 struct student s 已经定义，就不能再执行 s=&#123;1001,&quot;lele&quot;,&#39;M&#39;,20,85.4,&quot;Shenzhen&quot;&#125;。如果结构体变量已经定义, 那么只能对它的每个成员单独赋值，如 s.num=1003。 采用 结构体变量名,成员名 的形式来访问结构体成员，例如用 s.num 访问学号。 在进行打印输出时，必须访问到成员，而且 printf 中的 % 类型要与各成员匹配。使用 scanf 读取标准输入时，也必须是各成员取地址，然后进行存储，不可以写成 &amp;s，即不可以直接对结构体变量取地址。整型数据（%d）、浮点型数据（%f）、字符串型数据（%s）都会忽略空格，但是字符型数据（%c）不会忽略空格，所以如果要读取字符型数据，那么就要在待读取的字符数据与其他数据之间加入空格。 二、结构体指针一个结构体变量的指针就是该变量所占据的内存段的起始地址。可以设置一个指针变量，用它指向一个结构体变量，此时该指针变量的值是结构体变量的起始地址。指针变量也可以用来指向结构体数组中的元素。 12345678910111213141516171819202122232425//结构体指针struct student&#123; int num; char name[20]; char sex;&#125;;int main()&#123; struct student s = &#123;1001, &quot;wangle&quot;, &quot;M&quot;&#125;; struct student sarr[3] = &#123;1001, &quot;lilei&quot;, &#x27;M&#x27;, 1005, &quot;zhangsan&quot;, &#x27;M&#x27;, 1007, &quot;lili&quot;, &#x27;F&#x27;&#125;; struct student *p; //定义结构体指针 int num; p = &amp;s; printf(&quot;%d %s %c\\n&quot;, p-&gt;num, p-&gt;name, p-&gt;sex); p = sarr; printf(&quot;%d %s %c\\n&quot;, (*p).num, (*p).name, (*p).sex); //方式一获取成员 printf(&quot;%d %s %c\\n&quot;, p-&gt;num, p-&gt;name, p-&gt;sex); //方式二获取成员 num = p-&gt;num++; printf(&quot;num=%d,p-&gt;num=%d\\n&quot;, num, p-&gt;num); num = p++-&gt;num; printf(&quot;num=%d,p-&gt;num=%d\\n&quot;, num, p-&gt;num); system(&quot;pause&quot;);&#125; 可以看到，p 就是一个结构体指针，可以对结构体 s 取地址并赋给 p，这样借助成员选择操作符，就可以通过 p 访问结构体的每个成员，然后进行打印。我们知道数组名中存储的是数据的首地址，所以可以将 sarr 赋给 p，这样就可以通过两种方式访问对应的成员。 使用 (*p).num 访问成员为什么要加括号呢？原因是 “.” 成员选择的优先级高于 “*”（即取值）运算符，所以必须加括号，通过 *p 得到 sarr[0]，然后获取对应的成员。 三、typedef 的使用使用 typedef 声明新的类型名来代替已有的类型名。使用 stu 定义结构体变量和使用 struct student 定义结构体变量是等价的；使用 INTEGER 定义变量 ⅰ 和使用 int 定义变量i是等价的；pstu 等价于 struct student*，所以 p 是结构体指针变量。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//结构体指针typedef struct student&#123; int num; char name[20]; char sex;&#125; stu, *pstu; // pstu 等价于 struct student *typedef int INTEGER; //代码即注释int main()&#123; stu s = &#123;1001, &quot;wangle&quot;, &#x27;M&#x27;&#125;; pstu p; //也可写为 stu *p，此时 p 也是结构体指针 INTEGER i = 10; p = &amp;s; printf(&quot;i=%d,p-&gt;num=%d\\n&quot;, i, p-&gt;num); system(&quot;pause&quot;);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://blog.zhuangzhihao.top/categories/C-C/"}],"tags":[]},{"title":"浅谈 C 语言指针","slug":"浅谈指针","date":"2022-05-07T16:00:00.000Z","updated":"2022-06-11T05:27:12.110Z","comments":true,"path":"浅谈指针/","link":"","permalink":"http://blog.zhuangzhihao.top/%E6%B5%85%E8%B0%88%E6%8C%87%E9%92%88/","excerpt":"计算机内存区域中的每字节都对应一个编号，这个编号就是“地址”。如果在程序中定义了一个变量，那么在对程序进行编译时，系统就会给这个变量分配内存单元。如果我们在程序中需要将某个整型、浮点型或字符型数据变量的地址保存下来，需要用到 C 语言为我们提供的指针。在 C 语言中，指针变量是一种特殊的变量，它用来存放变量地址。掌握指针，对于学习操作系统、理解操作系统原理会有非常大的帮助。","text":"计算机内存区域中的每字节都对应一个编号，这个编号就是“地址”。如果在程序中定义了一个变量，那么在对程序进行编译时，系统就会给这个变量分配内存单元。如果我们在程序中需要将某个整型、浮点型或字符型数据变量的地址保存下来，需要用到 C 语言为我们提供的指针。在 C 语言中，指针变量是一种特殊的变量，它用来存放变量地址。掌握指针，对于学习操作系统、理解操作系统原理会有非常大的帮助。 一、取地址操作符和取值操作符取地址操作符为 &amp;，也称引用，通过该操作符我们可以获取一个变量的地址值；取值操作符为 *，也称解引用，通过该操作符我们可以得到一个地址对应的数据。取地址操作符和取值操作符优先级相同，按照自右向左的顺序相结合。 12345678int main()&#123; int i = 10; int *p; //p就是一个指针变量，可以用来存储地址，类型是整型指针 p = &amp;i; //初始化赋值 printf(&quot;i = %d\\n&quot;, i); //直接访问 printf(&quot;*p = %d\\n&quot;, *p); //间接访问&#125; 指针变量前面的表示该变量为指针型变量，例如 float **pointer_1; 的指针变量名是 pointer_1。在定义指针变量时必须指定其类型，只有整型变量的地址才能放到指向整型变量的指针变量中。 二、指针的传递和偏移C 语言中的函数调用均为值传递。指针的传递将变量 i 的地址传递给 change 函数时，实际效果是 j=&amp;i，这时 j 是一个指针变量，依然是值传递, 只是 j 内部存储的是变量 i 的地址，所以通过 *j 就间接访问到了与变量 i 相同的区域，通过 *j=5 就实现了对变量 i 的值的改变。 1234567891011void change(int* j)&#123; *j = 5; //间接访问得到变量 i&#125;int main() //指针的传递&#123; int i = 10; printf(&quot;before change i=%d\\n&quot;, i); change(&amp;i); //传递变量 i 的地址 printf(&quot;after change i=%d\\n&quot;, i);&#125; 我们把对指针的加减称为指针的偏移，加就是向后偏移，减就是向前偏移，但对指针进行乘除是没有意义的。 1234567891011121314151617//指针的偏移int main()&#123; int a[5]=&#123;1,2,3,4,5&#125;; int *p; int i; p = a; //保证等号两边的数值类型一致 for(i=0; i&lt;5; i++) //正序输出 &#123; printf(&quot;%3d&quot;, *(p+i)); &#125; p = &amp;a[4]; //让 p 指向最后一个元素 for(i=0; i&lt;5; i++) //逆序输出 &#123; printf(&quot;%3d&quot;,*(p-i)); &#125;&#125; 三、指针与一维数组数组在传递时弱化为指针。这是由于一维数组名中存储的是数组的首地址，因此一维数组在函数调用进行传递时，它的长度子函数无法知道。定义一个指针变量时，指针变量的类型要和数组的数据类型保持一致，通过取值操作, 就可获取数组元素, 这种方法称为指针法。也可以通过取下标的方式来获取数组元素并进行修改，这种方法称为下标法。 123456789101112void change(char *d) //*d 为形参&#123; *d = &#x27;H&#x27;; //指针法 d[1] = &#x27;E&#x27;; //下标法 *(d+2) = &#x27;L&#x27;; //指针的偏移&#125;int main()&#123; char c[10] = &#x27;hello&#x27;; change(c); //c 为实参 printf(&quot;%c\\n&quot;, c);&#125; 四、指针与动态内存申请C 语言的数组长度固定是因为其定义的整型、浮点型、字符型变量、数组变量都在栈空间中，而栈空间的大小在编译时是确定的。如果使用的空间大小不确定，那么就要使用堆空间申请动态内存申请。栈空间由系统自动管理，而堆空间的申请和释放需要自行管理，所以在具体例子中需要通过 free 函数释放堆空间。 栈是计算机系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈操作、出栈操作都有专门的指令执行，这就决定了栈的效率比较高；堆则是 C/C++ 函数库提供的数据结构，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能由于内存碎片太多）那么就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后返回。显然，堆的效率要比栈低得多。 1234567891011int main()&#123; int i; char *p; scanf(&quot;%d&quot;, &amp;i); //输入要申请的空间大小 p = (char*)malloc(i)；//使用 malloc 动态申请堆空间，(char *)是强制类型转换 strcpy(p, &quot;malloc success&quot;); puts(p); free(p)；//free 时必须使用 malloc 申请时返回的指针值，不能进行任何偏移 p = NULL; //消除野指针&#125; C 初始动态分配 vs C++ 初始动态分配 12345// C 初始动态分配L.data = (ElemType *)malloc(sizeof(Elemtype) *InitSize);int *p = (int *)malloc(sizeof(int) *10);// C++ 初始动态分配L.data = new Elemtype[InitSize];","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://blog.zhuangzhihao.top/categories/C-C/"}],"tags":[]},{"title":"gets 函数与 puts 函数","slug":"gets函数与puts函数","date":"2022-05-02T16:00:00.000Z","updated":"2022-05-24T08:55:53.735Z","comments":true,"path":"gets函数与puts函数/","link":"","permalink":"http://blog.zhuangzhihao.top/gets%E5%87%BD%E6%95%B0%E4%B8%8Eputs%E5%87%BD%E6%95%B0/","excerpt":"C 语言标准输入 scanf 在通过 %s 读取字符串时遇到空格就认为读取结束，这样没办法把一行带有空格的字符串存入到一个字符数组中。所以当需要输入的字符串中含有空格时，我们需要使用 gets 函数进行读取，使用 puts 函数进行输出。","text":"C 语言标准输入 scanf 在通过 %s 读取字符串时遇到空格就认为读取结束，这样没办法把一行带有空格的字符串存入到一个字符数组中。所以当需要输入的字符串中含有空格时，我们需要使用 gets 函数进行读取，使用 puts 函数进行输出。 一、字符数组字符数组的定义方法一维数组、二维数组类似，例如 char c[10]=&quot;hello&quot;。 因为 C 语言规定字符串的结束标志为 \\0，而系统会对字符串常量自动加一个 \\0，为了保证处理方法一致，一般会人为地在字符数组中添加 \\0，所以字符数组存储的字符串长度必须比字符数组少 1 字节。例如 char[10] 最多存储 9 个字符，最后一个字符用来存储 \\0。 字符数组的数组名里存的就是字符数组的起始地址，类型是字符指针。即编译器给字符数组 c 内部存了一个值，c 中存储的值的类型是字符指针。 二、gets 函数和 puts 函数scanf 函数没办法把一行带有空格的字符串存入到一个字符数组中，所以当需要输入的字符串中含有空格时，我们需要使用 gets 函数进行读取：char *gets(char *str)。 gets 函数从 STDIN（标准输入）读取字符并把它们加载到 str（字符串）中，直到遇到换行符（\\n）或到达 EOF。gets 遇到 \\n 后, 不会存储 \\n，而是将其翻译为空字符 \\0。 puts 函数类似于 printf 函数，用于输出标准输出：int puts(char *str);。 函数 puts 把 str (字符串) 写人STDOU (标准输出)。puts 执行成功时返回非负值，执行失败时返回 EOF。相对于 printf 函数，puts 只能用于输出字符串，同时多打印一个换行符。 1234567int main()&#123; char c[20]; gets(c); //当一次读取一行时，使用gets puts(c); //等价于printf(&quot;%s\\n&quot;,c); return 0;&#125; 虽然用 gets() 时有空格也可以直接输入，但是 gets 不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界，所以编程时建议使用 fgets()。fgets 相对于 gets 去读取标准输入时，会把 \\n 放到字符数组中。char *fgets(char *s, int size, FILE *stream);。 123456789int main()&#123; char c[20]; fgets(c, sizeof(c), stdin); int len = strlen(c); c[len -1] = &#x27;\\0&#x27;; puts(c); return 0;&#125; 三、str 系列字符串操作函数str 系列字符串操作函数主要包括 strlen、strcpy 、strcmp、strcat 等。strlen 函数用于统计字符串长度，strcpy 函数用于将某个字符串复制到字符数组中，strcmp 函数用于比较两个字符串的大小，strcat 函数用于将两个字符串连接到一起： 12345#include &lt;string.h&gt;size_t strlen(char *str);char *strcpy(char *to, const char *from); //有const修饰代表此处可以放字符串常量int strcmp(const char *str1, const char *str2);char *strcat(char *str1, const char *str2); 对于传参类型 char*，直接放入字符数组的数组名即可。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char c[20] = &quot;zhuang&quot;; puts(c); //zhuang printf(&quot;数组c内字符串的长度=%d\\n&quot;, strlen(c)); char d[20]; strcpy(d, c); // 将c的内容复制到d中 puts(d); //zhuang strcpy(d, &quot;study&quot;); // 将字符串study复制到d中 //strcmp比较字符串对应字符位置的ascii码值 int ret = strcmp(&quot;hello&quot;, &quot;how&quot;); printf(&quot;两个字符串比较结果=%d\\n&quot;, ret); //-1 //strcat拼接两个字符串 strcat(d, &quot;!&quot;); // 将字符串!拼接到d中 puts(d); //study! return 0;&#125; 四、判断回文数读取一个字符串，字符串可能含有空格，将字符串逆转，原来的字符串与逆转后字符串相同，输出 0，原字符串小于逆转后字符串输出 -1，大于逆转后字符串输出 1。例如输入 hello，逆转后的字符串为 olleh，因为hello 小于 olleh，所以输出 -1。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char c[20], d[20]; gets(c); int i, j; for (i = strlen(c) - 1, j = 0; i &gt;= 0; i--, j++) &#123; d[j] = c[i]; &#125; d[j] = &#x27;\\0&#x27;; int result = strcmp(c, d); if (result &lt; 0) &#123; printf(&quot;%d\\n&quot;, -1); &#125; else if (result &gt; 0) &#123; printf(&quot;%d\\n&quot;, 1); &#125; else &#123; printf(&quot;%d\\n&quot;, 0); &#125; return 0；&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://blog.zhuangzhihao.top/categories/C-C/"}],"tags":[]},{"title":"Filter 和 Listener","slug":"Filter&Listener","date":"2022-04-26T16:00:00.000Z","updated":"2022-07-03T09:04:05.460Z","comments":true,"path":"Filter&Listener/","link":"","permalink":"http://blog.zhuangzhihao.top/Filter&Listener/","excerpt":"Java Web 核心第五章。Filter 和 Listener 是 JavaWeb 三大组件（Servlet、Filter、Listener）的另两个组成部分。Filter 表示过滤器，可以把对资源的请求拦截下来，从而实现一些特殊的功能。Listener 监听器可以监听就是在 application，session，request 三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。 application 是 ServletContext 类型的对象。ServletContext 代表整个 web 应用，在服务器启动的时候，tomcat 会自动创建该对象，在服务器关闭时会自动销毁该对象。","text":"Java Web 核心第五章。Filter 和 Listener 是 JavaWeb 三大组件（Servlet、Filter、Listener）的另两个组成部分。Filter 表示过滤器，可以把对资源的请求拦截下来，从而实现一些特殊的功能。Listener 监听器可以监听就是在 application，session，request 三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。 application 是 ServletContext 类型的对象。ServletContext 代表整个 web 应用，在服务器启动的时候，tomcat 会自动创建该对象，在服务器关闭时会自动销毁该对象。 一、Filter过滤器一般完成一些通用的操作。比如每个资源都要写一些代码完成某个功能，此时我们可以将这些代码写在过滤器中，因为请求每一个资源都要经过过滤器。例如：权限控制、统一编码处理、敏感字符处理等。 Filter 快速入门进行 Filter 开发分成以下三步实现： 定义类，实现 Filter 接口，并重写其所有方法。 配置 Filter 拦截资源的路径：在类上定义 @WebFilter 注解。而注解的 value 属性值 /* 表示拦截所有的资源。 在 doFilter 方法中输出一句话，并放行。 1234567891011121314151617181920@WebFilter(&quot;/*&quot;)public class FilterDemo implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;1.FilterDemo...&quot;); //放行 chain.doFilter(request,response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void destroy() &#123; &#125;&#125; Filter 执行流程 12graph LR a[执行放行前逻辑] --&gt; b[放行] --&gt; c[访问资源] --&gt; d[执行放行后逻辑] Filter 拦截路径配置拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 @WebFilter 注解进行配置。如：@WebFilter(&quot;拦截路径&quot;) 。拦截路径的配置方式和 Servlet 的请求资源路径配置方式一样，但是表示的含义不同。 拦截路径有四种配置方式： 拦截具体的资源：/index.jsp：只有访问 index.jsp 时才会被拦截。 目录拦截：/user/*：访问 /user 下的所有资源，都会被拦截。 后缀名拦截：*.jsp：访问后缀名为 jsp 的资源，都会被拦截。 拦截所有：/*：访问所有资源，都会被拦截。 过滤器链过滤器链是指在一个 Web 应用，可以配置多个过滤器，这多个过滤器称为过滤器链。注解配置 Filter 的优先级是按照过滤器类名（字符串）的自然先后排序。 需求实现访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面。只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@WebFilter(&quot;/*&quot;)public class LoginFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = &#123;&quot;/login.jsp&quot;,&quot;/imgs/&quot;,&quot;/css/&quot;,&quot;/loginServlet&quot;,&quot;/register.jsp&quot;,&quot;/registerServlet&quot;,&quot;/checkCodeServlet&quot;&#125;; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) &#123; //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u))&#123; //找到了，放行 chain.doFilter(request, response); //break; return; &#125; &#125; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(&quot;user&quot;); //2. 判断user是否为null if(user != null)&#123; // 登录过了 //放行 chain.doFilter(request, response); &#125;else &#123; // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(&quot;login_msg&quot;,&quot;您尚未登陆！&quot;); req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req,response); &#125; &#125; public void init(FilterConfig config) throws ServletException &#123; &#125; public void destroy() &#123; &#125;&#125; 二、ListenerListener 分类JavaWeb 提供了8个监听器： ServletContextListener 监听器ServletContextListener 接口中有以下两个方法： void contextInitialized(ServletContextEvent sce)：ServletContext 对象被创建了会自动执行的方法。 void contextDestroyed(ServletContextEvent sce)：ServletContext 对象被销毁时会自动执行的方法。 定义一个类，实现ServletContextListener 接口，重写所有的抽象方法，使用 @WebListener 进行配置： 12345678910111213@WebListenerpublic class ContextLoaderListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; //加载资源 System.out.println(&quot;ContextLoaderListener...&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; //释放资源 &#125;&#125; 启动服务器，就可以在启动的日志信息中看到 contextInitialized() 方法输出的内容，同时也说明了 ServletContext 对象在服务器启动的时候被创建了。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[]},{"title":"Java 会话跟踪技术","slug":"会话技术","date":"2022-04-22T16:00:00.000Z","updated":"2022-06-18T06:22:28.868Z","comments":true,"path":"会话技术/","link":"","permalink":"http://blog.zhuangzhihao.top/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/","excerpt":"Java Web 核心第四章。当用户打开浏览器，访问 web 服务器的资源时，会话就会建立，直到有一方断开连接，会话结束。在访问时，服务器会收到多个请求，这多个请求可能来自多个浏览器，服务器需要用会话跟踪来识别请求是否来自同一个浏览器。会话追踪技术在实际开发中也非常重要，可以用于实现一次会话多次请求之间的数据共享。","text":"Java Web 核心第四章。当用户打开浏览器，访问 web 服务器的资源时，会话就会建立，直到有一方断开连接，会话结束。在访问时，服务器会收到多个请求，这多个请求可能来自多个浏览器，服务器需要用会话跟踪来识别请求是否来自同一个浏览器。会话追踪技术在实际开发中也非常重要，可以用于实现一次会话多次请求之间的数据共享。 一、会话跟踪技术的概述会话：从浏览器发出请求到服务端响应数据给前端之后，一次会话（在浏览器和服务器之间）就被建立了。会话被建立后，如果浏览器或服务端都没有被关闭，则会话就会持续建立着。浏览器和服务器就可以继续使用该会话进行请求发送和响应，上述的整个过程就被称之为会话。 在一次会话中可以包含多次请求和响应。 会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。服务器用来识别浏览器的过程就是会话跟踪。 服务器识别浏览器后就可以在同一个会话中多次请求之间来共享数据。 为什么现在浏览器和服务器不支持数据共享呢？ 浏览器和服务器之间使用的是 HTTP 请求来进行数据传输，HTTP 协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求。 HTTP 协议设计成无状态的目的是让每次请求之间相互独立，互不影响。 请求与请求之间独立后，就无法实现多次请求之间的数据共享。 会话跟踪技术的具体实现方式： 客户端会话跟踪技术：Cookie 服务端会话跟踪技术：Session 这两个技术都可以实现会话跟踪，它们之间最大的区别：Cookie 是存储在浏览器端而 Session 是存储在服务器端。 二、CookieCookie：客户端会话技术，将数据保存到客户端，以后每次请求都携带 Cookie 数据进行访问。 服务端提供了两个 Servlet，分别是 Servlet A 和 Servlet B。 浏览器发送 HTTP 请求 1 给服务端，服务端 Servlet A 接收请求并进行业务处理；服务端 Servlet A 在处理的过程中可以创建一个 Cookie 对象并将 name=zs 的数据存入 Cookie；服务端 Servlet A 在响应数据的时候，会把 Cookie 对象响应给浏览器；浏览器接收到响应数据，会把 Cookie 对象中的数据存储在浏览器内存中，此时浏览器和服务端就建立了一次会话。 在同一次会话中浏览器再次发送 HTTP 请求 2 给服务端 Servlet B，浏览器会携带 Cookie 对象中的所有数据；Servlet B 接收到请求和数据后，就可以获取到存储在 Cookie 对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享。 Cookie 的基本使用发送Cookie： 创建 Cookie 对象，并设置数据： 1Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;); 使用 response 对象发送Cookie到客户端： 1response.addCookie(cookie); 在 Servlet 中生成 Cookie 对象并存入数据，然后将数据发送给浏览器： 创建 Maven 项目 cookie-demo，并在 pom.xml 添加依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jsp--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 编写 Servlet 类，名称为 AServlet，在Servlet中创建Cookie对象，存入数据，发送给前端： 12345678910111213141516@WebServlet(&quot;/aServlet&quot;)public class AServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //发送Cookie //1. 创建Cookie对象 Cookie cookie = new Cookie(&quot;username&quot;,&quot;zs&quot;); //2. 发送Cookie，response response.addCookie(cookie); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 获取 Cookie： 获取客户端携带的所有 Cookie，使用 request 对象： 1Cookie[] cookies = request.getCookies(); 遍历数组，获取每一个 Cookie 对象，使用 Cookie 对象方法获取数据： 12cookie.getName();cookie.getValue(); 在 Servlet 中获取前一个案例存入在 Cookie 对象中的数据： 编写一个新 Servlet 类，名称为 BServlet，在 BServlet 中使用 request 对象获取 Cookie 数组，遍历数组，从数据中获取指定名称对应的值： 12345678910111213141516171819202122232425@WebServlet(&quot;/bServlet&quot;)public class BServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取Cookie //1. 获取Cookie数组 Cookie[] cookies = request.getCookies(); //2. 遍历数组 for (Cookie cookie : cookies) &#123; //3. 获取数据 String name = cookie.getName(); if(&quot;username&quot;.equals(name))&#123; String value = cookie.getValue(); System.out.println(name+&quot;:&quot;+value); break; &#125; &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; Cookie 的原理分析对于 Cookie 的实现原理是基于 HTTP 协议的两个请求头信息：响应头 set-cookie 和请求头 cookie。 对于 AServlet 响应数据的时候，Tomcat 服务器是基于 HTTP 协议来响应数据，当 Tomcat 发现后端要返回的是一个 Cookie 对象之后，Tomcat 就会在响应头中添加一行数据 Set-Cookie:username=zs。浏览器获取到响应结果后，从响应头中就可以获取到 Set-Cookie 对应值 username=zs，并将数据存储在浏览器的内存中。 浏览器再次发送请求给 BServlet 的时候，浏览器会自动在请求头中添加 Cookie: username=zs 发送给服务端 BServlet。Request 对象会把请求头中 cookie 对应的值封装成一个个 Cookie 对象，最终形成一个数组。BServlet 通过 Request 对象获取到 Cookie[] 后，就可以从中获取自己需要的数据。 Cookie 的使用细节Cookie 的存活时间：默认情况下，Cookie 存储在浏览器内存中，当浏览器关闭，内存释放，则 Cookie 被销毁。 如何将 Cookie 持久化存储？Cookie 其实已经为我们提供好了对应的 API 来完成这件事，这个 API 就是 setMaxAge： 1setMaxAge(int seconds) //设置Cookie存活时间 setMaxAge 参数值为： 正数：将 Cookie 写入浏览器所在电脑的硬盘，持久化存储，到时间自动删除。 负数：默认值，Cookie 在当前浏览器内存中，当浏览器关闭，则 Cookie 被销毁。 零：删除对应 Cookie。 在 AServlet 中设置 Cookie 的存活时间： 12345678910111213141516171819@WebServlet(&quot;/aServlet&quot;)public class AServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //发送Cookie //1. 创建Cookie对象 Cookie cookie = new Cookie(&quot;username&quot;,&quot;zs&quot;); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //易阅读，需程序计算 //cookie.setMaxAge(604800); //不易阅读(可以使用注解弥补)，程序少进行一次计算 //2. 发送Cookie，response response.addCookie(cookie); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; Cookie 存储中文Cookie 不能存储中文，但是如果有这方面的需求，可以使用 URL编码 进行转码： 在 AServlet 中对中文进行 URL 编码： 12345678910111213141516171819202122@WebServlet(&quot;/aServlet&quot;)public class AServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //发送Cookie String value = &quot;张三&quot;; //对中文进行URL编码 value = URLEncoder.encode(value, &quot;UTF-8&quot;); System.out.println(&quot;存储数据：&quot;+value); //将编码后的值存入Cookie中 Cookie cookie = new Cookie(&quot;username&quot;,value); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //2. 发送Cookie，response response.addCookie(cookie); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 在 BServlet 中获取值，并对值进行解码： 123456789101112131415161718192021222324252627@WebServlet(&quot;/bServlet&quot;)public class BServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取Cookie //1. 获取Cookie数组 Cookie[] cookies = request.getCookies(); //2. 遍历数组 for (Cookie cookie : cookies) &#123; //3. 获取数据 String name = cookie.getName(); if(&quot;username&quot;.equals(name))&#123; String value = cookie.getValue();//获取的是URL编码后的值 %E5%BC%A0%E4%B8%89 //URL解码 value = URLDecoder.decode(value,&quot;UTF-8&quot;); System.out.println(name+&quot;:&quot;+value);//value解码后为 张三 break; &#125; &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 三、SessionSession：另一种服务端会话跟踪技术，将数据保存到服务端。 Session 是存储在服务端而 Cookie 是存储在客户端。存储在客户端的数据容易被窃取和截获，存在很多不安全的因素，存储在服务端的数据相比于客户端来说就更安全。 在服务端的 AServlet 获取一个 Session 对象，把数据存入其中，在服务端的 BServlet 获取到相同的 Session 对象，从中取出数据，就可以实现一次会话中多次请求之间的数据共享了。 Session 的基本使用JavaEE 提供了 HttpSession 接口来实现一次会话的多次请求之间数据共享功能。 获取 Session 对象,使用的是 request 对象： 1HttpSession session = request.getSession(); Session 对象提供的功能: Session 的获取： 1HttpSession session = request.getSession(); Session 常用方法的使用： 12void setAttribute(String name, Object o)Object getAttribute(String name) 存储数据到 session 域中： 1void setAttribute(String name, Object o) 根据 key，获取值： 1Object getAttribute(String name) 根据 key，删除该键值对： 1void removeAttribute(String name) 在一个 Servlet 中往 Session 中存入数据，在另一个 Servlet 中获取 Session 中存入的数据： 创建名为 SessionDemo1 的 Servlet 类，获取 Session 对象、存储数据： 12345678910111213141516@WebServlet(&quot;/demo1&quot;)public class SessionDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //存储到Session中 //1. 获取Session对象 HttpSession session = request.getSession(); //2. 存储数据 session.setAttribute(&quot;username&quot;,&quot;zs&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 创建名为 SessionDemo2 的 Servlet 类，获取 Session 对象、获取数据： 1234567891011121314151617@WebServlet(&quot;/demo2&quot;)public class SessionDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取数据，从session中 //1. 获取Session对象 HttpSession session = request.getSession(); //2. 获取数据 Object username = session.getAttribute(&quot;username&quot;); System.out.println(username); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; Session 的原理分析Session 是基于 Cookie 实现的，所以 Session 实现的也是一次会话中的多次请求之间的数据共享。 Session 要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取 Session 的对象是同一个，如果是不同浏览器或者重新打开浏览器后，打印的 Session 就不一样了。 Session 的使用细节Session 钝化与活化： Session 数据存储在服务端，服务器重启后，Session数据会被保存； 浏览器被关闭启动后，重新建立的连接就已经是一个全新的会话，获取的 Session 数据也是一个新的对象； Session 的数据要想共享，浏览器不能关闭，所以 Session 数据不能长期保存数据； Cookie 是存储在客户端，是可以长期保存的。 Session 的销毁有两种方式： 默认情况下，无操作，默认 30 分钟自动销毁，失效时间可以在项目的 web.xml 中配置修改： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;session-config&gt; &lt;session-timeout&gt;100&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 调用 Session 对象的 invalidate() 进行销毁，该销毁方法一般会在用户退出的时候及时将 Session 销毁掉： 12345678910111213141516171819202122@WebServlet(&quot;/demo2&quot;)public class SessionDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取数据，从session中 //1. 获取Session对象 HttpSession session = request.getSession(); System.out.println(session); // 销毁 session.invalidate(); //2. 获取数据 Object username = session.getAttribute(&quot;username&quot;); System.out.println(username); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 四、Cookie 和 SessionCookie 和 Session 都是来完成一次会话内多次请求间数据共享的。 Cookie 和 Session 的区别： 存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端。 安全性：Cookie 不安全，Session 安全。 数据大小：Cookie 最大 3 KB，Session 无大小限制。 存储时间：Cookie 可以通过 setMaxAge() 长期存储，Session 默认 30 分钟。 服务器性能：Cookie 不占服务器资源，Session 占用服务器资源。 Cookie 和 Session 的应用场景： 购物车：使用 Cookie 来存储； 以登录用户的名称展示：使用 Session 来存储； 记住我功能使用 Cookie 来存储； 验证码使用 Session 来存储。 简而言之，Cookie 是用来保证用户在未登录情况下的身份识别，Session 是用来保存用户登录后的数据。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[]},{"title":"JSP - Java Server Pages","slug":"JSP","date":"2022-04-19T16:00:00.000Z","updated":"2022-06-25T02:15:57.931Z","comments":true,"path":"JSP/","link":"","permalink":"http://blog.zhuangzhihao.top/JSP/","excerpt":"Java Web 核心第三章。JSP（Java Server Pages）是由 Sun Microsystems 公司主导创建的一种动态网页技术标准。JSP 部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。","text":"Java Web 核心第三章。JSP（Java Server Pages）是由 Sun Microsystems 公司主导创建的一种动态网页技术标准。JSP 部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。 一、JSP 概述JSP（全称：Java Server Pages）：Java 服务端页面。是一种动态的网页技术，其中既可以定义 HTML、JS、CSS等静态内容，还可以定义 Java 代码的动态内容，也就是 JSP = HTML + Java： 1234567891011&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JSP,Hello World&lt;/h1&gt; &lt;% System.out.println(&quot;hello,jsp~&quot;); %&gt; &lt;/body&gt;&lt;/html&gt; 上面代码 h1 标签内容是展示在页面上，而 Java 的输出语句是输出在 idea 的控制台 JSP 作用：简化开发，避免了在 Servlet 中直接输出 HTML 标签。 JSP 快速入门 创建一个 maven 的 web 项目，项目结构如下： pom.xml 文件内容如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;jsp-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 在 dependencies 标签中导入 JSP 依赖： 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 该依赖的 scope 必须设置为 provided，因为 tomcat 中有这个 jar 包了，所以在打包时我们是不希望将该依赖打进到我们工程的 war 包中。 在项目的 webapp 下创建 JSP 页面，在 hello.jsp 页面中书写 HTML 标签和 Java 代码： 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello jsp&lt;/h1&gt; &lt;% System.out.println(&quot;hello,jsp~&quot;); %&gt;&lt;/body&gt;&lt;/html&gt; 测试，在浏览器地址栏输入 http://localhost:8080/jsp-demo/hello.jsp。 二、JSP 原理JSP 本质上就是一个 Servlet。浏览器第一次访问 hello.jsp 页面时，tomcat 会将 hello.jsp 转换为名为 hello_jsp.java 的一个 Servlet，tomcat 再将转换的 servlet 编译成字节码文件 hello_jsp.class，tomcat 会执行该字节码文件，向外提供服务。 123// 继承关系public final class hello_jsp extends org.apache.jasper.runtime.HttpJspBase implements org,apache.jasper.runtime.JspSourceDependent &#123;&#125;public abstract class HttpJspBase extends HttpServlet implements HttpJspPage &#123;&#125; 三、JSP 脚本JSP 脚本用于在 JSP页面内定义 Java 代码。 JSP 脚本有如下三个分类： &lt;%...%&gt;：内容会直接放到 _jspService() 方法之中。 &lt;%=…%&gt;：内容会放到 out.print() 中，作为 out.print() 的参数。 &lt;%!…%&gt;：内容会放到 _jspService() 方法之外，被类直接包含。 JSP 脚本案例使用JSP脚本展示品牌数据 将 Brand.java 文件放置到项目的 com.itheima.pojo 包下，在项目的 webapp 中创建 brand.jsp ，并将 brand.html页面中的内容拷贝过来。brand.jsp 内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;%@ page import=&quot;com.itheima.pojo.Brand&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% // 查询数据库 List&lt;Brand&gt; brands = new ArrayList&lt;Brand&gt;(); brands.add(new Brand(1,&quot;三只松鼠&quot;,&quot;三只松鼠&quot;,100,&quot;三只松鼠，好吃不上火&quot;,1)); brands.add(new Brand(2,&quot;优衣库&quot;,&quot;优衣库&quot;,200,&quot;优衣库，服适人生&quot;,0)); brands.add(new Brand(3,&quot;小米&quot;,&quot;小米科技有限公司&quot;,1000,&quot;为发烧而生&quot;,1));%&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;新增&quot;&gt;&lt;br&gt;&lt;hr&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;800&quot;&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;品牌名称&lt;/th&gt; &lt;th&gt;企业名称&lt;/th&gt; &lt;th&gt;排序&lt;/th&gt; &lt;th&gt;品牌介绍&lt;/th&gt; &lt;th&gt;状态&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;% for (int i = 0; i &lt; brands.size(); i++) &#123; Brand brand = brands.get(i); %&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;&lt;%=brand.getId()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=brand.getBrandName()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=brand.getCompanyName()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=brand.getOrdered()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=brand.getDescription()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=brand.getStatus() == 1 ? &quot;启用&quot;:&quot;禁用&quot;%&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125; %&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 四、JSP 缺点由于 JSP页面内，既可以定义 HTML 标签，又可以定义 Java代码，造成了以下问题： 书写麻烦：特别是复杂的页面，既要写 HTML 标签，还要写 Java 代码。 阅读麻烦：上面案例的代码，相信你后期再看这段代码时还需要花费很长的时间去梳理。 复杂度高：运行需要依赖于各种环境，JRE，JSP容器，JavaEE… 占内存和磁盘：JSP 会自动生成 .java 和 .class 文件占磁盘，运行的是 .class 文件占内存。 调试困难：出错后，需要找到自动生成的 .java 文件进行调试。 不利于团队协作：前端人员不会 Java，后端人员不精 HTML。如果页面布局发生变化，前端工程师对静态页面进行修改，然后再交给后端工程师，由后端工程师再将该页面改为 JSP 页面。 由于上述的问题， JSP 已逐渐退出历史舞台，以后开发更多的是使用 HTML + Ajax 来替代。 技术的发展： 第一阶段：使用 servlet 即实现逻辑代码编写，也对页面进行拼接。 第二阶段：随着技术的发展，出现了 JSP ，人们发现 JSP 使用起来比 Servlet 方便很多，但是还是要在 JSP 中嵌套 Java 代码，也不利于后期的维护。 第三阶段：使用 Servlet 进行逻辑代码开发，而使用 JSP 进行数据展示。 第四阶段：使用 servlet 进行后端逻辑代码开发，而使用 HTML 进行数据展示。而这里面就存在问题，HTML 是静态页面，怎么进行动态数据展示呢？这就是 ajax 的作用了。 五、EL 表达式EL（全称Expression Language ）表达式语言，用于简化 JSP 页面内的 Java 代码。EL 表达式的主要作用是获取数据，其实就是从域对象中获取数据，然后将数据展示在页面上。 而 EL 表达式的语法：$&#123;expression&#125; 。例如：$&#123;brands&#125; 就是获取域中存储的 key 为 brands 的数据。 定义 servlet，在 servlet 中封装一些数据并存储到 request 域对象中并转发到 el-demo.jsp 页面。此处需要用转发，因为转发才可以使用 request 对象作为域对象进行数据共享。 12345678910111213141516171819202122@WebServlet(&quot;/demo1&quot;)public class ServletDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 准备数据 List&lt;Brand&gt; brands = new ArrayList&lt;Brand&gt;(); brands.add(new Brand(1,&quot;三只松鼠&quot;,&quot;三只松鼠&quot;,100,&quot;三只松鼠，好吃不上火&quot;,1)); brands.add(new Brand(2,&quot;优衣库&quot;,&quot;优衣库&quot;,200,&quot;优衣库，服适人生&quot;,0)); brands.add(new Brand(3,&quot;小米&quot;,&quot;小米科技有限公司&quot;,1000,&quot;为发烧而生&quot;,1)); //2. 存储到request域中 request.setAttribute(&quot;brands&quot;,brands); //3. 转发到 el-demo.jsp request.getRequestDispatcher(&quot;/el-demo.jsp&quot;).forward(request,response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 在 el-demo.jsp 中通过 EL表达式 获取数据 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;brands&#125;&lt;/body&gt;&lt;/html&gt; 域对象：Java Web 中有四大域对象： page：当前页面有效。 request：当前请求有效。 session：当前会话有效。 application：当前应用有效。 el 表达式获取数据，会依次从这4个域中寻找，直到找到为止。而这四个域对象的作用范围由小到大，例如：$&#123;brands&#125;，el 表达式获取数据，会先从 page 域对象中获取数据，如果没有再到 requet 域对象中获取数据，如果再没有再到 session 域对象中获取，如果还没有才会到 application 中获取数据。 六、JSTL 标签JSP 标准标签库（Jsp Standarded Tag Library），使用标签取代 JSP 页面上的 Java 代码，比 JSP 中嵌套 Java 代码看起来舒服多了： 123456&lt;c:if test=&quot;$&#123;flag == 1&#125;&quot;&gt; 男&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;flag == 2&#125;&quot;&gt; 女&lt;/c:if&gt; JSTL 提供了很多标签，最常用的标签是 &lt;c:forEach&gt; 标签和 &lt;c:if&gt; 标签。 JSTL 使用也是比较简单的，分为如下步骤： 导入坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; 在JSP页面上引入JSTL标签库 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 使用标签 if 标签&lt;c:if&gt;：相当于 if 判断。属性：test，用于定义条件表达式。 123456&lt;c:if test=&quot;$&#123;flag == 1&#125;&quot;&gt; 男&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;flag == 2&#125;&quot;&gt; 女&lt;/c:if&gt; 定义一个 servlet ，在该 servlet 中向 request 域对象中添加 键是 status ，值为 1 的数据。 12345678910111213141516@WebServlet(&quot;/demo2&quot;)public class ServletDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 存储数据到request域中 request.setAttribute(&quot;status&quot;,1); //2. 转发到 jstl-if.jsp 数据request.getRequestDispatcher(&quot;/jstl-if.jsp&quot;).forward(request,response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 定义 jstl-if.jsp 页面，在该页面使用 &lt;c:if&gt; 标签。 12345678910111213141516171819&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; // 引入 JSTL核心标签库&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- c:if：来完成逻辑判断，替换java if else --%&gt; &lt;c:if test=&quot;$&#123;status ==1&#125;&quot;&gt; 启用 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;status ==0&#125;&quot;&gt; 禁用 &lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt; forEach 标签&lt;c:forEach&gt;：相当于 for 循环。Java 中有增强 for 循环和普通 for 循环，JSTL 中的 &lt;c:forEach&gt; 也有两种用法： 增强 for 循环。涉及到的 &lt;c:forEach&gt; 中的属性： items：被遍历的容器 var：遍历产生的临时变量 varStatus：遍历状态对象 例，从域对象中获取名为 brands 数据，该数据是一个集合；遍历遍历，并给该集合中的每一个元素起名为 brand，是 Brand 对象。在循环里面使用 EL表达式获取每一个 Brand 对象的属性值。 12345678&lt;c:forEach items=&quot;$&#123;brands&#125;&quot; var=&quot;brand&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;$&#123;brand.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;brand.brandName&#125;&lt;/td&gt; &lt;td&gt;$&#123;brand.companyName&#125;&lt;/td&gt; &lt;td&gt;$&#123;brand.description&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 从0循环到10，变量名是 i ，每次自增1 123&lt;c:forEach begin=&quot;0&quot; end=&quot;10&quot; step=&quot;1&quot; var=&quot;i&quot;&gt; $&#123;i&#125;&lt;/c:forEach&gt; 七、MVC 模式和三层架构MVC 模式MVC 是一种分层开发的模式，其中： M：Model，业务模型，处理业务 V：View，视图，界面展示 C：Controller，控制器，处理请求，调用模型和视图 控制器（serlvlet）用来接收浏览器发送过来的请求，控制器调用模型（JavaBean）来获取数据，比如从数据库查询数据；控制器获取到数据后再交由视图（JSP）进行数据展示。 MVC 的优点： 职责单一，互不影响。每个角色做它自己的事，各司其职。 有利于分工协作。 有利于组件重用。 三层架构三层架构是将我们的项目分成了三个层面，分别是 表现层、业务逻辑层、数据访问层。 数据访问层：对数据库的 CRUD 基本操作。 业务逻辑层：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能。例如 注册业务功能 ，我们会先调用 数据访问层 的 selectByName() 方法判断该用户名是否存在，如果不存在再调用 数据访问层 的 insert() 方法进行数据的添加操作。 表现层：接收请求，封装数据，调用业务逻辑层，响应数据。 而整个流程是，浏览器发送请求，表现层的 Servlet 接收请求并调用业务逻辑层的方法进行业务逻辑处理，而业务逻辑层方法调用数据访问层方法进行数据的操作，依次返回到 serlvet，然后 servlet 将数据交由 JSP 进行展示。 三层架构的每一层都有特有的包名称： 表现层： com.itheima.controller 或者 com.itheima.web。 业务逻辑层：com.itheima.service。 数据访问层：com.itheima.dao 或者 com.itheima.mapper。 MVC 和 三层架构 MVC 模式 中的 C（控制器）和 V（视图）就是 三层架构 中的表现层，而 MVC 模式 中的 M（模型）就是 三层架构 中的 业务逻辑层 和 数据访问层。 可以将 MVC 模式 理解成是一个大的概念，而 三层架构 是对 MVC 模式 实现架构的思想。 那么我们以后按照要求将不同层的代码写在不同的包下，每一层里功能职责做到单一，将来如果将表现层的技术换掉，而业务逻辑层和数据访问层的代码不需要发生变化。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://blog.zhuangzhihao.top/tags/JSP/"}]},{"title":"Request 和 Response 对象详解","slug":"Request&Response","date":"2022-04-09T16:00:00.000Z","updated":"2022-06-12T05:33:33.017Z","comments":true,"path":"Request&Response/","link":"","permalink":"http://blog.zhuangzhihao.top/Request&Response/","excerpt":"Java Web 核心第二章。在 Java Servlet 中，Request 对象是用来封装请求数据的对象，Response 对象是用来封装响应数据的对象。Web 服务器收到客户端的 HTTP 请求，会针对每一次请求分别创建一个用于代表请求的 Request 对象和代表响应的 Response 对象。","text":"Java Web 核心第二章。在 Java Servlet 中，Request 对象是用来封装请求数据的对象，Response 对象是用来封装响应数据的对象。Web 服务器收到客户端的 HTTP 请求，会针对每一次请求分别创建一个用于代表请求的 Request 对象和代表响应的 Response 对象。 一、Request 和 Response 对象的使用Request 和 Response 这两个参数的作用是什么? Request：获取请求数据 浏览器会发送 HTTP 请求到后台服务器（Tomcat）。 HTTP 的请求中会包含很多请求数据（请求行 + 请求头 + 请求体）。 后台服务器会对 HTTP 请求中的数据进行解析并把解析结果存入到一个对象中。 所存入的对象即为 Request 对象，所以我们可以从 Request 对象中获取请求的相关参数。 获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务。 Response：设置响应数据 业务处理完后，后台就需要给前端返回业务处理的结果，即响应数据。 把响应数据封装到 Response 对象中。 后台服务器（Tomcat）会解析 Response 对象，按照（响应行 + 响应头 + 响应体）格式拼接结果。 浏览器最终解析结果，把内容展示在浏览器给用户浏览。 初步体验下 Request 和 Response 对象的使用案例。 1234567891011121314151617@WebServlet(&quot;/demo3&quot;)public class ServletDemo3 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //使用request对象 获取请求数据 String name = request.getParameter(&quot;name&quot;);//url?name=zhangsan //使用response对象 设置响应数据 response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;); response.getWriter().write(&quot;&lt;h1&gt;&quot;+name+&quot;,欢迎您！&lt;/h1&gt;&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;Post...&quot;); &#125;&#125; 二、Request 对象Request 继承体系当我们的 Servlet 类实现的是 Servlet 接口的时候，service 方法中的参数是 ServletRequest 和 ServletResponse，当我们的 Servlet 类继承的是 HttpServlet 类的时候，doGet 和 doPost 方法中的参数就变成 HttpServletRequest 和 HttpServletReponse。 Request 的继承体系： 12graph BTRequestFacade --&gt; HttpServletRequest --&gt; ServletRequest ServletRequest 和 HttpServletRequest 是继承关系，并且两个都是接口，接口是无法创建对象，需要用到 RequestFacade：该类实现了 HttpServletRequest 接口，也间接实现了ServletRequest接口。Servlet 类中的 service 方法、doGet 方法或者是 doPost 方法最终都是由 Web 服务器来调用的，所以 Tomcat 提供了方法参数接口的具体实现类，并完成了对象的创建。 要想了解 RequestFacade 中都提供了哪些方法，我们可以直接查看 JavaEE API 文档中关于 ServletRequest 和 HttpServletRequest 的接口文档，因为 RequestFacade 实现了其接口就需要重写接口中的方法。 1234567891011@WebServlet(&quot;/demo2&quot;)public class ServletDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(request); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; Request 获取请求数据获取请求行数据：请求行包含三块内容，分别是 请求方式、请求资源路径、HTTP协议及版本。 123456789101112131415161718192021222324@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // String getMethod()：获取请求方式： GET String method = req.getMethod(); System.out.println(method);//GET // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo String contextPath = req.getContextPath(); System.out.println(contextPath); // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1 StringBuffer url = req.getRequestURL(); System.out.println(url.toString()); // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1 String uri = req.getRequestURI(); System.out.println(uri); // String getQueryString()：获取请求参数（GET方式）： username=zhangsan String queryString = req.getQueryString(); System.out.println(queryString); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; 获取请求头数据：请求头的数据格式为 key: value。 123456789101112@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求头: user-agent: 浏览器的版本信息 String agent = req.getHeader(&quot;user-agent&quot;); System.out.println(agent); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; 获取请求体数据：浏览器在发送 GET 请求的时候是没有请求体的，所以需要把请求方式变更为 POST。 如果前端发送的是字节数据，比如传递的是文件数据，则使用 getInputStream() 方法获取字节输入流。 如果前端发送的是纯文本数据，则使用 getReader() 方法获取字符输入流。 123456789101112131415@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取post 请求体：请求参数 //1. 获取字符输入流 BufferedReader br = req.getReader(); //2. 读取数据 String line = br.readLine(); System.out.println(line); &#125;&#125; BufferedReader 流是通过 request 对象来获取的，当请求完成后 request 对象就会被销毁，request 对象被销毁后，BufferedReader 流就会自动关闭，所以此处就不需要手动关闭流了。 获取请求参数的通用方式请求参数是请求数据中的部分内容（如：用户名和密码），请求数据则是包含请求行、请求头和请求体的所有数据，如果是 GET 请求，请求参数在请求行中，如果是 POST 请求，请求参数一般在请求体中。 GET 方式获取请求参数：String getQueryString() POST 方式获取请求参数：BufferedReader getReader(); 12345678910111213141516@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //GET 方式获取请求参数 String result = req.getQueryString(); System.out.println(result); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // POST 方式获取请求参数 BufferedReader br = req.getReader(); String result = br.readLine(); System.out.println(result); &#125;&#125; GET 请求方式和 POST 请求方式区别主要在于获取请求参数的方式不一样，为了统一获取请求参数，Request 对象为我们提供了如下方法： 获取所有参数Map集合：Map&lt;String,String[]&gt; getParameterMap() 根据名称获取参数值（数组）：String[] getParameterValues(String name) 根据名称获取参数值（单个值）：String getParameter(String name) 1234567891011121314151617181920212223242526272829303132333435363738/** * request 通用方式获取请求参数 */@WebServlet(&quot;/req2&quot;)public class RequestDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //GET请求逻辑 System.out.println(&quot;get....&quot;); //1. 获取所有参数的Map集合 Map&lt;String, String[]&gt; map = req.getParameterMap(); for (String key : map.keySet()) &#123; // username:zhangsan lisi System.out.print(key+&quot;:&quot;); //获取值 String[] values = map.get(key); for (String value : values) &#123; System.out.print(value + &quot; &quot;); &#125; System.out.println(); &#125; //2. 获取GET请求参数中的爱好，结果是数组值 System.out.println(&quot;------------&quot;); String[] hobbies = req.getParameterValues(&quot;hobby&quot;); for (String hobby : hobbies) &#123; System.out.println(hobby); &#125; //3. 获取GET请求参数中的用户名和密码，结果是单个值 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); System.out.println(username); System.out.println(password); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; req.getParameter() 方法使用的频率会比较高，以后我们再写代码的时候，就只需要按照如下格式来编写： 1234567891011public class RequestDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //采用request提供的获取请求参数的通用方式来获取请求参数 //编写其他的业务代码... &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 请求参数中文乱码问题POST 的请求参数是通过 request 的 getReader() 来获取流中的数据，Tomcat 在获取流的时候采用的编码是ISO-8859-1（不支持中文），需要通过 request.setCharacterEncoding(&quot;UTF-8&quot;) 把 Tomcat 在获取流数据之前的编码设置为UTF-8。 1234567891011121314151617@WebServlet(&quot;/req4&quot;)public class RequestDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 解决乱码: POST getReader() //设置字符输入流的编码，设置的字符集要和页面保持一致 request.setCharacterEncoding(&quot;UTF-8&quot;); //2. 获取username String username = request.getParameter(&quot;username&quot;); System.out.println(username); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; GET 请求获取请求参数的方式是 request.getQueryString()，并没有通过流的方式获取数据，所以 GET 请求不能用设置编码的方式来解决中文乱码问题。 GET 请求中文参数出现乱码的原因，是浏览器把中文参数按照 UTF-8 进行 URL 编码，而后台的 Tomcat 对获取到的内容进行 ISO-8859-1 的 URL 解码，我们可以按照 ISO-8859-1 编码获取乱码对应的字节数组，再按照 UTF-8 编码获取字节数组对应的字符串，在转换的过程中它们的编码一致，就可以解决中文乱码问题。 URL编码实现方式: 编码：URLEncoder.encode(str,&quot;UTF-8&quot;); 解码：URLDecoder.decode(s,&quot;ISO-8859-1&quot;); 1234567891011121314151617181920212223public class URLDemo &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; String username = &quot;张三&quot;; //1. URL编码 String encode = URLEncoder.encode(username, &quot;utf-8&quot;); System.out.println(encode); //2. URL解码 String decode = URLDecoder.decode(encode, &quot;ISO-8859-1&quot;); System.out.println(decode); //此处打印的是对应的乱码数据 //3. 转换为字节数据,编码 byte[] bytes = decode.getBytes(&quot;ISO-8859-1&quot;); for (byte b : bytes) &#123; System.out.print(b + &quot; &quot;); &#125; //此处打印的是:-27 -68 -96 -28 -72 -119 //4. 将字节数组转为字符串，解码 String s = new String(bytes, &quot;utf-8&quot;); System.out.println(s); //此处打印的是张三 &#125;&#125; 通用中文乱码解决方案：先解码，再编码。 1234567891011121314151617181920212223242526272829@WebServlet(&quot;/req4&quot;)public class RequestDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 解决乱码：POST，getReader() //request.setCharacterEncoding(&quot;UTF-8&quot;);//设置字符输入流的编码 //2. 获取username String username = request.getParameter(&quot;username&quot;); System.out.println(&quot;解决乱码前：&quot;+username); //3. GET,获取参数的方式：getQueryString // 乱码原因：tomcat进行URL解码，默认的字符集ISO-8859-1 /* //3.1 先对乱码数据进行编码：转为字节数组 byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1); //3.2 字节数组解码 username = new String(bytes, StandardCharsets.UTF_8);*/ username = new String(username.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8); System.out.println(&quot;解决乱码后：&quot;+username); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 把 request.setCharacterEncoding(&quot;UTF-8&quot;) 代码注释掉后，会发现 GET 请求参数乱码解决方案同时也可也把 POST 请求参数乱码的问题也解决了，只不过对于 POST 请求参数一般都会比较多，采用这种方式解决乱码起来比较麻烦，所以对于 POST 请求还是建议使用设置编码的方式进行。 Tomcat 8.0 之后的版本已将 GET 请求乱码问题解决，设置默认的解码方式为 UTF-8。 Request 请求转发请求转发（forward）是一种在服务器内部的资源跳转方式。 请求转发的实现方式：req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);。 1234567891011121314@WebServlet(&quot;/req5&quot;)public class RequestDemo5 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;demo5...&quot;); //请求转发 request.getRequestDispatcher(&quot;/req6&quot;).forward(request,response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 请求转发资源间共享数据：使用 Request 对象。 存储数据到 request 域中：void setAttribute(String name,Object o); 根据 key 获取值：Object getAttribute(String name); 根据 key 删除该键值对：void removeAttribute(String name); 123456789101112131415161718192021222324252627282930@WebServlet(&quot;/req5&quot;)public class RequestDemo5 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;demo5...&quot;); //存储数据 request.setAttribute(&quot;msg&quot;,&quot;hello&quot;); //请求转发 request.getRequestDispatcher(&quot;/req6&quot;).forward(request,response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125;@WebServlet(&quot;/req6&quot;)public class RequestDemo6 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;demo6...&quot;); //获取数据 Object msg = request.getAttribute(&quot;msg&quot;); System.out.println(msg); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 请求转发的特点：浏览器地址栏路径不发生变化，只能转发到当前服务器的内部资源，而不能从一个服务器通过转发访问另一台服务器。一次请求可以在转发资源间使用 request 共享数据。 三、Response 对象Reponse 的继承体系和 Request 的继承体系非常相似 Servlet -&gt; service(request, response) 12graph BTReponseFacade --&gt; HttpServletReponse --&gt; ServletReponse Response 设置响应数据HTTP响应数据总共分为三部分内容，分别是响应行、响应头、响应体，对于这三部分内容的数据，respone 对象都提供了哪些方法来进行设置? 对于响应头，比较常用的就是设置响应状态码：void setStatus(int sc);。 设置响应头键值对：void setHeader(String name,String value);。 对于响应体，是通过字符、字节输出流的方式往浏览器写，获取字符输出流：PrintWriter getWriter();，或获取字节输出流：ServletOutputStream getOutputStream();。 介绍完这些方法后，后面我们会通过案例把这些方法都用一用，首先先来完成下重定向的功能开发。 Respones 请求重定向Response 重定向（redirect）是一种资源跳转方式。浏览器发送请求给服务器，服务器中对应的资源 A 接收到请求。当资源 A 现在无法处理该请求，就会给浏览器响应一个 302 的状态码 + location 的一个访问资源 B 的路径。浏览器接收到响应状态码为 302 就会重新发送请求到 location 对应的访问地址去访问资源 B。资源 B 接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向。 重定向的实现方式： 12resp.setStatus(302);resp.setHeader(&quot;location&quot;,&quot;资源B的访问路径&quot;); 具体使用，我们先创建 ResponseDemo1 类 123456789101112@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;resp1....&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 创建 ResponseDemo2 类 123456789101112@WebServlet(&quot;/resp2&quot;)public class ResponseDemo2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;resp2....&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 在 ResponseDemo1 的 doGet 方法中给前端响应数据 1234567891011121314151617@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;resp1....&quot;); //重定向 //1.设置响应状态码 302 response.setStatus(302); //2. 设置响应头 Location response.setHeader(&quot;Location&quot;,&quot;/request-demo/resp2&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 虽然功能已经实现，但是从设置重定向的两行代码来看，会发现除了重定向的地址不一样，其他的内容都是一模一样，所以request对象给我们提供了简化的编写方式为：resposne.sendRedirect(&quot;/request-demo/resp2&quot;)。 12345678910111213@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;resp1....&quot;); //重定向 resposne.sendRedirect(&quot;/request-demo/resp2&quot;)； &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 重定向的特点 浏览器地址栏路径发送变化：当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化。 可以重定向到任何位置的资源(服务内容、外部均可)，因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。 两次请求，不能在多个资源使用 request 共享数据，因为浏览器发送了两次请求，是两个不同的 request 对象，就无法通过 request 对象进行共享数据 路径问题 转发的时候路径上没有加 /request-demo 而重定向加了，因为对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录。对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。 在重定向的代码中，/request-demo 是固定编码的，如果后期通过 Tomcat 插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，因此我们可以在代码中动态去获取项目访问的虚拟目录进行优化，具体可以借助 request 对象 getContextPath()方法，修改后的代码如下： 1234567891011121314151617@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;resp1....&quot;); //简化方式完成重定向 //动态获取虚拟目录 String contextPath = request.getContextPath(); response.sendRedirect(contextPath+&quot;/resp2&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 重新启动访问测试，功能依然能够实现，此时就可以动态获取项目访问的虚拟路径，从而降低代码的耦合度。 Response 响应字符数据要想将字符数据写回到浏览器，我们需要两个步骤：首先通过 Response 对象获取字符输出流（PrintWriter writer = resp.getWriter();），再通过字符输出流写数据（writer.write(&quot;aaa&quot;);） 返回一个简单的字符串 aaa。 1234567891011121314151617/** * 响应字符数据：设置字符数据的响应体 */@WebServlet(&quot;/resp3&quot;)public class ResponseDemo3 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); //1. 获取字符输出流 PrintWriter writer = response.getWriter(); writer.write(&quot;aaa&quot;); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 返回一串 html 字符串，并且能被浏览器解析。 12345PrintWriter writer = response.getWriter();//content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签response.setHeader(&quot;content-type&quot;,&quot;text/html&quot;);writer.write(&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;);//一次请求响应结束后，response 对象就会被销毁掉，所以不要手动关闭流。 返回一个中文的字符串 你好，需要注意设置响应数据的编码为 utf-8 123//设置响应的数据格式及数据的编码response.setContentType(&quot;text/html;charset=utf-8&quot;);writer.write(&quot;你好&quot;); Response 响应字节数据要想将字节数据写回到浏览器，我们需要两个步骤：首先通过Response对象获取字节输出流（ServletOutputStream outputStream = resp.getOutputStream();），再通过字节输出流写数据（outputStream.write(字节数据);）。 响应字符数据的实际应用： 返回一个图片文件到浏览器 12345678910111213141516171819202122232425/** * 响应字节数据：设置字节数据的响应体 */@WebServlet(&quot;/resp4&quot;)public class ResponseDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 读取文件 FileInputStream fis = new FileInputStream(&quot;d://a.jpg&quot;); //2. 获取response字节输出流 ServletOutputStream os = response.getOutputStream(); //3. 完成流的copy byte[] buff = new byte[1024]; int len = 0; while ((len = fis.read(buff))!= -1)&#123; os.write(buff,0,len); &#125; fis.close(); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 上述代码中，对于流的 copy 的代码还是比较复杂的，所以我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是： pom.xml 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 调用工具类方法 123//fis:输入流//os:输出流IOUtils.copy(fis,os); 优化后的代码： 123456789101112131415161718192021/** * 响应字节数据：设置字节数据的响应体 */@WebServlet(&quot;/resp4&quot;)public class ResponseDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 读取文件 FileInputStream fis = new FileInputStream(&quot;d://a.jpg&quot;); //2. 获取response字节输出流 ServletOutputStream os = response.getOutputStream(); //3. 完成流的copy IOUtils.copy(fis,os); fis.close(); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://blog.zhuangzhihao.top/tags/Servlet/"}]},{"title":"HTTP 协议和 Servlet","slug":"HTTP&Servlet","date":"2022-04-04T16:00:00.000Z","updated":"2022-05-16T05:49:21.642Z","comments":true,"path":"HTTP&Servlet/","link":"","permalink":"http://blog.zhuangzhihao.top/HTTP&Servlet/","excerpt":"Java Web 核心第一章。Java Web 是用 Java 技术来解决相关 web 互联网领域的技术栈，国内很多大型网站公司也是首选 Java 语言来解决 web 互联网相关的问题。要了解 Java Web 开发的技术栈，首先需要理解 HTTP 协议和 HTTP 请求与响应数据的格式，理解 Servlet 的执行流程和生命周期，掌握 Servlet 的使用和相关配置。","text":"Java Web 核心第一章。Java Web 是用 Java 技术来解决相关 web 互联网领域的技术栈，国内很多大型网站公司也是首选 Java 语言来解决 web 互联网相关的问题。要了解 Java Web 开发的技术栈，首先需要理解 HTTP 协议和 HTTP 请求与响应数据的格式，理解 Servlet 的执行流程和生命周期，掌握 Servlet 的使用和相关配置。 一、HTTP 协议HyperText Transfer Protocol（超文本传输协议）规定了浏览器和服务器之间数据传输的规则。数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。 HTTP 协议是基于 TCP 的协议，TCP 是一种面向连接的（建立连接前是需经过三次握手）、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。 HTTP 同样也是基于请求—响应模型的，一次请求对应一次响应，请求和响应是一一对应关系。 HTTP 协议是无状态协议，对于事物处理没有记忆能力，每次请求—响应都是独立的。无状态指的是客户端发送 HTTP 请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点，缺点是多次请求间不能共享数据，但速度快。 请求之间无法共享数据会引发的问题，如电商网站加入购物车和去购物车结算是两次请求，加入购物车请求响应结束后，并未记录加入购物车是何商品，发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据，在 Java Web 中要使用会话技术（Cookie、Session）来解决这个问题。 请求数据格式HTTP 请求数据总共分为三部分内容，分别是请求行、请求头、请求体，请求方式有七种，最常用的是 GET 和 POST 方法。 请求行是 HTTP 请求中的第一行数据，请求行包含三块内容，分别是 [请求方式] /[请求URL路径] / [HTTP协议及版本]。 1GET / HTTP/1.1 请求头从第二行开始，格式均为 key: value 形式，请求头中会包含若干个属性。 12345Host: 请求的主机名User-Agent: 浏览器版本, Mozilla/5.0 Chrome/79Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等 服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，比如浏览器兼容问题。 请求体是 POST 请求的最后一部分，存储请求参数，请求体和请求头之间是有一个空行隔开。 1username=bezhuang@password=1234 GET 和 POST 两个请求的区别：GET 请求请求参数在请求行中，没有请求体，POST 请求请求参数在请求体中，GET 请求请求参数大小有限制，POST 没有。 响应数据格式响应数据总共分为三部分内容，分别是响应行、响应头、响应体。 响应行是响应数据的第一行，响应行包含三块内容，分别是 [HTTP协议及版本] [响应状态码] [状态码的描述]。 1HTTP/1.1 200 OK 响应状态码 200 ok 客户端请求成功 404 Not Found 请求资源不存在 500 Internal Server Error 服务端发生不可预期的错误 响应头从第二行开始，格式也为 key：value 形式，响应头中会包含若干个属性。 1234Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；Content-Length：表示该响应内容的长度（字节数）；Content-Encoding：表示该响应压缩算法，例如gzip；Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 响应体是最后一部分，存放响应数据，&lt;html&gt;数据内容&lt;/html&gt;。 自定义服务器可以使用 Java 编写服务器，用来接受页面发送的请求和响应数据给前端浏览器，主要使用到的是 ServerSocket 和 Socket。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.itheima;import sun.misc.IOUtils;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.nio.charset.StandardCharsets;import java.nio.file.Files;public class Server &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(8080); // 监听指定端口 System.out.println(&quot;server is running...&quot;); while (true)&#123; Socket sock = ss.accept(); System.out.println(&quot;connected from &quot; + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); &#125; &#125;&#125;class Handler extends Thread &#123; Socket sock; public Handler(Socket sock) &#123; this.sock = sock; &#125; public void run() &#123; try (InputStream input = this.sock.getInputStream()) &#123; try (OutputStream output = this.sock.getOutputStream()) &#123; handle(input, output); &#125; &#125; catch (Exception e) &#123; try &#123; this.sock.close(); &#125; catch (IOException ioe) &#123; &#125; System.out.println(&quot;client disconnected.&quot;); &#125; &#125; private void handle(InputStream input, OutputStream output) throws IOException &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); // 读取HTTP请求: boolean requestOk = false; String first = reader.readLine(); if (first.startsWith(&quot;GET / HTTP/1.&quot;)) &#123; requestOk = true; &#125; for (;;) &#123; String header = reader.readLine(); if (header.isEmpty()) &#123; // 读取到空行时, HTTP Header读取完毕 break; &#125; System.out.println(header); &#125; System.out.println(requestOk ? &quot;Response OK&quot; : &quot;Response Error&quot;); if (!requestOk) &#123; // 发送错误响应: writer.write(&quot;HTTP/1.0 404 Not Found\\r\\n&quot;); writer.write(&quot;Content-Length: 0\\r\\n&quot;); writer.write(&quot;\\r\\n&quot;); writer.flush(); &#125; else &#123; // 发送成功响应: //读取html文件，转换为字符串 BufferedReader br = new BufferedReader(new FileReader(&quot;http/html/a.html&quot;)); StringBuilder data = new StringBuilder(); String line = null; while ((line = br.readLine()) != null)&#123; data.append(line); &#125; br.close(); int length = data.toString().getBytes(StandardCharsets.UTF_8).length; writer.write(&quot;HTTP/1.1 200 OK\\r\\n&quot;); writer.write(&quot;Connection: keep-alive\\r\\n&quot;); writer.write(&quot;Content-Type: text/html\\r\\n&quot;); writer.write(&quot;Content-Length: &quot; + length + &quot;\\r\\n&quot;); writer.write(&quot;\\r\\n&quot;); // 空行标识Header和Body的分隔 writer.write(data.toString()); writer.flush(); &#125; &#125;&#125; 二、Tomcat 服务器Web 服务器是一个安装在服务器端的对 HTTP 协议的操作进行封装的应用程序，使得程序员不必直接对协议进行操作，让 Web 开发更加便捷，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。 Tomcat 是 Apache 软件基金会一个核心项目，是一个开源免费的轻量级 Web 服务器，支持 Servlet/JSP 少量 JavaEE 规范。JavaEE 规范是指 Java 企业级开发的技术规范总和。因为 Tomcat 支持 Servlet/JSP 规范，所以 Tomcat 也被称为Web容器、Servlet容器。Servlet需要依赖 Tomcat 才能运行。 使用 Maven 工具能更加简单快捷的把 Web 项目给创建出来，创建方式有两种：使用骨架和不使用骨架。使用骨架，默认没有 java 和 resources 目录，需要手动完成创建补齐，不使用骨架要在 pom.xml 设置打包方式为 war、补齐 Maven Web 项目缺失 webapp 的目录结构和 WEB-INF/web.xml 的目录结构。 Maven Web 项目创建成功后，通过 Maven 的 package 命令可以将项目打包成 war 包，将 war 文件拷贝到 Tomcat 的 webapps 目录下，启动 Tomcat 就可以将项目部署成功，然后通过浏览器进行访问即可。 在 IDEA 中可以直接使用 Maven 中的 Tomcat 插件来部署项目，即在 pom.xml 中添加 Tomcat 插件，再使用 Maven Helper 插件快速启动项目。 1234567891011121314151617181920&lt;build&gt; &lt;plugins&gt; &lt;!--Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt;&lt;!--访问端口号 --&gt; &lt;!--项目访问路径 未配置访问路径: http://localhost:80/tomcat-demo2/a.html 配置/后访问路径: http://localhost:80/a.html 如果配置成 /hello,访问路径会变成什么? 答案: http://localhost:80/hello/a.html --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 三、ServletServlet 是 Java Web 最为核心的内容，它是 Java 提供的一门动态 web 资源开发技术。使用 Servlet 就可以实现根据不同的登录用户在页面上动态显示不同内容。Servlet 是 JavaEE 规范之一，其实就是一个接口，将来我们需要定义 Servlet 类实现 Servlet 接口，并由 web 服务器运行 Servlet。 快速入门编写一个 Servlet 类，并使用 IDEA 中 Tomcat 插件进行部署，最终通过浏览器访问所编写的 Servlet 程序。具体的实现步骤如下： 创建 Web 项目 web-demo，导入 Servlet 依赖坐标。 1234567891011&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;!-- 此处为什么需要添加该标签? provided指的是在编译和测试过程中有效,最后生成的war包时不会加入 因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错 --&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 创建：定义一个类，实现 Servlet 接口，并重写接口中所有方法，并在 service 方法中输入一句话。 123456789101112131415161718package com.itheima.web;import javax.servlet.*;import java.io.IOException;public class ServletDemo1 implements Servlet &#123; public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;servlet hello world~&quot;); &#125; public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public String getServletInfo() &#123; return null; &#125; public void destroy() &#123; &#125;&#125; 配置：在类上使用 @WebServlet 注解，配置该 Servlet 的访问路径。 1@WebServlet(&quot;/demo1&quot;) 访问：启动 Tomcat，浏览器中输入 URL 地址访问该 Servlet。 1http://localhost:8080/web-demo/demo1 通过浏览器访问后，在控制台会打印 servlet hello world~ ，说明 servlet 程序已经成功运行。 执行流程Servlet 的执行流程：浏览器发出 http://localhost:8080/web-demo/demo1 请求，从请求中可以解析出三部分内容，分别是 localhost:8080、web-demo、demo1，根据 localhost:8080 可以找到要访问的 Tomcat Web 服务器，根据 web-demo 可以找到部署在 Tomcat 服务器上的 web-demo 项目，根据 demo1 可以找到要访问的是项目中的哪个 Servlet 类，根据 @WebServlet 后面的值进行匹配。 找到 ServletDemo1 这个类后，Tomcat Web 服务器就会为 ServletDemo1 这个类创建一个对象，然后调用对象中的 service 方法。 ServletDemo1 实现了 Servlet 接口，所以类中必然会重写 service 方法供 Tomcat Web 服务器进行调用，service 方法中 ServletRequest 和 ServletResponse 两个参数，ServletRequest 封装的是请求数据，ServletResponse 封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互。 Servlet 由 web 服务器创建，Servlet 方法由 web 服务器调用。 因为我们自定义的 Servlet 必须实现 Servlet 接口并复写其方法，而 Servlet 接口中有 service 方法，因此服务器知道 Servlet 中一定有 service 方法。 生命周期对象的生命周期指一个对象从被创建到被销毁的整个过程。 Servlet 运行在 Servlet 容器（web 服务器）中，其生命周期由容器来管理，分为 4 个阶段： 加载和实例化：默认情况下，当 Servlet 第一次被访问时，由容器创建 Servlet 对象，，但是如果创建 Servlet 比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们可以把 Servlet 的创建放到服务器启动的时候来创建。 123456@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)/*loadOnstartup的取值有两类情况 （1）负整数:第一次访问时创建Servlet对象 （2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高*/ 初始化：在 Servlet 实例化之后，容器将调用 Servlet 的 init() 方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次。 请求处理：每次请求 Servlet 时，Servlet 容器都会调用 Servlet 的 service() 方法对请求进行处理 服务终止：当需要释放内存或者容器关闭时，容器就会调用 Servlet 实例的 destroy() 方法完成资源的释放。在 destroy() 方法调用之后，容器会释放这个 Servlet 实例，该实例随后会被 Java 的垃圾收集器所回收。 通过案例演示 Servlet 生命周期方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/*** Servlet生命周期方法*/@WebServlet(urlPatterns = &quot;/demo2&quot;,loadOnStartup = 1)public class ServletDemo2 implements Servlet &#123; /** * 初始化方法 * 1.调用时机：默认情况下，Servlet被第一次访问时，调用 * * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用 * 2.调用次数: 1次 * @param config * @throws ServletException */ public void init(ServletConfig config) throws ServletException &#123; System.out.println(&quot;init...&quot;); &#125; /** * 提供服务 * 1.调用时机:每一次Servlet被访问时，调用 * 2.调用次数: 多次 * @param req * @param res * @throws ServletException * @throws IOException */ public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(&quot;servlet hello world~&quot;); &#125; /** * 销毁方法 * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用 * 2.调用次数: 1次 */ public void destroy() &#123; System.out.println(&quot;destroy...&quot;); &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public String getServletInfo() &#123; return null; &#125;&#125; Servlet 对象默认是第一次访问的时候被创建，可以使用 @WebServlet(urlPatterns = &quot;/demo2&quot;,loadOnStartup = 1) 的 loadOnStartup 修改成在服务器启动的时候创建。 Servlet 生命周期中涉及到三个方法，分别是 init()、service()、destroy()，init 方法在 Servlet 对象被创建的时候执行，只执行 1 次，service 方法在 Servlet 被访问的时候调用，每访问 1 次就调用 1 次，destroy 方法在 Servlet 对象被销毁的时候调用，只执行 1 次。 方法介绍Servlet 中总共有5个方法，我们已经介绍过其中的三个，剩下的两个方法为 getServletInfo() 和 getServletConfig()。 初始化方法，在 Servlet 被创建时执行，只执行一次。 1void init(ServletConfig config) 提供服务方法， 每次 Servlet 被访问，都会调用该方法。 1void service(ServletRequest req, ServletResponse res) 销毁方法，当 Servlet 被销毁时，调用该方法。在内存释放或服务器关闭时销毁 Servlet。 1void destroy() 获取 Servlet 信息方法 12345String getServletInfo() //该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可public String getServletInfo() &#123; return &quot;&quot;;&#125; 获取 ServletConfig 对象方法 1ServletConfig getServletConfig() ServletConfig 对象在 init 方法的参数中有，而 Tomcat Web 服务器在创建 Servlet 对象的时候会调用 init 方法，必定会传入一个 ServletConfig 对象，我们只需要将服务器传过来的 ServletConfig 进行返回即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/** * Servlet方法介绍 */@WebServlet(urlPatterns = &quot;/demo3&quot;,loadOnStartup = 1)public class ServletDemo3 implements Servlet &#123; private ServletConfig servletConfig; /** * 初始化方法 * 1.调用时机：默认情况下，Servlet被第一次访问时，调用 * * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用 * 2.调用次数: 1次 * @param config * @throws ServletException */ public void init(ServletConfig config) throws ServletException &#123; this.servletConfig = config; System.out.println(&quot;init...&quot;); &#125; public ServletConfig getServletConfig() &#123; return servletConfig; &#125; /** * 提供服务 * 1.调用时机:每一次Servlet被访问时，调用 * 2.调用次数: 多次 * @param req * @param res * @throws ServletException * @throws IOException */ public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(&quot;servlet hello world~&quot;); &#125; /** * 销毁方法 * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用 * 2.调用次数: 1次 */ public void destroy() &#123; System.out.println(&quot;destroy...&quot;); &#125; public String getServletInfo() &#123; return &quot;&quot;; &#125;&#125; 体系结构B/S 架构的 web 项目都是针对 HTTP 协议，所以我们自定义 Servlet，会通过继承 HttpServlet，具体的编写格式如下: 12345678910111213@WebServlet(&quot;/demo4&quot;)public class ServletDemo4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //TODO GET 请求方式处理逻辑 System.out.println(&quot;get...&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //TODO Post 请求方式处理逻辑 System.out.println(&quot;post...&quot;); &#125;&#125; 要想发送一个 GET 请求，请求该 Servlet，只需要通过浏览器发送 http://localhost:8080/web-demo/demo4，就能看到 doGet 方法被执行了。 要想发送一个 POST 请求，请求该 Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个 form 表单来发送请求，在 webapp 下创建一个 a.html 页面，启动测试，即可看到 doPost 方法被执行了。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/web-demo/demo4&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;username&quot;/&gt;&lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 因为前端发送 GET 和 POST 请求的时候，参数的位置不一致，GET 请求参数在请求行中，POST 请求参数在请求体中，为了能处理不同的请求方式，我们得在 service 方法中进行判断，然后写不同的业务处理。 123456789101112131415161718192021222324252627282930313233package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/demo5&quot;)public class ServletDemo5 implements Servlet &#123; public void init(ServletConfig config) throws ServletException &#123; &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; //如何调用? //获取请求方式，根据不同的请求方式进行不同的业务处理 HttpServletRequest request = (HttpServletRequest)req; //1. 获取请求方式 String method = request.getMethod(); //2. 判断 if(&quot;GET&quot;.equals(method))&#123; // get方式的处理逻辑 &#125;else if(&quot;POST&quot;.equals(method))&#123; // post方式的处理逻辑 &#125; &#125; public String getServletInfo() &#123; return null; &#125; public void destroy() &#123; &#125;&#125; 这样能实现，但是每个 Servlet 类中都将有相似的代码，针对这个问题，我们可以对 Servlet 接口进行继承封装，来简化代码开发。 123456789101112131415161718192021222324252627282930313233package com.itheima.web;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class MyHttpServlet implements Servlet &#123; public void init(ServletConfig config) throws ServletException &#123; &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request = (HttpServletRequest)req; //1. 获取请求方式 String method = request.getMethod(); //2. 判断 if(&quot;GET&quot;.equals(method))&#123; // get方式的处理逻辑 doGet(req,res); &#125;else if(&quot;POST&quot;.equals(method))&#123; // post方式的处理逻辑 doPost(req,res); &#125; &#125; protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125; protected void doGet(ServletRequest req, ServletResponse res) &#123; &#125; public String getServletInfo() &#123; return null; &#125; public void destroy() &#123; &#125;&#125; 有了 MyHttpServlet 这个类，以后我们再编写 Servlet 类的时候，只需要继承 MyHttpServlet，重写父类中的 doGet 和 doPost 方法，就可以用来处理 GET 和 POST 请求的业务逻辑。 1234567891011@WebServlet(&quot;/demo5&quot;)public class ServletDemo5 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;post...&quot;); &#125;&#125; 将来页面发送的是 GET 请求，则会进入到 doGet 方法中进行执行，如果是 POST 请求，则进入到 doPost 方法。这样代码在编写的时候就相对来说更加简单快捷。 类似 MyHttpServlet 这样的类 Servlet 中已经为我们提供好了，就是 HttpServlet。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn&#x27;t support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; lastModified) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125; &#125; HttpServlet 的使用步骤是先继承 HttpServlet，再重写 doGet、doPost 或其他方法。HttpServlet 的原理就是获取请求方式，并根据不同的请求方式，调用不同的 doXxx 方法。 urlPattern 配置Servlet 类编写好后，要想被访问到，就需要配置其访问路径（urlPattern），一个 Servlet，可以配置多个 urlPattern。 123456789101112131415161718package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/*** urlPattern: 一个 Servlet 可以配置多个访问路径*/@WebServlet(urlPatterns = &#123;&quot;/demo7&quot;,&quot;/demo8&quot;&#125;)public class ServletDemo7 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo7 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125;// 在浏览器上输入 http://localhost:8080/web-demo/demo7, http://localhost:8080/web-demo/demo8 这两个地址都能访问到 ServletDemo7 的 doGet 方法 urlPattern 总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配，配置的优先级为 精确匹配 &gt; 目录匹配 &gt; 扩展名匹配 &gt; /* &gt; / 。 精确匹配 12345678910@WebServlet(urlPatterns = &quot;/user/select&quot;)public class ServletDemo8 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo8 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; //访问路径：http://localhost:8080/web-demo/user/select 目录匹配：/* 1234567891011121314package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;/user/*&quot;)public class ServletDemo9 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo9 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; //访问路径：http://localhost:8080/web-demo/user/任意 扩展名匹配：*.do 1234567891011121314package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;*.do&quot;)public class ServletDemo10 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo10 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; //访问路径：http://localhost:8080/web-demo/任意.do 任意匹配：/ 或 /* 1234567891011121314package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;/&quot;)public class ServletDemo11 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo11 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; //访问路径：http://localhost:8080/demo-web/任意 1234567891011121314package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;/*&quot;)public class ServletDemo12 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo12 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; // 访问路径：http://localhost:8080/demo-web/任意 当我们的项目中的 Servlet 配置了 /，会覆盖掉 tomcat 中的 DefaultServlet，当其他的 url-pattern 都匹配不上时都会走这个 Servlet。当我们的项目中配置了 /*，意味着匹配任意访问路径。 DefaultServlet 是用来处理静态资源，如果配置了 / 会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的 Servlet 类，最终导致静态资源不能被访问。 XML 配置一般情况下 Servlet 使用的是注解配置 @WebServlet，但 3.0 版本前只支持 XML 配置文件的配置方法。对于 XML 的配置步骤有两步： 编写Servlet类。 12345678910111213package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;public class ServletDemo13 extends MyHttpServlet &#123; @Override protected void doGet(ServletRequest req, ServletResponse res) &#123; System.out.println(&quot;demo13 get...&quot;); &#125; @Override protected void doPost(ServletRequest req, ServletResponse res) &#123; &#125;&#125; 在 web.xml 中配置该 Servlet。 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- Servlet 全类名 --&gt; &lt;servlet&gt; &lt;!-- servlet的名称，名字任意--&gt; &lt;servlet-name&gt;demo13&lt;/servlet-name&gt; &lt;!--servlet的类全名--&gt; &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- Servlet 访问路径 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的名称，要和上面的名称一致--&gt; &lt;servlet-name&gt;demo13&lt;/servlet-name&gt; &lt;!-- servlet的访问路径--&gt; &lt;url-pattern&gt;/demo13&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.zhuangzhihao.top/tags/HTTP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://blog.zhuangzhihao.top/tags/Servlet/"}]},{"title":"MyBatis 基础知识总结","slug":"MyBatis基础","date":"2022-03-18T16:00:00.000Z","updated":"2022-05-05T11:47:00.363Z","comments":true,"path":"MyBatis基础/","link":"","permalink":"http://blog.zhuangzhihao.top/MyBatis%E5%9F%BA%E7%A1%80/","excerpt":"MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。","text":"MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 一、Mybatis 概述MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发。 MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 官网：https://mybatis.org/mybatis-3/zh/index.html 。 持久层：负责将数据到保存到数据库的那一层代码。以后开发我们会将操作数据库的 Java 代码作为持久层。而 Mybatis 就是对 jdbc 代码进行了封装。 JavaEE三层架构：表现层、业务层、持久层。 框架：框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。在框架的基础之上构建软件编写更加高效、规范、通用、可扩展。 JDBC 缺点硬编码：注册驱动、获取连接代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要换成其他的关系型数据库的话，要修改源代码。如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。 操作繁琐：手动设置参数。手动封装结果集。 使用Mybatis 优化：硬编码可以配置到配置文件，操作繁琐的地方 MyBatis 都自动完成。 MyBatis 快速入门需求：查询 user 表中所有的数据。 创建 user 表，添加数据。 12345678910111213create database mybatis;use mybatis;drop table if exists tb_user;create table tb_user( id int primary key auto_increment, username varchar(20), password varchar(20), gender char(1), addr varchar(30));INSERT INTO tb_user VALUES (1, &#x27;zhangsan&#x27;, &#x27;123&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;);INSERT INTO tb_user VALUES (2, &#x27;李四&#x27;, &#x27;234&#x27;, &#x27;女&#x27;, &#x27;天津&#x27;);INSERT INTO tb_user VALUES (3, &#x27;王五&#x27;, &#x27;11&#x27;, &#x27;男&#x27;, &#x27;西安&#x27;); 创建模块，导入坐标：需要在项目的 resources 目录下创建 logback 的配置文件。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;!-- CONSOLE ：表示当前的日志信息是可以输出到控制台的。 --&gt; &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;[%level] %blue(%d&#123;HH:mm:ss.SSS&#125;) %cyan([%thread]) %boldGreen(%logger&#123;15&#125;) - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name=&quot;com.itheima&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;!-- level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF ， 默认debug &lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个输出位置将会被本日志级别控制。 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;!--mybatis 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit 单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加slf4j日志api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-classic依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加logback-core依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写 MyBatis 核心配置文件 — &gt; 替换连接信息 解决硬编码问题。 在模块下的 resources 目录下创建 MyBatis 的配置文件 mybatis-config.xml，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写 SQL 映射文件：统一管理sql语句，解决硬编码问题。 在模块的 resources 目录下创建映射配置文件 UserMapper.xml，内容如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 编码 在 com.itheima.pojo 包下创建 User类。 12345678public class User &#123; private int id; private String username; private String password; private String gender; private String addr; //添加 setter 和 getter&#125; 在 com.itheima 包下编写 MybatisDemo 测试类。 123456789101112131415public class MyBatisDemo &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;); //参数是一个字符串，该字符串必须是映射配置文件的namespace.id System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; 二、Mapper 代理开发Mapper 代理方式的目的：解决原生方式中的硬编码，简化后期执行SQL。 使用 Mapper 代理要求 定义与 SQL 映射文件同名的 Mapper 接口，并且将 Mapper 接口和 SQL 映射文件放置在同一目录下。 设置 SQL 映射文件的 namespace 属性为 Mapper 接口全限定名。 在 Mapper 接口中定义方法，方法名就是 SQL 映射文件中 sql 语句的 id，并保持参数类型和返回值类型一致。 Mapper 代理代码实现在 com.itheima.mapper 包下创建 UserMapper接口，代码如下： 1234public interface UserMapper &#123; List&lt;User&gt; selectAll(); User selectById(int id);&#125; 在 resources 下创建 com/itheima/mapper 目录，并在该目录下创建 UserMapper.xml 映射配置文件： 12345678&lt;!-- namespace:名称空间。必须是对应接口的全限定名--&gt;&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt; 在 com.itheima 包下创建 MybatisDemo2 测试类，代码如下： 123456789101112131415161718192021222324/** * Mybatis 代理开发 */public class MyBatisDemo2 &#123; public static void main(String[] args) throws IOException &#123; //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2. 获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3. 执行sql //3.1 获取UserMapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectAll(); System.out.println(users); //4. 释放资源 sqlSession.close(); &#125;&#125; 如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。 也就是将核心配置文件的加载映射配置文件的配置修改为： 123456&lt;mappers&gt; &lt;!--加载sql映射文件--&gt; &lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt; &lt;!--Mapper代理方式--&gt; &lt;package name=&quot;com.itheima.mapper&quot;/&gt;&lt;/mappers&gt; 三、MyBatis 核心配置文件多环境配置在核心配置文件的 environments 标签中其实是可以配置多个 environment ，使用 id 给每段环境起名，在 environments 中使用 default=&#39;环境id&#39; 来指定使用哪儿段配置。一般就配置一个 environment 即可。 1234567891011121314151617181920212223&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;= 类型别名在映射配置文件中的 resultType 属性需要配置数据封装的类型（类的全限定名）。 Mybatis 提供了 类型别名(typeAliases) 可以简化这部分的书写。 首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。 1234&lt;typeAliases&gt; &lt;!--name属性的值是实体类所在包--&gt; &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt; 通过上述的配置，我们就可以简化映射配置文件中 resultType 属性值的编写。 12345&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; select * from tb_user; &lt;/select&gt;&lt;/mapper&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://blog.zhuangzhihao.top/tags/MyBatis/"}]},{"title":"Maven 项目管理知识总结","slug":"Maven项目管理","date":"2022-03-13T16:00:00.000Z","updated":"2022-05-23T09:47:21.043Z","comments":true,"path":"Maven项目管理/","link":"","permalink":"http://blog.zhuangzhihao.top/Maven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","excerpt":"Maven 是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理，也可被用于构建和管理其他语言编写的各种项目，例如 C#，Ruby，Scala。","text":"Maven 是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理，也可被用于构建和管理其他语言编写的各种项目，例如 C#，Ruby，Scala。 一、Maven 概述Maven 是专门用于管理和构建 Java 项目的工具，它提供了一套标准化的项目结构，提供了一套标准化的构建流程（编译，测试，打包，发布……），提供了一套依赖管理机制。 标准化的项目结构：每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。在 Eclipse 中创建的目录，无法在 IDEA 中进行使用，这就造成了很大的不方便，而 Maven 提供了一套标准化的项目结构，所有的 IDE 使用 Maven 构建的项目完全一样，所以 IDE 创建的 Maven 项目可以通用。 标准化的构建流程：开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而 Maven 提供了一套简单的命令来完成项目构建。 依赖管理：管理你项目所依赖的第三方资源（jar包、插件），而 Maven 使用标准的坐标配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。 Maven 模型： 项目对象模型（Project Object Model）：将我们自己抽象成一个对象模型，有自己专属的坐标。 123&lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;artifactId&gt;maven&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 依赖管理模型（Dependency）：使用坐标来描述当前项目依赖哪儿些第三方jar包。 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt;&lt;/dependency&gt; Maven 仓库 本地仓库：自己计算机上的一个目录。 中央仓库：由 Maven 团队维护的全球唯一的仓库： https://repo1.maven.org/maven2/。 远程仓库(私服)：一般由公司团队搭建的私有仓库。 当项目中使用坐标引入对应依赖 jar 包后，首先会查找本地仓库中是否有对应的 jar 包，如果有，则在项目直接引用；如果没有，则去中央仓库中下载对应的jar包到本地仓库。 如果还可以搭建远程仓库，将来jar包的查找顺序则变为：本地仓库 —&gt; 远程仓库—&gt; 中央仓库。 Maven 安装配置 IDEA 自带 Maven 且 Mac 无需配置环境变量。 安装 Maven Helper 插件。 二、Maven 基本使用Maven 常用命令mvn compile ：编译，在项目下会生成一个 target 目录。 mvn clean：清理，删除项目下的 target 目录。 mvn test：测试，执行所有的测试代码。 mvn package：打包，将当前项目打成的 jar 包。 mvn install：安装，将当前项目打成jar包，并安装到本地仓库。 Maven 生命周期Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件。 Maven 对项目构建的生命周期划分为3套： clean ：清理工作。 default ：核心工作，例如编译，测试，打包，安装等。 site ： 产生报告，发布站点等。这套声明周期一般不会使用。 同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。当我们执行 install（安装）命令时，它会先执行 compile命令，再执行 test 命令，再执行 package 命令，最后执行 install 命令；当我们执行 package （打包）命令时，它会先执行 compile 命令，再执行 test 命令，最后执行 package 命令。 Maven 坐标详解Maven 中的坐标是资源的唯一标识，资源可以是插件、依赖、当前项目。 使用坐标来定义项目或引入项目中需要的依赖。 Maven 坐标主要组成： groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）。 artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）。 version：定义当前项目版本号。 我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。 三、Maven 依赖管理使用坐标引入 jar 包在项目的 pom.xml 中编写&lt;dependencies&gt; 标签。 在 &lt;dependencies&gt;标签中 使用 &lt;dependency&gt; 引入坐标。 定义坐标的 groupId，artifactId，version。 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖范围通过设置坐标的依赖范围（scope），可以设置对应 jar 包的作用范围：编译环境、测试环境、运行环境。 通过 scope 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。 123456&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; scope 的取值： 依赖范围 编译classpath 测试classpath 运行classpath 例子 compile Y Y Y logback test - Y - Junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 system Y Y - 存储在本地的jar包 compile：作用于编译环境、测试环境、运行环境。 test：作用于测试环境。典型的就是 Junit 坐标，以后使用 Junit 时，都会将 scope 指定为该值。 provided：作用于编译环境、测试环境。我们后面会学习 servlet-api ，在使用它时，必须将 scope 设置为该值，不然运行时就会报错。 runtime： 作用于测试环境、运行环境。jdbc驱动一般将 scope 设置为该值，当然不设置也没有任何问题 。 如果引入坐标不指定 scope 标签时，默认就是 compile 值，大部分 jar 包都是使用默认值。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://blog.zhuangzhihao.top/tags/Maven/"}]},{"title":"数据操作和数据预处理","slug":"数据操作和预处理","date":"2022-03-12T16:00:00.000Z","updated":"2022-05-05T12:26:18.138Z","comments":true,"path":"数据操作和预处理/","link":"","permalink":"http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86/","excerpt":"要学习深度学习，首先需要先掌握一些基本技能。 所有机器学习方法都涉及从数据中提取信息。 因此，动手学深度学习 v2 课程在第二章的一开始先教授了一些关于数据的实用技能，包括存储、操作和预处理数据，作为预备知识的内容。以下为学习 Dive to Deep Learning（d2l） 课程第二章数据操作 + 数据预处理所记笔记，可供参考。","text":"要学习深度学习，首先需要先掌握一些基本技能。 所有机器学习方法都涉及从数据中提取信息。 因此，动手学深度学习 v2 课程在第二章的一开始先教授了一些关于数据的实用技能，包括存储、操作和预处理数据，作为预备知识的内容。以下为学习 Dive to Deep Learning（d2l） 课程第二章数据操作 + 数据预处理所记笔记，可供参考。 数据操作 为了能够完成各种数据操作，我们需要某种方法来存储和操作数据 通常，我们需要做两件重要的事：获取数据和将数据读入计算机后对其进行处理 如果没有某种方法来存储数据，那么获取数据是没有意义的 n 维数组 深度学习存储和操作数据的主要接口是张量（n维数组）。它提供了各种功能，包括基本数学运算、广播、索引、切片、内存节省和转换其他Python对象 n 维数组，也称为张量（tensor） 深度学习框架的张量类（在MXNet中为ndarray， 在PyTorch和TensorFlow中为Tensor）与Numpy的ndarray类似 但深度学习框架又比Numpy的ndarray多一些重要功能： 首先，GPU 很好地支持加速计算，而 NumPy 仅支持CPU计算； 其次，张量类支持自动微分。 这些功能使得张量类更适合深度学习 张量表示由一个数值组成的数组，这个数组可能有多个维度。 具有一个轴的张量对应数学上的向量（vector）； 具有两个轴的张量对应数学上的矩阵（matrix） 可以使用arange创建一个行向量x。 这个行向量包含从0开始的前12个整数，它们被默认创建为浮点数。 张量中的每个值都称为张量的元素（element） 123import torchx = torch.arange(12)x # tensor([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) 可以通过张量的shape属性来访问张量（沿每个轴的长度）的形状 1x.shape # torch.Size([12]) 如果只想知道张量中元素的总数，即形状的所有元素乘积，可以检查它的大小（size） 1x.numel() # 12 要想改变一个张量的形状而不改变元素数量和元素值，可以调用reshape函数 1234X = x.reshape(3, 4) # 张量x从形状为（12,）的行向量转换为形状为（3,4）的矩阵X # tensor([[ 0, 1, 2, 3], # [ 4, 5, 6, 7], # [ 8, 9, 10, 11]]) 我们可以通过-1来调用此自动计算出维度的功能。 即我们可以用x.reshape(-1,4)或x.reshape(3,-1)来取代x.reshape(3,4) 使用全0、全1、其他常量，或者从特定分布中随机采样的数字来初始化矩阵 12345678torch.zeros((2, 3, 4)) # tensor([[[0., 0., 0., 0.], # [0., 0., 0., 0.], # [0., 0., 0., 0.]], # [[0., 0., 0., 0.], # [0., 0., 0., 0.], # [0., 0., 0., 0.]]])torch.ones((2, 3, 4)) # 一个形状为(2,3,4)的张量，其中所有元素都设置为1torch.randn(3, 4) # 一个形状为（3,4）的张量。 其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样 通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值。 在这里，最外层的列表对应于轴0，内层的列表对应于轴1 1torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) 运算符 在这些数据上执行数学运算，其中最简单且最有用的操作是按元素（elementwise）运算。 它们将标准标量运算符应用于数组的每个元素。 对于将两个数组作为输入的函数，按元素运算将二元运算符应用于两个数组中的每对位置对应的元素。 我们可以基于任何从标量到标量的函数来创建按元素函数 对于任意具有相同形状的张量，常见的标准算术运算符（+、-、\\*、/和**）都可以被升级为按元素运算。 我们可以在同一形状的任意两个张量上调用按元素操作 123x = torch.tensor([1.0, 2, 4, 8])y = torch.tensor([2, 2, 2, 2])x + y, x - y, x * y, x / y, x ** y # **运算符是求幂运算 按元素方式可以应用更多的计算，包括像求幂这样的一元运算符 1torch.exp(x) 除了按元素计算外，我们还可以执行线性代数运算，包括向量点积和矩阵乘法。 也可以把多个张量连结（concatenate）在一起， 把它们端对端地叠起来形成一个更大的张量。 我们只需要提供张量列表，并给出沿哪个轴连结 1234X = torch.arange(12, dtype=torch.float32).reshape((3,4))Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])torch.cat((X, Y), dim=0) # 沿行（轴-0，形状的第一个元素）连结两个矩阵torch.cat((X, Y), dim=1) # 按列（轴-1，形状的第二个元素）连结两个矩阵 第一个输出张量的轴 -0 长度（6）是两个输入张量轴 -0 长度的总和（3+3）； 第二个输出张量的轴 -1 长度（8）是两个输入张量轴 -1 长度的总和（4+4） 通过逻辑运算符构建二元张量： 对于每个位置，如果X和Y在该位置相等，则新张量中相应项的值为1。 这意味着逻辑语句X == Y在该位置处为真，否则该位置为0 123X == Y # tensor([[False, True, False, True], # [False, False, False, False], # [False, False, False, False]]) 对张量中的所有元素进行求和，会产生一个单元素张量 1X.sum() # tensor(66.) 广播机制 即使形状不同，我们仍然可以通过调用广播机制（broadcasting mechanism）来执行按元素操作 首先，通过适当复制元素来扩展一个或两个数组， 以便在转换之后，两个张量具有相同的形状。 其次，对生成的数组执行按元素操作。在大多数情况下，我们将沿着数组中长度为1的轴进行广播 123456a = torch.arange(3).reshape((3, 1))b = torch.arange(2).reshape((1, 2))a, b # (tensor([[0], # [1], # [2]]), # tensor([[0, 1]])) 由于a和b分别是3×1和1×2矩阵，如果让它们相加，它们的形状不匹配。 我们将两个矩阵广播为一个更大的3×2矩阵，如下所示：矩阵a将复制列， 矩阵b将复制行，然后再按元素相加 123a + b # tensor([[0, 1], # [1, 2], # [2, 3]]) 索引和切片 就像在任何其他Python数组中一样，张量中的元素可以通过索引访问。 与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1； 可以指定范围以包含第一个元素和最后一个之前的元素 123X[-1], X[1:3] # (tensor([ 8., 9., 10., 11.]), # tensor([[ 4., 5., 6., 7.], # [ 8., 9., 10., 11.]])) 除读取外，我们还可以通过指定索引来将元素写入矩阵 1X[1, 2] = 9 # 将第二行第三列元素改为 9 为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值，例如，[0:2, :]访问第1行和第2行，其中 “:” 代表沿轴1（列）的所有元素 123X[0:2, :] = 12 # tensor([[12., 12., 12., 12.], # [12., 12., 12., 12.], # [ 8., 9., 10., 11.]]) 节省内存 运行一些操作可能会导致为新结果分配内存。 例如，如果我们用Y = X + Y，我们将取消引用Y指向的张量，而是指向新分配的内存处的张量 123before = id(Y)Y = Y + Xid(Y) == before # False 执行原地操作非常简单。 我们可以使用切片表示法将操作的结果分配给先前分配的数组，例如Y[:] = &lt;expression&gt; 1234Z = torch.zeros_like(Y) # 创建一个新的矩阵Z，其形状与另一个Y相同， 使用zeros_like来分配一个全 0 的块print(&#x27;id(Z):&#x27;, id(Z))Z[:] = X + Yprint(&#x27;id(Z):&#x27;, id(Z)) # id一样 如果在后续计算中没有重复使用X， 我们也可以使用X[:] = X + Y或X += Y来减少操作的内存开销 转换为其他Python对象 将深度学习框架定义的张量[转换为NumPy张量（ndarray）很容易，反之也同样容易 torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量 123A = X.numpy()B = torch.tensor(A)type(A), type(B) # (numpy.ndarray, torch.Tensor) 要(将大小为1的张量转换为Python标量，我们可以调用item函数或Python的内置函数 123a = torch.tensor([3.5])a, a.item(), float(a), int(a)# (tensor([3.5000]), 3.5, 3.5, 3) 数据预处理 为了能用深度学习来解决现实世界的问题，我们经常从预处理原始数据开始， 而不是从那些准备好的张量格式数据开始 在Python中常用的数据分析工具中，我们通常使用pandas软件包。 像庞大的Python生态系统中的许多其他扩展包一样，pandas可以与张量兼容 读取数据集 首先创建一个人工数据集，并存储在CSV（逗号分隔值文件) ../data/house_tiny.csv中。 以其他格式存储的数据也可以通过类似的方式进行处理 12345678910import osos.makedirs(os.path.join(&#x27;..&#x27;, &#x27;data&#x27;), exist_ok=True)data_file = os.path.join(&#x27;..&#x27;, &#x27;data&#x27;, &#x27;house_tiny.csv&#x27;)with open(data_file, &#x27;w&#x27;) as f: f.write(&#x27;NumRooms,Alley,Price\\n&#x27;) # 列名 f.write(&#x27;NA,Pave,127500\\n&#x27;) # 每行表示一个数据样本 f.write(&#x27;2,NA,106000\\n&#x27;) f.write(&#x27;4,NA,178100\\n&#x27;) f.write(&#x27;NA,NA,140000\\n&#x27;) 要从创建的CSV文件中加载原始数据集，我们导入pandas包并调用read_csv函数 1234import pandas as pddata = pd.read_csv(data_file)print(data) 该数据集有四行三列。其中每行描述了房间数量（“NumRooms”）、巷子类型（“Alley”）和房屋价格（“Price”） 处理缺失值 “NaN”项代表缺失值 为了处理缺失的数据，典型的方法包括插值法和删除法，其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值 插值法：通过位置索引iloc，将data分成inputs和outputs， 其中前者为data的前两列，而后者为data的最后一列 对于inputs中缺少的数值，我们用同一列的均值替换“NaN”项 123inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]inputs = inputs.fillna(inputs.mean())print(inputs) 对于inputs中的类别值或离散值，我们将“NaN”视为一个类别 12inputs = pd.get_dummies(inputs, dummy_na=True)print(inputs) 转换为张量格式 现在inputs和outputs中的所有条目都是数值类型，它们可以转换为张量格式 当数据采用张量格式后，可以通过张量函数来进一步操作 123import torchX, y = torch.tensor(inputs.values), torch.tensor(outputs.values)X, y","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.zhuangzhihao.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"http://blog.zhuangzhihao.top/tags/PyTorch/"},{"name":"pandas","slug":"pandas","permalink":"http://blog.zhuangzhihao.top/tags/pandas/"}]},{"title":"Java 数据库基础知识总结","slug":"JDBC基础","date":"2022-03-11T16:00:00.000Z","updated":"2022-05-16T06:02:28.659Z","comments":true,"path":"JDBC基础/","link":"","permalink":"http://blog.zhuangzhihao.top/JDBC%E5%9F%BA%E7%A1%80/","excerpt":"Java 数据库连接，JDBC（Java Database Connectivity），是 Java 语言编程中与数据库连接的 API，封装了各种数据库访问的 API 和基础类库，支持多种数据库连接，也是 Java Web 技术核心的第一部分，我把整个学习过程分为 MySQL 基础、MySQL 高级、JDBC 和数据连接池四个部分，便于理解。","text":"Java 数据库连接，JDBC（Java Database Connectivity），是 Java 语言编程中与数据库连接的 API，封装了各种数据库访问的 API 和基础类库，支持多种数据库连接，也是 Java Web 技术核心的第一部分，我把整个学习过程分为 MySQL 基础、MySQL 高级、JDBC 和数据连接池四个部分，便于理解。 MySQL 基础SQL简介 英文：Structured Query Language，简称 SQL 结构化查询语言，一门操作关系型数据库的编程语言 定义操作所有关系型数据库的统一标准 对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方 通用语法 SQL 语句可以单行或多行书写，以分号结尾。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 注释 单行注释: -- 注释内容 或 #注释内容 多行注释: /* 注释 */ SQL分类 DDL (Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等 DML (Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改 DQL (Data Query Language) 数据查询语言，用来查询数据库中表的记录（数据） DCL (Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户 DDL：操作数据库 查询所有的数据库 1SHOW DATABASES; 创建数据库（先判断，如果不存在则创建） 1CREATE DATABASE IF NOT EXISTS 数据库名称; 删除数据库（先判断，如果存在则删除） 1DROP DATABASE IF EXISTS 数据库名称; 使用数据库 1USE 数据库名称; 查看当前使用的数据库 1SELECT DATABASE(); DDL：操作表 查询当前数据库下所有表名称 1SHOW TABLES; 查询表结构 1DESC 表名称; 创建表 12345create table tb_user ( id int, username varchar(20), password varchar(32) -- 最后一行末尾，不能加逗号); 删除表（先判断表是否存在） 1DROP TABLE IF EXISTS 表名; 修改表名 1ALTER TABLE 表名 RENAME TO 新的表名; 添加一列 1234ALTER TABLE 表名 ADD 列名 数据类型;-- 给stu表添加一列address，该字段类型是varchar(50)alter table stu add address varchar(50); 修改数据类型 1234ALTER TABLE 表名 MODIFY 列名 新数据类型;-- 将stu表中的address字段的类型改为 char(50)alter table stu modify address char(50); 修改列名和数据类型 1234ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;-- 将stu表中的address字段名改为 addr，类型改为varchar(50)alter table stu change address addr varchar(50); 删除列 1ALTER TABLE 表名 DROP 列名; SQL 的数据类型 数值 123456tinyint : 小整数型，占一个字节int ： 大整数类型，占四个字节 eg ： age intdouble ： 浮点类型 使用格式： 字段名 double(总长度,小数点后保留的位数) eg ： score double(5,2) 日期 123date ： 日期值。只包含年月日 eg ：birthday date ： datetime ： 混合日期和时间值。包含年月日时分秒 字符串 12345678char ： 定长字符串。 优点：存储性能高 缺点：浪费空间 eg ： name char(10) 如果存储的数据字符个数不足10个，也会占10个的空间varchar ： 变长字符串。 优点：节约空间 缺点：存储性能底 eg ： name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间 DML 查询所有数据 1SELECT * FROM 表名; 给指定列添加数据 1INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…); 给全部列添加数据 1INSERT INTO 表名 VALUES(值1,值2,…); 批量添加数据 12INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…; 修改表数据 12UPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ;-- 修改语句中如果不加条件，则将所有数据都修改！ 删除数据 1DELETE FROM 表名 [WHERE 条件] ; 删除表中所有的数据 1DELETE FROM 表名; DQL 查询多个字段 12SELECT 字段列表 FROM 表名;SELECT * FROM 表名; -- 查询所有数据 去除重复记录 1SELECT DISTINCT 字段列表 FROM 表名; 起别名 1SELECT 字段列表 AS: 别名 FROM 表名; -- AS 也可以省略 条件查询 1SELECT 字段列表 FROM 表名 WHERE 条件列表; 模糊查询 使用 LIKE 关键字，可以使用通配符进行占位 _ ：代表单个任意字符 % ：代表任意个数字符 12345select * from stu where name like &#x27;马%&#x27;; -- 查询姓&#x27;马&#x27;的学员信息select * from stu where name like &#x27;_花%&#x27;; -- 查询第二个字是&#x27;花&#x27;的学员信息 select * from stu where name like &#x27;%德%&#x27;; -- 查询名字中包含 &#x27;德&#x27; 的学员信息 排序查询 1234567SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;/*排序方式有两种，分别是：ASC ： 升序排列（默认值）DESC ： 降序排列如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序*/ 聚合函数 将一列数据作为一个整体，进行纵向计算 函数名 功能 count(列名) 统计数量（一般选用不为null的列） max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 12SELECT 聚合函数名(列名) FROM 表;-- null 值不参与所有聚合函数运算 分组查询 12SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];-- 分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义 where 和 having 区别： 执行时机不一样：where 是分组之前进行限定，不满足 where 条件，则不参与分组，而 having 是分组之后对结果进行过滤。 可判断的条件不一样：where 不能对聚合函数进行判断，having 可以 分页查询 12SELECT 字段列表 FROM 表名 LIMIT 起始索引 , 查询条目数;-- 起始索引是从0开始 起始索引计算公式： 1起始索引 = (当前页码 - 1) * 每页显示的条数 MySQL 进阶约束 约束是作用于表中列上的规则，用于限制加入表的数据 约束的存在保证了数据库中数据的正确性、有效性和完整性 约束的分类 非空约束：关键字是 NOT NULL，保证列中所有的数据不能有null值。 唯一约束：关键字是 UNIQUE，保证列中所有数据各不相同 主键约束： 关键字是 PRIMARY KEY，主键是一行数据的唯一标识，要求非空且唯一 检查约束： 关键字是 CHECK，保证列中的值满足某一条件（MySQL不支持检查约束） 默认约束： 关键字是 DEFAULT，保存数据时，未指定值则采用默认值 外键约束： 关键字是 FOREIGN KEY，外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性 非空约束 用于保证列中所有数据不能有NULL值 添加约束 12345-- 创建表时添加非空约束CREATE TABLE 表名( 列名 数据类型 NOT NULL, …); 12-- 建完表后添加非空约束ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL; * 删除约束 1ALTER TABLE 表名 MODIFY 字段名 数据类型; 唯一约束 用于保证列中所有数据各不相同 * 添加约束 1234567891011-- 创建表时添加唯一约束CREATE TABLE 表名( 列名 数据类型 UNIQUE [AUTO_INCREMENT], -- AUTO_INCREMENT: 当不指定值时自动增长 …); CREATE TABLE 表名( 列名 数据类型, … [CONSTRAINT] [约束名称] UNIQUE(列名)); 12-- 建完表后添加唯一约束ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE; * 删除约束 1ALTER TABLE 表名 DROP INDEX 字段名; 主键约束 主键是一行数据的唯一标识，要求非空且唯一 一张表只能有一个主键 添加约束 12345678910-- 创建表时添加主键约束CREATE TABLE 表名( 列名 数据类型 PRIMARY KEY [AUTO_INCREMENT], …); CREATE TABLE 表名( 列名 数据类型, [CONSTRAINT] [约束名称] PRIMARY KEY(列名)); 12-- 建完表后添加主键约束ALTER TABLE 表名 ADD PRIMARY KEY(字段名); 删除约束 1ALTER TABLE 表名 DROP PRIMARY KEY; 默认约束 保存数据时，未指定值则采用默认值 添加约束 12345-- 创建表时添加默认约束CREATE TABLE 表名( 列名 数据类型 DEFAULT 默认值, …); 12-- 建完表后添加默认约束ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值; 删除约束 1ALTER TABLE 表名 ALTER 列名 DROP DEFAULT; 默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值 外键约束 外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性 添加外键约束 123456-- 创建表时添加外键约束CREATE TABLE 表名( 列名 数据类型, … [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) ); 12-- 建完表后添加外键约束ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 删除外键约束 1ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 添加数据 123456789-- 添加 2 个部门insert into dept(dep_name,addr) values(&#x27;研发部&#x27;,&#x27;广州&#x27;),(&#x27;销售部&#x27;, &#x27;深圳&#x27;);-- 添加员工,dep_id 表示员工所在的部门INSERT INTO emp (NAME, age, dep_id) VALUES (&#x27;张三&#x27;, 20, 1),(&#x27;李四&#x27;, 20, 1),(&#x27;王五&#x27;, 20, 1), 删除外键 1alter table emp drop FOREIGN key fk_emp_dept; 重新添加外键 1alter table emp add CONSTRAINT fk_emp_dept FOREIGN key(dep_id) REFERENCES dept(id); 数据库设计 数据库设计概念 数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型 建立数据库中的表结构以及表与表之间的关联关系的过程 有哪些表？表里有哪些字段？表和表之间有什么关系？ 数据库设计的步骤 需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么） 逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统） 物理设计（根据数据库自身的特点把逻辑设计转换为物理设计） 维护设计（1.对新的需求进行建表；2.表优化） 表关系 一对一（如：用户 和 用户详情）：一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能 一对多（如：部门 和 员工）：一个部门对应多个员工，一个员工对应一个部门 多对多（如：商品 和 订单）：一个商品对应多个订单，一个订单包含多个商品 表关系（一对多） 实现方式：在多的一方建立外键，指向一的一方的主键 以 员工表 和 部门表 举例：在员工表中添加一列（dep_id），指向于部门表的主键（id） 1234567891011121314151617181920-- 删除表DROP TABLE IF EXISTS tb_emp;DROP TABLE IF EXISTS tb_dept;-- 部门表CREATE TABLE tb_dept( id int primary key auto_increment, dep_name varchar(20), addr varchar(20));-- 员工表 CREATE TABLE tb_emp( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 添加外键 dep_id,关联 dept 表的id主键 CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES tb_dept(id) ); 表关系（多对多） 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 以 订单表 和 商品表 举例：订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键： 12345678910111213141516171819202122232425262728293031-- 删除表DROP TABLE IF EXISTS tb_order_goods;DROP TABLE IF EXISTS tb_order;DROP TABLE IF EXISTS tb_goods;-- 订单表CREATE TABLE tb_order(id int primary key auto_increment,payment double(10,2),payment_type TINYINT,status TINYINT);-- 商品表CREATE TABLE tb_goods(id int primary key auto_increment,title varchar(100),price double(10,2));-- 订单商品中间表CREATE TABLE tb_order_goods(id int primary key auto_increment,order_id int,goods_id int,count int);-- 建完表后，添加外键alter table tb_order_goods add CONSTRAINT fk_order_id FOREIGN key(order_id) REFERENCES tb_order(id);alter table tb_order_goods add CONSTRAINT fk_goods_id FOREIGN key(goods_id) REFERENCES tb_goods(id); 表关系（一对一） 在任意一方加入外键，关联另一方主键，并且设置外键为唯一（UNIQUE） 以 用户表 举例：在真正使用过程中发现 id、photo、nickname、age、gender 字段比较常用，此时就可以将这张表查分成两张表 12345678910111213141516171819create table tb_user_desc ( id int primary key auto_increment, city varchar(20), edu varchar(10), income int, status char(2), des varchar(100));create table tb_user ( id int primary key auto_increment, photo varchar(100), nickname varchar(50), age int, gender char(1), desc_id int unique, -- 添加外键 CONSTRAINT fk_user_desc FOREIGN KEY(desc_id) REFERENCES tb_user_desc(id) ); 多表查询 多表查询顾名思义就是从多张表中一次性的查询出我们想要的数据 1234567891011121314151617181920212223242526272829DROP TABLE IF EXISTS emp;DROP TABLE IF EXISTS dept;# 创建部门表 CREATE TABLE dept( did INT PRIMARY KEY AUTO_INCREMENT, dname VARCHAR(20) ); # 创建员工表 CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dep_id INT, FOREIGN KEY (dep_id) REFERENCES dept(did) -- 外键，关联部门表(部门表的主键) ); -- 添加部门数据 INSERT INTO dept (dNAME) VALUES (&#x27;研发部&#x27;),(&#x27;市场部&#x27;),(&#x27;财务部&#x27;),(&#x27;销售部&#x27;); -- 添加员工数据 INSERT INTO emp(NAME,gender,salary,join_date,dep_id) VALUES (&#x27;孙悟空&#x27;,&#x27;男&#x27;,7200,&#x27;2013-02-24&#x27;,1), (&#x27;猪八戒&#x27;,&#x27;男&#x27;,3600,&#x27;2010-12-02&#x27;,2), (&#x27;唐僧&#x27;,&#x27;男&#x27;,9000,&#x27;2008-08-08&#x27;,2), (&#x27;白骨精&#x27;,&#x27;女&#x27;,5000,&#x27;2015-10-07&#x27;,3), (&#x27;蜘蛛精&#x27;,&#x27;女&#x27;,4500,&#x27;2011-03-14&#x27;,1), (&#x27;小白龙&#x27;,&#x27;男&#x27;,2500,&#x27;2011-02-14&#x27;,null); 执行下面的多表查询语句 1select * from emp , dept; -- 从emp和dept表中查询所有的字段数据 通过限制员工表中的 dep_id 字段的值和部门表 did 字段的值相等来消除无效的数据， 1select * from emp , dept where emp.dep_id = dept.did; 连接查询 内连接查询 ：相当于查询AB交集数据 外连接查询 左外连接查询 ：相当于查询A表所有数据和交集部门数据 右外连接查询 ： 相当于查询B表所有数据和交集部分数据 子查询 内连接查询 12345-- 隐式内连接SELECT 字段列表 FROM 表1,表2… WHERE 条件;-- 显示内连接SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件; 隐式内连接 1SELECT * FROM emp, dept WHERE emp.dep_id = dept.did; 查询 emp 的 name， gender，dept 表的 dname 123456789SELECT t1. NAME, t1.gender, t2.dnameFROM emp t1, dept t2WHERE t1.dep_id = t2.did; 显式内连接 123select * from emp inner join dept on emp.dep_id = dept.did;-- 上面语句中的inner可以省略，可以书写为如下语句select * from emp join dept on emp.dep_id = dept.did; 外连接查询 12345-- 左外连接：相当于查询A表所有数据和交集部分数据SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;-- 右外连接：相当于查询B表所有数据和交集部分数据SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件; 查询emp表所有数据和对应的部门信息（左外连接） 12select * from emp left join dept on emp.dep_id = dept.did;-- 结果显示查询到了左表（emp）中所有的数据及两张表能关联的数据 查询dept表所有数据和对应的员工信息（右外连接） 12select * from emp right join dept on emp.dep_id = dept.did;-- 结果显示查询到了右表（dept）中所有的数据及两张表能关联的数据 。要查询出部门表中所有的数据，也可以通过左外连接实现，只需要将两个表的位置进行互换： 1select * from dept left join emp on emp.dep_id = dept.did; 子查询 查询中嵌套查询，称嵌套查询为子查询 子查询根据查询结果不同，作用不同 子查询语句结果是单行单列，子查询语句作为条件值，使用 = != &gt; &lt; 等进行条件判断 子查询语句结果是多行单列，子查询语句作为条件值，使用 in 等关键字进行条件判断 子查询语句结果是多行多列，子查询语句作为虚拟表 查询 ‘财务部’ 和 ‘市场部’ 所有的员工信息 1234-- 查询 &#x27;财务部&#x27; 或者 &#x27;市场部&#x27; 所有的员工的部门didselect did from dept where dname = &#x27;财务部&#x27; or dname = &#x27;市场部&#x27;;select * from emp where dep_id in (select did from dept where dname = &#x27;财务部&#x27; or dname = &#x27;市场部&#x27;); 查询入职日期是 ‘2011-11-11’ 之后的员工信息和部门信息 1234-- 查询入职日期是 &#x27;2011-11-11&#x27; 之后的员工信息select * from emp where join_date &gt; &#x27;2011-11-11&#x27; ;-- 将上面语句的结果作为虚拟表和dept表进行内连接查询select * from (select * from emp where join_date &gt; &#x27;2011-11-11&#x27; ) t1, dept where t1.dep_id = dept.did; 事务 概述 数据库的事务（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败 事务是一个不可分割的工作逻辑单元 语法 开启事务 123START TRANSACTION;或者 BEGIN; 提交事务 1commit; 回滚事务 1rollback; 代码验证 环境准备 1234567891011DROP TABLE IF EXISTS account;-- 创建账户表CREATE TABLE account( id int PRIMARY KEY auto_increment, name varchar(10), money double(10,2));-- 添加数据INSERT INTO account(name,money) values(&#x27;张三&#x27;,1000),(&#x27;李四&#x27;,1000); 不加事务演示问题 123456789-- 转账操作-- 1. 查询李四账户金额是否大于500-- 2. 李四账户 -500UPDATE account set money = money - 500 where name = &#x27;李四&#x27;;出现异常了... -- 此处不是注释，在整体执行时会出问题，后面的sql则不执行-- 3. 张三账户 +500UPDATE account set money = money + 500 where name = &#x27;张三&#x27;; 添加事务 sql 1234567891011121314151617-- 开启事务BEGIN;-- 转账操作-- 1. 查询李四账户金额是否大于500-- 2. 李四账户 -500UPDATE account set money = money - 500 where name = &#x27;李四&#x27;;出现异常了... -- 此处不是注释，在整体执行时会出问题，后面的sql则不执行-- 3. 张三账户 +500UPDATE account set money = money + 500 where name = &#x27;张三&#x27;;-- 提交事务COMMIT;-- 回滚事务ROLLBACK; 上面sql中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句，以后我们肯定不可能这样操作，而是在java中进行操作，在java中可以抓取异常，没出现异常提交事务，出现异常回滚事务 事务的四大特征 原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败 一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态 隔离性（Isolation） :多个事务之间，操作的可见性 持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 MySQL 中事务是自动提交的，也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务 可以通过下面语句查询默认提交方式： 1SELECT @@autocommit; 查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式 1set @@autocommit = 0; JDBCJDBC 简介 JDBC 概念 JDBC 就是使用Java语言操作关系型数据库的一套API JDBC 全称：( Java DataBase Connectivity ) Java 数据库连接 sun公司指定了一套标准接口（JDBC），JDBC中定义了所有操作关系型数据库的规则，众所周知接口是无法直接使用的，我们需要使用接口的实现类，而这套实现类（称之为：驱动）就由各自的数据库厂商给出 JDBC本质 官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口 各个数据库厂商去实现这套接口，提供数据库驱动jar包 我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类 JDBC好处 各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发 可随时替换底层数据库，访问数据库的Java代码基本不变 以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包 JDBC快速入门 通过Java操作数据库的流程 第一步：编写Java代码 - 第二步：Java代码将SQL发送到MySQL服务端 - 第三步：MySQL服务端接收到SQL语句并执行该SQL语句 - 第四步：将SQL语句执行的结果返回给Java代码 编写代码步骤 创建工程，导入驱动 jar 包（mysql-connector-java-5.1.48.jar） 注册驱动 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 获取连接 1Connection conn = DriverManager.getConnection(url, username, password); Java代码需要发送SQL给MySQL服务端，就需要先建立连接 定义SQL语句 1String sql = &quot;select * from table;&quot; ; 获取执行SQL对象 执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象 1Statement stmt = conn.createStatement(); 执行SQL 1stmt.executeUpdate(sql); 处理返回结果 释放资源 IDEA 中编写代码 1234567891011121314151617181920212223242526/** * JDBC快速入门 */public class JDBCDemo &#123; public static void main(String[] args) throws Exception &#123; //1. 注册驱动 //Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 获取连接 String url = &quot;jdbc:mysql://127.0.0.1:3306/db1?useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql = &quot;update account set money = 2000 where id = 1&quot;; //4. 获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //5. 执行sql int count = stmt.executeUpdate(sql);//受影响的行数 //6. 处理结果 System.out.println(count); //7. 释放资源 stmt.close(); conn.close(); &#125;&#125; JDBC API 详解 DriverManager（驱动管理类） 注册驱动：registerDriver 方法是用于注册驱动的，但是我们之前做的入门案例并不是这样写的。而是如下实现 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 在该类中的静态代码块中已经执行了 DriverManager 对象的 registerDriver() 方法进行驱动的注册了，那么我们只需要加载 Driver 类，该静态代码块就会执行，而 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 就可以加载 Driver 类 * 获取数据库连接 1Connection conn = DriverManager.getConnection(url, username, password); * url ： `jdbc:mysql://ip地址(域名):端口号/数据库名称?参数键值对1&amp;参数键值对2…` * 配置 `useSSL=false` 参数，禁用安全连接方式，解决警告提示 * user ：用户名 * poassword ：密码 Connection（数据库连接对象） 获取执行 SQL 的对象 普通执行SQL对象 1234Statement createStatement() -- 通过该方法获取执行对象Statement stmt = conn.createStatement();int count = stmt.executeUpdate(sql); 预编译SQL的执行SQL对象：防止SQL注入 1PreparedStatement prepareStatement(sql) 通过这种方式获取的 PreparedStatement SQL语句执行对象可以防止SQL注入 执行存储过程的对象 1CallableStatement prepareCall(sql) 通过这种方式获取的 CallableStatement 执行对象是用来执行存储过程的，但存储过程在MySQL中不常用 - 事务管理 - MySQL事务管理的操作（MySQL默认是自动提交事务） * 开启事务 ： `BEGIN;` 或者 `START TRANSACTION;` * 提交事务 ： `COMMIT;` * 回滚事务 ： `ROLLBACK;` - JDBC事务管理的方法 - Connection几个接口中定义了3个对应的方法： * 开启事务 1setAutoCommit(boolean autoCommit) * 参与 `autoCommit` 表示是否自动提交事务，true表示自动提交事务，false表示手动提交事务，而开启事务需要将该参数设为为 false * 提交事务 1commit() * 回滚事务 1rollback; Statement（声明执行对象） Statement对象的作用就是用来执行SQL语句，而针对不同类型的SQL语句使用的方法也不一样 * 执行DDL、DML语句 1int excuteUpdate(sql) * 返回值：DML语句影响的行数，DDL语句执行成功后可能返回0 * 执行DQL语句 1ResultSet excuteQuery(sql) - 返回值： `ResultSet` 结果集对象 ResultSet（结果集对象） 封装了SQL查询语句的结果，执行DQL语句后就会返回该对象 ResultSet executeQuery(sql)：执行DQL 语句，返回 ResultSet 对象 ResultSet 对象提供了获取查询结果数据的方法 boolean next()：将光标从当前位置向前移动一行，判断当前行是否为有效行 方法返回值：true （ 有效行，当前行有数据），false（无效行，当前行没有数据） xxx getXxx(参数)：获取数据 xxx : 数据类型；如： nt getInt(参数) ；String getString(参数) int 类型的参数：列的编号，从1开始 String 类型的参数： 列的名称 一开始光标指定于第一行前，当我们调用了 next() 方法后，光标就下移到第一行数据，并且方法返回 true，此时就可以通过 getInt(&quot;id&quot;) 获取当前行id字段的值，也可以通过 getString(&quot;name&quot;) 获取当前行name字段的值。如果想获取下一行的数据，继续调用 next() 方法，以此类推。 PreparedStatement 预编译SQL语句并执行：预防SQL注入问题 SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。 代码模拟SQL注入问题 12345678910111213141516171819202122232425262728@Testpublic void testLogin() throws Exception &#123; //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); // 接收用户输入 用户名和密码 String name = &quot;sjdljfld&quot;; String pwd = &quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;; String sql = &quot;select * from tb_user where username = &#x27;&quot;+name+&quot;&#x27; and password = &#x27;&quot;+pwd+&quot;&#x27;&quot;; // 获取stmt对象 Statement stmt = conn.createStatement(); // 执行sql ResultSet rs = stmt.executeQuery(sql); // 判断登录是否成功 if(rs.next())&#123; System.out.println(&quot;登录成功~&quot;); &#125;else&#123; System.out.println(&quot;登录失败~&quot;); &#125; //7. 释放资源 rs.close(); stmt.close(); conn.close();&#125; 上面代码是将用户名和密码拼接到sql语句中，拼接后的sql语句如下 1select * from tb_user where username = &#x27;sjdljfld&#x27; and password = &#x27;&#x27;or &#x27;1&#x27; = &#x27;1&#x27; 获取 PreparedStatement 对象 1234// SQL语句中的参数值，使用？占位符替代String sql = &quot;select * from user where username = ? and password = ?&quot;;// 通过Connection对象获取，并传入对应的sql语句PreparedStatement pstmt = conn.prepareStatement(sql); 设置参数值：PreparedStatement 的sql语句中参数使用 ? 进行占位，在之前之前肯定要设置这些 ? 的值 PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值 Xxx：数据类型 ； 如 setInt (参数1，参数2) 参数： 参数1： ？的位置编号，从1 开始 参数2： ？的值 执行SQL语句 executeUpdate(); 执行DDL语句和DML语句 executeQuery(); 执行DQL语句 调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了 使用PreparedStatement改进 1234567891011121314151617181920212223242526272829303132 @Testpublic void testPreparedStatement() throws Exception &#123; //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); // 接收用户输入 用户名和密码 String name = &quot;zhangsan&quot;; String pwd = &quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;; // 定义sql String sql = &quot;select * from tb_user where username = ? and password = ?&quot;; // 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); // 设置？的值 pstmt.setString(1,name); pstmt.setString(2,pwd); // 执行sql ResultSet rs = pstmt.executeQuery(); // 判断登录是否成功 if(rs.next())&#123; System.out.println(&quot;登录成功~&quot;); &#125;else&#123; System.out.println(&quot;登录失败~&quot;); &#125; //7. 释放资源 rs.close(); pstmt.close(); conn.close();&#125; PreparedStatement 实际上是将特殊字符进行了转义，转义的SQL如下： 1select * from tb_user where username = &#x27;sjdljfld&#x27; and password = &#x27;\\&#x27;or \\&#x27;1\\&#x27; = \\&#x27;1&#x27; PreparedStatement原理 预编译SQL，性能更高 防止SQL注入：将敏感字符进行转义 将sql语句发送到MySQL服务器端 * MySQL服务端会对sql语句进行如下操作 * 检查SQL语句的语法是否正确。 * 编译SQL语句。将SQL语句编译成可执行的函数。 * 检查SQL和编译SQL花费的时间比执行SQL的时间还要长。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行。这样就提高了性能。 * 执行SQL语句 开启预编译功能：useServerPrepStmts=true 1String url = &quot;jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true&quot;; 配置MySQL执行日志（重启mysql服务后生效） 在mysql配置文件（my.ini）中添加如下配置 123456log-output=FILEgeneral-log=1general_log_file=&quot;D:\\mysql.log&quot;slow-query-log=1slow_query_log_file=&quot;D:\\mysql_slow.log&quot;long_query_time=2 PreparedStatement 小结 在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时） 执行时就不用再进行这些步骤了，速度更快 如果sql模板一样，则只需要进行一次检查、编译 数据库连接池数据库连接池简介 数据库连接池是个容器，负责分配、管理数据库连接(Connection) 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个； 释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏 好处 资源重用 提升系统响应速度 避免数据库连接遗漏 之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的 而数据库使用了数据库连接池后，就能达到Connection对象的复用 连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度 数据库连接池实现 标准接口：DataSource 官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能： 1Connection getConnection() 那么以后就不需要通过 DriverManager 对象获取 Connection 对象，而是通过连接池（DataSource）获取 Connection 对象。 常见的数据库连接池 DBCP C3P0 Druid 我们现在使用更多的是Druid，它的性能比其他两个会好一些。 Druid（德鲁伊） Druid连接池是阿里巴巴开源的数据库连接池项目 功能强大，性能优秀，是Java语言最好的数据库连接池之一 Driud 使用 导入jar包 druid-1.1.12.jar 定义配置文件：src 目录下新建 druid.properties 12345678910driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=trueusername=rootpassword=1234# 初始化连接数量initialSize=5# 最大连接数maxActive=10# 最大等待时间maxWait=3000 加载配置文件 获取数据库连接池对象 获取连接 1234567891011121314151617/** * Druid数据库连接池演示 */public class DruidDemo &#123; public static void main(String[] args) throws Exception &#123; // 加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(&quot;jdbc-demo/src/druid.properties&quot;)); // 获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); // 获取数据库连接 Connection Connection connection = dataSource.getConnection(); System.out.println(connection); //获取到了连接后就可以继续做其他操作了 //System.out.println(System.getProperty(&quot;user.dir&quot;)); &#125;&#125; druid 配置详解 属性 说明 建议值 url 数据库的jdbc连接地址。一般为连接oracle/mysql。示例如下： mysql : jdbc:mysql://ip:port/dbname?option1&amp;option2&amp;… oracle : jdbc:oracle:thin:@ip:port:oracle_sid username 登录数据库的用户名 password 登录数据库的用户密码 initialSize 启动程序时，在连接池中初始化多少个连接 10-50已足够 maxActive 连接池中最多支持多少个活动会话 maxWait 程序向连接池中请求连接时,超过maxWait的值后，认为本次请求失败，即连接池 100 没有可用连接，单位毫秒，设置-1时表示无限等待 minEvictableIdleTimeMillis 池中某个连接的空闲时长达到 N 毫秒后, 连接池在下次检查空闲连接时，将 见说明部分 回收该连接,要小于防火墙超时设置 net.netfilter.nf_conntrack_tcp_timeout_established的设置 timeBetweenEvictionRunsMillis 检查空闲连接的频率，单位毫秒, 非正整数时表示不进行检查 keepAlive 程序没有close连接且空闲时长超过 minEvictableIdleTimeMillis,则会执 true 行validationQuery指定的SQL,以保证该程序连接不会池kill掉,其范围不超 过minIdle指定的连接个数。 minIdle 回收空闲连接时，将保证至少有minIdle个连接. 与initialSize相同 removeAbandoned 要求程序从池中get到连接后, N 秒后必须close,否则druid 会强制回收该 false,当发现程序有未 连接,不管该连接中是活动还是空闲, 以防止进程不会进行close而霸占连接。 正常close连接时设置为true removeAbandonedTimeout 设置druid 强制回收连接的时限，当程序从池中get到连接开始算起，超过此 应大于业务运行最长时间 值后，druid将强制回收该连接，单位秒。 logAbandoned 当druid强制回收连接后，是否将stack trace 记录到日志中 true testWhileIdle 当程序请求连接，池在分配连接时，是否先检查该连接是否有效。(高效) true validationQuery 检查池中的连接是否仍可用的 SQL 语句,drui会连接到数据库执行该SQL, 如果 正常返回，则表示连接可用，否则表示连接不可用 testOnBorrow 程序 申请 连接时,进行连接有效性检查（低效，影响性能） false testOnReturn 程序 返还 连接时,进行连接有效性检查（低效，影响性能） false poolPreparedStatements 缓存通过以下两个方法发起的SQL: true public PreparedStatement prepareStatement(String sql) public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) maxPoolPrepareStatementPerConnectionSize 每个连接最多缓存多少个SQL 20 filters 这里配置的是插件,常用的插件有: stat,wall,slf4j 监控统计: filter:stat 日志监控: filter:log4j 或者 slf4j 防御SQL注入: filter:wall connectProperties 连接属性。比如设置一些连接池统计方面的配置。 druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 比如设置一些数据库连接属性:","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.zhuangzhihao.top/tags/MySQL/"},{"name":"JDBC","slug":"JDBC","permalink":"http://blog.zhuangzhihao.top/tags/JDBC/"}]},{"title":"机器学习和深度学习介绍及入门","slug":"动手学深度学习","date":"2022-03-07T16:00:00.000Z","updated":"2022-05-05T12:33:23.682Z","comments":true,"path":"动手学深度学习/","link":"","permalink":"http://blog.zhuangzhihao.top/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"机器学习（machine learning，ML）是一类强大的可以从经验中学习的技术。 通常采用观测数据或与环境交互的形式，机器学习算法会积累更多的经验，其性能也会逐步提高就在过去的五年里，深度学习给世界带来了惊喜，推动了计算机视觉、自然语言处理、自动语音识别、强化学习和统计建模等领域的快速发展。我选择动手学深度学习 v2 课程来开启机器学习之旅，并特别关注深度学习（deep learning，DL）的基础知识深度学习。","text":"机器学习（machine learning，ML）是一类强大的可以从经验中学习的技术。 通常采用观测数据或与环境交互的形式，机器学习算法会积累更多的经验，其性能也会逐步提高就在过去的五年里，深度学习给世界带来了惊喜，推动了计算机视觉、自然语言处理、自动语音识别、强化学习和统计建模等领域的快速发展。我选择动手学深度学习 v2 课程来开启机器学习之旅，并特别关注深度学习（deep learning，DL）的基础知识深度学习。 日常生活中的机器学习 Hey, Siri：收集一个包含音频样本的巨大的数据集（dataset），并对包含和不包含唤醒词的样本进行标记 通过机器学习算法，我们不需要设计一个“明确地”识别唤醒词的系统。 相反，我们定义一个灵活的程序算法，其输出由许多参数（parameter）决定。 然后我们使用数据集来确定当下的“最佳参数集”，这些参数通过某种性能度量来获取完成任务的最佳性能 把参数看作是旋钮，我们可以转动旋钮来调整程序的行为。 任一调整参数后的程序，我们称为模型（model） 通过操作参数而生成的所有不同程序（输入-输出映射）的集合称为“模型族” 使用数据集来选择参数的元程序被称为学习算法（learning algorithm） 在我们开始用机器学习算法解决问题之前，我们必须精确地定义问题，确定输入（input）和输出（output）的性质，并选择合适的模型族 在机器学习中，学习（learning）是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据训练（train）我们的模型 训练过程通常包含如下步骤： 从一个随机初始化参数的模型开始，这个模型基本毫不“智能” 获取一些数据样本（例如，音频片段以及对应的{是,否}{是,否}标签） 调整参数，使模型在这些样本中表现得更好 重复第2步和第3步，直到模型在任务中的表现令你满意 机器学习的关键组件数据 每个数据集由一个个样本（example, sample）组成，大多时候，它们遵循独立同分布（independently and identically distributed, i.i.d.） 样本有时也叫做数据点（data point）或者数据实例（data instance），通常每个样本由一组称为特征（features，或协变量（covariates））的属性组成，机器学习模型会根据这些属性进行预测 在监督学习问题中，要预测的是一个特殊的属性，它被称为标签（label，或目标（target）） 当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的维数（dimensionality）。 固定长度的特征向量是一个方便的属性，它有助于我们量化学习大量样本 然而，并不是所有的数据都可以用“固定长度”的向量表示，例如文本数据。与传统机器学习方法相比，深度学习的一个主要优势是可以处理不同长度的数据 一般来说，我们拥有的数据越多，通常可以训练出更强大的模型，从而减少对预先设想假设的依赖。 数据集的由小变大为现代深度学习的成功奠定基础。 在没有大数据集的情况下，许多令人兴奋的深度学习模型黯然失色。 就算一些深度学习模型在小数据集上能够工作，但其效能并不比传统方法高 仅仅拥有海量的数据是不够的，我们还需要正确的数据。 如果数据中充满了错误，或者如果数据的特征不能预测任务目标，那么模型很可能无效 此外，糟糕的预测性能甚至会加倍放大事态的严重性。 在一些敏感应用中，如预测性监管、简历筛选和用于贷款的风险模型，我们必须特别警惕垃圾数据带来的后果。一种常见的问题来自不均衡的数据集，比如在一个有关医疗的训练数据集中，某些人群没有样本表示 当数据不具有充分代表性，甚至包含了一些社会偏见时，模型就很有可能有偏见 模型 大多数机器学习会涉及到数据的转换。 比如，建立一个“摄取照片并预测笑脸”的系统 深度学习与经典方法的区别主要在于：前者关注的功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换，因此被称为深度学习（deep learning） 目标函数 在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，我们称之为目标函数（objective function） 我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为损失函数（loss function，或cost function）。 但这只是一个惯例，你也可以取一个新的函数，优化到它的最高点。 这两个函数本质上是相同的，只是翻转一下符号 当任务在试图预测数值时，最常见的损失函数是平方误差（squared error），即预测值与实际值之差的平方 当试图解决分类问题时，最常见的目标函数是最小化错误率，即预测与实际情况不符的样本比例 有些目标函数（如平方误差）很容易被优化，有些目标（如错误率）由于不可微性或其他复杂性难以直接优化。 在这些情况下，通常会优化替代目标 通常，损失函数是根据模型参数定义的，并取决于数据集。 在一个数据集上，我们通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称为训练数据集（training dataset，或称为训练集（training set）） 然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的效能，这里的“新数据集”通常称为测试数据集（test dataset，或称为测试集（test set）） 综上所述，我们通常将可用数据集分成两部分：训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。 然后我们观察模型在这两部分数据集的效能 换言之，测试性能可能会显著偏离训练性能。 当一个模型在训练集上表现良好，但不能推广到测试集时，我们说这个模型是“过拟合”（overfitting）的 优化算法 一旦我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，我们接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数 深度学习中，大多流行的优化算法通常基于一种基本方法——梯度下降（gradient descent）。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果你仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数 各种机器学习问题监督学习 监督学习（supervised learning）擅长在“给定输入特征”的情况下预测标签。 每个“特征-标签”对都称为一个样本（example）。 有时，即使标签是未知的，样本也可以指代输入特征。 我们的目标是生成一个模型，能够将任何输入特征映射到标签，即预测 监督学习之所以发挥作用，是因为在训练参数时，我们为模型提供了一个数据集，其中每个样本都有真实的标签。 用概率论术语来说，我们希望预测“估计给定输入特征的标签”的条件概率 虽然监督学习只是几大类机器学习问题之一，但是在工业中，大部分机器学习的成功应用都是监督学习。 这是因为在一定程度上，许多重要的任务可以清晰地描述为：在给定一组特定的可用数据的情况下，估计未知事物的概率 监督学习的学习过程： 首先，从已知大量数据样本中随机选取一个子集，为每个样本获取基本的真实标签 有时，这些样本已有标签（例如，患者是否在下一年内康复？）； 有时，我们可能需要人工标记数据（例如，将图像分类）。这些输入和相应的标签一起构成了训练数据集 随后，我们选择有监督的学习算法，它将训练数据集作为输入，并输出一个“完成学习模型” 最后，我们将之前没见过的样本特征放到这个“完成学习模型”中，使用模型的输出作为相应标签的预测 即使使用简单的描述“给定输入特征的预测标签”，监督学习也可以采取多种形式的模型，并且需要大量不同的建模决策，这取决于输入和输出的类型、大小和数量 回归 回归（regression）是最简单的监督学习任务之一 回归问题本质上是输出决定的。 假设你在市场上寻找新房子，你可能需要估计一栋房子的公平市场价值。 销售价格，即标签，是一个数值。 当标签取任意数值时，我们称之为回归问题。 我们的目标是生成一个模型，它的预测非常接近实际标签值 分类 虽然回归模型可以很好地解决“有多少？”的问题，但是解决不了“哪一个？”的问题，这种问题叫做分类（classification）问题 在分类问题中，我们希望模型能够预测样本属于哪个类别（category，正式称为类（class）） 最简单的分类问题是只有两类，我们称之为“二元分类” 在回归中，我们训练一个回归函数来输出一个数值； 而在分类中，我们训练一个分类器，它的输出即为预测的类别 可以试着用概率语言来理解模型。 给定一个样本特征，我们的模型为每个可能的类分配一个概率，比如，猫狗分类器可能会输出图像是猫的概率为0.9，即分类器90%确定图像描绘的是一只猫。 预测类别的概率的大小传达了一种模型的不确定性 当我们有两个以上的类别时，我们把这个问题称为多元分类（multiclass classification）问题，常见的例子包括手写字符识别 与解决回归问题不同，分类问题的常见损失函数被称为交叉熵（cross-entropy） 最常见的类别不一定是你将用于决策的类别，或许不确定风险的影响远远大于收益。 因此，我们需要将“预期风险”作为损失函数。 也就是说，我们需要将结果的概率乘以与之相关的收益（或伤害） 有一些分类任务的变体可以用于寻找层次结构，层次结构假定在许多类之间存在某种关系。 因此，并不是所有的错误都是均等的。 我们宁愿错误地分入一个相关的类别，也不愿错误地分入一个遥远的类别，这通常被称为层次分类（hierarchical classification） 标记问题 学习预测不相互排斥的类别的问题称为多标签分类（multi-label classification） 举个例子，人们在技术博客上贴的标签，比如“机器学习”、“技术”、“小工具”、“编程语言”、“Linux”、“云计算”、“AWS”。 一篇典型的文章可能会用5-10个标签，因为这些概念是相互关联的。 关于“云计算”的帖子可能会提到“AWS”，而关于“机器学习”的帖子也可能涉及“编程语言” 搜索 有时，我们不仅仅希望输出为一个类别或一个实值。 在信息检索领域，我们希望对一组项目进行排序 以网络搜索为例，我们的目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。 搜索结果的排序也十分重要，我们的学习算法需要输出有序的元素子集 该问题的一种可能的解决方案：首先为集合中的每个元素分配相应的相关性分数，然后检索评级最高的元素。PageRank，谷歌搜索引擎背后最初的秘密武器就是这种评分系统的早期例子 如今，搜索引擎使用机器学习和用户行为模型来获取网页相关性得分，很多学术会议也致力于这一主题 推荐系统 另一类与搜索和排名相关的问题是推荐系统（recommender system），它的目标是向特定用户进行“个性化”推荐 简单来说，推荐系统会为“给定用户和物品”的匹配性打分，这个“分数”可能是估计的评级或购买的概率。 由此，对于任何给定的用户，推荐系统都可以检索得分最高的对象集，然后将其推荐给用户。工业生产的推荐系统还要先进得多，它会将详细的用户活动和项目特征考虑在内 尽管推荐系统具有巨大的应用价值，但单纯用它作为预测模型仍存在一些缺陷。首先，用户更倾向于给他们感觉强烈的事物打分，此外，推荐系统有可能形成反馈循环 序列学习 以上大多数问题都具有固定大小的输入和产生固定大小的输出，在这些情况下，模型只会将输入作为生成输出的“原料”，而不会“记住”输入的具体内容 但是如果输入是连续的，我们的模型可能就需要拥有“记忆”功能。 比如，处理视频片段时，每个视频片段可能由不同数量的帧组成，通过前一帧的图像，我们可能对后一帧中发生的事情更有把握。 语言也是如此，机器翻译的输入和输出都为文字序列 序列学习的实例，是机器学习最令人兴奋的应用之一。 序列学习需要摄取输入序列或预测输出序列，或两者兼而有之。 具体来说，输入和输出都是可变长度的序列，例如机器翻译和从语音中转录文本 标记和解析：这涉及到用属性注释文本序列。 换句话说，输入和输出的数量基本上是相同的。 例如，我们可能想知道动词和主语在哪里，或者，我们可能想知道哪些单词是命名实体。 通常，目标是基于结构和语法假设对文本进行分解和注释，以获得一些注释 自动语音识别：在语音识别中，输入序列是说话人的录音，输出序列是说话人所说内容的文本记录。 它的挑战在于，与文本相比，音频帧多得多，也就是说，音频和文本之间没有1:1的对应关系，因为数千个样本可能对应于一个单独的单词。 这也是“序列到序列”的学习问题，其中输出比输入短得多 文本到语音：这与自动语音识别相反。 换句话说，输入是文本，输出是音频文件。 在这种情况下，输出比输入长得多。 虽然人类很容易识判断发音别扭的音频文件，但这对计算机来说并不是那么简单 机器翻译：在语音识别中，输入和输出的出现顺序基本相同。 而在机器翻译中，颠倒输入和输出的顺序非常重要。 换句话说，虽然我们仍将一个序列转换成另一个序列，但是输入和输出的数量以及相应序列的顺序大都不会相同 无监督学习 监督学习向模型提供巨大数据集，每个样本包含特征和相应标签值，准确地告诉模型在每种情况下应该做什么，直到模型学会从情况到行动的映射 如果没有十分具体的目标，就需要“自发”地去学习了，我们称这类数据中不含有“目标”的机器学习问题为无监督学习（unsupervised learning） 无监督学习可以回答什么样的问题 聚类（clustering）问题：没有标签的情况下，我们是否能给数据分类。比如，给定一组照片，把它们分成风景照片、狗、婴儿、猫和山峰的照片 主成分分析（principal component analysis）问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性。比如，一个球的运动轨迹可以用球的速度、直径和质量来描述 因果关系（causality）和概率图模型（probabilistic graphical models）问题：我们能否描述观察到的许多数据的根本原因。例如，如果我们有关于房价、污染、犯罪、地理位置、教育和工资的人口统计数据，我们能否简单地根据经验数据发现它们之间的关系 生成对抗性网络（generative adversarial networks）：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的非结构化数据。潜在的统计机制是检查真实和虚假数据是否相同的测试，它是无监督学习的另一个重要而令人兴奋的领域 与环境互动 不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。 这里所有学习都是在算法与环境断开后进行的，被称为离线学习（offline learning） 离线学习可以孤立地进行模式识别，而不必分心于其他问题，但缺点是，解决的问题相当有限 你可能会期望人工智能不仅能够做出预测，而且能够与真实环境互动。 与预测不同，“与真实环境互动”实际上会影响环境。 这里的人工智能是“智能代理”，而不仅是“预测模型”。 因此，我们必须考虑到它的行为可能会影响未来的观察结果 考虑“与真实环境互动”将打开一整套新的建模问题 环境还记得我们以前做过什么吗？ 环境是否有助于我们建模？例如，用户将文本读入语音识别器。 环境是否想要打败模型？例如，一个对抗性的设置，如垃圾邮件过滤或玩游戏？ 环境是否重要？ 当训练和测试数据不同时，环境是否变化？这是分布偏移（distribution shift）的问题。例如，未来的数据是否总是与过去相似，还是随着时间的推移会发生变化？是自然变化还是响应我们的自动化工具而发生变化？ 强化学习 如果你对使用机器学习开发与环境交互并采取行动感兴趣，那么你最终可能会专注于强化学习（reinforcement learning）。 这可能包括应用到机器人、对话系统，甚至开发视频游戏的人工智能（AI） 深度强化学习（deep reinforcement learning）将深度学习应用于强化学习的问题，是非常热门的研究领域 我们可以将任何监督学习问题转化为强化学习问题。 假设我们有一个分类问题，我们可以创建一个强化学习agent，每个分类对应一个“动作”。 然后，我们可以创建一个环境，该环境给予agent的奖励。 这个奖励与原始监督学习问题的损失函数是一致的 在监督学习中，我们总是希望输入与正确的标签相关联。 但在强化学习中，我们并不假设环境告诉agent每个观测的最优动作。 一般来说，agent只是得到一些奖励。 环境甚至可能不会告诉我们是哪些行为导致了奖励，因此，强化学习者必须处理学分分配（credit assignment）问题：决定哪些行为是值得奖励的，哪些行为是需要惩罚的 强化学习可能还必须处理部分可观测性问题。 也就是说，当前的观察结果可能无法阐述有关当前状态的所有信息 最后，在任何时间点上，强化学习agent可能知道一个好的策略，但可能有许多更好的策略从未尝试过的。 强化学习agent必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识） 环境可以是完整观察到的，也可以是部分观察到的，解释所有这些复杂性可能会对研究人员要求太高。 此外，并不是每个实际问题都表现出所有这些复杂性。 因此，学者们研究了一些特殊情况下的强化学习问题 当环境可被完全观察到时，我们将强化学习问题称为马尔可夫决策过程（markov decision process）。 当状态不依赖于之前的操作时，我们称该问题为上下文赌博机（contextual bandit problem）。 当没有状态，只有一组最初未知回报的可用动作时，这个问题就是经典的多臂赌博机（multi-armed bandit problem） 深度学习的发展 为了解决各种各样的机器学习问题，深度学习提供了强大的工具。 虽然许多深度学习方法都是最近的才有重大突破，但使用数据和神经网络编程的核心思想已经研究了几个世纪 伯努利分布是以雅各布•伯努利（1654–1705）命名的。 而高斯分布是由卡尔•弗里德里希•高斯（1777—1855）发现的， 他发明了最小均方算法，至今仍用于解决从保险计算到医疗诊断的许多问题 随着数据的收集和可获得性，统计数据真正实现了腾飞。 罗纳德·费舍尔（1890-1962）对统计理论和在遗传学中的应用做出了重大贡献。 他的许多算法（如线性判别分析）和公式（如费舍尔信息矩阵）至今仍被频繁使用 机器学习的第二个影响来自克劳德·香农(1916–2001)的信息论和艾伦·图灵（1912-1954）的计算理论。 图灵在他著名的论文《计算机器与智能》中提出了“机器能思考吗？”的问题（图灵测试） 唐纳德·赫布 (1904–1985)开创性的著作《行为的组织》提出神经元通过积极强化学习，是Rosenblatt感知器学习算法的原型，被称为“赫布学习”。 这个算法也为当今深度学习的许多随机梯度下降算法奠定了基础：强化期望行为和减少不良行为，从而在神经网络中获得良好的参数设置 神经网络（neural networks）的得名源于生物灵感。 一个多世纪以来（追溯到1873年亚历山大·贝恩和1890年詹姆斯·谢林顿的模型），研究人员一直试图组装类似于相互作用的神经元网络的计算电路。 随着时间的推移，对生物学的解释变得不再肤浅，但这个名字仍然存在。 其核心是当今大多数网络中都可以找到的几个关键原则： 线性和非线性处理单元的交替，通常称为层（layers）。 使用链式规则（也称为反向传播（backpropagation））一次性调整网络中的全部参数 神经网络的研究从1995年左右一直开始停滞不前，直到到2005年才稍有起色。 这主要是因为两个原因。 首先，训练网络（在计算上）非常昂贵， 其次，数据集相对较小 大约2010年开始，那些在计算上看起来不可行的神经网络算法变得热门起来，实际上是以下两点导致的： 其一，随着互联网的公司的出现，为数亿在线用户提供服务，大规模数据集变得触手可及。 另外，廉价又高质量的传感器、廉价的数据存储（克莱德定律）以及廉价计算（摩尔定律）的普及，特别是GPU的普及，使大规模算力唾手可得 很明显，随机存取存储器没有跟上数据增长的步伐。 与此同时，算力的增长速度已经超过了现有数据的增长速度。 这意味着统计模型需要提高内存效率（这通常是通过添加非线性来实现的） 同时由于计算预算的增加，能够花费更多时间来优化这些参数。 因此，机器学习和统计的关注点从（广义的）线性模型和核方法转移到了深度神经网络。 这也造就了许多深度学习的中流砥柱，如多层感知机、卷积神经网络、长短期记忆网络和Q学习，在相对休眠了相当长一段时间之后，在过去十年中被“重新发现 深度学习的成功案例 感知 -&gt; 推理 -&gt; 知识 -&gt; 规划：自然语言处理 -&gt; 计算机视觉 -&gt; 深度学习 深度学习应用：图片地图、样式迁移、人脸合成、文字生成图片、文字生成、无人驾驶 案例研究：广告点击 触发 -&gt; 点击率预估 -&gt; 排序（$点击率 * 竞价$） 预测：特征提取 -&gt; 模型 -&gt; 点击率预测 训练：训练数据（过去广告展现与用户点击） -&gt; 特征和用户点击 -&gt; 模型 领域专家：点击 -&gt; 展现 数据科学家：数据 -&gt; 模型（模型控制广告展现，这些用来训练新的模型） AI 专家：提升模型精度和性能 深度学习的特点 机器学习可以使用数据来学习输入和输出之间的转换，例如在语音识别中将音频转换为文本。 在这样做时，通常需要以适合算法的方式表示数据，以便将这种表示转换为输出 深度学习是“深度”的，模型学习了许多“层”的转换，每一层提供一个层次的表示。 例如，靠近输入的层可以表示数据的低级细节，而接近分类输出的层可以表示用于区分的更抽象的概念。 由于表示学习（representation learning）目的是寻找表示本身，因此深度学习可以称为“多级表示学习” 多层模型能够以以前的工具所不能的方式处理低级的感知数据。 毋庸置疑，深度学习方法中最显著的共同点是使用端到端训练。 也就是说，与其基于单独调整的组件组装系统，不如构建系统，然后联合调整它们的性能。 在过去的日子里，将机器学习应用于这些问题的关键部分是提出人工设计的特征工程方法，将数据转换为某种适合于浅层模型的形式。 然而，与一个算法自动执行的数百万个选择相比，人类通过特征工程所能完成的事情很少。 当深度学习开始时，这些特征抽取器被自动调整的滤波器所取代，产生了更高的精确度 因此，深度学习的一个关键优势是它不仅取代了传统学习管道末端的浅层模型，而且还取代了劳动密集型的特征工程过程。 此外，通过取代大部分特定领域的预处理，深度学习消除了以前分隔计算机视觉、语音识别、自然语言处理、医学信息学和其他应用领域的许多界限，为解决各种问题提供了一套统一的工具 除了端到端的训练，我们正在经历从参数统计描述到完全非参数模型的转变。 当数据稀缺时，人们需要依靠简化对现实的假设来获得有用的模型。 当数据丰富时，可以用更准确地拟合实际情况的非参数模型来代替。 现在人们可以借助于相关偏微分方程的数值模拟，而不是用手来求解电子行为的参数近似。这导致了更精确的模型，尽管常常以牺牲可解释性为代价。与以前工作的另一个不同之处是接受次优解，处理非凸非线性优化问题，并且愿意在证明之前尝试。 这种在处理统计问题上新发现的经验主义，加上人才的迅速涌入，导致了实用算法的快速进步 安装动手学深度学习 v2 安装环境：Ubuntu 18.04 + build-essential + Python 3.8 + 安装 Miniconda 到 \\root\\miniconda3 12wget https://repo.anaconda.com/miniconda/Miniconda3-py38_4.11.0-Linux-x86_64.shbash Miniconda3-py38_4.11.0-Linux-x86_64.sh 安装其他软件包 1pip install jupyter d2l torch torchvision 拷贝 Jupyter 记事本 12wget https://zh-v2.d2l.ai/d2l-zh.zipgit clone git@github.com:d2l-ai/d2l-zh-pytorch-slides.git 远程运行 Jupyter Notebook 1jupyter notebook --allow-root 将远端 localhost 映射到本地 localhost（端口 :8888） 1ssh -L8888:localhost:8888 root@106.15.200.147 安装 jupyter 插件 1pip install rise 总结 机器学习研究计算机系统如何利用经验（通常是数据）来提高特定任务的性能。它结合了统计学、数据挖掘和优化的思想。通常，它是被用作实现人工智能解决方案的一种手段 表示学习作为机器学习的一类，其研究的重点是如何自动找到合适的数据表示方式。深度学习是通过学习多层次的转换来进行的多层次的表示学习 深度学习不仅取代了传统机器学习的浅层模型，而且取代了劳动密集型的特征工程 最近在深度学习方面取得的许多进展，大都是由廉价传感器和互联网规模应用所产生的大量数据，以及（通过GPU）算力的突破来触发的 整个系统优化是获得高性能的关键环节。有效的深度学习框架的开源使得这一点的设计和实现变得非常容易","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.zhuangzhihao.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"macOS + Ubuntu 实现远程开发配置","slug":"Ubuntu远程开发配置","date":"2022-03-05T16:00:00.000Z","updated":"2022-05-23T10:37:31.975Z","comments":true,"path":"Ubuntu远程开发配置/","link":"","permalink":"http://blog.zhuangzhihao.top/Ubuntu%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/","excerpt":"刚刚续费了一年的阿里云轻量应用服务器，打算把大多数的开发环境放到服务器上，实现远程开发。我使用的是 macOS Monterey 和基于 Ubuntu 18.04 的 LNMP 镜像系统，IDE 选取 Visual Studio Code 和 IntelliJ IDEA 进行开发学习。","text":"刚刚续费了一年的阿里云轻量应用服务器，打算把大多数的开发环境放到服务器上，实现远程开发。我使用的是 macOS Monterey 和基于 Ubuntu 18.04 的 LNMP 镜像系统，IDE 选取 Visual Studio Code 和 IntelliJ IDEA 进行开发学习。 一、服务器镜像信息我使用的是阿里云轻量应用服务器提供的 LNMP 7.4 镜像，该镜像为LNMP（Ubuntu18.04 64位+Nginx+MySQL5.7+PHP5.3～8.0切换）架构，jemalloc优化内存管理，脚本菜单式添加Nginx虚拟主机绑定，并支持内网OSS备份功能，是常见的搭建Web应用所需的环境，支持高并发性能。 应用程序安装信息： Nginx 1.18：/usr/local/nginx PHP 7.4：/usr/local/php MySQL 5.7：/usr/local/mysql 数据库地址：127.0.0.1:3306 网站根目录：/data/wwwroot 查询数据库和 FTP 密码 1sudo cat /root/ReadMe 二、Ubuntu 系统配置依赖源设置： 123456789101112131415161718mv /etc/apt/sources.list&#123;,bak&#125; #备份sources.listcat &gt; /etc/apt/sources.list &lt;&lt; EOFdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverseEOFapt update 在防火墙添加规则放行 21、20000/30000 端口，允许通过 FTP 连接。 三、搭建开发环境C/C++ 开发环境： 1sudo apt-get install build-essential Python3 开发环境： 12python3 --version sudo apt-get install python3-pip Java 开发环境： 1sudo apt install openjdk-11-jdk Go 开发环境： 12sudo wget -c https://dl.google.com/go/go1.15.6.linux-amd64.tar.gz -O - | sudo tar -xz -C /usr/localvim /etc/profile 添加以下内容： 1234export GOROOT=/usr/local/goexport GOPATH=/tufei/code/goexport GOBIN=$GOPATH/binexport PATH=$GOPATH:$GOBIN:$GOROOT/bin:$PATH 保存： 12source /etc/profilego version Git 安装配置： 12345sudo apt-get install gitgit config --global user.name &quot;Zhuang Zhihao&quot;git config --global user.email &quot;bezhuang@outlook.com&quot;ssh-keygen -t rsa -C &quot;bezhuang@outlook.com&quot;cat /root/.ssh/id_rsa.pub 提交公钥到 Github 或其他 Git 仓库。 四、管理服务Nginx： 1service nginx &#123;start|stop|status|restart|reload|configtest&#125; MySQL： 1service mysqld &#123;start|stop|restart|reload|status&#125; PHP： 1service php-fpm &#123;start|stop|restart|reload|status&#125; Pure-Ftpd： 1service pureftpd &#123;start|stop|restart|status&#125; Redis： 1service redis-server &#123;start|stop|status|restart&#125; Memcached： 1service memcached &#123;start|stop|status|restart|reload&#125; 五、虚拟主机管理添加虚拟主机： 12cd /root/oneinstack./vhost.sh 删除虚拟主机： 1./vhost.sh --del 六、本地开发环境使用 Visual Studio Code 中的 Remote -SSH 插件连接， 使用 Termius 进行 SSH 和 SFTP 连接， 博客现仍使用 Hexo，Typora 软件用于编写博客文章，uPic 软件用于上传图床。","categories":[{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.zhuangzhihao.top/tags/Linux/"}]},{"title":"Go 语言基础知识总结","slug":"Go语言之旅","date":"2022-02-12T16:00:00.000Z","updated":"2022-05-23T10:33:38.132Z","comments":true,"path":"Go语言之旅/","link":"","permalink":"http://blog.zhuangzhihao.top/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/","excerpt":"Go 语言是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，它用批判吸收的眼光，融合 C 语言、Java 等众家之长，将简洁、高效演绎得淋漓尽致。Golang非常适合用来做网络并发方面的服务，比如消息推送、监控、容器等。初次学习我选择的是 Go 编程语言指南，指南涵盖了该语言的大部分重要特性，放在以下为所记笔记，另附有随堂代码放在 Github 仓库中，可供参考。","text":"Go 语言是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，它用批判吸收的眼光，融合 C 语言、Java 等众家之长，将简洁、高效演绎得淋漓尽致。Golang非常适合用来做网络并发方面的服务，比如消息推送、监控、容器等。初次学习我选择的是 Go 编程语言指南，指南涵盖了该语言的大部分重要特性，放在以下为所记笔记，另附有随堂代码放在 Github 仓库中，可供参考。 包、变量和函数包 每个 Go 程序都是由包构成的 程序从 main 包开始运行 1package main 导入 此代码用圆括号组合了导入，这是“分组”形式的导入语句 1234import ( &quot;fmt&quot; &quot;math&quot;) 当然也可以编写多个导入语句，不过使用分组导入语句是更好的形式 导出名 在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，Pizza 就是个已导出名，Pi 也同样，它导出自 math 包 123func main() &#123; fmt.Println(math.Pi)&#125; 在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问 函数 函数可以没有参数或接受多个参数 1234// add 接受两个 int 类型的参数func add(x int, y int) int &#123; return x + y&#125; 注意类型在变量名 之后 当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略 123func add(x, y int) int &#123; return x + y&#125; 多值返回 函数可以返回任意数量的返回值 swap 函数返回了两个字符串 123func swap(x, y string) (string, string) &#123; return y, x&#125; 命名返回值 Go 的返回值可被命名，它们会被视作定义在函数顶部的变量 返回值的名称应当具有一定的意义，它可以作为文档使用 没有参数的 return 语句返回已命名的返回值。也就是 直接 返回 直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性 12345func split(sum int) (x, y int) &#123; x = sum * 4 / 9 y = sum - x return&#125; 变量 var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后 var 语句可以出现在包或函数级别 12345var c, python, java boolfunc main() &#123; var i int fmt.Println(i, c, python, java)&#125; 变量的初始化 变量声明可以包含初始值，每个变量对应一个 如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型 12345var i, j int = 1, 2func main() &#123; var c, python, java = true, false, &quot;no!&quot; fmt.Println(i, j, c, python, java)&#125; 短变量声明 在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明 函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用 123456func main() &#123; var i, j int = 1, 2 k := 3 c, python, java := true, false, &quot;no!&quot; fmt.Println(i, j, k, c, python, java)&#125; 基本类型 Go 的基本类型有 1234567891011121314boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名，表示一个 Unicode 码点float32 float64complex64 complex128 同导入语句一样，变量声明也可以“分组”成一个语法块 12345var ( ToBe bool = false MaxInt uint64 = 1&lt;&lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i)) int, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型 零值 没有明确初始值的变量声明会被赋予它们的 零值 数值类型零值为 0 布尔类型零值为 false 字符串零值为 &quot;&quot;（空字符串） 类型转换 表达式 T(v) 将值 v 转换为类型 T。 123i := 42f := float64(i)u := uint(f) 与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换 123var i int = 42var f float64 = float64(i)var u uint = uint(f) 类型推导 在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法） 变量的类型由右值推导得出 当右值声明了类型时，新变量的类型与其相同： 12var i intj := i // j 也是一个 int 不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int, float64 或 complex128 了，这取决于常量的精度： 123i := 42 // intf := 3.142 // float64g := 0.867 + 0.5i // complex128 常量 常量的声明与变量类似，只不过是使用 const 关键字 常量可以是字符、字符串、布尔值或数值 常量不能用 := 语法声明 1const Pi = 3.14 数值常量 数值常量是高精度的 值 一个未指定类型的常量由上下文来决定其类型 int 可以存放最大64位的整数，根据平台不同有时会更少 1234567891011const ( // 将 1 左移 100 位来创建一个非常大的数字 // 即这个数的二进制是 1 后面跟着 100 个 0 Big = 1 &lt;&lt; 100 // 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2 Small = Big &gt;&gt; 99)func needInt(x int) int &#123; return x*10 + 1 &#125;func needFloat(x float64) float64 &#123; return x * 0.1&#125; 流程控制语句for Go 只有一种循环结构：for 循环 基本的 for 循环由三部分组成，它们用分号隔开 初始化语句：在第一次迭代前执行 条件表达式：在每次迭代前求值 后置语句：在每次迭代的结尾执行 123for i := 0; i &lt; 10; i++ &#123; sum += i&#125; 初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见 一旦条件表达式的布尔值为 false，循环迭代就会终止 注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 &#123; &#125; 则是必须的 for 是 Go 中的 “while” 初始化语句和后置语句是可选的 此时你可以去掉分号，因为 C 的 while 在 Go 中叫做 for 1234sum := 1for sum &lt; 1000 &#123; sum += sum&#125; 如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑 1234func main() &#123; for &#123; &#125;&#125; if Go 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 &#123; &#125; 则是必须的 123456func sqrt(x float64) string &#123; if x &lt; 0 &#123; return sqrt(-x) + &quot;i&quot; &#125; return fmt.Sprint(math.Sqrt(x))&#125; 同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 if 之内 123456func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; return lim&#125; if 和 else 在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用 123456789func pow(x, n, lim float64) float64 &#123; if v := math.Pow(x, n); v &lt; lim &#123; return v &#125; else &#123; fmt.Printf(&quot;%g &gt;= %g\\n&quot;, v, lim) &#125; // 这里开始就不能使用 v 了 return lim&#125; switch switch 是编写一连串 if - else 语句的简便方法，它运行第一个值等于条件表达式的 case 语句 Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句 除非以 fallthrough 语句结束，否则分支会自动终止 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数 1234567switch os := runtime.GOOS; os &#123; case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: fmt.Println(&quot;%s. \\n&quot;, os) switch 的求值顺序：case 语句从上到下顺次执行，直到匹配成功时停止 1234switch i &#123;case 0:case f(): // 在 i==0 时 f 不会被调用&#125; 没有条件的 switch 同 switch true 一样。这种形式能将一长串 if-then-else 写得更加清晰 1234567switch &#123; case t.Hour() &lt; 12: fmt.Println(&quot;Good morning!&quot;) case t.Hour() &lt; 17: fmt.Println(&quot;Good afternoon.&quot;) default: fmt.Println(&quot;Good evening.&quot;) defer defer 语句会将函数推迟到外层函数返回之后执行 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用 1234func main() &#123; defer fmt.Println(&quot;world&quot;) fmt.Println(&quot;hello&quot;)&#125; // 输出：hello world defer 栈 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用 1234567func main() &#123; fmt.Println(&quot;counting&quot;) defer fmt.Println(&quot;done&quot;) for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125;&#125; // 输出：counting 9 8 7 6 5 4 3 2 1 0 done 结构体、数组、切片和映射指针 Go 拥有指针。指针保存了值的内存地址 类型 *T 是指向 T 类型值的指针。其零值为 nil 1var p *int &amp; 操作符会生成一个指向其操作数的指针。 12i := 42p = &amp;i * 操作符表示指针指向的底层值 12fmt.Println(*p) // 通过指针 p 读取 i*p = 21 // 通过指针 p 设置 i 这也就是通常所说的“间接引用”或“重定向” 与 C 不同，Go 没有指针运算 结构体 一个结构体（struct）就是一组字段（field） 1234567type Vertex struct &#123; X int Y int&#125;func main() &#123; fmt.Println(Vertex&#123;1, 2&#125;)&#125; 结构体字段使用点号来访问 12345func main() &#123; v := Vertex&#123;1, 2&#125; v.X = 4 fmt.Println(v, v.X, v.Y)&#125; 结构体指针 结构体字段可以通过结构体指针来访问 如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以 123456func main() &#123; v := Vertex&#123;1, 2&#125; p = &amp;v p.X = 1e9 fmt.Println(v)&#125; 结构体文法 结构体文法通过直接列出字段的值来新分配一个结构体 使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。） 特殊的前缀 &amp; 返回一个指向结构体的指针 123456789type Vertex struct &#123; X, Y int&#125;var ( v1 = Vertex&#123;1, 2&#125; // 创建一个 Vertex 类型的结构体 &#123;1, 2&#125; v2 = Vertex&#123;X: 1&#125; // Y:0 被隐式地赋予 &#123;1, 0&#125; v3 = Vertex&#123;&#125; // X:0 Y:0 &#123;0, 0&#125; p = &amp;Vertex&#123;1, 2&#125; // 创建一个 *Vertex 类型的结构体（指针） &amp;&#123;1, 2&#125;) 数组 类型 [n]T 表示拥有 n 个 T 类型的值的数组。 123var a [2]string // 会将变量 a 声明为拥有 10 个整数的数组a[0] = &quot;Hello&quot;a[1] = &quot;World&quot; 数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组 切片 每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。 类型 []T 表示一个元素类型为 T 的切片。 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔： 1a[low : high] // 选择一个半开区间，包括第一个元素，但排除最后一个元素 123primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125;var s []int = primes[1:4] // 创建了一个切片，它包含 primes 中下标从 1 到 3 的元素 fmt.Println(s) // 输出：[3 5 7] 切片就像数组的引用，切片并不存储任何数据，它只是描述了底层数组中的一段 更改切片的元素会修改其底层数组中对应的元素，与它共享底层数组的切片都会观测到这些修改 切片文法 切片文法类似于没有长度的数组文法。 这是一个数组文法： 1[3]bool&#123;true, true, false&#125; 下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片： 1[]bool&#123;true, true, false&#125; 切片的默认行为 在进行切片时，你可以利用它的默认行为来忽略上下界。 切片下界的默认值为 0，上界则是该切片的长度 123456var a [10]int// 以下切片是等价的a[0:10]a[:10]a[0:]a[:] 切片的长度与容量 切片拥有 长度 和 容量。 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取 12345678910111213141516func main() &#123; s := []int&#123;2, 3, 5, 7, 11, 13&#125; printSlice(s) // 截取切片使其长度为 0 s = s[:0] printSlice(s) // 拓展其长度 s = s[:4] printSlice(s) // 舍弃前两个值 s = s[2:] printSlice(s)&#125;func printSlice(s []int) &#123; fmt.Printf(&quot;len=%d cap=%d %v\\n&quot;, len(s), cap(s), s)&#125; nil 切片 切片的零值是 nil。 nil 切片的长度和容量为 0 且没有底层数组 12var s []int // s == nilfmt.Println(s, len(s), cap(s)) // [] 0 0 用 make 创建切片 切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。 make 函数会分配一个元素为零值的数组并返回一个引用了它的切片： 1a := make([]int, 5) // len(a)=5 要指定它的容量，需向 make 传入第三个参数： 123b := make([]int, 0, 5) // len(b)=0, cap(b)=5b = b[:cap(b)] // len(b)=5, cap(b)=5b = b[1:] // len(b)=4, cap(b)=4 切片的切片 切片可包含任何类型，甚至包括其它的切片 1234567891011121314151617func main() &#123; // 创建一个井字板（经典游戏） board := [][]string&#123; []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, &#125; // 两个玩家轮流打上 X 和 O board[0][0] = &quot;X&quot; board[2][2] = &quot;O&quot; board[1][2] = &quot;X&quot; board[1][0] = &quot;O&quot; board[0][2] = &quot;X&quot; for i := 0; i &lt; len(board); i++ &#123; fmt.Printf(&quot;%s\\n&quot;, strings.Join(board[i], &quot; &quot;)) &#125;&#125; 向切片追加元素 为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数 1func append(s []T, vs ...T) []T append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾 append 的结果是一个包含原切片所有元素加上新添加元素的切片 当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组 Range for 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本 123456var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;func main() &#123; for i, v := range pow &#123; fmt.Printf(&quot;2**%d = %d\\n&quot;, i, v) &#125;&#125; 可以将下标或值赋予 _ 来忽略它 12for i, _ := range powfor _, value := range pow 若你只需要索引，忽略第二个变量即可。 1for i := range pow 映射 映射将键映射到值 映射的零值为 nil 。nil 映射既没有键，也不能添加键 make 函数会返回给定类型的映射，并将其初始化备用 12var m map[key_type]value_typem = make(map[key_type]value_type) 短声明写法 1m := make(map[string]int) // m := make(map[key_type]value_type) 映射的文法与结构体相似，不过必须有键名 1234567891011type Vertex struct &#123; Lat, Long float64&#125;var m = map[string]Vertex&#123; &quot;Bell Labs&quot;: Vertex&#123; 40.68433, -74.39967, &#125;, &quot;Google&quot;: Vertex&#123; 37.42202, -122.08408, &#125;,&#125; 若顶级类型只是一个类型名，你可以在文法的元素中省略它 1234var m = map[string]Vertex&#123; &quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;, &quot;Google&quot;: &#123;37.42202, -122.08408&#125;,&#125; 修改映射 在映射 m 中插入或修改元素： 1m[key] = elem 获取元素： 1elem = m[key] 删除元素： 1delete(m, key) 通过双赋值检测某个键是否存在： 1elem, ok = m[key] 若 elem 或 ok 还未声明，你可以使用短变量声明 1elem, ok := m[key] 若 key 在 m 中，ok 为 true ；否则，ok 为 false 若 key 不在映射中，那么 elem 是该映射元素类型的零值 12v, ok := m[&quot;Answer&quot;]fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok) // The value: 0 Present? false 同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值 函数值 函数也是值。它们可以像其它值一样传递。 函数值可以用作函数的参数或返回值 123hypot := func(x, y float64) float64 &#123; return math.Sqrt(x*x + y*y)&#125; 函数的闭包 Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。 例如，函数 adder 返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上 12345678910111213141516func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125;&#125; 方法和接口方法 Go 没有类。不过你可以为结构体类型定义方法。 方法就是一类带特殊的 接收者 参数的函数。 方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。 在此例中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者 12345678910type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs())&#125; 记住：方法只是个带接收者参数的函数。 现在这个 Abs 的写法就是个正常的函数，功能并没有什么变化 1234567func Abs(v Vertex) float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(Abs(v))&#125; 也可以为非结构体类型声明方法。 在此例中，我们看到了一个带 Abs 方法的数值类型 MyFloat 12345678910func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;func main() &#123; f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs())&#125; 只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法（就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。） 指针接收者 可以为指针接收者声明方法。 这意味着对于某类型 T，接收者的类型可以用 *T 的文法。（此外，T 不能是像 *int 这样的指针。） 例如，这里为 *Vertex 定义了 Scale 方法 123456789101112131415type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(10) fmt.Println(v.Abs())&#125; 指针接收者的方法可以修改接收者指向的值（就像 Scale 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。 若使用值接收者，那么 Scale 方法会对原始 Vertex 值的副本进行操作。（对于函数的其它参数也是如此。）Scale 方法必须用指针接受者来更改 main 函数中声明的 Vertex 的值。 方法与指针重定向 注意：带指针参数的函数必须接受一个指针 123456789func ScaleFunc(v *Vertex, f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; ScaleFunc(v, 5) // 编译错误！ ScaleFunc(&amp;v, 5) // OK&#125; 而以指针为接收者的方法被调用时，接收者既能为值又能为指针 12345678910func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(5) // OK p := &amp;v p.Scale(10) // OK &#125; 对于语句 v.Scale(5)，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5) 同样的事情也发生在相反的方向。 接受一个值作为参数的函数必须接受一个指定类型的值 12345678func AbsFunc(v Vertex) float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(AbsFunc(v)) // OK fmt.Println(AbsFunc(&amp;v)) // 编译错误！&#125; 而以值为接收者的方法被调用时，接收者既能为值又能为指针 12345678910func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; var v Vertex fmt.Println(v.Abs()) // OK p := &amp;v fmt.Println(p.Abs()) // OK&#125; 这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs() 选择值或指针作为接收者 使用指针接收者的原因有二： 首先，方法能够修改其接收者指向的值。 其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。 在本例中，Scale 和 Abs 接收者的类型为 *Vertex，即便 Abs 并不需要修改其接收者。 12345678910111213func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := &amp;Vertex&#123;3, 4&#125; fmt.Printf(&quot;Before scaling: %+v, Abs: %v\\n&quot;, v, v.Abs()) v.Scale(5) fmt.Printf(&quot;After scaling: %+v, Abs: %v\\n&quot;, v, v.Abs())&#125; 通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用 接口 接口类型 是由一组方法签名定义的集合。 接口类型的变量可以保存任何实现了这些方法的值 123456789101112131415161718192021222324type Abser interface &#123; Abs() float64&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat 实现了 Abser a = &amp;v // a *Vertex 实现了 Abser fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125; 接口与隐式实现 类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。 隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。 因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。 1234567891011121314type I interface &#123; M()&#125;type T struct &#123; S string&#125;// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。func (t T) M() &#123; fmt.Println(t.S)&#125;func main() &#123; var i I = T&#123;&quot;hello&quot;&#125; i.M()&#125; 接口值 接口也是值。它们可以像其它值一样传递。 接口值可以用作函数的参数或返回值。 在内部，接口值可以看做包含值和具体类型的元组：(value, type) 接口值保存了一个具体底层类型的具体值。 接口值调用方法时会执行其底层类型的同名方法。 12345678910111213141516171819202122232425type I interface &#123; M()&#125;type T struct &#123; S string&#125;func (t *T) M() &#123; fmt.Println(t.S)&#125;type F float64func (f F) M() &#123; fmt.Println(f)&#125;func main() &#123; var i I i = &amp;T&#123;&quot;Hello&quot;&#125; describe(i) i.M() i = F(math.Pi) describe(i) i.M()&#125;func describe(i I) &#123; fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i)&#125; 底层值为 nil 的接口值 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。 在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 M 方法）。 注意: 保存了 nil 具体值的接口其自身并不为 nil。 nil 接口值既不保存值也不保存具体类型。 为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。 空接口 指定了零个方法的接口值被称为 空接口： 1interface&#123;&#125; 空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。） 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface&#123;&#125; 的任意数量的参数。 1234567891011func main() &#123; var i interface&#123;&#125; describe(i) i = 42 describe(i) i = &quot;hello&quot; describe(i)&#125;func describe(i interface&#123;&#125;) &#123; fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i)&#125; 类型断言 类型断言 提供了访问接口值底层具体值的方式。 1t := i.(T) 该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。 若 i 并未保存 T 类型的值，该语句就会触发一个恐慌。 为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。 1t, ok := i.(T) 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。 否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌。 请注意这种语法和读取一个映射时的相同之处 1234567891011func main() &#123; var i interface&#123;&#125; = &quot;hello&quot; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // 报错(panic) fmt.Println(f)&#125; 类型选择 类型选择 是一种按顺序从几个类型断言中选择分支的结构。 类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。 12345678switch v := i.(type) &#123;case T: // v 的类型为 Tcase S: // v 的类型为 Sdefault: // 没有匹配，v 与 i 的类型相同&#125; 类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。 此选择语句判断接口值 i 保存的值类型是 T 还是 S。在 T 或 S 的情况下，变量 v 会分别按 T 或 S 类型保存 i 拥有的值。在默认（即没有匹配）的情况下，变量 v 与 i 的接口类型和值相同。 123456789101112131415func do(i interface&#123;&#125;) &#123; switch v := i.(type) &#123; case int: fmt.Printf(&quot;Twice %v is %v\\n&quot;, v, v*2) case string: fmt.Printf(&quot;%q is %v bytes long\\n&quot;, v, len(v)) default: fmt.Printf(&quot;I don&#x27;t know about type %T!\\n&quot;, v) &#125;&#125;func main() &#123; do(21) do(&quot;hello&quot;) do(true)&#125; Stringer fmt 包中定义的 Stringer 是最普遍的接口之一。 123type Stringer interface &#123; String() string&#125; Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。 123456789101112type Person struct &#123; Name string Age int&#125;func (p Person) String() string &#123; return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)&#125;func main() &#123; a := Person&#123;&quot;Arthur Dent&quot;, 42&#125; z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125; fmt.Println(a, z)&#125; 错误 Go 程序使用 error 值来表示错误状态。 与 fmt.Stringer 类似，error 类型是一个内建接口： 123type error interface &#123; Error() string&#125; （与 fmt.Stringer 类似，fmt 包在打印值时也会满足 error。） 通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil 来进行错误处理。 123456i, err := strconv.Atoi(&quot;42&quot;)if err != nil &#123; fmt.Printf(&quot;couldn&#x27;t convert number: %v\\n&quot;, err) return&#125;fmt.Println(&quot;Converted integer:&quot;, i) error 为 nil 时表示成功；非 nil 的 error 表示失败 12345678910111213141516171819type MyError struct &#123; When time.Time What string&#125;func (e *MyError) Error() string &#123; return fmt.Sprintf(&quot;at %v, %s&quot;, e.When, e.What)&#125;func run() error &#123; return &amp;MyError&#123; time.Now(), &quot;it didn&#x27;t work&quot;, &#125;&#125;func main() &#123; if err := run(); err != nil &#123; fmt.Println(err) &#125;&#125; Reader io 包指定了 io.Reader 接口，它表示从数据流的末尾进行读取。 Go 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。 io.Reader 接口有一个 Read 方法： 1func (T) Read(b []byte) (n int, err error) Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。 示例代码创建了一个 strings.Reader 并以每次 8 字节的速度读取它的输出 123456789101112func main() &#123; r := strings.NewReader(&quot;Hello, Reader!&quot;) b := make([]byte, 8) for &#123; n, err := r.Read(b) fmt.Printf(&quot;n = %v err = %v b = %v\\n&quot;, n, err, b) fmt.Printf(&quot;b[:n] = %q\\n&quot;, b[:n]) if err == io.EOF &#123; break &#125; &#125;&#125; 图像 image 包定义了 Image 接口： 123456package imagetype Image interface &#123; ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color&#125; 注意: Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明。 参阅文档了解全部信息 color.Color 和 color.Model 类型也是接口，但是通常因为直接使用预定义的实现 image.RGBA 和 image.RGBAModel 而被忽视了。这些接口和类型由 image/color 包定义 12345func main() &#123; m := image.NewRGBA(image.Rect(0, 0, 100, 100)) fmt.Println(m.Bounds()) fmt.Println(m.At(0, 0).RGBA())&#125; 并发Go 程 Go 程（goroutine）是由 Go 运行时管理的轻量级线程。 1go f(x, y, z) 会启动一个新的 Go 程并执行 1f(x, y, z) f, x, y 和 z 的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中。 Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。sync 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法 信道 信道是带有类型的管道，你可以通过它用信道操作符 &lt;- 来发送或者接收值。 12ch &lt;- v // 将 v 发送至信道 ch。v := &lt;-ch // 从 ch 接收值并赋予 v。 （“箭头”就是数据流的方向。） 和映射与切片一样，信道在使用前必须创建： 1ch := make(chan int) 默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。 以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果 123456789101112131415func sum(s []int, c chan int) &#123; sum := 0 for _, v := range s &#123; sum += v &#125; c &lt;- sum // 将和送入 c&#125;func main() &#123; s := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // 从 c 中接收 fmt.Println(x, y, x+y)&#125; 带缓冲的信道 信道可以是 带缓冲的。将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道： 1ch := make(chan int, 100) 仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。 1234567func main() &#123; ch := make(chan int, 2) ch &lt;- 1 ch &lt;- 2 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)&#125; range 和 close 发送者可通过 close 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完 1v, ok := &lt;-ch 之后 ok 会被设置为 false。 循环 for i := range c 会不断从信道接收值，直到它被关闭。 注意： 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。 还要注意： 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。 123456789101112131415func fibonacci(n int, c chan int) &#123; x, y := 0, 1 for i := 0; i &lt; n; i++ &#123; c &lt;- x x, y = y, x+y &#125; close(c)&#125;func main() &#123; c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c &#123; fmt.Println(i) &#125;&#125; select 语句 select 语句使一个 Go 程可以等待多个通信操作。 select 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行 1234567891011121314151617181920212223func fibonacci(c, quit chan int) &#123; x, y := 0, 1 for &#123; select &#123; case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println(&quot;quit&quot;) return &#125; &#125;&#125;func main() &#123; c := make(chan int) quit := make(chan int) go func() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(&lt;-c) &#125; quit &lt;- 0 &#125;() fibonacci(c, quit)&#125; 默认选择 当 select 中的其它分支都没有准备好时，default 分支就会执行。 为了在尝试发送或者接收时不发生阻塞，可使用 default 分支： 123456select &#123;case i := &lt;-c: // 使用 idefault: // 从 c 中接收会阻塞时执行&#125; sync.Mutex 我们已经看到信道非常适合在各个 Go 程间进行通信。 但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？ 这里涉及的概念叫做 互斥（mutual*exclusion），我们通常使用 互斥锁（Mutex）这一数据结构来提供这种机制。 Go 标准库中提供了 sync.Mutex 互斥锁类型及其两个方法： Lock Unlock 我们可以通过在代码前调用 Lock 方法，在代码后调用 Unlock 方法来保证一段代码的互斥执行。参见 Inc 方法。 我们也可以用 defer 语句来保证互斥锁一定会被解锁。参见 Value 方法 其他资料 Go 文档 如何使用Go编程 包手册 语言规范 进一步探索 Go 的并发模型，参阅 Go 并发模型(幻灯片)以及深入 Go 并发模型(幻灯片)并阅读通过通信共享内存的代码之旅 一个简单的编程环境(幻灯片) 编写 Web 应用的指南 函数：Go 中的一等公民展示了有趣的函数类型 Go 博客有着众多关于 Go 的文章和信息 mikespook 的博客中有大量中文的关于 Go 的文章和翻译 开源电子书 Go Web 编程和 Go 入门指南能够帮助你更加深入的了解和学习 Go 语言","categories":[{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"Java 实现银行 ATM 系统","slug":"ATM系统","date":"2022-02-04T16:00:00.000Z","updated":"2022-05-05T12:16:45.366Z","comments":true,"path":"ATM系统/","link":"","permalink":"http://blog.zhuangzhihao.top/ATM%E7%B3%BB%E7%BB%9F/","excerpt":"在复习完 Java SE 的全部基础知识点后，为了更加熟练掌握 Java 面向对象的特性，进一步掌握编程技巧和调试技巧，使用 Java 模拟实现一个银行 ATM 系统软件，共 Account.java 和 ATM.java 两个 Java 类。","text":"在复习完 Java SE 的全部基础知识点后，为了更加熟练掌握 Java 面向对象的特性，进一步掌握编程技巧和调试技巧，使用 Java 模拟实现一个银行 ATM 系统软件，共 Account.java 和 ATM.java 两个 Java 类。 一、银行 ATM 系统技术选型分析面向对象编程：每个用户对象要对应一个账户对象，所以需要设计账户类 Account。 使用集合容器：系统需要提供一个容器用于存储这些账户对象的信息，选用 ArrayList 集合。 程序流程控制：需要结合分支、循环、跳转等相关操作控制程序的业务逻辑。 使用常见API：内容比较，分析，数据处理等需要用到 String 等常用 API。 二、Account 账户类设计每个用户一个账户对象，需要设计账户类 Account，账户类至少包含（卡号、用户名、余额、取现额度、密码）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Account &#123; private String cardId; // 卡号 private String userName; // 用户名称 private String passWord; // 密码 private double money; // 账户余额 private double quotaMoney; // 每次取现额度限度。 public String getCardId() &#123; return cardId; &#125; public void setCardId(String cardId) &#123; this.cardId = cardId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; public double getQuotaMoney() &#123; return quotaMoney; &#125; public void setQuotaMoney(double quotaMoney) &#123; this.quotaMoney = quotaMoney; &#125;&#125; 三、首页设计需要定义一个 ArrayList 的集合用于存储账户对象。 1ArrayList accounts = new ArrayList&lt;&gt;(); 需要展示欢迎页包含2个功能：注册开户、登录账户。 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; // 2、创建一个集合对象，用于后期存入账户对象。 ArrayList&lt;Account&gt; accounts = new ArrayList&lt;&gt;(); // 3、展示系统欢迎页面 System.out.println(&quot;======欢迎您进入到黑马ATM系统===============&quot;); while (true) &#123; System.out.println(&quot;1、登录账户&quot;); System.out.println(&quot;2、注册账户&quot;); System.out.println(&quot;请您选择操作：&quot;); Scanner sc = new Scanner(System.in); int command = sc.nextInt(); switch (command)&#123; case 1: // 登录操作 login(accounts, sc); break; case 2: // 注册账户 register(accounts, sc); break; default: System.out.println(&quot;当前输入的操作不存在！&quot;); &#125; &#125; &#125; 四、用户开户功能实现开户功能应该独立定义成方法，并传入当前集合对象给该方法。 1public static void register(ArrayList&lt;Account&gt; accounts) &#123;…&#125; 需要提示用户输入个人信息，开户的卡号是系统自动生成的8位数。 1public static String createCardId()&#123;…&#125; 注意自动生成的卡号不能与其他用户的卡号重复。 最终把用户开户的信息封装成 Account 对象，存入到集合中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /** 用户开户功能 */ private static void register(ArrayList&lt;Account&gt; accounts, Scanner sc) &#123; System.out.println(&quot;==================欢迎您进入到开户操作======================&quot;); // 2、创建一个账户对象封装账户信息 Account acc = new Account(); // 1、录入用户账户信息 System.out.println(&quot;请您输入账户名称：&quot;); String userName =sc.next(); acc.setUserName(userName); while (true) &#123; System.out.println(&quot;请您输入账户密码：&quot;); String passWord =sc.next(); System.out.println(&quot;请您输入确认密码：&quot;); String okPassWord =sc.next(); if(okPassWord.equals(passWord))&#123; // 密码无问题 acc.setPassWord(okPassWord); break; &#125;else &#123; System.out.println(&quot;两次输入的密码不一致！&quot;); &#125; &#125; System.out.println(&quot;请您设置当次取现额度：&quot;); double quataMoney = sc.nextDouble(); acc.setQuotaMoney(quataMoney); // 关键点：为当前账户生成一个随机的8位数字作为卡号，卡号不能与其他用户的卡号重复。 String cardId = createCardId(accounts); acc.setCardId(cardId); // 3、把账户对象存入到集合容器对象中去 accounts.add(acc); System.out.println(&quot;恭喜您,&quot;+acc.getUserName()+&quot;先生/女士，您开户完成，您的卡号是：&quot; + acc.getCardId()); &#125; public static String createCardId(ArrayList&lt;Account&gt; accounts)&#123; while (true) &#123; String cardId = &quot;&quot;; // 随机8个数字 Random r = new Random(); for (int i = 1; i &lt;= 8 ; i++) &#123; cardId += r.nextInt(10); &#125; // 判断这个卡号是否重复：根据卡号去查询账户对象 Account account = getAccountByCardId(cardId , accounts); if(account == null)&#123; return cardId; &#125; &#125; &#125; public static Account getAccountByCardId(String cardId , ArrayList&lt;Account&gt; accounts)&#123; for (int i = 0; i &lt; accounts.size(); i++) &#123; Account acc = accounts.get(i); if(acc.getCardId().equals(cardId))&#123; return acc; &#125; &#125; return null; &#125;&#125; 五、用户登录功能和界面实现定义方法： 1public static void login(ArrayList&lt;Account&gt; accounts) &#123;…&#125; 需要根据卡号去集合中查询对应的账户对象。如果找到了账户对象，说明卡号存在，继续输入密码。如果密码也正确，则登录成功。 用户登录成功后，需要进入用户操作页。查询就是直接展示当前登录成功的账户对象的信息。退出账户是需要回到首页的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** 用户登录功能 */private static void login(ArrayList&lt;Account&gt; accounts, Scanner sc) &#123; System.out.println(&quot;==================欢迎您进入到登录操作======================&quot;); if(accounts.size() &gt; 0)&#123; while (true) &#123; System.out.println(&quot;请您输入登录的卡号：&quot;); String cardId = sc.next(); // 2、根据卡号去集合中查询是否存在账户对象 Account acc = getAccountByCardId(cardId , accounts); // 判断账户对象是否存在，存在说明卡号正确 if(acc != null)&#123; while (true) &#123; // 3、判断密码是否正确 System.out.println(&quot;请您输入登录的密码：&quot;); String passWord = sc.next(); if(acc.getPassWord().equals(passWord))&#123; // 登录成功了！ System.out.println(&quot;欢迎你：&quot; + acc.getUserName() + &quot;先生/女士进入系统，您可开始办理你的业务了!&quot;); // 展示登录成功后的操作界面。 showCommand(sc, acc, accounts); return; &#125;else &#123; System.out.println(&quot;您的密码不正确！&quot;); &#125; &#125; &#125;else &#123; System.out.println(&quot;卡号不存在，请确认！&quot;); &#125; &#125; &#125;else &#123; System.out.println(&quot;当前系统无任何账户，请先注册再登录！&quot;); &#125;&#125;/** 登录后展示的界面 */private static void showCommand(Scanner sc, Account acc, ArrayList&lt;Account&gt; accounts) &#123; while (true) &#123; System.out.println(&quot;==================欢迎您进入到操作界面======================&quot;); System.out.println(&quot;1、查询&quot;); System.out.println(&quot;2、存款&quot;); System.out.println(&quot;3、取款&quot;); System.out.println(&quot;4、转账&quot;); System.out.println(&quot;5、修改密码&quot;); System.out.println(&quot;6、退出&quot;); System.out.println(&quot;7、注销账户&quot;); System.out.println(&quot;请您输入操作命令：&quot;); int command = sc.nextInt(); switch (command) &#123; case 1: // 查询账户信息展示 showAccount(acc); break; case 2: // 存款 depositMoney(acc,sc); break; case 3: // 取款 drawMoney(acc,sc); break; case 4: // 转账 transferMoney(acc, accounts, sc); break; case 5: // 修改密码 updatePassWord(acc, sc); return; // 跳出当前操作的方法，最终回到首页 case 6: // 退出 回到首页 System.out.println(&quot;欢迎下次继续光临！！&quot;); return; // 结束登录后的全部操作 case 7: // 注销账户 accounts.remove(acc); // 从集合对象中删除当前账户对象。 System.out.println(&quot;您的账户已经完成了销毁，您将不可以进行登录了！&quot;); return; default: System.out.println(&quot;您的操作命令有误！&quot;); &#125; &#125;&#125; 六、用户转账、存款、取款功能转账功能要分析对方账户是否存在的问题。还要分析自己的余额是否足够的问题。 存款和取款都是拿到当前用户的账户对象，通过调用账户对象的 set 方法修改其余额。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216/** * 从当前账户对象中把金额转给其他账户对象。 * @param acc * @param accounts * @param sc */private static void transferMoney(Account acc, ArrayList&lt;Account&gt; accounts, Scanner sc) &#123; // 1、判断自己的账户中是否有钱 if(acc.getMoney() &lt;= 0)&#123; System.out.println(&quot;您自己都没钱，就别转了吧！&quot;); return; &#125; // 2、判断总账户数量是否大于等于2个。 if(accounts.size() &gt;= 2)&#123; while (true) &#123; // 3、让当前用户输入对方的账号进行转账 System.out.println(&quot;请您输入对方卡号：&quot;); String cardId = sc.next(); // 4、根据卡号查询出集合中的账户对象 Account otherAcc = getAccountByCardId(cardId , accounts); // 5、判断账户对象是否存在，而且这个账户对象不能是自己。 if(otherAcc != null)&#123; // 6、判断当前账户是否是自己。 if(acc.getCardId().equals(otherAcc.getCardId()))&#123; System.out.println(&quot;不能给自己账户转账！&quot;); &#125;else &#123; // 7、正式进入到转账逻辑了 // 黑马刘德华 String rs = &quot;*&quot; + otherAcc.getUserName().substring(1); System.out.println(&quot;请您确认[&quot;+rs +&quot;]的姓氏来确认！&quot;); System.out.println(&quot;请您输入对方的姓氏：&quot;); String preName = sc.next(); if(otherAcc.getUserName().startsWith(preName))&#123; // 认证通过 while (true) &#123; System.out.println(&quot;请您输入转账的金额（您最多可以转账：&quot; + acc.getMoney() +&quot;元）：&quot;); double money = sc.nextDouble(); if(money &gt; acc.getMoney())&#123; System.out.println(&quot;你不听话，没有这么多钱可以转！&quot;); &#125;else &#123; // 开始转 acc.setMoney(acc.getMoney() - money); // 更新自己账户 otherAcc.setMoney(otherAcc.getMoney() + money); System.out.println(&quot;您已经完成转账！您当前还剩余：&quot; + acc.getMoney()); return; &#125; &#125; &#125;else &#123; System.out.println(&quot;您输入对方的信息有误！&quot;); &#125; &#125; &#125;else &#123; System.out.println(&quot;您输入的转账卡号不存在！&quot;); &#125; &#125; &#125;else &#123; System.out.println(&quot;当前系统中没有其他账户可以转账，去注册一个账户吧！&quot;); &#125;&#125;private static void drawMoney(Account acc, Scanner sc) &#123; System.out.println(&quot;==================欢迎进入账户取款操作======================&quot;); // 1、判断账户的余额是否高于等于100 double money = acc.getMoney(); if(money &gt;= 100) &#123; while (true) &#123; // 2、输入取钱的金额 System.out.println(&quot;请您输入取钱的金额：&quot;); double drawMoney = sc.nextDouble(); // 3、判断取钱金额是否超过了当次限额 if(drawMoney &gt; acc.getQuotaMoney())&#123; System.out.println(&quot;您当前取款金额超过了每次限额！&quot;); &#125;else &#123; // 4、判断当前取钱金额是超过了账户的余额 if(drawMoney &gt; money)&#123; System.out.println(&quot;当前余额不足！当前余额是：&quot; + money); &#125;else &#123; // 更新账户余额 acc.setMoney(money - drawMoney); System.out.println(&quot;您当前取钱完成，请拿走你的钱，当前剩余余额是：&quot; + acc.getMoney()); break; &#125; &#125; &#125; &#125;else &#123; System.out.println(&quot;您当前账户余额不足100元，存钱去吧！&quot;); &#125;&#125;private static void depositMoney(Account acc, Scanner sc) &#123; System.out.println(&quot;==================欢迎进入账户存款操作======================&quot;); System.out.println(&quot;请您输入存款金额：&quot;); double money = sc.nextDouble(); acc.setMoney(acc.getMoney() + money); showAccount(acc);&#125;private static void showAccount(Account acc) &#123; System.out.println(&quot;==================您当前账户详情信息如下======================&quot;); System.out.println(&quot;卡号：&quot; + acc.getCardId()); System.out.println(&quot;户主：&quot; + acc.getUserName()); System.out.println(&quot;余额：&quot; + acc.getMoney()); System.out.println(&quot;当次取现额度：&quot; + acc.getQuotaMoney());&#125;/** * 从当前账户对象中把金额转给其他账户对象。 * @param acc * @param accounts * @param sc */private static void transferMoney(Account acc, ArrayList&lt;Account&gt; accounts, Scanner sc) &#123; // 1、判断自己的账户中是否有钱 if(acc.getMoney() &lt;= 0)&#123; System.out.println(&quot;您自己都没钱，就别转了吧！&quot;); return; &#125; // 2、判断总账户数量是否大于等于2个。 if(accounts.size() &gt;= 2)&#123; while (true) &#123; // 3、让当前用户输入对方的账号进行转账 System.out.println(&quot;请您输入对方卡号：&quot;); String cardId = sc.next(); // 4、根据卡号查询出集合中的账户对象 Account otherAcc = getAccountByCardId(cardId , accounts); // 5、判断账户对象是否存在，而且这个账户对象不能是自己。 if(otherAcc != null)&#123; // 6、判断当前账户是否是自己。 if(acc.getCardId().equals(otherAcc.getCardId()))&#123; System.out.println(&quot;不能给自己账户转账！&quot;); &#125;else &#123; // 7、正式进入到转账逻辑了 // 黑马刘德华 String rs = &quot;*&quot; + otherAcc.getUserName().substring(1); System.out.println(&quot;请您确认[&quot;+rs +&quot;]的姓氏来确认！&quot;); System.out.println(&quot;请您输入对方的姓氏：&quot;); String preName = sc.next(); if(otherAcc.getUserName().startsWith(preName))&#123; // 认证通过 while (true) &#123; System.out.println(&quot;请您输入转账的金额（您最多可以转账：&quot; + acc.getMoney() +&quot;元）：&quot;); double money = sc.nextDouble(); if(money &gt; acc.getMoney())&#123; System.out.println(&quot;你不听话，没有这么多钱可以转！&quot;); &#125;else &#123; // 开始转 acc.setMoney(acc.getMoney() - money); // 更新自己账户 otherAcc.setMoney(otherAcc.getMoney() + money); System.out.println(&quot;您已经完成转账！您当前还剩余：&quot; + acc.getMoney()); return; &#125; &#125; &#125;else &#123; System.out.println(&quot;您输入对方的信息有误！&quot;); &#125; &#125; &#125;else &#123; System.out.println(&quot;您输入的转账卡号不存在！&quot;); &#125; &#125; &#125;else &#123; System.out.println(&quot;当前系统中没有其他账户可以转账，去注册一个账户吧！&quot;); &#125;&#125;private static void drawMoney(Account acc, Scanner sc) &#123; System.out.println(&quot;==================欢迎进入账户取款操作======================&quot;); // 1、判断账户的余额是否高于等于100 double money = acc.getMoney(); if(money &gt;= 100) &#123; while (true) &#123; // 2、输入取钱的金额 System.out.println(&quot;请您输入取钱的金额：&quot;); double drawMoney = sc.nextDouble(); // 3、判断取钱金额是否超过了当次限额 if(drawMoney &gt; acc.getQuotaMoney())&#123; System.out.println(&quot;您当前取款金额超过了每次限额！&quot;); &#125;else &#123; // 4、判断当前取钱金额是超过了账户的余额 if(drawMoney &gt; money)&#123; System.out.println(&quot;当前余额不足！当前余额是：&quot; + money); &#125;else &#123; // 更新账户余额 acc.setMoney(money - drawMoney); System.out.println(&quot;您当前取钱完成，请拿走你的钱，当前剩余余额是：&quot; + acc.getMoney()); break; &#125; &#125; &#125; &#125;else &#123; System.out.println(&quot;您当前账户余额不足100元，存钱去吧！&quot;); &#125;&#125;private static void depositMoney(Account acc, Scanner sc) &#123; System.out.println(&quot;==================欢迎进入账户存款操作======================&quot;); System.out.println(&quot;请您输入存款金额：&quot;); double money = sc.nextDouble(); acc.setMoney(acc.getMoney() + money); showAccount(acc);&#125;private static void showAccount(Account acc) &#123; System.out.println(&quot;==================您当前账户详情信息如下======================&quot;); System.out.println(&quot;卡号：&quot; + acc.getCardId()); System.out.println(&quot;户主：&quot; + acc.getUserName()); System.out.println(&quot;余额：&quot; + acc.getMoney()); System.out.println(&quot;当次取现额度：&quot; + acc.getQuotaMoney());&#125; 七、用户密码修改功能、销户功能修改密码就是把当前对象的密码属性使用 set 方法进行更新。销户是从集合对象中删除当前对象，并回到首页。 123456789101112131415161718192021222324252627282930/** 修改当前账户对象的密码 * @param acc */private static void updatePassWord(Account acc, Scanner sc) &#123; // 1、判断旧密码是否正确 while (true) &#123; System.out.println(&quot;请您输入当前密码认证：&quot;); String passWord = sc.next(); if(acc.getPassWord().equals(passWord))&#123; while (true) &#123; // 2、输入新密码 System.out.println(&quot;请您输入新密码：&quot;); String newPassWord = sc.next(); System.out.println(&quot;请您确认新密码：&quot;); String okPassWord = sc.next(); // 3、比对两次密码是否一致 if(newPassWord.equals(okPassWord))&#123; acc.setPassWord(okPassWord); System.out.println(&quot;密码已经修改成功，请重新登录！&quot;); return; &#125;else &#123; System.out.println(&quot;两次密码不一致！&quot;); &#125; &#125; &#125;else &#123; System.out.println(&quot;您输入的密码有误。请重新确认密码！&quot;); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[]},{"title":"Accenture Coding Virtual Experience Program","slug":"Accenture-Coding-Virtual-Experience","date":"2022-01-15T16:00:00.000Z","updated":"2022-05-05T12:51:34.433Z","comments":true,"path":"Accenture-Coding-Virtual-Experience/","link":"","permalink":"http://blog.zhuangzhihao.top/Accenture-Coding-Virtual-Experience/","excerpt":"The Accenture Know-the-Code Virtual Experience Program covers the fundamentals of software development, including object-oriented programming, code refactoring, and agile delivery. It empowers me to explore what a career in software development could look like at Accenture while practicing my coding skills. The following are the notes I took during this virtual experience.","text":"The Accenture Know-the-Code Virtual Experience Program covers the fundamentals of software development, including object-oriented programming, code refactoring, and agile delivery. It empowers me to explore what a career in software development could look like at Accenture while practicing my coding skills. The following are the notes I took during this virtual experience. Task 1: Object Oriented ProgrammingBackground Information Recently, a company has brought on Accenture to help with the development of its e-commerce website written in Java using the Spring Boot framework. The first task they need help with is searching for products One of the UX designers at Accenture has already implemented the new search capability in the UI My responsibility is to implement the search capability in our backend Java app Requirements Expose an HTTP GET request on the path /api/products/search The request should take a single parameter named “query” which will be the text that was entered in the search bar The request will return a Collection of ProductItem which are the matching products for the search Implement a new controller to handle searching Download and unzip the mock-company-webapp codebase Open the application in IDEA with Gradle support Follow the README.md instructions for setting up the development environment Implement the “search” method of the class SearchController, the relevant code is outlined with a TODO comment The controller should use the “productItemRepository” to interface with the product database Review the tests and implement the controller to the spec Practical skills gained Object Oriented Programming Java Spring Task 2: Code RefactoringBackground Information Now we’ve identified some code in the ReportController class that seems to be doing similar product searching I need to refactor the SearchController logic into a new SearchService class that can be used in the SearchController as well as in the ReportController Requirements Logic moved from SearchController to SearchService SearchController and ReportController both updated to use the SearchService All unit tests pass Refactor controllers to a shared service Follow the README.md instructions for setting up the development environment Create the new SearchService class in the “services” package. All of the search logic from the SearchController should be moved into a function in this class for reusability. The relevant code is outlined with a TODO comment Using @Autowired, inject the SearchService into the SearchController and ReportController Refactor both controller classes to use the service by rewriting their functions to use the new service Ensure unit tests all pass Practical skills gained Java Spring Task 3: Continuous IntegrationBackground Information Continuous Integration is the practice of automating the integration of code changes from multiple contributors into a single software project It’s a primary DevOps best practice, allowing developers to frequently merge code changes into a central repository where building and test runs can occur Use the most popular Continuous Integration tool, Jenkins Creating a Jenkinsfile that will build and test the application on all branches of the repository Requirements GitHub account created, Git CLI setup, mock-company-webapp repository forked and cloned Jenkinsfile defined with stages setting it up to run on commit to any branch in the repository Continuous Integration server runs build/test and succeeds Change made to code that breaks test Continuous Integration server runs build/test and fails Simulating Jenkins using the Jenkinsfile Runner Action in a GitHub Workflow Create an account with GitHub and fork the mock-company-webapp repository Setup the Git CLI on workstation and “clone” the repository you forked to workstation Install the Pipelines application from the GitHub marketplace to use Jenkins directly use the Simulated Jenkins for GitHub link to add a .github/workflows/workflow.yml to the repository. Add the following stages to the Jenkinsfile, the relevant code is outlined with a TODO comment. Build: ./gradlew assemble Test: ./gradlew test Continue to tweak the Jenkinsfile until the build is successful Change the SearchService to always return Collections.emptyList() in order to break the tests. Commit the change and validate the Continuous Integration build fails which proves that we’ve properly set up Continuous Integration guard rails, that will catch failing tests each time a commit is made by a developer Practical skills gained Continuous Integration Jenkins DevOps Task 4: Agile PlanningBackground Information In an Agile planning session, developers are given a set of large software features that they then must break up into smaller units of work, called stories, that can be completed within a one to three week period, called a sprint A story is an informal, general explanation of a software feature written from the perspective of the end user or customer and is made up of the following components: Who the feature is for What they need Why they need it What shows it’s done Requirements Stories are written in the following format: As a &lt;who the feature is for&gt;, I need to be able to &lt;what they need&gt; so I can &lt;why they need it&gt; The “what shows it’s done”, called acceptance criteria, must be provided with the story as well Stories are then pointed or sized which means to assign some kind of value indicating the difficulty of implementing the story Use a T-Shirt size strategy assigning a value of small/medium/large to each story It’s very important that stories are broken down as small as they can be so try and keep them either small or medium This allows for better concurrency throughout the sprint and easier completion within a single sprint planning a sprint to implement the checkout feature of the site Create a document that defines around 10 to 20 stories around the checkout feature Pull in a subset of these stories based on our capacity to work on in the next sprint Make sure the stories are broken up as small as possible, and the acceptance criteria is testable Practical skills gained Agile Methodology Software Development Lifecycle (SDLC)","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.zhuangzhihao.top/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.zhuangzhihao.top/tags/Spring-Boot/"},{"name":"Gradle","slug":"Gradle","permalink":"http://blog.zhuangzhihao.top/tags/Gradle/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://blog.zhuangzhihao.top/tags/Jenkins/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2021-12-09T16:00:00.000Z","updated":"2022-05-23T09:49:40.093Z","comments":true,"path":"计算机网络/","link":"","permalink":"http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。","text":"计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。 计算机网络体系结构计算机网络概述 计算机网络就是一些互联的、自治的计算机系统的集合。 自治计算机就是能够进行自我管理、配置和维护的计算机。 计算机网络包括硬件、软件、协议三大部分。 硬件由主机、通信处理机、通信线路和交换设备组成。 从工作方式上看，计算机网络可分为边缘部分和核心部分。 从功能组成上看，计算机网络由通信子网和资源子网两部分构成。 通信子网包括物理层、数据链路层和网络层。 数据通信是计算机网络最基本和最重要的功能。 资源共享包括数据资源、软件资源以及硬件资源。 计算机网络体系结构与参考模型 实体是任何可发送或接收信息的硬件或软件进程。 对等层是不同机器上的同一层，对等实体是同一层上的实体。 协议是控制2个对等实体进行通信的规则。 接口又称服务访问点，没有接口就不能提供服务。从物理层开始，每一层都向上层提供服务访问点。 服务数据单元 SDU，协议控制信息 PCI，接口控制信息 ICI。 协议数据单元 PDU，表示的是同等层对等实体间传送的数据单元。n-SDU+n-PCI=n-PDU，n-PDU=(n-1)-SDU 接口数据单元 IDU，表示的是在相邻层接口间传送的数据单元。n-SDU+n-ICI=n-IDU 服务至下层为相邻上层提供的功能调用。只有那些能够被高一层实体看得见的功能才成为服务。 面向连接的服务（TCP），面向无连接的服务（IP和UDP）。 第n层的实体使用第n-1层的服务，向第n+1层提供本层的服务。该服务是第n层及其下各层所提供的服务的总和。 最高层向用户提供服务，下一层提供服务的实现细节对上一层透明。 OSI参考模型具有7层结构，而TCP/IP模型仅有4层结构。 应用层（用户对用户），提供系统与用户的接口。文件传输、访问和管理、电子邮件服务。FTP，smtp，pop3，HTTP。 传输层（应用对应用，进程对进程），负责主机中2个进程之间的通信。为端到端连接提供可靠的运输服务、流量控制、差错控制、服务质量管理。TCP、udp、ARQ。 网络层（主机对主机），为传输层提供服务、组包和拆包、路由选择、拥塞控制。ICMP、Arp、RARP、IP、IGMP。 网络接口层 = 数据链路层 + 物理层 数据链路层，将网络层传下来的IP数据报组装成帧数。PPP、HDLC。 物理层，为数据端设备提供传送数据通路，传输比特流。 应用层 = 应用层 + 表示层 + 会话层 会话层的主要功能是在2个节点间建立维护和释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传送。 表示层负责处理在2个内部数据表示结构不同的通信系统间交换信息的表示格式，数据压缩及解压。 TCP/IP模型没有明确区分服务、接口、协议，且网络层仅有无连接。OSI参考模型网络层有连接和无连接，但传输层仅面向连接。 计算机网络性能指标 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 数据传输率是由总时延决定的，而带宽仅决定了发送时延。 发送时延 = 数据帧长度（bit）/ 发送速率（bit/s） 传播时延 = 信道长度（m）/ 电磁波在信道上的传播速度（m/s） 时延带宽积 = 传播时延 × 带宽 利用率包括信道利用率和网络利用率（全网络的信道利用率的加权平均值）。 1 MB/s = 8 Mbit/s 物理层通信基础 数据是传送信息的实体。而信号是数据的电气或电磁的表现。 基带对应数字信号，宽带对应模拟信号。 数据传输方式分为串行传输和并行传输。通信方式分为同步通信和异步通信。通信模式分为单向通信、双向交替通信、双向同时通信。 波特率（码元传输速率）表示单位时间内数字通信系统所传输的码元个数，单位波特（Baud）。 比特率（信息传输速率）表示单位时间内通信数字系统所传输的二进制码元个数，单位比特数（bit/s）。 每比特只能表示两种信号变化，可看成二进制。 带宽表示在单位时间内从网络中的某一点到另一点所能通过的最高数据率（网络的通信线路所能传送数据的能力）。单位比特每秒（bit/s）。 在通信领域，带宽是指信号最高频率与最低频率之差（Hz）。因此将模拟信号转换成数字信号时，采样频率必须大于等于最大频率f的2倍。 奈奎斯特定理给出了在无噪声情况下码元的最大传输速率。f表示理想低通信道的带宽。N表示每个码元的离散电平的数目。 $C{\\max }=f_1*\\log {2}N=2f*\\log _{2}N$ 信噪比是信号的平均功率和噪声的平均功率之比。S/N（dB）‘ 香农公式给出了信号传输速率的极限。W为信道的带宽。 $C{\\max }=W*\\log {2}\\left( 1+\\dfrac{S}{N}\\right)$ 要使信息的极限传输速率提高，就必须提高信道的带宽或信道中的信噪比。实际信道的传输速率要比极限速率低不少。 模拟数据和数字数据都可以转化成模拟信号（调制）或数字信号（编码）。 数据传输方式包括电路交换、报文交换和分组交换。 电路交换一定面向连接。通信时延小、实时性强、有序传输，但信道利用率低、缺乏统一标准、灵活性差。 报文交换，报文携带有目的地址、源地址。无需建立连接、动态分配线路，但报文大小没限制，要求网络节点需要有较大的存储缓存空间。 分组交换仍采用存储转发传输方式。将一个长报文分割成若干个较短的分组。加速传输、简化存储管理、减少出错概率和重发数据量，但存在传输时延、可能出现失序、丢失或重复分组现象。 TCP可以向应用层提供面向连接的服务，而UDP在传输层是无连接的。 分组交换可分为面向连接的虚电路方式和面向无连接的数据报方式，二者都由网络层提供。 数据报无需建立连接、提高吞吐量、对故障适应力强，每个分组包含完整的源地址和目的地址，可靠通信由用户主机来保证。 虚电路时延小、按序到达，每个分组包含一个虚电路号，可靠通信由网络来保证。 传输介质 传输介质分为导向性传输介质和非导向性传输介质。 导向性传输介质包含双绞线、同轴电缆和光纤。 双绞线分为无屏蔽双绞线和屏蔽双绞线。 同轴电缆分为基带同轴电缆（50Ω）和宽带同轴电缆（75Ω）。 光纤分为单模光纤（远距离）和多模光纤（近距离）。 非导向性传输介质有短波、微波、红外线与可见光等。 传输介质并不是物理层，在传输介质中传输的是信号。物理层主要的功能就是确定与传输介质的接口有关的一些特性，即物理层接口的特性，如机械特性、电气特性、功能特性、规程特性。 物理层设备主要包含中继器和集线器。放大器放大的是模拟信号，中继器放大的是数字信号。 集线器实际就是一个多端口的中继器（Hub）。集线器在一个时钟周期内只能传输一组信息。集线器不能隔离冲突域。 通过中继器或集线器连接起来的几个网段仍然是一个局域网。使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用CSMA/CD协议，共享逻辑上的总线。 数据链路层数据链路层的功能 数据链路层在物理层所提供的服务的基础上向网络层提供服务，分为无确认的无连接服务、有确认的无连接服务和有确认的有连接服务。 数据链路层的主要功能分为链路管理、帧同步、差错控制、透明传输。 当2个主机互相传送信息时，网络层的分组。必须封装成帧，并以帧的格式进行传送。即将一段数据的前后分别添加首部和尾部形成帧，首部和尾部中有很多控制信息，如帧定界。 组帧 组帧方法分为字符计数法、字节填充的首尾界符法、比特填充的首尾标志法、物理编码违例法。 在网络中以帧为最小单位进行传输，所以组帧既要有首部又要加尾部，确定接收端清楚该帧在一串比特流中从哪里开始、到哪里结束。 字符计数法用一个特殊的字符表示一帧的开始，用一个计数字段表明该帧包含的字节数，计数字段提供的字节数包含自身所占的一个字节。 首尾界符法选定2个字符（SOH/EOT）作为每一个帧的开始和结束。字符填充的首尾界符法是将数据中可能出现的控制字符SOH和EOT在接收端不解释为控制字符。 比特填充的首尾标志法使用01111110作为帧的开始和结束标志。零比特填充法每有5个连续的1马上在其后插入0，接收方每收到5个连续的1自动删除后面紧跟的0恢复原始数据。 物理编码违例法利用物理介质上的编码的违法标志来区分帧的开始和结束，例如在曼彻斯特编码中高-高和低-低电平的编码方式是无效的，用来作为帧的起始和结束标志。 差错控制 检错编码分为奇偶校验码和循环冗余码。 奇偶校验码是在信息码后面加1位校验码，分为奇校验和偶校验。奇校验是添加1位校验码后使得整个码字里面1的个数是奇数。 循环冗余码（CRC）是在发送端产生一个冗余码，附加在信息位后面一起发送到接收端，接收端收到的信息按发送端形成循冗余码同样的算法进行校验，如果发现错误则通知发送端重发。 CRC的本质是模-2除法的余数，采用的除数不同，CRC的类型也就不一样。 循环冗余码具有r检测位的多项式能够检测出所有小于或等于r的突发错误，长度大于r+1的错误逃脱的概率是 $\\dfrac{1}{2^{r}}$。 常见的纠错编码是海明码，在 k 位信息字段中插入若干位数据用于监督码字里的哪一位数据发生变化，具有一位纠错能力。 确认校验码的位数 r：$2^{r}-1\\geq k+r$ 校验码$P_i$在编码中的位置为$2^{i-1}$ 出错位$e_n$等于所有有关位$M_n$互为异或，求出$P_i$，按序写出海明码 校验海明码：出错位$e_n$等于所有有关位$M_n$互为异或，求出$e_n$ 出错位$e_n$对应的十进制数就是出错的位数 流量控制与可靠传输机制 流量控制就是要控制发送方发送数据的速率使接收方来得及接收，分为停止-等待流量控制和滑动窗口流量控制。 停止-等待流量控制就是发送方发出一帧，等接收方收到一帧后返回应答信号，再发送下一帧。 滑动窗口流量控制允许一次发送多个帧。在任意时刻发送方都维持一组连续的允许发送的帧的序号，称为发送窗口。同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送端每收到一个帧的确认，发送窗口就向前移动1个帧的位置。 只有在接收窗口向前滑动时，发送窗口才有可能向前滑动。 只要当接收窗口大小为1时，则可保证帧按序接受。 端到端的可靠传输就是在传输层使用面向连接的TCP，而不是数据链路层。 可靠传输一般使用确认和超时重传两种机制共同完成（ARQ自动请求重发）。 可靠传输机制包括停止-等待协议、后退N帧协议和选择重传协议。 停止等待协议就是发送窗口和接收窗口大小均为1。帧一般分为数据帧和确认帧。 后退N帧协议：发送方连续发送若干个数据帧，如果收到接收方的确认帧接着发送数据，如果某个帧出错，接收方只能简单丢弃该帧及后续所有帧。增加吞吐量，但造成一定浪费。 后退N帧协议接收窗口大小=1，$1&lt;发送窗口大小W_{T}\\leq 2^{n}-1$。n为对帧编号的比特数。 选择重传（SR）协议：当一帧出错时，后续帧先存入接收方的缓冲区中,同时要求发送方重传出错帧。提高信道利用率但增加缓冲空间。 选择重传协议的接收窗口尺寸和发送窗口尺寸都大于1，以便能一次性接受多个帧。发送窗口的最大尺寸也不能超过序列号范围的一半。当发送窗口等于接收窗口=$2^{n}-1$时达到最大效率。 按序到达的且没有被交付给主机的帧被放在接收缓存里。不按序到达的数据且没有错误的帧放在接收窗口里。不直接给主机，等缺少的帧收到后再一起放到接收缓存。 介质访问控制 静态分配信道的方法是信道划分介质访问控制。动态分配信道的方法分为随机访问介质访问控制和轮询访问介质访问控制。 多路复用技术是在一条介质上同时携带多个传输信号，使多个计算机或终端设备共享信道资源，提高信道的利用率。实现信道划分介质访问控制。 信道划分介质访问控制分为频分多路复用、时分多路复用、波分多路复用和码分多路复用。 频分多路复用时如果复用数增加，那么信号的频率带宽增加。 统计时分复用是一种动态的时间分配。 波分多路复用就是光的频分多路复用。 码分多路复用，又称为码分多址（CDMA），既共享信道的频率又共享时间，主要用于无线通信系统。 任意2个站点的码片向量的规格化内积一定为1。任意站点的码片向量与该码片向量自身的规格化内积一定为1。任何站点的码片向量和该码片的反码向量的规格化内积一定为负1。 动态划分信道分为随机接入（争用性协议）和受控接入。 ALOHA协议：不检测发送数据，一段时间没收到确认即为发送冲突，发生冲突的节点等待一段随机事件后再发送数据。 时分ALOHA：所有节点的时间被划分为间隔相同的时隙，并规定每个节点就会等到下一个时隙到来时才可发送数据。 载波侦听多路访问（CSMA）协议：每个节点发送数据之前，都使用载波侦听技术来判定通信信道是否空闲，在局域网中被广泛的应用。 1-坚持CSMA：监听到信道空闲时，立即发送数据，否则继续监听。 p-坚持CSMA：监听到信道空闲时，以概率P发送数据，以概率(1-P)延迟一段时间并重新监听。 非坚持CSMA。监听到信道空闲时，立即发送数据，否则延迟一段随机的时间再重新监听。 CSMA/CD协议（带冲突检测的载波侦听多路访问协议）：检测超过发送站点本身发送的载波信号的幅度，由此判断出冲突的存在，并向总线上发一串阻塞信号。 CSMA/CD工作流程：先听后发，边听边发，冲突停发，随机重发。 CSMACD用于信道使用半双工的网络环境，而对于使用全双工的网络环境，则无需采用这种介质访问控制技术。 争用期（$2\\tau$）：以太网端到端的往返时延，又称冲突窗口或碰撞窗口。只有经过争用期还没有检测到冲突，才能肯定这次发送不会发生冲突。 以太网规定最短帧长为64B，凡长度小于64B的都是由于冲突而异常停止的无效帧。以太网端到端的单程时延实际上小于争用期的一半（25.6μs）。 最短有效帧长和最远2个站的距离及传输速率成正比。 截断二进制指数类型退避算法：发生碰撞的站在停止发送数据后要推迟一个随机时间才能发送数据，基本退避时间一般取争用期（$2\\tau$），重传需要推迟的平均时间随重传次数的增大而增大。 CSMA/CA协议主要用在无线局域网中，在CSMA的基础上增加了冲突避免的功能。 CSMA/CA协议要对正确接收到的数据帧进行确认。 轮询访问介质访问控制主要用于在令牌环局域网中。典型的轮询访问介质访问控制协议就是令牌传递协议。 局域网 局域网（local area network，LAN）是指一个较小范围内的多台计算机或其他通信设备通过双绞线、同轴电缆等连接介质互联起来，以达到资源和信息共享目的的互联网络。 局域网有较高的数据率、较低的时延和较小的误码率，具有广播功能，便于系统的扩展和演变。 局域网的主要技术要素包括网络拓扑结构传输介质与介质访问控制方法。局域网的主要拓扑结构包括星型网环形网总线型网和树型网（星型网和总线型网的结合）。双绞线为局域网的主流传输介质。 局域网的主要介质访问控制方法包括CSMA/CD、令牌总线和令牌环。前两种作用于总线型网，令牌环作用于环形网。 局域网对应OSI参考模型中的数据链路层和物理层，并将数据链路层拆分为2个子层，逻辑链路控制（LLC）子层和媒体接入控制（MAC）子层。 以太网采用总线拓扑结构。所有计算机都共享一条总线信息，以广播方式发送，使用CSMACD技术对总线进行访问控制。 以太网采用无连接的工作方式，不对发送的数据帧进行编号，也不要求对发送方发送确认。以太网提供的服务是不可靠服务，所以有重传机制，且差错纠正由传输层的TCP完成。 数据传输速率达到或超过100Mbit/s的以太网称为高速以太网。100base-T以太网称为快速以太网。吉比特以太网成为千兆以太网,允许在全双工和半双工两种方式工作。在半双工方式下工作时必须使用CSMA/CD协议进行冲突检测。 无线局域网分为有固定基础设施和无固定基础设施两类。IEEE802.11规定有固定基础设施的无线局域网的最小构建为基本服务集（BSS），BSS中的基站称为接入点（AP）。 基本服务集可以是孤立的，也可以通过接入点连接到一个主干分配系统（DS）构成扩展的服务器（ESS），ESS还可通过门桥（portal）设备为无线用户提供到非IEEE802.11无线局域网的接入。 IEEE802.11标准中的物理层有跳频扩频（FHSS）、直接序列扩频（DSS）、红外线（IR）3种实现方法。 IEEE802.11标准中的MAC层在物理层上，包括2个子层，从下往上依次为分布协调功能（DCF）子层和点协调功能（PCF）子层。在带有碰撞避免功能的CSMA/CA协议的基础上增加确认机制。 广域网是覆盖范围很广的长距离网络，由一些节点交换机以及连接这些交换机的链路组成。节点交换机完成分组存储转发的功能。 广域网是通过交换机连接多个局域网组成，因特网是由广域网和局域网共同通过路由器相连。 局域网使用的协议主要在数据链路层，而广域网使用的协议主要在网络层。 广域网的路由选择协议负责搜索分组从某个节点到目的节点的最佳传输路由，以便构成路由表，从路由表再构造出转发分组的转发表，分组是通过转发表进行转发的。 点对点协议（PPP）由一个将IP数据报封装到串行链路的方法、一个用于建立配置和测试数据链路连接的链路控制协议（LCP）和一套用来建立和配置不同的网络层协议的网络控制协议（NCP），其中每个协议支持不同的网络层协议。 PPP是一个面向字节的协议，不需要纠错（只负责检错）、流量控制（由TCP负责）、序号（不可靠的传输协议）、多点线路，只支持全双工链路。 高级数据链路控制（HDLC）协议是ISO制定的面向比特的数据链路控制协议，可适用于链路的非平衡配置（一个主站控制整个链路的工作）和平衡配置（链路两端2个站都是复合站）。 PPP帧比HDLC协议帧多一个2字节的协议字段，当协议字段值为Ox0021时表示信息字段是IP数据报。 PPP不使用序号和确认机制，只保证无差错接收（通过硬件进行循环冗余码校验），HDLC协议的信息帧使用了编号和确认机制。 数据链路层设备 在物理层拓展局域网使用中继器和集线器扩大冲突域，但总吞吐量未提高，且不能互联使用不同以太网技术的局域网。 在数据链路层扩展局域网使用网桥，具有过滤帧的功能。网桥至少有2个端口，每一个端口与一个网段相连。 网桥从一个端口接收一个帧，先暂存到缓存中，若未出现差错，且发往目的站MAC地址属于另一网段，则通过查找转发表将该帧从对应端口发出。 网桥过滤通信量、扩大物理范围、提高可靠性、可互连不同物理层、不同MAC子层和不同速率的以太网，但存储转发增加时延，且在MAC层并没有流量控制功能，用户过多会因传播过多的广播信息而产生网络拥塞（广播风暴）。 网桥包括透明网桥（选择的不是最佳路由）和源选径网桥（选择的是最佳路由）。最佳路由并不一定是经过路由器最少的路由，也可以是发送帧往返时间最短的路由（实现负载平衡）。 局域网交换机实质上是工作在数据链路层的多端口网桥。局域网交换机的每个端口都直接与主机或集线器相连，并且一般都工作在全双工方式。 交换机总容量 = 端口数×每个端口带宽（半双工）or 端口数×每个端口带宽×2（全双工） 交换机分为直通式交换和存储转发式交换，工作原理与网桥类似。 网桥的端口一般连接到局域网的网段，而以太网交换机的每个端口一般都直接与主机相连，也可连接到Hub。 一块网卡发出一个广播，能收到这个广播的所有网卡集合为一个广播域。通常情况下，一个网段就是一个冲突域，一个局域网就是一个广播域。 网络层网络层提供的两种服务 网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务，并且网络层不提供服务质量的承诺。 这样的好处在于网络造价大大降低，运行方式灵活。 网际协议IP 网际协议IP是TCP/IP体系中两个最主要的协议之一。其中，与IP协议配套使用的有三种协议： 地址解析协议ARP 网际控制报文协议ICMP 网际组管理协议IGMP 其中，ICMP、IGMP协议是往基层向上提供的两种服务 互联网络 因为用户的需求是多种多样的，没有一种单一的网络能够适应所有用户的需求,所以不同的网络之间，将网络互联起来需要使用一些中间设备。 物理层使用的中间设备是转发器 数据链路层使用的中间设备是网桥或者桥接器 网络层使用的中间设备是路由器 网络层以上使用的中间设备叫网关 IP地址与硬件地址 物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和网络层以上各层使用的地址 在发送数据时，数据从高层下到底层，然后才到通信链路上使用IP的IP数据报一旦交给了数据链路层，就被封装成MAC帧（MAC地址） 地址解析协议ARP 已知一个机器的IP地址，如何找出其所对应的硬件地址呢？这就是ARP的主要任务。 ARP协议的主要内容在于从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。 工作原理：一个主机都设有一个ARP高速缓存，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。 IP数据报 一个IP数据报由首部（20 字节+可选字段）和数据两部分组成 划分子网和构建超网 两级IP到三级IP 两级IP（&lt;网络号&gt;，&lt;主机号&gt;）的缺陷： IP地址的空间利用率有时很低 两级IP地址不够灵活 给每一个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏。 三级IP地址：将其中二级IP的主机号取出并高x位变成子网络，形成网络号+子网号+主机号的地址格式 划分子网：划分子网属于一个单位内部的事情，它将二级IP地址变为三级IP地址 无分类编制CIDR CIDR取消了传统的A类、B类和C类地址以及划分子网的概念，并且用网络前缀代替网络号和子网号，后面的部分指明主机。因此，CIDR使IP地址从三级地址(使用子网掩码)，又回到了两级地址（无分类的两级编址）。 CIDR把网络前缀相同的连续的IP地址组成一个”CIDR地址块”只要知道CIDR地址块中的任何一个地址，就可以知道这地址块的起始地址(即最小地址)和最大地址，以及地址块中的地址数。具体看如下例子 地址掩码：是一连串的1和0组成，而1的个数救赎网络前缀长度。在斜线记法中。斜线后面的数字就是地址掩码中1的个数。 构成超网：由于一个CIDR地址块中含有很多地址，所以在路由表中就利用CIDR地址块来查找目标网络，这种地址的聚合常称为路由聚合，也称构成超网。 最长前缀匹配 最长前缀匹配之前，使用CIDR时，每个项目由网络前缀和下一跳地址组成。但是在查找路由表时会得到不止一个匹配结果该怎么办呢？ 此时应该选择匹配结果中，有最长网络前缀的路由。因为网络前缀越长，可分配的地址数就越少，其地址信息路由就越具体 网际控制报文协议ICMP 为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP是互联网的标准协议，但不是高层协议。其种类如下： ICMP差错报告报文 ICMP询问报文 ICMP的应用在于分组网间探测PING，以用来测试两台主机之间的连通性。 互联网的路由选择协议 路由选择协议分为两大类： 内部网关协议 外部网关协议 内部网关协议 RIP是内部网关协议中最先得到广泛应用的协议，也被称为路由信息协议，但是其很少被使用。其主要特点如下： 仅和相邻路由器交换信息。 路由器交换的信息是当前路由器所知道的全部信息，即自己现在的路由 按固定的时间间隔交换路由信息，例如，每隔30秒。 因此，RIP有如下的优缺点。 当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。 RIP 协议最大的优点就是实现简单，开销较小。 RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。 路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 OSPF最主要的特征就是使用分布式的链路状态协议，其主要特点： 使用洪泛法向本自治系统中所有路由器发送信息。 发送的信息是与本路由器相邻的所有路由器的链路状态。 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 IPv6 解决IP地址耗尽的根本措施在于采用具有更大地址空间的新版本IP，即IPv6。它有两大部分组成：基本首部，有效载荷 IPv6采用的是点分十六进制的记法，把每个十六位的值用十六进制表示，并且各个值之间用冒号分割 冒号十六进制允许零压缩，但只能使用一次零压缩 冒号十六进制可以结合使用点分十进制记法的后缀。 传输层运输层协议概述 运输层功能 运输层应用进程之间提供端到端的逻辑通信。这与网络层的区别在于网络层是为主机之间提供逻辑通信的 运输层需要对收到的报文进行差错检验 运输层有两种不同的运输协议，即面向连接的TCP和无连接的UDP TCP/IP的运输层有两个不同的协议： 用户数据报协议UDP 传输控制协议TCP UDP协议特点 提供无连接服务 尽最大努力交付 面向报文，UDP 一次交付一个完整的报文 没有拥塞控制，网络拥塞不会使源主机的发送速率降低 支持一对一、一对多、多对一和多对多的交互通信 首部开销小，只有 8 个字节 应用：对可靠性要求不高，需要传送的数据不多，使用频率不高。并且可以实时应用。 TCP协议特点 提供面向连接的服务 可靠传输：主要以字节为单位的滑动窗口和超时重传时间的选择 面向字节流 拥塞控制：避免由于对网络中某资源的需求超过可用资源，令网络的性能变坏 TCP 的流量控制：让发送方的发送速率不要太快 总结：TCP和UDP协议的区别 TCP的特点 面向连接协议 提供交互保证 较UDP实时性低 TCP首部开销20个字节 TCP速度较慢 拥塞机制 TCP将数据看成一连串的字节 重量级协议，资源占用多 只有点对点连接 UDP的特点 无连接协议 尽最大努力交付，不提供有序、序列保证 较好的实时性 首部开销8字节 运行速度较快 无拥塞机制 面向报文 轻量级 一对一，一对多，多对多 运输层的端口 运行在计算机中的进程是用进程标识符来标志的。但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。 由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。有时我们会改换接收报文的进程，但并不需要通知所有发送方。所以我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。 解决这个问题的方法就是在运输层使用协议端口号 (protocol port number)，或通常简称为端口(port)。虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP来完成。 TCP可靠传输的实现 以字节单位的滑动窗口 TCP使用流水线传输和滑动窗口协议实现高效、可靠的传输。TCP 的滑动窗口是以字节为单位的。 发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。 发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。 接收窗口表示：只允许接收落入窗口内的数据。 超时重传时间的选择 重传机制是 TCP 中最重要和最复杂的问题之一。 TCP 每发送一个报文段，就对这个报文段设置一次计时器。 只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。 重传时间的选择是 TCP 最复杂的问题之一。 利用滑动窗口实现流量控制 一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。 流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。 利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 拥塞机制 在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。 最坏结果：系统崩溃。 网络拥塞往往是由许多因素引起的。例如： 点缓存的容量太小； 链路的容量不足； 处理机处理的速率太慢； 拥塞本身会进一步加剧拥塞； 总的来说，出现拥塞的原因在于对资源的需求大于可用资源 TCP的拥塞控制方法 慢开始与拥塞窗口 TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。 TCP发送方维持一个拥塞窗口 cwnd 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。 发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况 只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。 但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。 其中，对于拥塞的判断，有以下两个指标：1.重传定时器超时。2.收到三个重复的ACK。 应用层协议 应用层协议主要定义运行在不同端系统上的应用程序进程之间如何相互传递信息 常用的几种协议：DNS、FTP、HTTP、DHCP 的作用 DNS：域名系统DNS是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。DNS同时占用TCP协议与UDP协议的53号端口。 FTP：文件传送协议FTP是互联网上使用的最广泛的文件传送协议。FTP使用的传输层协议是 TCP，FTP 传数据流占用20号端口，FTP传控制流占用21号端口。 HTTP：HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。HTTP使用传输层协议为TCP，端口号为80。 DHCP：互联网目前广泛使用的动态主机配置协议DHCP，它提供一种机制，成为即插即用联网。DHCP使用UDP，端口号为67和68。 在应用层，用到DNS协议，作用是域名解析，HTTP协议浏览器和服务器之间的交互访问协议。 在传输层，运用UDP域名解析协议使用的运输层协议，TCP浏览器和WWW服务器之间建立连接，提供可靠的数据传输。 在网际层IP，IP数据报传输和路由选择，ICMP提供网络传输中的差错检测，ARP将本机缺省的网关IP地址映射成物理地址（MAC地址）","categories":[{"name":"计算机科学与技术","slug":"计算机科学与技术","permalink":"http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"操作系统","slug":"操作系统","date":"2021-11-29T16:00:00.000Z","updated":"2022-05-23T09:49:13.211Z","comments":true,"path":"操作系统/","link":"","permalink":"http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。","text":"操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。 操作系统概述操作系统基本概念 冯诺依曼模型：运算器、存储器、控制器、输入设备和输出设备 引入操作系统的目的：提供一个计算机用户与计算机硬件系统之间的接口、有效的控制和管理计算机系统中的各种硬件和软件资源、合理地组织计算机系统的工作流程 操作系统是计算机系统的资源管理程序 操作系统的核心是控制和协调进程的运行，解决进程之间的通信 操作系统的发展：无操作系统阶段 -&gt; 单道批处理系统 -&gt; 多道批处理系统 操作系统的特征 并行性：2个或多个事件在同一时刻发生 并发性：2个或多个事件在同一时间间隔内发生 并发和共享是操作系统的2个最基本的特征，二者之间互为存在条件 资源共享方式：互斥共享、同时访问 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物 异步性 操作系统的功能和服务 处理器管理：进程控制、进程同步、进程通信、进程调度 存储器管理：内存分配、内存保护、内存扩充 设备管理：设备分配、设备传输控制、设备独立性 文件管理：文件存储空间的管理、目录管理、文件操作管理、文件保护 用户接口：命令接口、程序接口、图形接口 联机命令接口又称交互式命令结构 脱机命令接口又称批处理命令接口 操作系统3种基本类型：批处理操作系统、分时操作系统、实时操作系统 其他操作系统：嵌入式操作系统、集群系统、网络操作系统、分布式操作系统 操作系统的运行环境 处理器的执行状态分为核心态与用户态 核心态是操作系统管理程序执行时机器所处的状态 用户态是用户程序执行时机器所处的状态 特权指令是只能由操作系统内核部分使用，不允许用户直接使用的指令，如I/O指令、设置中断屏蔽指令、清内存指令、存储保护指令和设置时钟指令 内核的指令操作工作在核心态 时钟管理 中断机制 原语 系统控制的数据结构及处理 异常，也称内中断，是由错误引起的 通常异常会引起中断，而中断未必是由异常引起的 系统调用（API）：进程控制、文件系统控制、系统控制、内存管理、网络管理、socket 管控、制用户管理以及进程间通信 操作系统的体系结构 操作系统的体系结构主要包括模块组合结构、层次结构和微内核结构 模块组合结构 接口简单直接，系统的效率相对较高 系统结构不清晰、可扩展性差、可适应性差 层次结构 按功能的调用次序排列成若干层 组织和依赖关系清晰明了，可读性、可适应性及可靠性都得到了增强 通常要将为进程提供服务的系统调用模块放在系统的内层。 微内核结构 客户服务器模式（C/S 模式） 每个服务进程运行在独立的用户进程中，可靠性好，灵活性好，便于维护 适合分布式处理的计算环境 效率不高，尤其是通信频繁的系统 进程管理进程 在计算机操作系统中，进程是资源分配的基本单位，也是独立运行的基本单位 程序顺序执行时的特征：顺序性，封闭性，可再现性 程序的并发执行的特征：间断性，失去封闭性，不可再现性 程序并发执行且其结果具有可再现性的条件（Bernstein 条件） R(p1) ∩ W(p2) = ∅ R(p2) ∩ W(p1) = ∅ W(p1) ∩ W(p2) = ∅ 进程的特征：动态性、并发性、独立性、异步性、结构特征（程序段、数据段和进程控制块） 进程和程序的关系 进程和程序的关系程序是静止的 进程是暂时的，程序是永久的 进程的组成包括程序段、数据块和进程控制块（Process Control Block） 通过多次执行，一个程序可以产生多个不同的进程，通过调用关系，一个进程可以执行多个程序 进程可创建其他进程，而程序不能形成新的程序 由程序段、相关数据段和PCB三部分构成的是进程映像，也叫进程实体 映像是静态的，进程是动态的，进程是进程实体的运行过程 进程和作业的区别 作业是用户需要计算机完成某项任务而要求计算机所做的工作的集合 作业提交、作业收容、作业执行、作业完成 进程是已提交完毕的作业的执行过程，是资源分配的基本单位 作业是用户向计算机提交任务的任务实体，而进程是完成用户任务的执行实体 这个作业可由多个进程组成，而必须至少由一个进程组成，但一个进程不能构成多个作业 进程的组成 进程控制块（PCB）：标识进程的存在，刻画执行瞬间特征的数据机构 其他组成部分：程序段、数据段、进程标识符（PID）、进程当前状态、进程队列指针、程序和数据地址，进程优先级、CPU 现场保护区、通信信息、家族联系、占有资源清单 PCB 是进程存在的唯一标志 PCB 存在是为了保证程序的并发执行 创建进程实质上是创建进程的 PCB，而撤销进程实质上是撤销进程的 PCB 系统总是通过 PCB 对进程进行控制的 进程的5种基本状态：就续状态、执行状态、阻塞状态、创建状态、结束状态 执行状态只能由就绪状态转换，而无法由阻塞状态直接转换 不能从就绪状态变为阻塞状态 进程状态是唯一的 进程的创建 进程创建是通过创建原语实现的 申请一个空闲 PCB，并指定唯一的 PID -&gt; 分配必要的资源 -&gt; 将新进程的PCB初始化 -&gt; 插入到就绪队列 导致进程创建的事件：用户登录、作业调度和请求服务 撤销一个进程：撤销原语 找到被撤销进程的PCB -&gt; 停止该进程的执行 -&gt; 回收被撤销进程所占用的资源 -&gt; 回收PCB 进程的阻塞与唤醒：两条低级进程通讯原语 阻塞原语（P 原语）的功能是将进行进程由执行状态转为阻塞状态 唤醒原语（V 原语）的功能是将进程由阻塞状态变为就绪状态 一个进程由执行状态变为阻塞状态，是由这个进程自己调用阻塞原语去完成的 进程由阻塞状态变为就绪状态，是由另一个发现者进程调用唤醒原语去实现的。一般这个发现者进程与被唤醒进程是合作的并发进程 调度是决定将系统资源分配给哪个进程，进程切换是实际分配系统资源 进程切换一定会产生中断，但处理器模式切换不一定产生进程切换 进程的互斥与同步就是一种进程间的通信方式 高级进程通信方式：共享存储器系、消息传递系统、管道（共享文件）通信系统 线程 线程是进程内一个相对独立的可调度的执行单元 内核级线程依赖于内核，一个内核级线程由于 I/O 操作而阻塞时不会影响其他线程的运行 用户级线程不依赖于操作系统核心，由于操作系统内核不了解用户线程的存在，当一个线程阻塞时，整个进程必须等待 进程与线程 线程谁独立调度的基本单位，进程是拥有资源的基本单位 线程不拥有资源，但线程可以访问其隶属进程的系统资源 进程之间可以并发执行，同一进程内的多个线程之间也可以并发执行 多线程之间的同步与通信非常容易实现 多线程模型：多对一模型，一对一模型，多对多模型（将多个用户级线程映射到多个内核级线程） 处理器的三级调度 高级调度（作业调度）：从外存上处于后备状态的作业中选择一个或多个，给他们分配内存等必要资源并建立相应的进程，以便该作业具有获得竞争处理器的权利 作业调度每次要接纳多少个作业进入内存取决于多道程序的并发程度 多道程序的并发程度应根据系统的规模和运算速度来决定 应将哪些作业从外存调入内存取决于所采取的调度算法 中级调度（交换调度）：按照给定的原则和策略，将处于外存对换区中具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待 低级调度（进程调度）：按照某种策略和方法，从就绪队列中选取一个进程，将处理器先分配给他 进程调度的运行频率很高 作业调度的结果是为作业创造进程，而进程调度的结果是进程被执行 衡量调度算法的性能： CPU利用率、系统吞吐量、响应时间、周转时间 作业的周转时间 = 作业的完成时间 - 作业的提交时间 平均周转时间：多个作业周转时间的平均值 带权周转时间是作业周转时间与运行时间的比 进程调度 处理器分配的任务由进程调度程序完成 进程调度的功能：记录系统中所有进程的有关情况以及状态特征，选择获得处理器的进程和处理器分配 引起进程调度的原因 当前运行进程运行结束 当前运行进程因某种原因从运行状态进入阻塞状态 执行完系统调用等系统程序后返回用户进程 在采用抢占调度方式的系统中，一个更高优先级的进程要求使用处理器 在分时系统中分配给该进程的时间片已用完 不能进行进程调度的情况 处理中断的过程中 在操作系统内核程序临界区中 其他需要完全屏蔽中断的原子操作过程中 进程调度的方式：抢占方式、非抢占方式 常见调度算法 先来先服务调度算法（作业调度、进程调度） FCFS：按照进程进入就绪队列的先后次序来分配处理器 短作业优先调度算法（作业调度、进程调度） SJF：把处理器分配给最快完成的作业或进程 优先级调度算法（作业调度、进程调度） 静态优先级是在创建进程时确定的，确定之后整个进程运行期间不再改变 按进程类、作业的资源要求、用户类型和要求确定静态优先级 动态优先级是指在创建进程时根据进程的特点及相关情况确定一个优先级 根据进程占有CPU时间的长短和就绪进程等待CPU时间的长短确定动态优先级 基于优先级的调度算法还可按调度方式的不同，分为非抢占优先级调度算法和抢占优先级调度算法 在优先级相同的情况下，通常按照先来先服务或者短作业优先的顺序执行 时间片轮转调度算法（进程调度） 分时系统必须满足系统对响应时间的要求 就绪队列中的进程数与时间片的大小成反比 系统的处理能力决定时间片的大小 高响应比优先调度算法（作业调度） 响应比 = 作业响应时间 / 估计运行时间 作业响应时间 = 作业等待时间 + 估计运行时间 多级反馈队列调度算法（作业调度） 时间片轮转调度算法和优先级调度算法的综合与发展 同步与互斥 互斥是间接相互制约关系，而同步是直接相互制约关系 只要是同类进程即为互斥关系，不同类进程即为同步关系 临界资源：同时仅允许一个进程使用的资源 进入区、临界区、退出区、剩余区 临界区：进程中用于访问临界资源的代码，又称临界段 临界资源是必须互斥访问的资源，这种资源同时只能被一个进程所使用，但需要这种资源的进程不止一个，因此需要对使用临界资源的进程进行管理 每个进程的临界区代码可以不相同 互斥的要求：空闲让进，忙则等待，有限等待，让权等待 互斥实现方法 软件实现方法 互斥实现的硬件方法：中断屏蔽、硬件指令 硬件方法适用范围广，支持多个临界区，但不能实现让权等待 信号量 信号量 (s,q) 及同步原语 整型变量 s 表示系统中某类资源的数目，q 是一个初始状态为空的队列 信号量的值仅能由 P 操作（wait）操作和 V 操作（signal）操作改变，操作系统利用它的状态对进程和资源进行管理 P 操作相当于申请资源，V 操作相当于释放资源 信号量分为整型信号量和记录型信号量（资源信号量） 记录型信号量添加了链表结构用于链接所有等待该资源的进程，解决忙等的问题 信号量可以用来实现进程互斥和描述前趋关系 经典同步问题 生产者-消费者问题 P(full) / P(empty) 与 P(mutex) 的顺序不可倒，必须先对资源信号量进行 P 操作，再对互斥信号量进行 P 操作。否则会导致死锁 互斥信号量就是给同类进程准备的 读者写者问题（许多进程共享数据区） 读者不互斥，写者必须互斥 读者优先，公平情况和写者优先三种不同算法 哲学家进餐问题 最多允许4个哲学家同时进餐 仅当一个哲学家左右两边的筷子同时可用时，他才可以拿起筷子 将哲学家编号要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子 理发师问题 信号量机制问题的解题步骤分析 关系分析 确定临界资源 整理思路 实现同步互斥的 P、V 操作必须成对出现，先进行 P 操作进入临界区，后进行 V 操作退出临界区 P、V操作要分别紧靠临界区的头尾部 通常用于互斥的信号量初值设为 1 管程 管程定义了一个数据结构和能为并发进程所执行的一组操作 局部于管程的数据只能被局部于管程内的过程所访问 一个进程只有通过调用管程内的过程才能进入管程访问共享数据 每次仅允许一个进程在管程内执行某个内部过程，即进程互斥地通过调用内部过程进入管程 管程的互斥访问完全由编译程序在编译时自动添加 为实现进程间的同步，管程还必须包含若干用于同步的设施 局限于管程并仅能从管程内进行访问的若干变量，用于区别各种不同的等待原因 在条件变量上进行操作的两个函数过程，wait 和 signal 死锁 死锁的概念 参死锁的进程至少有两个 每个参与死锁的进程均等待资源 参与死锁的进程中至少有两个进程占有资源 死锁进程是系统中当前进程集合的一个子集 死锁产生的原因是竞争资源 一个资源是否属于可剥夺资源，完全取决于资源本身的性质 死锁产生的必要条件 互斥条件 不剥夺条件 请求于保持条件：可采用预先静态分配方法 环路等待条件：可采用有序资源分配法 处理死锁的方法：鸵鸟算法、预防死锁、避免死锁、检测及解除死锁（被动） 死锁预防对系统加的限制条件通常很严格，对系统的并发性会产生很大的副作用 死锁避免往往在资源被分配出去之前，要计算分配之后系统是否安全 死锁的避免 系统在进行资源分配之前，先计算资源分配的安全性（安全序列） 并非所有不安全状态都是死锁状态，死锁是不安全状态的真子集 银行家算法 死锁的检测和解除 系统资源分配图（system resource allocation graph）可定义为一个二元组 SRAG = (V,E) 死锁定理：不同简化顺序将得到相同的不可简化图。系统状态 S 为死锁状态的条件是当且仅当 S 状态的资源分配图是不可完全简化的 死锁检测算法：available、allocation、request、临时变量（work与finish） 死锁解除：剥夺资源，撤销进程，进程回退 进程与饿死 当等待时间给进程推进和响应带来明显影响时，发生进程饥饿 当饥饿到一定程度，进程所赋予的任务即使完成也不再具有实际意义时，进程被饿死 活锁：在忙时等待条件下发生的饥饿 饥饿和饿死与资源分配策略有关，因而可从公平性方面考虑防止饥饿与饿死 内存管理内存管理概述 内存管理的功能是为多道程序的运行提供良好的环境 内存的分配和回收：记住内存空间的使用情况、实施内存的分配、回收系统或用户释放的内存空间 地址变换：将逻辑地址转换为物理地址 扩充内存：虚拟存储技术或其他自动覆盖技术 存储保护：由硬件和软件配合完成 应用程序的编译、链接与装入 经过编译程序将源代码编译为若干个目标模块 通过链接程序将编译好的目标模块以及所需的库函数链接在一起，形成完整的装入模块 通过装入程序将这些装入模块装入内存并执行 源程序（名地址）-&gt; 目标程序（逻辑地址）-&gt; 可执行程序（物理地址） 对程序设计者来说，数据的存放地址由数据名称决定，称为名地址或符号名地址，即为源程序的地址空间 当链接程序将多个模块链接为装入模块时，链接程序会按照各个模块的相对地址，将其地址构成统一的从0号单元开始编址的相对地址 当装入程序将可执行代码装入内存时，程序的逻辑地址与程序存在内存的实际地址，通常不同这就需要通过地址转换将逻辑地址转为物理地址，这个过程叫重定位 程序链接的 3 种方式 静态链接：在程序运行之前，先将各目标模块及所需的库函数连接成一个完整的可执行程序（装入模块），之后不再拆开 装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式 运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是物理地址便于修改和更新，便于实现对目标模块的共享 程序装入的 3 种方式 绝对装入：在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码 可重定位装入：根据内存当前情况将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，容易实现，无需增加硬件地址变换机构 动态运行装入：允许程序运行时在内存中移动位置，在程序执行过程中，每当访问到相应指令或数据时，才将要访问的程序或数据的相对地址转换为物理地址，可以将程序分配到不连续的存储区中 在重定位中通常会设一个重定位寄存器，用来存放进程分配的内存空间的地址（基址寄存器） 当 CPU 需要访问内存时，将逻辑地址转换为物理地址 物理地址 = 基址计算器内容 + 逻辑地址 逻辑地址和物理地址 逻辑地址是指由程序产生的与段相关的偏移部分地址（与页无关，因为只有段对用户可见） 物理地址是指出现在 CPU 外部地址总线上的寻址物理内存的地址信号，是逻辑地址变换后的最终结果地址，物理地址空间是指内存中物理地址单元的集合 从逻辑地址到物理地址的转换过程由硬件自动完成，这个转换过程叫做地址重定位 内存保护 界限寄存器方法 上、下界寄存器方法：分别存放作业的结束地址和开始地址 基址和限长寄存器方法 存储保护键方法：给每个存储块分配一个单独的保护键 交换与覆盖 覆盖技术，就是把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位 把程序执行时并不要求同时装入内存的复盖组成一组，称为覆盖段 将这个覆盖段分配到同一存储区域，这个存储区域称为覆盖区 覆盖区与覆盖段一一对应 覆盖技术只能覆盖与覆盖程序段无关的程序段 为了使一个覆盖区能被相应覆盖段中每个覆盖在不同时刻共享，其大小应由覆盖段中最大覆盖来确定 覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时执行程序的代码量超过主存时，程序仍然不能运行 交换技术就是把暂时不用的某个程序及数据部分从内存移到外存中，以便腾出必要的内存空间，或把指定的程序或数据从外存读到相应的内存中，并将控制权转让给他，让其在系统上运行的一种内存扩充技术 处理器三级调度中的中级调度就是采用了交换技术 与覆盖技术相比，交换技术不要求程序员给出程序段之间的覆盖结构，且交换主要是在进程或作业之间进行，而覆盖主要在同一个作业或进程中进行 交换进程由换出和换入两个过程组成 交换技术的特点是打破了一个程序一旦进入主存便一直运行到结束的限制，但运行的进程大小仍然受实际主存的限制 交换需要备份存储 影响交换时间的因素主要是转移时间 如果换出进程，必须确保该进程完全空闲 交换空间通常作为磁盘的一整块，且独立于文件系统 交换通常在有许多进程运行，且内存空间紧张时开始启动，而在系统负荷减轻时暂停 连续分配管理方式 内部碎片和外部碎片 内部碎片是指已经分配给作业，但不能被利用的内部空间 外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块 单一连续分配：将内存分为两个连续存储区域，其中一个存储区域固定的分配给操作系统使用，通常放在内存低地址部分，另一个存储区域给用户作业使用 通常用户作业只占用所有分配空间的一部分，剩下一部分实际上浪费掉了 单一连续分配方式采用静态分配，适合单道程序，可采用覆盖技术 作业一旦进入内存，就要等到其结束后才能释放内存，因此这种分配方式不支持虚拟存储器的实现，无法实现多道程序共享主存 单一连续分配会产生内部碎片 固定分区分配：将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序 分区的大小可以不等，但事先必须确定，在运行时不能改变 当有空闲分区时，便从后备队列中选择一个适当大小的作业装入运行 固定分区分配中程序通常采用静态重定位方式装入内存 固定分区分配的优点是可用于多道程序系统最简单的存储分配，缺点是不能实现多进程共享一个主存区，利用率较低，会产生内部碎片 动态分区分配：作业进入主存时，根据作业的大小动态的建立分区，并使分区的大小正好满足作业的需要，因此系统中分区的大小是可变的，分区数目也是可变的 空闲分区表、空闲分区链 首次适应算法（FF）、下次适应算法（NF）、最佳适应算法（BF）、最差适应算法（WF） 分区回收 分区分配的动态管理：拼接技术、动态重定位分区分配技术 动态分区分配的优缺点 优点：实现了多道程序共用主存、管理方案相对简单、实现存储保护的手段比较简单 缺点：主存利用不够充分，存在外部碎片、无法实现多进程共享存储器信息、无法实现主存的扩充，进程地址空间受实际存储空间的限制 非连续分配管理方式 非连续分配允许一个程序分散地装入到不相邻的内存分区中 非连续分配管理方式根据分区大小是否固定为分页存储管理方式和分段存储管理方式 分页存储管理方式根据运行作业时是否需要把作业的所有页都装入内存才能运行而分为基本分页存储管理方式和请求分页存储管理方式 基本分页存储管理方式（物理单位） 分页原理：用户作业的地址空间被划分成若干个大小相等的区域，称为页或页面 将主存的存储空间分成与页面大小相等的区域，称为块或物理块 在为作业分配存储空间时，总是以块为单位来分配，可以将作业中的任意一页放到主存的任意一块中 主存中与页面大小相等的物理块也可称为页框 为了将逻辑地址上连续的页号映射到物理内存中后成为离散分布的多个物理块，需要将每个页面和每个物理块一一对应，这种映射关系体现在页表中 每个页表项由页号和块号组成 基本地址变换机构：页表寄存器（PTR） 具有快表（TLB）的地址的地址变换机构：具有并行查找功能的高度缓冲存储器 两级页表和多级页表 基本分页存储管理方式优缺点 优点：内存利用率高、实现了离散分配、便于存储访问控制、无外部碎片 缺点：需要硬件支持（快表）、内存访问效率下降、共享困难、内部碎片 基本分段存储管理方式（逻辑单位） 逻辑地址结构由段号 S 和段内位移 W（段内偏移量）组成 段的长度不定 作业空间地址是二维的 段表及地址变换过程 基本分段存储管理方式优缺点 优点：便于程序模块化处理和处理变换的数据结构、便于动态链接和共享、无内部碎片 缺点：与分页类似，需要硬件支持、为满足分段的动态增长和减少外部碎片，要采用拼接手段、分段的最大尺寸受到主存可用空间的限制、有外部碎片 虚拟内存的基本概念 在真实的操作系统中，通常采用段页式存储管理，段面向用户，页面向硬件 虚拟内存解决的问题 一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：①作业很大时，不能全部装入内存，导致大作业无法运行；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。 虚拟内存的实现： 基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。 请求分页管理 请求分页管理：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存 缺页中断： 在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断 缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，同时要注意，若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面 理解缺页，缺页就像货架上缺少了商品，需要从仓库里调取商品，就先暂停这个货架的销售，等商品调取完毕再重新出售。 页面置换算法 置换算法的评价指标是：缺页的次数，某种算法让缺页次数最低，调度效率最高，那就是最优的算法 最佳置换算法：每次淘汰的页面都是以后永久不用或最长时间不使用的页面，保证最低的缺页率。显然，这种需要预测未来的算法不可能实现。 先进先出算法FIFO：缺页时，淘汰最早进入的页面。算法简单，但局限性也明显，例如某些经常使用的页面一直被换进换出，和使用频率低的页面有相同的被换出的机会。 最近最久未使用置换算法LRU：每次淘汰的页面都是最近最久未使用的页面。需要在页面中添加一个记录项，记录上次被访问以来经历的时间t，当需要淘汰页面时，选择时间t最大的淘汰，也就是最久未使用的淘汰。算法设计虽好，但开销很大，实现困难。 时钟置换算法：时钟置换算法也可以称为最近未使用算法。是一种性能和开销均衡的算法。 简单的时钟算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描) I/O原理文件的逻辑结构 文件可以分为两类： 无结构文件：文件内部数据就是一系列二进制流或字符流。最典型的就是txt文件。 有结构文件：由一组相似的记录组成，又称记录式文件。典型的excel表、数据库表等。 有结构文件的逻辑结构又分顺序文件、索引文件、索引顺序文件，注意逻辑结构是展示给用户的，是文件的组织形式，例如是一张顺序存储的excel表格，还是一张excel索引表加上excel顺序表，还是多级索引加顺序，而不是在计算机上的存储方式。 顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。 顺序存储即逻辑相邻的文件物理上也相邻，链式存储即在末尾添加新的文件。 记录的类型又分为可变长和不可变长记录 索引顺序文件：索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项，索引表项的地址直接指向顺序文件所在区域，再顺序查找到所需的文件，从而节省了很大的空间。(例如我们可以通过An Qi找到An Kang、An Jie等，而不用在索引表中存放这么多信息。另外索引项之间不需要有按照逻辑关系排列) 多级索引顺序文件：在索引顺序文件的基础上再增加层次深度，可以减少查找的次数(顺序查找范围缩小了) 文件目录 文件目录可以分为：单级目录结构、两级目录结构、多级目录结构(树形目录结构) 单极目录结构：顾名思义，所有的文件放在一个目录中，类似于一个仓库把所有文件不加整理的堆放在一起，显然效率会很低下 两级目录结构:主要分为主文件目录和用户文件目录。类似于仓库中加了几个员工货架，不同员工的货物放在不同货架，但在一个货架中文件还是采用堆砌式的存储。 多级目录结构，又称树形目录结构:我们当前主流操作系统都是多级目录结构，简而言之就是文件目录可以一级一级的延申，从而文件更有条理。 FCB(文件控制块)，首先来看一张图，如果文件目录都以这种表的形式进行信息查找，会大大降低运行效率，增加系统负担。 提出对策，其实在查找各级目录的过程中，只需要用到文件名这个信息，可以考虑让目录表瘦身来提升效率。 索引结点指针指向索引结点(文件名之外的其他信息就存放在结点中，从而按需读取，提升效率) 每一个文件都有一个FCB，记录了文件的地址、信息、权限等等属性 文件的物理结构 最重要的三种物理结构：顺序、链接、索引，其中最主要使用的是索引文件，可以随机访问，同时增删效率高 文件的物理结构是文件分配在计算机存储上的分配方式。分配的基本单位是 物理块,可以构想一下，一个大文件，如一首音乐23MB，难道直接一整个塞入硬盘吗？显然可能会出现一些问题，硬盘的空间也需要不断调整，就像内存分页一样，硬盘也被分为小的物理块号方便进行调度。 连续分配 优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快 缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片 链式分配 隐式：采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。 显式：直观理解就是在隐式的基础上添加了一张表，从表上能看出不同物理块号的下一块的地址 结论：采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问i 号逻辑块时，并不需要依次访问之前的0 ~ i-1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多 显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。 索引分配 索引就是文件分成不同的物理块存入磁盘，对每个物理块都有一个索引与之对应，需要读写时就通过索引表查询其物理地址进行相关操作 磁盘结构 磁道：每一圈就是一个磁道，最内侧磁道面积最小，所以数据密度最大 扇区：磁道被划分为小的磁盘块 一个盘片可能有两个盘面;每个盘面对应一个磁头；所有磁头连在一起，共进退；每个盘面的相对位置的磁道组成柱面 磁盘调度算法 磁盘调度算法要解决的核心问题就是寻道时间，即移动磁头的时间，而其他的启动时间、传输时间都很迅速，不是最主要的时间消耗 先来先服务FCFS 根据进程请求房屋内磁盘的现后顺序进行调度。符合惯性思维，但在很多时候，效果很差。 最短寻找时间优先(学过数据结构与算法的话，核心思想就是贪心算法)，该算法会优先处理与当前磁头最近的磁道的需求 那么很可能磁头就会如图所示的移动，也会存在饥饿问题：磁头只在一个小区域移动，而不能满足需要远距离移动的需求。例如不断有18-&gt;38，38-&gt;18的需求，那磁头就不会执行18-&gt;150的请求，从而产生饥饿 扫描算法 核心思想，只有磁头移动到最外侧磁道的时候才能往内侧移动，移动到最内侧的时候才能向外侧移动。这样就不会产生饥饿问题。 文件共享 文件共享分两种链接方式，硬链接和软连接 硬链接就是在另一个用户的目录中，索引结点指针直接指向了发送分享的用户的索引节点，从而实现了共享，count的数量代表文件正在被几个用户使用。 软连接，类似于快捷方式，记录了原文件的路径，然后层层查找。 文件保护 文件保护有三种方式口令、加密、访问控制 口令：为文件设置一串口令，就像打开手机需要先解锁。 加密：使用加密方法对文件加密，只有拥有正确的解密方法才能解密，有点像不同军队之间进行通信，要实现进行加密，要是想窥探敌情，就要对密文进行破解。 访问控制：每个文件的FCB或者索引结点中设置访问控制表，如windows中，设置了很多的访问权限，例如 I/O设备 I/O就是输入输出，I/O设备就是可以将数据输入到计算机或将计算机数据输出的设备，常见的：鼠标、键盘、音响、显示器、打印机、话筒、摄像头等等。 I/O控制器:CPU无法直接控制I/O设备，需要一个电子部件去充当中间人，这个部件就是I/O控制器，CPU控制I/O控制器，I/O控制器控制I/O设备。 假如我们的CPU能够控制I/O设备，那不同的厂商、不同型号的设备，都要对应进行编码，显然是不切实际的，所以CPU要采用通用调度方式调度I/O设备从而需要I/O控制器。 Java语言中，调用System.out.Println()，这本身并不能在显示器上打印，而需要通过操作系统调用write方法，接着调用字符设备接口，命令显示器写","categories":[{"name":"计算机科学与技术","slug":"计算机科学与技术","permalink":"http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2021-11-19T16:00:00.000Z","updated":"2022-05-23T09:49:48.478Z","comments":true,"path":"计算机组成原理/","link":"","permalink":"http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","excerpt":"计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。","text":"计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。 计算机系统概述计算机系统的多层次结构 硬件： 微程序机器层M0（微指令系统），由硬件直接执行微指令 传统机器M1（机器语言机器），用微程序解释机器指令 软件： 虚拟机器M2（操作系统机器），用机器语言解释操作系统 汇编语言M3（汇编语言机器），用汇编程序翻译成机器语言程序 虚拟机器M4（高级语言机器），用编译程序翻译成汇编语言程序 冯·诺依曼机 基本工作方式：控制流驱动方式 最根本的特征：采用存储程序原理，即按地址访问并顺序执行指令 指令和数据均以二进制形式存放在存储器中 CPU区分依据是：指令周期的不同阶段 冯·诺依曼计算机：以运算器为中心 现代的计算器：以存储器为中心 5大部件：存储器、运算器、控制器、输入设备、输出设备（适配器） 三大部分：CPU（运算器、控制器）、I/O设备（输入设备、输出设备）、主存储器 哈佛结构：将指令和数据放在两个独立的存储器，允许在一个机器周期内同时获得指令和操作数，提高了执行速度 计算机性能指标 机器字长： CPU一次能处理数据的位数，通常与CPU的寄存器位数有关，字长越长，精度越高 机器的字长也会影响机器的运算速度：字长较短，运算位数多，可能需要多次运算才能完成 对硬件造价有影响：直接影响ALU、数据总线以及存储字长的位数 存储容量：主存容量、辅存容量 运算速度： 吞吐量和响应时间 主频和CPU时钟周期 CPI：执行一条指令所需的时钟周期数 CPU执行时间：指运行一个程序所花费的时间。取决于：主频、CPI、指令条数 MIPS：每秒执行多少百万条指令 MFLOPS：每秒执行多少百万次浮点运算（标志系统性能最有用参数） GFLOPS：每秒执行多少十亿次浮点运算 TFLOPS：每秒执行多少万亿次浮点运算 数据的表示和运算汉字的编码 输入码（外码）：区位码、国际码、拼音码、电报码、表形码等 内码：0、1（机器码） 输出码：汉字字形码 汉字编码包括汉字的输入编码、汉字内码、汉字字形。用两个字节表示一个汉字，每个字节用七位码。区位码是4位十进制数，前2位是区码，后2位是位码 国标码是将十进制的区位码转换为十六进制后，再在每个字节上加上20H。为了方便计算机区分中文字符和英文字符，将国标码两个字节的最高位都改为“1”，这就是汉字内码（十六进制） 字符串的存放 小端模式：按先存储低位字节、后存储高位字节的顺序存放字符串的内容 大端模式：按先存储高位字节、后存储低位字节的顺序存放字符串的内容 校验码 奇偶校验码：只能检出一位错误，不能确定出错的位置；只能检验处奇数位错误，不能检测出偶数位错误。 奇校验码：整个校验码中“1”的个数为奇数。 偶校验码：整个校验码中“1”的个数为偶数。 海明（汉明）检验码：可检出错位位置 循环冗余校验（CRC）码：可检出错误位置（通过除法运算） 原码、反码、补码、移码 原码、补码、反码三种机器数的最高位均是符号位 当真值为正时，原码、补码、反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同 当真值为负时，原码、补码、反码的表示形式不同，但其符号位都用“1”表示，而数值部分补码是原码的“求反加1”，反码是原码的“每位求反”。 同一个真值的移码和补码仅差一个符号位。 4、不同机器数表示±0时，其形式不同。 [+0]原≠[-0]原， [+0]反≠[-0]反，[+0]补=[-0]补，[+0]移=[-0]移 当机器字长确定后，补码比原码、反码能多表示一个负数 移码只能表示整数，用它表示浮点数的阶码时，能方便地判断阶码的大小 补码定点数的加/减运算 基本公式：（将符号位和数值部分一起参加运算，并且将符号位产生的进位自然丢掉即可） 加法：[A]补+[B]补=[A+B]补 减法：[A-B]补=[A]补+[-B]补（[-B]补由[B]补连同符号位在内，每位取反，末尾加1） 溢出判断 用一位符号判断溢出：实际参加操作的两个数符号相同，结果又与原操作数的符号不同，即为溢出 用两位符号位判断溢出：当2位符号位不同时，表示溢出，否则，无溢出。不论是否发生溢出，高位（第1位）符号永远代表真正的符号。（变形补码，运算时多一位） 01正溢出（上溢）；10负溢出（下溢） 采用一位符号位根据数据位的进位情况判断溢出。如果符号位的进位与最高数位的进位不同，则表示结果溢出 浮点数的加/减运算 对阶：两个数的小数点位置对齐（使阶码相等），两个数的阶码相减求阶差，使小阶的尾数向右移位，每右移一位，阶码加1 尾数求和：将对阶后的两个尾数按定点加（减）运算规则进行运算 规格化：补码规格化形式为[S]补 00.1××××；[S]补 11.0×××× 左规：尾数出现00.0××××或11.1××××时，需左规。尾数左移一位，阶码减1 右规：尾数出现01.××××或10.××××时，表示尾数溢出，但在浮点运算中不算溢出，可通过右规处理。尾数右移一位，阶码加1 舍入：在对阶和右规的过程中，可能会将尾数的低位丢失，引起误差，影响精度，用舍入法来提高尾数的精度 “0舍1入”法：被移去的最高位数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。又溢出时，再右规…… “恒置1”法：不论丢掉的最高数位是“1”还是“0”，都使尾数末位恒置“1”。 两种方法同样都有使尾数变大和变小两种可能 溢出判断（是否溢出由阶码的符号决定） 上溢：阶码[j]补=01，×××，作溢出处理 下溢：阶码[j]补=10，×××，按机器零处理 浮点数的表示范围 上溢：当浮点数阶码大于最大阶码时，上溢，机器停止运算，进行中断溢出处理。 下溢：当浮点数阶码小于最小阶码时，下溢，溢出的数绝对值很小，通常将位数各位强制为0，按机器零处理，机器可以继续运行。 8位二进制整数范围 原码、反码：-127—+127 补码、移码：-128—+127 标准IEEE 754标准 现代计算机中，浮点数一般采用IEEE制定的国际标准： 常用的浮点数有三种：阶码用移码表示 短实数、长实数、临时实数的偏移量用十六进制数表示分别为7FH（127）、3FFH、3FFFH 尾数部分通常是用原码、规格化表示，即非“0”的有效位最高位总是“1”，但在IEEE标准中，有效位呈如下形式：1▲ff…ffff 其中▲表示假想的二进制小数点。在实际表示中，对短实数和长实数，这个整数位的1省略，称隐藏位；对于临时实数不采用隐藏位方案 存储器层次结构存储器的层次化结构 存储器主要性能指标：速度、容量、每位价格（位价） 一般来说，速度越高，位价越高；容量越大，位价越低；容量越大，速度越低。 层次结构主要体现在缓存-主存和主存-辅存这两个层次上。 缓存-主存：主要解决CPU和主存速度不匹配问题（由硬件自动完成）数据调动对任何程序员透明。 主存-辅存：主要解决存储系统的容量问题（由硬件和操作系统共同完成）数据调动对应用程序员透明 动态RAM的刷新 一般取2ms，对动态RAM的全部基本单元电路必作一次刷新，称为刷新周期，又称再生周期。刷新的单位是行，仅需要行地址。 集中刷新：在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作，称“死时间”或“死区”。（全部一起刷） 分散刷新：对每行存储单元的刷新分到每个存取周期内完成。优点：没有死区。缺点：存取周期加长，整个系统速度降低。（一个个刷） 异步刷新：是前两种方式的结合，既缩短“死时间”，又充分利用最大刷新时间间隔为2ms的特点。（一行行刷） 一行行刷的平均刷新时间 行数 = 芯片容量 / 每行存储单元个数 平均刷新时间 = 间隔最长 / 行数 存储容量的扩展 位扩展 增加存储字长 例如：2片1K4位的存储芯片可组成1K8位的存储器。 注意：其中一片的数据线作为高4位D7-D4，另一片的数据线作为低4位D3-D0。 字扩展 增加存储器字的数量 例如：2片1K8位的存储芯片可组成一个2K8位的存储器。 注意：两片都连地址线A0-A9。（从低位连起） 字、位扩展 既增加存储字的数量又增加存储字长。 双口RAM和多模块存储器 为了提高CPU访问存储器的速度，可以采用双端口存储器（空间并行）、多模块存储器（时间并行）等技术，都属于并行技术。 多模块存储器 为了提高访存速度（CPU速度比存储器快，同时从存储器中取出n条指令，可以充分利用CPU资源，提高运行速度） 单体多字系统 在一个存取周期内，从同一地址取出n条指令，然后逐条将指令送至CPU执行，即每隔1/n存取周期，主存向CPU送一条指令，增大了存储器的带宽，提高了存储器的工作速度。 例如：从同一地址取出4条指令，为单体四字结构，每字W位。按地址在一个存取周期内可读出4*W位的指令或数据，使主存带宽提高到4倍。 缺点：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。 多体并行系统 采用多提模块组成的存储器。每个模块可以并行工作，也可以交叉工作。 低位交叉编址 程序连续存放在相邻体中（交叉存储）。低位地址表示体号，高位地址表示体内地址。地址的低n为片选。 优点：相邻地址单元的数据放在不同组，各组可以并行工作，能较好提高存储器的带宽。 缺点：某一组出现故障，会影响整个存储器的正常工作。 高位交叉编址 按体内地址顺序存放（顺序存储）。高位地址表示体号，低位地址表示体内地址。 地址的高n位片选。 优点： 某一组的故障不影响其他组，且容易通过添加模块来扩充容量。 缺点：相邻地址单元的数据放在同一组存储单元，各组间串行工作，不利于提升存储器的带宽。 Cache中主存块之间的映射方式 由主存地址映射到Cache地址称为地址映射 直接映射 主存数据只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无需使用替换算法）。 优点：实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。 缺点：不够灵活，降低命中率。 全相联映射 允许主存中每一字块映射到Cache中的任何一块位置上。可以从已被占满的Cache中替换出任一旧字块。 通常采用昂贵的“按内容寻址”的相联存储器来完成。 优点：灵活，命中率高，缩小了块冲突率，空间利用率高。 缺点：地址变换速度慢，实现成本高 组相联映射（上述两种映射的折中） 将Cache空间分成大小相同的组，主存的一个数据块可以装入到一组内的任何一个位置（组间采取直接映射，组内采取全相联映射）。 Cache中主存块的替换算法 先进先出（First-In-First-Out，FIFO）算法 近期最少使用（Least Recently Used，LRU）算法 随机法 磁盘存储器 磁盘寻址的最小单位是扇区。 道密度：沿磁盘半径方向单位长度的磁道数。 位密度：单位长度磁道上记录二进制的位数。 平均寻道时间：从一个磁道转移到另一个磁道的平均时间。（全部寻道时间的一半） 平均等待时间：旋转等待的平均时间。（转一周时间的一半） 一扇区的传送时间：T=1 / (转速×扇区数) 存取一个扇区的时间：T=每个扇区位数 / (转速×扇区数) 平均存取时间=平均寻道时间 + 平均等待时间 + 传输时间 每个记录面的磁道数：K=[(外直径-内直径)/2]*磁道密度 盘组格式化容量：C = 记录面数 K 每个扇区字节数 * 扇区数 盘组非格式化容量：CN = 记录面数 K 最内圈磁道周长 * 内层位密度 WE 为写允许信号：低电平0为写，高电平1为读 CS为片选信号：低电平0有效 借位/进位C：1=结果的最高位发生了进位，0=结果的最高位未发生进位 溢出标志位V：1=溢出，0=没有溢出 指令系统指令的寻址方式 寻址模式是大多数中央处理器 （CPU）设计中的指令集架构的一个方面 在给定指令集架构中定义的各种寻址模式决定了该架构中的机器语言指令如何识别每个指令的操作数 寻址模式指定如何通过使用寄存器中保存的信息和/或机器指令中包含的常量或其他地方包含的常量来计算操作数的有效存储器地址。 CISC和RISE 从硬件角度来看CISC处理的是不等长指令集，它必须对不等长指令进行分割，因此在执行单一指令的时候需要进行较多的处理工作。而RISC执行的是等长精简指令集，CPU在执行指令的时候速度较快且性能稳定。因此在并行处理方面RISC明显优于CISC，RISC可同时执行多条指令，它可将一条指令分割成若干个进程或线程，交由多个处理器同时执行。由于RISC执行的是精简指令集，所以它的制造工艺简单且成本低廉。 从软件角度来看，CISC运行的则是我们所熟识的DOS、Windows操作系统。而且它拥有大量的应用程序。因为全世界有65%以上的软件厂商都理为基于CISC体系结构的PC及其兼容机服务的，象赫赫有名的Microsoft就是其中的一家。而RISC在此方面却显得有些势单力薄。虽然在RISC上也可运行DOS、Windows，但是需要一个翻译过程，所以运行速度要慢许多。 地址指令操作数物理位置的三种形式 寄存器——寄存器型（RR型）； 寄存器——存储器型指令（RS型）； 存储器——存储器型（SS型）。 中央处理器计算机工作过程 加电——》产生reset信号——》执行程序——》停机——》停电 产生reset信号的任务 任务一：使计算机处于初始状态 任务二：从PC中取出指令地址 控制器作用是协调并控制计算机各部件执行程序的指令序列 控制器的组成 控制器的功能 取指令：发出指令地址，取出指令的内容 分析指令 对操作码译码产生操作相应部件的控制信号 根据寻址方式形成操作数地址 执行指令 根据分析指令后产生控制信号、操作数地址信号序列，通过CPU及输入输出设备的执行实现每条指令的功能 结果回送存储器 形成下条指令的地址 控制程序和数据的输入和结果输出 对异常情况和某些请求的处理 异常情况的处理：例如算术运算的溢出、数据传送奇偶错 某些请求的处理 “中断请求”信号 DMA请求信号 控制器的组成 程序计数器（PC）：即地址寄存器，用来存放当前正在执行的指令地址或即将要执行的下一条指令地址 指令寄存器（IR）：用以存放当前正在执行的指令，以便在指令执行过程中控制完成一条指令的全部功能 指令译码器或操作码译码器：对指令寄存器中的操作码进行分析解释，产生相应的控制信号 脉冲源及启停线路：脉冲源参数一定评率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号，在机器刚加电时，还应产生一个总清信号（reset） 时序控制信号形成部件：当程序启动后，在CLK时钟作用下，根据当前正在执行的指令的需要，产生相应的时序控制信号，并根据被控制功能部件的反馈信号调整时序控制信号 控制存储器 微指令寄存器：控制字段+下址 周期概念 指令周期：完成一条指令所需的时间，包括取指令、分析指令、执行指令 机器周期：也称为CPU周期，是CPU从内存中读取一个指令的时间，通常等于取指周期 时钟周期：称为节拍脉冲或T周期，是基准脉冲信号 三条假设 程序是存放在主存中的，当执行完一条指令后才从主存中取下一条指令（非流水线） 指令的长度是固定的，并限制了寻址方式的多样化 在程序运行前，程序和数据都已存在主存中 指令执行过程（运算器和控制器配合） 组成控制器的基本电路 具有记忆功能的触发器以及由它组成的寄存器，计数器和存储单元 没有记忆功能的门电路及由它组成的加法器，算术逻辑运算单元（ALU）和各种逻辑电路 控制器的功能就是按每一条指令的要求产生所需的控制信号 产生控制信号的方法 微程序控制 硬布线控制 微程序控制计算机的基本工作原理 微指令：在微程序控制的计算机中，将由同时发出的控制信号所执行的一组微操作 微命令：将指令分为若干条微指令，按次序执行这些微指令。组成微指令的操作即微命令 微程序：计算机的程序由指令序列构成，而计算机每条指令的功能均由微指令序列解释完成，这些微指令序列的集合就叫做微程序 控制存储器 微程序一般是存放在专门的存储器中的，由于该存储器主要存放控制命令（信号）与下一条执行的微指令地址（简称下址） 存储单元内容 微指令的控制信号——控制位 下条微指令的地址——下址字段 存储芯片：ROM 执行一条指令实际上就是执行一段存放在控制存储器中的微程序 实现微程序控制的基本原理 控制信号（23条） 加法的过程 微指令格式：控制字段+下址字段 23个控制位，12个下址位——》容量为4K 取址微指令的操作对所有指令都是相同的，所以是一条公用的微指令，其下址由操作码译码产生 微程序控制器 时序信号及工作脉冲的形成 停机和停电的区别 停机：电压稳定、存放内容保持、重启PC内容为断点指令地址 停电：电压消失、RAM的内容消失、重启PC内容为第一条指令地址 微程序设计技术 如何缩短微指令字长 直接控制法（容量太小） 编译方法：每一位代表一个控制信号，直接送往相应的控制点 优点：控制简单 缺点：微指令字长过大 字段直接编译法 选出互斥的微指令 每个字段都要留出一个代码，表示本段不发出任何指令（000） 优点：节省微指令的字长 缺点：增加了额外的硬件开销 字段间接编译法 指令之间相互联系的情况 举例：A为0-7，B为0-3，如果是直接编译——3+2=5，如果是间接编译——3+1=4 编码方法：在字段直接编译法中，译码输出端要兼由另一字段中的某些微命令配合解释 优点：减少了微指令长度 缺点：可能削弱微指令的并行控制能力，同时增加硬件开销 常熟源字段E 如何减少微指令长度 现行微指令/微地址 现行微指令：当前正在执行的指令 现行微地址：存放现行微指令的控制器存储单元 后继微指令/微地址 后继微指令：下一条要执行的微指令 后继微地址：存放后继微指令的控制器存储单元 增量与下址字段结合产生后继微指令的方法 下址字段分成：转移控制字段BCF和转移地址字段BAF BCF：控制微程序的转移情况 BAF：转移后的微指令所在地址 BAF有两种情况 与uPC的位数相等——转移灵活，但增加微指令长度 比uPC短——转移地址收到限制，但可缩短微指令长度 优点：微指令的下址字段很短，仅用于选择输入uPC计数器的某条线路有效 缺点：微程序转移不灵活，使得微程序在控存中的物理空间分配有困难 多路转移方式：一条微指令存在多个转移分支的情况称为多路转移 微中断 微中断请求信号是由程序中断请求信号引起的 在完成现行指令的微程序后响应该微中断请求 由硬件产生对应微中断处理程序在控存中的入口地址 如何提高微程序的执行速度 微指令格式 水平型微指令——直接控制，字段编译（直接、间接） 特点：在一条微指令中定义并并行执行多个微命令 垂直型微指令 特点：不强调实现微指令的并行控制功能 定义：采用微操作码编译法，由操作码规定微指令的功能 微程序控制存储器 一般采用ROM存储器 也可采用RAM，为防止断电后内容消失，则必须开机后将外存中存放的微程序调入控存RAM，然后才能执行程序。 当前为了能不断扩展指令系统，通常采用ROM+RAM 动态微程序设计 定义：能根据用户要求改变微程序 优点：是计算机能更灵活、有效的适应于各种不同的应用目标 控制存储器的操作 串行方式 并行方式——比串行多了微指令寄存器 微周期=max(取微指令时间,执行微指令时间) 由于取微指令、执行微指令同时进行，故对于某些后继微地址的产生根据处理结果而定的微指令，则延迟一个微周期再取微指令 硬布线控制的计算机（RISC）——特点快 形成操作控制信号的逻辑框图 操作控制信号的产生 取值周期cy1所产生的信号对所有指令都是相同的，即与当前执行的指令无关，逻辑式得到最简单的形式 通常，同一个控制控制信号在若干条指令的某些周期（或再加上一些条件）中都需要，为此需要把它们组合起来 同种类型的指令所需要的控制信号大部分是相同的，仅有少量区别 在确定指令的操作码时（即对具体指令赋予二进制操作码），为了便于逻辑表达式的化简以减少逻辑电路数量，往往给予特别关注 设计组合逻辑电路从而产生需要的控制信号的步骤 实际逻辑问题 真值表 公式化简 逻辑电路图 设计目标：使用最少的电路元件达到最高的操作速度 流水线工作原理 每条指令的执行时间不变 每条指令处理结果的时间缩短 流水线处理速率最高时=流水线处于满载的稳定状态 流水线处理速率最低时=流水线未满载状态 为了满足在重叠时间段不同指令的机器周期能够完成指定的操作，将时间段=操作完成的最长时间 为了保证一个周期内流水线的输入信号不变，相邻时间段之间必须设置锁存器或寄存器 除了指令执行流水线，还有运算操作流水线 流水线阻塞 数据相关产生 假设第二条指令需要的操作数是第一条指令运算的结果，那么出现了数据相关 指令执行时间不同产生 程序转移的影响 异常情况响应中断 存储系统存储系统的层次结构 cache-&gt;主存-&gt;辅存 高速缓冲存储器 cache的工作原理 局部性原理 主存地址和cache地址（P166 图7.2） 块长：块长一般取一个主存周期所能调出的信息长度（一般为16个字） cache的容量和块的大小是影响cache的效率的重要因素 命中率：CPU所要访问的信息是否在cache中的比率，而将所要访问的信息不在cache中的比率称为失败率 一致性策略 标志交换方式（写回法） 通过式写入（写通法） 写操作直接对主存进行，而不写入cache cache的平均存取时间=h*tc+(1-h)(tc+tm) 最好替换策略：按照被替换的字块是下一段时间最少使用的，由替换部件实现 cache组织地址映像 直接映像 cache中许多空的位置被浪费 主存地址：主存字块标记+cache字块地址+字块内地址 全相联映像 成本太高而不能采用 主存地址：主存字块标记+字块内地址 优点 方式灵活，缩小了块发生冲突的概率 缺点 增加了标识位位数 增加了寻找主存块在cache中对应块的时间 组相联映像 直接映像和全相联映像的折衷 主存地址：主存字块标记+组地址+块内地址 虚拟存储器 存储管理部件（MMU） 现代计算机一般都有辅助存储器，但具有辅存的存储系统不一定是虚拟存储系统 虚拟存储系统的特点 允许用户程序用比主存大的多的空间来访问主存 每次访存都要进行虚实地址的转换 辅助存储器 半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器 辅助存储器的种类 磁表面存储器 数字式磁记录：硬盘、软盘和磁带 模拟式磁记录：录音、录像设备 光存储器：光盘 串行存储器 顺序存取存储器 直接存取存储器 辅助存储器的技术指标 存储密度：单位长度或单位面积磁层表面磁层所存储的二进制信息量 道密度：沿磁盘半径方向单位长度的磁道数称为道密度，单位为道/英寸tpi或道/毫米tpmm 位密度或线密度：单位长度磁道所能记录二进制信息的位数叫位密度或线密度，单位为位/英寸bpi或位/毫米bpmm 每个磁道所存储的信息量是一样的 存储容量：C = n × k × s 寻址时间：平均寻址时间Ta=平均找道时间Ts+平均等待时间Tw 数据传输率：Dr = D × V 误码率 价格 硬磁盘存储器的类型 固定磁头和移动磁头 可换盘和固定盘 磁盘存储器 温彻斯特磁盘简称温盘 磁盘存储器由驱动器（HDD），控制器（HDC）和盘片组成 最外面的同心圆叫0磁道，最里面的同心圆假设称为n磁道 驱动器的定位驱动系统实现快速精准的磁头定位 主轴系统的作用是带动盘片按额定转速稳定旋转 数据控制系统的作用是控制数据的写入和读出，包括寻址，磁头旋转，写电流控制，读出放大，数据分离 磁盘控制器有两个方向的接口 与主机的接口 与驱动器（设备）的接口 光盘 采用光存储技术 利用激光写入和读出 第一代光存储技术采用非磁性介质，不可擦写 第二代光存储技术，采用磁性介质，可擦写 光盘的存储原理 只读型和只写一次型：热作用（物理或化学变化） 可擦写光盘：热磁效应 输出输出（I/O）设备/系统设备控制器（I/O）的基本功能 实现主机和外部设备之间的数据传送 实现数据缓冲，以达到主机同外部设备之间的速度匹配 接受主机的命令，提供设备接口的设备，并按照主机的命令控制设备 I/O 编址方式 统一编址：用取数、存数指令 不统一编址：有专门的 I/O 指令 I/O 与主机的连接方式 辐射式连接 每台设备都配有一套 控制线路和一组信号线 不便于增删设备 总线连接 便于增删设备 I/O设备 人机交互设备：键盘、鼠标等 计算机信息的驻留设备：硬盘、光盘等 机——机通信设备：MODEN等 为什么要设置接口？ 实现设备的选择 实现数据缓冲达到速度匹配 实现数据串 并格式转换 实现电平转换 传送控制命令 反映设备的状态（“忙”、“就绪”、“中断请求”） 中断服务程序的流程 保护现场 程序断点的保护 寄存器内容的保护 中断服务 对不同的 I/O 设备具有不同内容的设备服务 恢复现场：出栈指令 中断返回：中断返回指令 单重中断和多重中断 单重中断：不允许中断 现行的 中断服务程序 多重中断：允许级别更高 的中断源（现行的 中断服务程序） DMA 方式 主存和 I/O 之间有一条直接数据通道 CPU 和 I/O 并行工作 DMA 的三种工作方式 CPU暂停方式 CPU周期窃取方式 直接访问存储器 DMA 接口功能 向 CPU 申请 DMA 传送 处理总线 控制权的转交 管理 系统总线、控制 数据传送 确定 数据传送的 首地址和长度，修正 传送过程中的数据地址和长度 DMA 传送结束时，给出操作完成信号 DMA 传送过程：预处理、数据传送、后处理 外设接口 设备与主机相连时，必须按照规定的物理互连特性、电气特性等进行连接，这些特性的技术规范称为接口标准","categories":[{"name":"计算机科学与技术","slug":"计算机科学与技术","permalink":"http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"数据结构","slug":"数据结构","date":"2021-11-09T16:00:00.000Z","updated":"2022-05-23T10:36:04.752Z","comments":true,"path":"数据结构/","link":"","permalink":"http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。","text":"数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。 基本概念C/C++语言基础 数据类型 结构型 int a[maxSize]; 指针型 int *a; 链表结点12345typedef struct Node&#123; int data; struct Node *next;&#125;Node; 二叉树结点123456typedef struct BTNode&#123; int data; struct BTNode *lchild; struct BTNode *rchild;&#125;BTNode; 动态申请数组空间12int *p;p=(int *)malloc(n * sizeof(int)); 函数 函数参数的引用型定义123456int a=0;void f(int &amp;x)&#123; ++x;&#125;f(a); 数组作参数的引用型定义1void f(int x[][maxSize], int n)&#123;···;&#125; 算法的时间复杂度和空间复杂度 时间复杂度 $T(n)=O(f(n)中增长最快的项的系数)$ 将最坏的情况作为算法时间复杂度的度量 $O(1)≤O(\\log{2}\\left(n\\right)≤O(n)≤O(n\\log{2}\\left(n\\right)≤O(n^2)≤O(2^n)$（常对幂指阶） 取最深层循环内的语句所描述的操作为基本操作，由循环基本执行的次数为规模n，计算函数 $f(n)$ 空间复杂度：算法在运行时所需存储空间的度量，主要考虑在算法运行过程中临时占用的存储空间大小 空间复杂度 = 函数递归调用的深度 数据结构基本概念 数据是对客观事物的符号表示 数据元素是数据的基本单位 数据对象是性质相同的数据元素的集合 数据结构是相互之间存在一种或多种特定关系的数据元素的集合 数据的逻辑结构是对数据之间关系的描述，分为线性结构（一个数据元素的次序集合）和非线性结构（树、图） 数据的存储（物理）结构是数据的逻辑结构在计算机中的表示（映像），包括数据元素的表示和关系的表示 数据元素之间的关系：顺序映像和非顺序映像 数据结构中常用储存方法：顺序存储（数组）、链式存储（指针）、索引存储 &lt;关键字, 地址&gt;、散列存储（根据结点的关键字通过散列函数直接计算出该结点的存储地址） 算法的基本概念 算法的特性：有穷性、确定性、输入、输出、可行性 算法的设计目标：正确性、可读性、健壮性、高效率和低存储量需求 线性表线性表的基本概念 线性表是具有相同特性数据元素的一个有限序列，长度 $n≥0$ 线性表只有一个表头元素，一个表尾元素，除表头表尾元素外其他元素只有一个直接前驱和一个直接后继（有序性） 顺序表：随机访问特性、要求占用连续的存储空间、做插入操作要移动多个元素 链表：不支持随机访问、结点的存储空间利用率稍低、支持存储空间的动态分配 头指针指向链表的第一个结点、头结点指向带头结点链表的第一个结点 单链表、双链表、循环单链表、循环双链表、静态链表（数据元素分量+指针分量） 线性表的结构体定义 顺序表12345typedef struct&#123; int data[maxSize]; //考试写这两行 int length; //&#125;Sqlist; 单链表1234567typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode//构造LNode型结点LNode *A = (LNode*)malloc(sizeof(LNode)); 双链表123456typedef struct DLNode&#123; int data; struct DLNode *prior; struct DLNode *next;&#125;DLNode; 顺序表的操作 插入元素 1 ≤ i ≤ ListLength(L） 123456789101112131415int ListInsert(SeqList *L,int i,ElemType *e)&#123; int k； if(L-&gt;length==MAXSIZE)/*顺序线性表已经满*/ return ERROR; if（i&lt;1 || i&gt;L-&gt;length+1)/*当 i 不在范围内时*/ return ERROR; if(i&lt;=L-&gt;length) &#123; /*若插入数据位置不在表尾*/ for(k=L-&gt;length-1；k&gt;=i-1；k--) /*将要插入位置后的数据元素向后移动一位*/ L-&gt;data[k+1]=L-&gt;data[k]; &#125; L-&gt;data[i-1]=e;/*将新元素插入*/ L-&gt;length++; return OK;&#125; 删除元素 123456789101112131415int ListDelete(SqList *L,int i,ElemType *e)&#123; int k; if (L-&gt;length==0)/*线性表为空*/ return ERROR; if(i&lt;1|| i&gt;L-&gt;length)/*删除位置不正确*/ return ERROR; *e=L-&gt;data[i-1]; if(i&lt;L-&gt;1ength) &#123; /*如果删除不是最后位置*/ for（k=i；k&lt;L-&gt;length;k++)/*将删除位置后继元素前移*/ L-&gt;data[k-1]=L-&gt;data[k]; &#125; L-&gt;length--； return OK;&#125; 查找元素 12345678int findElem (Sqlist L, int e)&#123; int i; for (i=0; i&lt;L.length; ++i) if (e==L.data[i]) return i; return -1;&#125; 求指定位置元素 12345int getElem(Sqlist L, int p, int &amp;e) if(p&lt;0||p&gt;L.length-1) return 0; e=L.data[p]; return 1; 单链表的操作 尾插法建立链表C 12345678910111213141516void createlistR(LNode *&amp;C, int a[], int n)&#123; LNode *s, *r; //s指向新申请结点，r指向C的终端结点 int i; C=(LNode *)malloc(sizeof(LNode)); //申请C的头结点空间 C-&gt;next=NULL; r=C; for (i=0; i&lt;n; ++i) &#123; s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=a[i]; r-&gt;next=s; r=r-&gt;next; &#125; r-&gt;next=NULL;&#125; 归并成递减的单链表 1234567891011121314151617181920212223242526272829303132333435363738void merge (LNode *A, LNode *B, LNode *C)&#123; LNode *p=A-&gt;next; LNode *q=B-&gt;next; LNode *s; C=A; C-&gt;next=NULL; free(B); while(p!=NULL&amp;&amp;q!=NULL) &#123; /*下面的if else体现了头插法*/ if(p-&gt;data&lt;=q-&gt;data) &#123; s=p;p-&gt;next; s-&gt;next=C-&gt;next; C-next=s; &#125; else &#123; s=q;q=q-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; &#125; while(p!=NULL) &#123; s=p; p=p-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; while(q!=NULL) &#123; s=q; q=q-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125;&#125; 单链表获取元素 用 e 返回表中第 i 个数据元素的值 1234567891011121314int GetElem(LinkList L,int i,ElemType *e)&#123; int j=1; /*j 为计数器*/ LinkList p; /*声明一节点 p*/ p=L-&gt;next; /*p 指向链表 L 的第一个节点*/ while(p &amp;&amp; j&lt;i) &#123; /*当 p 不为空并且计数器不等于 i 时，循环继续*/ p=p-&gt;next； /*p 指向下一个节点*/ ++j; &#125; if(!p || j &gt; i) return ERROR; *e = p-&gt;data; return OK;&#125; 单链表插入元素 123456789101112131415161718int ListInsert(LinkList *L,int i,ElemType e)&#123; int j=1； LinkList p,s; p=*L； while (p &amp;&amp; j&lt;i) /*寻找第 i 个节点*/ &#123; p=p-&gt;next; ++j； &#125; if (!p || j&gt;i) return ERROR; /*第 i 个元素不存在*/ s=(LinkList *) malloc (sizeof(Node)); /*生成新节点（C 标准函数）*/ s-&gt;data=e; s-&gt;next=p-&gt;next; //将 p 的后继节点赋值给 s 的后继*） p-&gt;next=s; //将 s 赋值给 p 的后继 return OK;&#125; 双链表的操作 尾插法建立双链表 123456789101112131415161718void createDlistR(DLNode *&amp;L, int a[], int n)&#123; DLNode *s, *r; //s指向新申请结点，r指向C的终端结点 int i; L=(DLNode *)malloc(sizeof(DLNode)); L-&gt;prior=NULL; L-&gt;next=NULL; r=L; //和单链表一样，r始终指向终端节点，开始头节点也是尾节点 for (i=0; i&lt;n; ++i) &#123; s=(DLNode *)malloc(sizeof(DLNode)); s-&gt;data=a[i]; r-&gt;next=s; s-&gt;prior=r; r=s; &#125; r-&gt;next=NULL;&#125; 双链表寻找结点 1234567891011DLNoded* findNode(DLNode *C, int x)&#123; DLNode *p=C-&gt;next; while(p!=NULL) &#123; if(p-&gt;data==x) break; p=p-&gt;next; &#125; return p; //如果找到，则P中内容是结点地址，如果没找到，则P中内容是NULL&#125; 双链表插入结点 1234s-&gt;prior = p; s-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = s; p-&gt;next = s; 双链表删除结点 123p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; free(p) //释放空间，不要漏掉 链表的逆置 123456789ListNode* reverseList(ListNode head)&#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode* newhead = reverseList(head-&gt;next); //递归到链尾 head-&gt;next-&gt;next = head; //反转链表 head-&gt;next = NULL; //将指针置NULL return newhead; //newhead始终指向新链表的头&#125; 循环链表的操作 逆置循环链表 只交换节点中的数据成员 data，其他的前后指针不变 1234567891011void Reverse () &#123; LinkList * begin = _head; LinkList * end = _tail; while (begin != end &amp;&amp; begin-&gt;_prev != end) &#123; swap(begin-&gt;_data, end-&gt;_data); begin = begin-&gt;_next; end = end-&gt;_prev; &#125; &#125; 删除顺序表中值在 min 和 max 之间的数 对顺序表进行遍历查找介于 min 与 max 之间的数然后进行删除 123456789101112131415void Delete(Seqlist *L,int min,int max)&#123; int i=0,n=0; while(i&lt;L-&gt;length) &#123; if(L-&gt;elem[i]&gt;=min &amp;&amp; L-&gt;elem[i]&lt;=max) n++; else L-&gt;elem[i-n]=L-&gt;elem[i]; i++; &#125; L-&gt;length -= n; if(L-&gt;length==0) printf(&quot;the sqlist ie empty/n&quot;); &#125; 栈和队列栈和队列的基本概念 栈是一种只能在一端进行插入或删除操作的线性表（FILO） 栈顶（Top）动态变化，栈底固定不变 队列为仅允许在表的一端进行插入，在表的另一端进行删除的线性表（FIFO） 队头（Front）可进行删除，队尾（Rear）可进行插入 栈和队列的结构体定义 顺序栈的定义 12345typedef struct&#123; int data[maxSize]; int top;&#125; SqStack; 链栈结点的定义 12345typedef struct LNode&#123; int data; struct LNode *next;&#125; LNode; 顺序队列的定义 123456typedef struct&#123; int data[maxSize]; int front; int rear;&#125; SqQueue; 链队结点的定义 12345typedef struct QNode&#123; int data; struct QNode *next;&#125; QNode; 链队类型的定义 12345typedef struct&#123; QNode *front; QNode *rear;&#125; LiQueue; 顺序栈 栈空状态：st.top==-1 栈满状态：st.top==maxSize-1 非法状态：栈满后继续入站上溢，栈空继续出栈下溢 定义一个栈并初始化：int stack[maxSize]; int top==-1 进栈：先移动指针再进栈 stack[++top]=x; 12345678int push(SqStack &amp;st,int x)&#123; if(st.top==maxSize-1) return 0; ++(st.top); st.data[st.top]=x; return 1;&#125; 出栈：先取出元素，再移动指针 x=stack[top--]; 12345678int pop(SqStack &amp;st,int &amp;x)&#123; if(st.stop==-1) return 0; //栈空不能出栈 x = st.data[st.top]; --(st.top); return 1;&#125; 链栈 栈空状态：lst-&gt;next==NULL 不存在栈满状态 进栈：头插法建立链表中的插入操作 p-&gt;next=lst-&gt;next; lst-&gt;next=p; 出栈：单链表的删除操作，出栈元素保存在 x 中 p-lst-&gt;next; x=p-&gt;data; lst-&gt;next=p-&gt;next; free(p); 循环队列 解决假溢出：front=(front+1)%maxSize 队空状态：qu.rear==qu.front 队满状态：(qu.rear+1)%maxSize==qu.front 初始化队列：队首和队尾指针重合，并且指向0 qu.front=qu.rear=0; 进队算法 12345678int enQueue(SqQueue qu)&#123; if((qu.rear+1)%maxSize==qu.front) return 0 qu.rear=(qu.rear+1)%maxSize; //先移动指针 qu.data[qu.rear]=x; //再存入元素 return 1;&#125; 出队算法 12345678int denQueue(SqQueue &amp;qu, int &amp;x)&#123; if(qu.rear==qu.front) return 0; qu.front=((qu.front+1)%maxSize) //先移动指针 x=qu.data[qu.front]; return 1;&#125; 链队（尽量避免使用） 队空状态：lqu-&gt;rear==NULL 或者 lqu-&gt;front==NULL 不存在队满状态 初始化链队 12345void initQueue(LiQueue *&amp;lqu)&#123; lqu=(LiQueue*)malloc(sizeof(LiQueue)); lqu-&gt;front=lqu-&gt;rear=NULL;&#125; 进队操作：lqu-&gt;rear-&gt;next=p; lqu-&gt;rear=p; 出队操作：p=lqu-&gt;front; lqu-&gt;front=p-&gt;next; x=p-&gt;data; free(p); 用队列实现栈 入栈：push(x)，除栈顶元素：pop() — 移，获取栈顶元素：top() ，返回栈是否为空：empty() 12345678910111213141516171819202122232425262728293031323334353637383940414243// Push element x onto stack.void push(int x)&#123; q1.push(x);&#125;// Removes the element on top of the stack and returns thatint pop()&#123; int length1 = q1size(); for(int i-0; i&lt; length1- 1; i++) &#123; q2.push(q1.front()); q1. pop(); &#125; data= q1.front() int length2= q2size(): for(int j=0;j&lt; length2; j++) &#123; q1.push(q2.front()); q2.pop(); &#125; return data;&#125;// Get the top element. *int top() int length1 = q1.size(); int data; for (int i=0; i&lt; length1- 1; i++) &#123; q2.push(q1.front()); q1.pop(); &#125; data= q1.front(); return data;&#125;// Returns whether the stack isemptybool empty()&#123; if(q1.empty()&amp;&amp;q2.empty()) return true; else return false;&#125; 串串数据类型的定义 串是限定了元素为字符的线性表，char str[]=&quot;abcdef&quot;; 空格串不是空串 串赋值：对数组中的每个元素进行逐一赋值操作 strassign(str,&quot;cur input&quot;); 取串长度 return str.length; 串比较操作 1234567int strcompare(Str s1, Str s2)&#123; for(int i=0;i&lt;s1.length&amp;&amp;i&lt;s2.length;++i) if(s1.ch[i]!=s2.ch[i]) return s1.ch[i]-s2.ch[i]; return s1.length - s2.length;&#125; 串的模式匹配算法 KMP 算法 123456789101112131415161718192021222324252627282930void getnext(str substr, int next[])&#123; int i=1, j=0; next[1]=0; while (i&lt;substr.length) &#123; if (j==0||substr.ch[i]==substr.ch[j]) &#123; ++i, ++j; next[i]=j; &#125; else j=next[j]; &#125;&#125;int KMP (Str str, Str substr, int next[])&#123; int i=j=1; while(i&lt;=str.length&amp;&amp;j&lt;=substr.length) &#123; if (j==0||str.ch[i]==substr.ch[j]) ++i, ++j; else j=next[ j]; if (j&gt;substr.length) return i-substr.length; else return 0; &#125;&#125; 矩阵与广义表矩阵 矩阵的转置 123456void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) B[j][i] = A[i][j];&#125; 矩阵相加 123456void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) C[i][j] = A[i][j] + B[i][j];&#125; 矩阵相乘 12345678910void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; k;++j) &#123; C[i][j] = 0; for int(h = 0;h &lt; n;++h) C[i][j] += A[i][j] * B[i][j]; &#125;&#125; 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵 对称矩阵、三角阵、对角矩阵 广义表 表元素可以是原子或者广义表的一种线性表的扩展结构 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾 原子结点有两个域：标志域和数据域 广义表结点有三个域：标志域，头指针域与尾指针域 树树的基本概念 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成 结点不仅包含数据元素，并且包含指向子树的分支 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值 树的高度是树中结点的最大层次，根结点的高度为树的高度 树的双亲存储结构：int tree[maxSize] 树的链式存储结构 邻接表：孩子存储结构 孩子兄弟存储结构 二叉树的概念和性质 二叉树的定义 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2 子树有左右顺序之分，不能颠倒 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的 二叉树的主要性质 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$ 在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$ 二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$ 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点： 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\\lfloor i/2\\rfloor$ 的结点为其双亲结点（向下取整） 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点 Catalan()：给定 n 个结点，能够成 $h\\left( n\\right) =\\dfrac{C_{2n}^{n}}{n+1}$ 棵不同的二叉树 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\\lfloor log2n\\rfloor+1$ 二叉树的顺序存储结构最适用于完全二叉树 二叉树的链式存储结构 123456typedef struct BTNode&#123; char data; //数据域 struct BTNoode* lchild; struct BTNode* rchild;&#125; BTNode; 二叉树的遍历算法 先序遍历 12345678910111213141516171819202122232425262728293031323334353637383940/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; printf(&quot;树为空！\\n&quot;); return; &#125; //end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //p 所指节点入栈 printf(&quot;%c &quot;, p-&gt;data); //相当于 visit（p） p = p-&gt;lchild ; //指向 p 的左孩子 &#125;//end if else &#123; //p 所指节点为空，则出栈赋给 p，遍历右子树 StackPop(S, p); p = p-&gt;rchild; //若右孩子有左子树则继续 while 将左孩子入栈 &#125; //end else &#125; //end while free(S);&#125; //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123; if (root) &#123; printf(&quot;%d &quot;, root-&gt;data); preOrder(root-&gt;lchild); preOrder(root-&gt;rchild); &#125;&#125; 中序遍历 1234567891011121314151617181920212223242526272829303132333435363738/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; //如果是空树 printf(&quot;树为空！\\n&quot;) ; return; &#125;//end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //将节点入栈 p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子 &#125;//end if else &#123; StackPop(S, p); //p 左子树为空则出栈 printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点 p = p-&gt;rchild; //向右子树移动 &#125;//end else &#125;//end while free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123; if (root) &#123; inOrder(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); inOrder(root-&gt;rchild); &#125;&#125; 后序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123; StackNode* S; BiTNode* cur, * pre;//定义一个栈指针 S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点 if (NULL == root) &#123; printf(&quot;树为空！\\n&quot;); return; &#125;//end if pre = NULL; cur = NULL; StackPush(S, T); //根节点入栈 while (!StackEmpty(S)) &#123; //若栈非空 cur = NULL; StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/ if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) || (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild))) &#123; printf(&quot;%c &quot;, cur-&gt;data); pre = cur; StackPop(S, cur); &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。 else &#123; if (cur-&gt;rchild != NULL) StackPush(S, cur-&gt;rchild); if (cur-&gt;lchild != NULL) StackPush(S, cur-&gt;lchild); &#125;//end else &#125;//end while free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123; if (root) &#123; postOrder(root-&gt;lchild); postOrder(root-&gt;rchild); printf(&quot;%d &quot;, root-&gt;data); &#125; &#125; 层次遍历：自上而下，自左向右 首先，将二叉树的祖先节点入队列 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队 12345678910111213void LayerOrder(BiTreeNode* head)&#123; LQueue Q; Initiate_Queue(&amp;Q); BiTreeNode* p; if (head != NULL) AppendQueue(&amp;Q, head); while (QueueNotEmpty(&amp;Q)) &#123; p = QueueDelete(&amp;Q); cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild); if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild); &#125;&#125; 哈夫曼树和哈夫曼编码 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短 树的路径长度是指从根到每个节点的路径长度之和 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度 123456789101112ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0 &#123; if (FBT == NULL) //空树返回0 return 0; else &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点 return FBT-&gt;data * len; else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增 return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1); &#125; &#125; 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct BTreeNode* CreateHuffman(ElemType a[], int n) &#123; int i, j; struct BTreeNode **b, *q; b = malloc(n*sizeof(struct BTreeNode)); for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点 &#123; b[i] = malloc(sizeof(struct BTreeNode)); b[i]-&gt;data = a[i]; b[i]-&gt;left = b[i]-&gt;right = NULL; &#125; for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树 &#123; //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标 int k1 = -1, k2; for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵 &#123; if (b[j] != NULL &amp;&amp; k1 == -1) &#123; k1 = j; continue; &#125; if (b[j] != NULL) &#123; k2 = j; break; &#125; &#125; for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小 &#123; if (b[j] != NULL) &#123; if (b[j]-&gt;data &lt; b[k1]-&gt;data) &#123; k2 = k1; k1 = j; &#125; else if (b[j]-&gt;data &lt; b[k2]-&gt;data) k2 = j; &#125; &#125; //由最小权值树和次最小权值树建立一棵新树，q指向树根结点 q = malloc(sizeof(struct BTreeNode)); q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data; q-&gt;left = b[k1]; q-&gt;right = b[k2]; b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置 b[k2] = NULL;//k2位置为空 &#125; free(b); //删除动态建立的数组b return q; //返回整个哈夫曼树的树根指针 &#125; 哈夫曼编码 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码 哈夫曼编码产生的是最短前缀码 12345678910111213141516171819202122void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0 &#123; static int a[10]; //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一 if (FBT != NULL) //访问到叶子结点时输出其保存在数组a中的0和1序列编码 &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL) &#123; int i; printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data); for (i = 0; i &lt; len; i++) printf(&quot;%d&quot;, a[i]); printf(&quot;\\n&quot;); &#125; else //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a &#123; //的对应元素中，向下深入一层时len值增1 a[len] = 0; HuffManCoding(FBT-&gt;left, len + 1); a[len] = 1; HuffManCoding(FBT-&gt;right, len + 1); &#125; &#125; &#125; 图图的基本概念 图由结点的有穷集合的 V 和边的集合 E 组成（G(V,E)） 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $$ 表示 路径长度：路径上边或者弧的数目 顶点的度：顶点关联边的数目 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度 在有向图中，顶点的度就是两者之和 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量 图的存储结构 邻接矩阵 图的顺序存储结构 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息 无向图中邻接矩阵是个对称矩阵 0表示无边，1表示有边 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费 1234567891011typedef struct&#123; int no; char info;&#125; VertexType;typedef struct&#123; int edges[maxSize][maxSize]; //有权图中int改为float int n,e; //顶点数和边数 VertexType vex[maxSize]; //存放结点信息&#125; MGragh; 邻接表 数组和链表相结合的存储方法，图的链式存储结构 图中顶点用一个一维数组存储 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表 顶点表的各个结点由 data 和 Firstedge 两个域表示 data 是数据域，存储顶点信息 firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点 边表结点由 adjvex 和 next 两个域组成 adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标 next 存储边表中下一个结点指针 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表 12345678910111213141516typedef struct ArcNode&#123; int adnex; //该边所指向的结点的位置 struct ArcNode * nextarc; //指向下一条边的指针 int info; //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123; char data; //顶点信息 ArcNode* firstarc; //指向第一条边的指针&#125;VNode;typedef struct&#123; VNode adjlist[maxSize]; //邻接表 int n, e; //顶点数和边数&#125; AGraph; //图的邻接表类型 十字链表 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表 定点表 firstin：入边表头指针，指向顶点入边表的第一个结点 firstout：出边表头指针，指向顶点出边表第一个结点 边表 tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标 headlink 入边表指针域，指向终点相同的下一条边 taillink 是指边表指针域，指向起点相同的下一条边 邻接多重表 ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标 ilink 指向依附项点 ivex 的下一条边 jlink 指向依附顶点 jvex 的下一条边 图的遍历算法 深度优先遍历（DFS，Depth First Search） 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历 1234567891011121314151617bool visited[Max_Vex]; //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123; for (v = 0;v &lt; G.vexnum;++v) visited[v] = false; //初始化标记数组 for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做深度优先遍历 DFS(G, v);&#125;void DFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) DFS(G, w);&#125; 广度优先遍历（BFS，Breadth First Search） 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完 BFS 遍历的方式类似于树的层次遍历 1234567891011121314151617181920212223242526bool visited[Max_Vex]; //定义访问标记数组void BFSTraverse(Graph G)&#123; for (i = 0;i &lt; G.vexnum;++i) visited[v] = false; //初始化标记数组 InitQueue(Q); for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做广度优先遍历 BFS(G, v);&#125;void BFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 while (!isEmpty(Q)) &#123; DeQueue(Q, v); for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) &#123; visit(w); visited[w] = true; EnQueue(Q, w) &#125; //if &#125; //while&#125; 最小生成树 Prim 算法 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树 1234567891011void prim (G,T)&#123; T = ∅; U = &#123;w&#125;; while ((V - U) != ∅ ) &#123; //若图中不含全部顶点 设 (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边; T = T∪ (u，v); //边归入树 U = U∪ &#123;v&#125;; //顶点归入树 &#125;&#125; Kruskal 算法 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止 Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图 普里姆算法和克鲁斯卡尔算法都是针对于无向图的 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合 1234567891011121314void kruskal（V，T）&#123; T = V; //初始化树，仅含顶点 numS = n; //不连分量的数目 while (numS &gt; 1) &#123; 从 E 中取出权值最小的边（v,u）; if（v 和 u 属于 T 中不同的连通分量） &#123; T = T∪（u，v）;//将此边加入到生成树中； numS--; //不连通的分量减少 1 &#125; &#125;&#125; 最短路径 Dijkstra 算法 通常用于求图中某一顶点到其余各顶点的最短路径 设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中） 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度 Dijkstra 算法步骤 初始时，S 只包含源点，即 S＝{v}，v 的距离为 0，U 包含除 v 外的其他顶点，即:U={其 余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$ 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度） 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离 重复步骤 b 和 c 直到所有顶点都包含在 S 中 12345678910111213141516171819202122232425262728293031323334353637void Dijkstra(int v0)&#123; bool S[MAXNUM]; // 判断是否已存入该点到S集合中 int n=MAXNUM; for(int i=1; i&lt;=n; ++i) &#123; dist[i] = A[v0][i]; S[i] = false; // 初始都未用过该点 if(dist[i] == MAXINT) prev[i] = -1; else prev[i] = v0; &#125; dist[v0] = 0; S[v0] = true; for(int i=2; i&lt;=n; i++) &#123; int mindist = MAXINT; int u = v0; // 找出当前未使用的点j的dist[j]最小值 for(int j=1; j&lt;=n; ++j) if((!S[j]) &amp;&amp; dist[j]&lt;mindist) &#123; u = j; // u保存当前邻接点中距离最小的点的号码 mindist = dist[j]; &#125; S[u] = true; for(int j=1; j&lt;=n; j++) if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT) &#123; if(dist[u] + A[u][j] &lt; dist[j]) //在通过新加入的u点路径找到离v0点更短的路径 &#123; dist[j] = dist[u] + A[u][j]; //更新dist prev[j] = u; //记录前驱顶点 &#125; &#125; &#125;&#125; Floyd 算法 Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包 Floyd-Warshall 算法的时间复杂度为 $O(N^3)$，空间复杂度为 $O(N^2)$ Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离 Floyd 算法步骤 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它 12345for (k = 1;k &lt;= n;k++) for (i = 1;i &lt;= n;i++) for (j = 1;j &lt;= n;j++) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; 拓扑排序 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边 从 DAG 图中选择一个没有前驱的节点并输出 从图中删除该节点和所有以它为起点的有向边 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止 12345678910111213141516171819202122232425bool topologicalSort(Graph GL)&#123; EdgeNode* e; int top = 0; //用于栈指针下标 int count = 0; // 用于统计输出顶点的个数 int* stack; // 建栈将入度为 0 的顶点入栈 stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int)); for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈 stack[++top] = i; while (top != 0) &#123; gettop = stack[top--]; printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data); count++; //输出 i 号顶点，并计数 for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123; k = e-&gt;adjvex; if (!(--GL-&gt;adjList[k].in)) //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈 stack[++top] = k; &#125; &#125; if (count &lt; GL-&gt;numVertexes) return false; else return true;&#125; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构国家精品课，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的代码，可供参考。其他部分笔记详见数据结构（上）和数据结构（下） 矩阵与广义表矩阵 矩阵的转置 123456void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) B[j][i] = A[i][j];&#125; 矩阵相加 123456void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) C[i][j] = A[i][j] + B[i][j];&#125; 矩阵相乘 12345678910void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; k;++j) &#123; C[i][j] = 0; for int(h = 0;h &lt; n;++h) C[i][j] += A[i][j] * B[i][j]; &#125;&#125; 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵 对称矩阵、三角阵、对角矩阵 广义表 表元素可以是原子或者广义表的一种线性表的扩展结构 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾 原子结点有两个域：标志域和数据域 广义表结点有三个域：标志域，头指针域与尾指针域 树树的基本概念 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成 结点不仅包含数据元素，并且包含指向子树的分支 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值 树的高度是树中结点的最大层次，根结点的高度为树的高度 树的双亲存储结构：int tree[maxSize] 树的链式存储结构 邻接表：孩子存储结构 孩子兄弟存储结构 二叉树的概念和性质 二叉树的定义 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2 子树有左右顺序之分，不能颠倒 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的 二叉树的主要性质 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$ 在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$ 二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$ 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点： 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\\lfloor i/2\\rfloor$ 的结点为其双亲结点（向下取整） 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点 Catalan()：给定 n 个结点，能够成 $h\\left( n\\right) =\\dfrac{C_{2n}^{n}}{n+1}$ 棵不同的二叉树 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\\lfloor log2n\\rfloor+1$ 二叉树的顺序存储结构最适用于完全二叉树 二叉树的链式存储结构 123456typedef struct BTNode&#123; char data; //数据域 struct BTNoode* lchild; struct BTNode* rchild;&#125; BTNode; 二叉树的遍历算法 先序遍历 12345678910111213141516171819202122232425262728293031323334353637383940/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; printf(&quot;树为空！\\n&quot;); return; &#125; //end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //p 所指节点入栈 printf(&quot;%c &quot;, p-&gt;data); //相当于 visit（p） p = p-&gt;lchild ; //指向 p 的左孩子 &#125;//end if else &#123; //p 所指节点为空，则出栈赋给 p，遍历右子树 StackPop(S, p); p = p-&gt;rchild; //若右孩子有左子树则继续 while 将左孩子入栈 &#125; //end else &#125; //end while free(S);&#125; //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123; if (root) &#123; printf(&quot;%d &quot;, root-&gt;data); preOrder(root-&gt;lchild); preOrder(root-&gt;rchild); &#125;&#125; 中序遍历 1234567891011121314151617181920212223242526272829303132333435363738/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; //如果是空树 printf(&quot;树为空！\\n&quot;) ; return; &#125;//end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //将节点入栈 p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子 &#125;//end if else &#123; StackPop(S, p); //p 左子树为空则出栈 printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点 p = p-&gt;rchild; //向右子树移动 &#125;//end else &#125;//end while free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123; if (root) &#123; inOrder(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); inOrder(root-&gt;rchild); &#125;&#125; 后序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123; StackNode* S; BiTNode* cur, * pre;//定义一个栈指针 S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点 if (NULL == root) &#123; printf(&quot;树为空！\\n&quot;); return; &#125;//end if pre = NULL; cur = NULL; StackPush(S, T); //根节点入栈 while (!StackEmpty(S)) &#123; //若栈非空 cur = NULL; StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/ if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) || (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild))) &#123; printf(&quot;%c &quot;, cur-&gt;data); pre = cur; StackPop(S, cur); &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。 else &#123; if (cur-&gt;rchild != NULL) StackPush(S, cur-&gt;rchild); if (cur-&gt;lchild != NULL) StackPush(S, cur-&gt;lchild); &#125;//end else &#125;//end while free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123; if (root) &#123; postOrder(root-&gt;lchild); postOrder(root-&gt;rchild); printf(&quot;%d &quot;, root-&gt;data); &#125; &#125; 层次遍历：自上而下，自左向右 首先，将二叉树的祖先节点入队列 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队 12345678910111213void LayerOrder(BiTreeNode* head)&#123; LQueue Q; Initiate_Queue(&amp;Q); BiTreeNode* p; if (head != NULL) AppendQueue(&amp;Q, head); while (QueueNotEmpty(&amp;Q)) &#123; p = QueueDelete(&amp;Q); cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild); if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild); &#125;&#125; 哈夫曼树和哈夫曼编码 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短 树的路径长度是指从根到每个节点的路径长度之和 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度 123456789101112ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0 &#123; if (FBT == NULL) //空树返回0 return 0; else &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点 return FBT-&gt;data * len; else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增 return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1); &#125; &#125; 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct BTreeNode* CreateHuffman(ElemType a[], int n) &#123; int i, j; struct BTreeNode **b, *q; b = malloc(n*sizeof(struct BTreeNode)); for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点 &#123; b[i] = malloc(sizeof(struct BTreeNode)); b[i]-&gt;data = a[i]; b[i]-&gt;left = b[i]-&gt;right = NULL; &#125; for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树 &#123; //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标 int k1 = -1, k2; for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵 &#123; if (b[j] != NULL &amp;&amp; k1 == -1) &#123; k1 = j; continue; &#125; if (b[j] != NULL) &#123; k2 = j; break; &#125; &#125; for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小 &#123; if (b[j] != NULL) &#123; if (b[j]-&gt;data &lt; b[k1]-&gt;data) &#123; k2 = k1; k1 = j; &#125; else if (b[j]-&gt;data &lt; b[k2]-&gt;data) k2 = j; &#125; &#125; //由最小权值树和次最小权值树建立一棵新树，q指向树根结点 q = malloc(sizeof(struct BTreeNode)); q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data; q-&gt;left = b[k1]; q-&gt;right = b[k2]; b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置 b[k2] = NULL;//k2位置为空 &#125; free(b); //删除动态建立的数组b return q; //返回整个哈夫曼树的树根指针 &#125; 哈夫曼编码 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码 哈夫曼编码产生的是最短前缀码 12345678910111213141516171819202122void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0 &#123; static int a[10]; //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一 if (FBT != NULL) //访问到叶子结点时输出其保存在数组a中的0和1序列编码 &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL) &#123; int i; printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data); for (i = 0; i &lt; len; i++) printf(&quot;%d&quot;, a[i]); printf(&quot;\\n&quot;); &#125; else //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a &#123; //的对应元素中，向下深入一层时len值增1 a[len] = 0; HuffManCoding(FBT-&gt;left, len + 1); a[len] = 1; HuffManCoding(FBT-&gt;right, len + 1); &#125; &#125; &#125; 图图的基本概念 图由结点的有穷集合的 V 和边的集合 E 组成（G(V,E)） 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $$ 表示 路径长度：路径上边或者弧的数目 顶点的度：顶点关联边的数目 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度 在有向图中，顶点的度就是两者之和 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量 图的存储结构 邻接矩阵 图的顺序存储结构 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息 无向图中邻接矩阵是个对称矩阵 0表示无边，1表示有边 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费 1234567891011typedef struct&#123; int no; char info;&#125; VertexType;typedef struct&#123; int edges[maxSize][maxSize]; //有权图中int改为float int n,e; //顶点数和边数 VertexType vex[maxSize]; //存放结点信息&#125; MGragh; 邻接表 数组和链表相结合的存储方法，图的链式存储结构 图中顶点用一个一维数组存储 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表 顶点表的各个结点由 data 和 Firstedge 两个域表示 data 是数据域，存储顶点信息 firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点 边表结点由 adjvex 和 next 两个域组成 adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标 next 存储边表中下一个结点指针 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表 12345678910111213141516typedef struct ArcNode&#123; int adnex; //该边所指向的结点的位置 struct ArcNode * nextarc; //指向下一条边的指针 int info; //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123; char data; //顶点信息 ArcNode* firstarc; //指向第一条边的指针&#125;VNode;typedef struct&#123; VNode adjlist[maxSize]; //邻接表 int n, e; //顶点数和边数&#125; AGraph; //图的邻接表类型 十字链表 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表 定点表 firstin：入边表头指针，指向顶点入边表的第一个结点 firstout：出边表头指针，指向顶点出边表第一个结点 边表 tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标 headlink 入边表指针域，指向终点相同的下一条边 taillink 是指边表指针域，指向起点相同的下一条边 邻接多重表 ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标 ilink 指向依附项点 ivex 的下一条边 jlink 指向依附顶点 jvex 的下一条边 #### 图的遍历算法 - 深度优先遍历（DFS，Depth First Search） - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了 - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问 - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历 1234567891011121314151617bool visited[Max_Vex]; //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123; for (v = 0;v &lt; G.vexnum;++v) visited[v] = false; //初始化标记数组 for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做深度优先遍历 DFS(G, v);&#125;void DFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) DFS(G, w);&#125; - 广度优先遍历（BFS，Breadth First Search） - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点 - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完 - BFS 遍历的方式类似于树的层次遍历 1234567891011121314151617181920212223242526bool visited[Max_Vex]; //定义访问标记数组void BFSTraverse(Graph G)&#123; for (i = 0;i &lt; G.vexnum;++i) visited[v] = false; //初始化标记数组 InitQueue(Q); for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做广度优先遍历 BFS(G, v);&#125;void BFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 while (!isEmpty(Q)) &#123; DeQueue(Q, v); for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) &#123; visit(w); visited[w] = true; EnQueue(Q, w) &#125; //if &#125; //while&#125; #### 最小生成树 - Prim 算法 - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树 - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树 - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树 1234567891011void prim (G,T)&#123; T = ∅; U = &#123;w&#125;; while ((V - U) != ∅ ) &#123; //若图中不含全部顶点 设 (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边; T = T∪ (u，v); //边归入树 U = U∪ &#123;v&#125;; //顶点归入树 &#125;&#125; - Kruskal 算法 - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止 - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图 - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的 - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树 - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合 - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合 1234567891011121314void kruskal（V，T）&#123; T = V; //初始化树，仅含顶点 numS = n; //不连分量的数目 while (numS &gt; 1) &#123; 从 E 中取出权值最小的边（v,u）; if（v 和 u 属于 T 中不同的连通分量） &#123; T = T∪（u，v）;//将此边加入到生成树中； numS--; //不连通的分量减少 1 &#125; &#125;&#125; #### 最短路径 - Dijkstra 算法 - 通常用于求图中某一顶点到其余各顶点的最短路径 - 设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组 - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中） - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度 - Dijkstra 算法步骤 1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$ 2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度） 3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离 4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中 12345678910111213141516171819202122232425262728293031323334353637void Dijkstra(int v0)&#123; bool S[MAXNUM]; // 判断是否已存入该点到S集合中 int n=MAXNUM; for(int i=1; i&lt;=n; ++i) &#123; dist[i] = A[v0][i]; S[i] = false; // 初始都未用过该点 if(dist[i] == MAXINT) prev[i] = -1; else prev[i] = v0; &#125; dist[v0] = 0; S[v0] = true; for(int i=2; i&lt;=n; i++) &#123; int mindist = MAXINT; int u = v0; // 找出当前未使用的点j的dist[j]最小值 for(int j=1; j&lt;=n; ++j) if((!S[j]) &amp;&amp; dist[j]&lt;mindist) &#123; u = j; // u保存当前邻接点中距离最小的点的号码 mindist = dist[j]; &#125; S[u] = true; for(int j=1; j&lt;=n; j++) if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT) &#123; if(dist[u] + A[u][j] &lt; dist[j]) //在通过新加入的u点路径找到离v0点更短的路径 &#123; dist[j] = dist[u] + A[u][j]; //更新dist prev[j] = u; //记录前驱顶点 &#125; &#125; &#125;&#125; - Floyd 算法 - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包 - Floyd-Warshall 算法的时间复杂度为 $O(N^3)$，空间复杂度为 $O(N^2)$ - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离 - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离 - Floyd 算法步骤 - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大 - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它 12345for (k = 1;k &lt;= n;k++) for (i = 1;i &lt;= n;i++) for (j = 1;j &lt;= n;j++) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; #### 拓扑排序 - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边 1. 从 DAG 图中选择一个没有前驱的节点并输出 2. 从图中删除该节点和所有以它为起点的有向边 3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止 12345678910111213141516171819202122232425bool topologicalSort(Graph GL)&#123; EdgeNode* e; int top = 0; //用于栈指针下标 int count = 0; // 用于统计输出顶点的个数 int* stack; // 建栈将入度为 0 的顶点入栈 stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int)); for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈 stack[++top] = i; while (top != 0) &#123; gettop = stack[top--]; printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data); count++; //输出 i 号顶点，并计数 for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123; k = e-&gt;adjvex; if (!(--GL-&gt;adjList[k].in)) //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈 stack[++top] = k; &#125; &#125; if (count &lt; GL-&gt;numVertexes) return false; else return true;&#125; &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下) &lt;!--more--&gt; ### 矩阵与广义表 #### 矩阵 - 矩阵的转置 123456void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) B[j][i] = A[i][j];&#125; - 矩阵相加 123456void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) C[i][j] = A[i][j] + B[i][j];&#125; - 矩阵相乘 12345678910void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; k;++j) &#123; C[i][j] = 0; for int(h = 0;h &lt; n;++h) C[i][j] += A[i][j] * B[i][j]; &#125;&#125; - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵 - 对称矩阵、三角阵、对角矩阵 #### 广义表 - 表元素可以是原子或者广义表的一种线性表的扩展结构 - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数 - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾 - 原子结点有两个域：标志域和数据域 - 广义表结点有三个域：标志域，头指针域与尾指针域 ### 树 #### 树的基本概念 - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成 - 结点不仅包含数据元素，并且包含指向子树的分支 - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值 - 树的高度是树中结点的最大层次，根结点的高度为树的高度 - 树的双亲存储结构：`int tree[maxSize]` - 树的链式存储结构 - 邻接表：孩子存储结构 - 孩子兄弟存储结构 #### 二叉树的概念和性质 - 二叉树的定义 - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2 - 子树有左右顺序之分，不能颠倒 - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层 - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的 - 二叉树的主要性质 1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$ 2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$ 3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$ 4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点： - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\\lfloor i/2\\rfloor$ 的结点为其双亲结点（向下取整） - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点 - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点 5. Catalan()：给定 n 个结点，能够成 $h\\left( n\\right) =\\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$ 棵不同的二叉树 6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\\lfloor log2n\\rfloor+1$ - 二叉树的顺序存储结构最适用于完全二叉树 - 二叉树的链式存储结构 123456typedef struct BTNode&#123; char data; //数据域 struct BTNoode* lchild; struct BTNode* rchild;&#125; BTNode; #### 二叉树的遍历算法 - 先序遍历 12345678910111213141516171819202122232425262728293031323334353637383940/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; printf(&quot;树为空！\\n&quot;); return; &#125; //end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //p 所指节点入栈 printf(&quot;%c &quot;, p-&gt;data); //相当于 visit（p） p = p-&gt;lchild ; //指向 p 的左孩子 &#125;//end if else &#123; //p 所指节点为空，则出栈赋给 p，遍历右子树 StackPop(S, p); p = p-&gt;rchild; //若右孩子有左子树则继续 while 将左孩子入栈 &#125; //end else &#125; //end while free(S);&#125; //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123; if (root) &#123; printf(&quot;%d &quot;, root-&gt;data); preOrder(root-&gt;lchild); preOrder(root-&gt;rchild); &#125;&#125; - 中序遍历 1234567891011121314151617181920212223242526272829303132333435363738/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; //如果是空树 printf(&quot;树为空！\\n&quot;) ; return; &#125;//end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //将节点入栈 p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子 &#125;//end if else &#123; StackPop(S, p); //p 左子树为空则出栈 printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点 p = p-&gt;rchild; //向右子树移动 &#125;//end else &#125;//end while free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123; if (root) &#123; inOrder(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); inOrder(root-&gt;rchild); &#125;&#125; - 后序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123; StackNode* S; BiTNode* cur, * pre;//定义一个栈指针 S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点 if (NULL == root) &#123; printf(&quot;树为空！\\n&quot;); return; &#125;//end if pre = NULL; cur = NULL; StackPush(S, T); //根节点入栈 while (!StackEmpty(S)) &#123; //若栈非空 cur = NULL; StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/ if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) || (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild))) &#123; printf(&quot;%c &quot;, cur-&gt;data); pre = cur; StackPop(S, cur); &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。 else &#123; if (cur-&gt;rchild != NULL) StackPush(S, cur-&gt;rchild); if (cur-&gt;lchild != NULL) StackPush(S, cur-&gt;lchild); &#125;//end else &#125;//end while free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123; if (root) &#123; postOrder(root-&gt;lchild); postOrder(root-&gt;rchild); printf(&quot;%d &quot;, root-&gt;data); &#125; &#125; - 层次遍历：自上而下，自左向右 - 首先，将二叉树的祖先节点入队列 - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队 12345678910111213void LayerOrder(BiTreeNode* head)&#123; LQueue Q; Initiate_Queue(&amp;Q); BiTreeNode* p; if (head != NULL) AppendQueue(&amp;Q, head); while (QueueNotEmpty(&amp;Q)) &#123; p = QueueDelete(&amp;Q); cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild); if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild); &#125;&#125; #### 哈夫曼树和哈夫曼编码 - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短 - 树的路径长度是指从根到每个节点的路径长度之和 - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值 - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和 - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度 123456789101112ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0 &#123; if (FBT == NULL) //空树返回0 return 0; else &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点 return FBT-&gt;data * len; else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增 return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1); &#125; &#125; - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct BTreeNode* CreateHuffman(ElemType a[], int n) &#123; int i, j; struct BTreeNode **b, *q; b = malloc(n*sizeof(struct BTreeNode)); for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点 &#123; b[i] = malloc(sizeof(struct BTreeNode)); b[i]-&gt;data = a[i]; b[i]-&gt;left = b[i]-&gt;right = NULL; &#125; for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树 &#123; //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标 int k1 = -1, k2; for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵 &#123; if (b[j] != NULL &amp;&amp; k1 == -1) &#123; k1 = j; continue; &#125; if (b[j] != NULL) &#123; k2 = j; break; &#125; &#125; for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小 &#123; if (b[j] != NULL) &#123; if (b[j]-&gt;data &lt; b[k1]-&gt;data) &#123; k2 = k1; k1 = j; &#125; else if (b[j]-&gt;data &lt; b[k2]-&gt;data) k2 = j; &#125; &#125; //由最小权值树和次最小权值树建立一棵新树，q指向树根结点 q = malloc(sizeof(struct BTreeNode)); q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data; q-&gt;left = b[k1]; q-&gt;right = b[k2]; b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置 b[k2] = NULL;//k2位置为空 &#125; free(b); //删除动态建立的数组b return q; //返回整个哈夫曼树的树根指针 &#125; - 哈夫曼编码 - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树 - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码 - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码 - 哈夫曼编码产生的是最短前缀码 12345678910111213141516171819202122void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0 &#123; static int a[10]; //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一 if (FBT != NULL) //访问到叶子结点时输出其保存在数组a中的0和1序列编码 &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL) &#123; int i; printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data); for (i = 0; i &lt; len; i++) printf(&quot;%d&quot;, a[i]); printf(&quot;\\n&quot;); &#125; else //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a &#123; //的对应元素中，向下深入一层时len值增1 a[len] = 0; HuffManCoding(FBT-&gt;left, len + 1); a[len] = 1; HuffManCoding(FBT-&gt;right, len + 1); &#125; &#125; &#125; ### 图 #### 图的基本概念 - 图由结点的有穷集合的 V 和边的集合 E 组成（`G(V,E)`） - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示 - 路径长度：路径上边或者弧的数目 - 顶点的度：顶点关联边的数目 - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度 - 在有向图中，顶点的度就是两者之和 - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量 - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量 #### 图的存储结构 - 邻接矩阵 - 图的顺序存储结构 - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息 - 无向图中邻接矩阵是个对称矩阵 - 0表示无边，1表示有边 - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费 1234567891011typedef struct&#123; int no; char info;&#125; VertexType;typedef struct&#123; int edges[maxSize][maxSize]; //有权图中int改为float int n,e; //顶点数和边数 VertexType vex[maxSize]; //存放结点信息&#125; MGragh; - 邻接表 - 数组和链表相结合的存储方法，图的链式存储结构 - 图中顶点用一个一维数组存储 - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表 - 顶点表的各个结点由 data 和 Firstedge 两个域表示 - data 是数据域，存储顶点信息 - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点 - 边表结点由 adjvex 和 next 两个域组成 - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标 - next 存储边表中下一个结点指针 - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表 12345678910111213141516typedef struct ArcNode&#123; int adnex; //该边所指向的结点的位置 struct ArcNode * nextarc; //指向下一条边的指针 int info; //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123; char data; //顶点信息 ArcNode* firstarc; //指向第一条边的指针&#125;VNode;typedef struct&#123; VNode adjlist[maxSize]; //邻接表 int n, e; //顶点数和边数&#125; AGraph; //图的邻接表类型 - 十字链表 - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表 - 定点表 - firstin：入边表头指针，指向顶点入边表的第一个结点 - firstout：出边表头指针，指向顶点出边表第一个结点 - 边表 - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标 - headlink 入边表指针域，指向终点相同的下一条边 - taillink 是指边表指针域，指向起点相同的下一条边 - 邻接多重表 - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标 - ilink 指向依附项点 ivex 的下一条边 - jlink 指向依附顶点 jvex 的下一条边 #### 图的遍历算法 - 深度优先遍历（DFS，Depth First Search） - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了 - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问 - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历 1234567891011121314151617bool visited[Max_Vex]; //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123; for (v = 0;v &lt; G.vexnum;++v) visited[v] = false; //初始化标记数组 for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做深度优先遍历 DFS(G, v);&#125;void DFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) DFS(G, w);&#125; - 广度优先遍历（BFS，Breadth First Search） - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点 - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完 - BFS 遍历的方式类似于树的层次遍历 1234567891011121314151617181920212223242526bool visited[Max_Vex]; //定义访问标记数组void BFSTraverse(Graph G)&#123; for (i = 0;i &lt; G.vexnum;++i) visited[v] = false; //初始化标记数组 InitQueue(Q); for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做广度优先遍历 BFS(G, v);&#125;void BFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 while (!isEmpty(Q)) &#123; DeQueue(Q, v); for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) &#123; visit(w); visited[w] = true; EnQueue(Q, w) &#125; //if &#125; //while&#125; #### 最小生成树 - Prim 算法 - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树 - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树 - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树 1234567891011void prim (G,T)&#123; T = ∅; U = &#123;w&#125;; while ((V - U) != ∅ ) &#123; //若图中不含全部顶点 设 (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边; T = T∪ (u，v); //边归入树 U = U∪ &#123;v&#125;; //顶点归入树 &#125;&#125; - Kruskal 算法 - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止 - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图 - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的 - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树 - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合 - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合 1234567891011121314void kruskal（V，T）&#123; T = V; //初始化树，仅含顶点 numS = n; //不连分量的数目 while (numS &gt; 1) &#123; 从 E 中取出权值最小的边（v,u）; if（v 和 u 属于 T 中不同的连通分量） &#123; T = T∪（u，v）;//将此边加入到生成树中； numS--; //不连通的分量减少 1 &#125; &#125;&#125; #### 最短路径 - Dijkstra 算法 - 通常用于求图中某一顶点到其余各顶点的最短路径 - 设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组 - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中） - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度 - Dijkstra 算法步骤 1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$ 2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度） 3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离 4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中 12345678910111213141516171819202122232425262728293031323334353637void Dijkstra(int v0)&#123; bool S[MAXNUM]; // 判断是否已存入该点到S集合中 int n=MAXNUM; for(int i=1; i&lt;=n; ++i) &#123; dist[i] = A[v0][i]; S[i] = false; // 初始都未用过该点 if(dist[i] == MAXINT) prev[i] = -1; else prev[i] = v0; &#125; dist[v0] = 0; S[v0] = true; for(int i=2; i&lt;=n; i++) &#123; int mindist = MAXINT; int u = v0; // 找出当前未使用的点j的dist[j]最小值 for(int j=1; j&lt;=n; ++j) if((!S[j]) &amp;&amp; dist[j]&lt;mindist) &#123; u = j; // u保存当前邻接点中距离最小的点的号码 mindist = dist[j]; &#125; S[u] = true; for(int j=1; j&lt;=n; j++) if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT) &#123; if(dist[u] + A[u][j] &lt; dist[j]) //在通过新加入的u点路径找到离v0点更短的路径 &#123; dist[j] = dist[u] + A[u][j]; //更新dist prev[j] = u; //记录前驱顶点 &#125; &#125; &#125;&#125; - Floyd 算法 - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包 - Floyd-Warshall 算法的时间复杂度为 $O(N^3)$，空间复杂度为 $O(N^2)$ - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离 - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离 - Floyd 算法步骤 - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大 - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它 12345for (k = 1;k &lt;= n;k++) for (i = 1;i &lt;= n;i++) for (j = 1;j &lt;= n;j++) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; #### 拓扑排序 - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边 1. 从 DAG 图中选择一个没有前驱的节点并输出 2. 从图中删除该节点和所有以它为起点的有向边 3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止 12345678910111213141516171819202122232425bool topologicalSort(Graph GL)&#123; EdgeNode* e; int top = 0; //用于栈指针下标 int count = 0; // 用于统计输出顶点的个数 int* stack; // 建栈将入度为 0 的顶点入栈 stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int)); for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈 stack[++top] = i; while (top != 0) &#123; gettop = stack[top--]; printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data); count++; //输出 i 号顶点，并计数 for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123; k = e-&gt;adjvex; if (!(--GL-&gt;adjList[k].in)) //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈 stack[++top] = k; &#125; &#125; if (count &lt; GL-&gt;numVertexes) return false; else return true;&#125; &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下) &lt;!--more--&gt; ### 矩阵与广义表 #### 矩阵 - 矩阵的转置 123456void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) B[j][i] = A[i][j];&#125; - 矩阵相加 123456void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) C[i][j] = A[i][j] + B[i][j];&#125; - 矩阵相乘 12345678910void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; k;++j) &#123; C[i][j] = 0; for int(h = 0;h &lt; n;++h) C[i][j] += A[i][j] * B[i][j]; &#125;&#125; - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵 - 对称矩阵、三角阵、对角矩阵 #### 广义表 - 表元素可以是原子或者广义表的一种线性表的扩展结构 - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数 - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾 - 原子结点有两个域：标志域和数据域 - 广义表结点有三个域：标志域，头指针域与尾指针域 ### 树 #### 树的基本概念 - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成 - 结点不仅包含数据元素，并且包含指向子树的分支 - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值 - 树的高度是树中结点的最大层次，根结点的高度为树的高度 - 树的双亲存储结构：`int tree[maxSize]` - 树的链式存储结构 - 邻接表：孩子存储结构 - 孩子兄弟存储结构 #### 二叉树的概念和性质 - 二叉树的定义 - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2 - 子树有左右顺序之分，不能颠倒 - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层 - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的 - 二叉树的主要性质 1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$ 2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$ 3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$ 4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点： - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\\lfloor i/2\\rfloor$ 的结点为其双亲结点（向下取整） - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点 - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点 5. Catalan()：给定 n 个结点，能够成 $h\\left( n\\right) =\\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$ 棵不同的二叉树 6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\\lfloor log2n\\rfloor+1$ - 二叉树的顺序存储结构最适用于完全二叉树 - 二叉树的链式存储结构 123456typedef struct BTNode&#123; char data; //数据域 struct BTNoode* lchild; struct BTNode* rchild;&#125; BTNode; #### 二叉树的遍历算法 - 先序遍历 12345678910111213141516171819202122232425262728293031323334353637383940/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; printf(&quot;树为空！\\n&quot;); return; &#125; //end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //p 所指节点入栈 printf(&quot;%c &quot;, p-&gt;data); //相当于 visit（p） p = p-&gt;lchild ; //指向 p 的左孩子 &#125;//end if else &#123; //p 所指节点为空，则出栈赋给 p，遍历右子树 StackPop(S, p); p = p-&gt;rchild; //若右孩子有左子树则继续 while 将左孩子入栈 &#125; //end else &#125; //end while free(S);&#125; //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123; if (root) &#123; printf(&quot;%d &quot;, root-&gt;data); preOrder(root-&gt;lchild); preOrder(root-&gt;rchild); &#125;&#125; - 中序遍历 1234567891011121314151617181920212223242526272829303132333435363738/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; //如果是空树 printf(&quot;树为空！\\n&quot;) ; return; &#125;//end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //将节点入栈 p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子 &#125;//end if else &#123; StackPop(S, p); //p 左子树为空则出栈 printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点 p = p-&gt;rchild; //向右子树移动 &#125;//end else &#125;//end while free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123; if (root) &#123; inOrder(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); inOrder(root-&gt;rchild); &#125;&#125; - 后序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123; StackNode* S; BiTNode* cur, * pre;//定义一个栈指针 S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点 if (NULL == root) &#123; printf(&quot;树为空！\\n&quot;); return; &#125;//end if pre = NULL; cur = NULL; StackPush(S, T); //根节点入栈 while (!StackEmpty(S)) &#123; //若栈非空 cur = NULL; StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/ if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) || (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild))) &#123; printf(&quot;%c &quot;, cur-&gt;data); pre = cur; StackPop(S, cur); &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。 else &#123; if (cur-&gt;rchild != NULL) StackPush(S, cur-&gt;rchild); if (cur-&gt;lchild != NULL) StackPush(S, cur-&gt;lchild); &#125;//end else &#125;//end while free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123; if (root) &#123; postOrder(root-&gt;lchild); postOrder(root-&gt;rchild); printf(&quot;%d &quot;, root-&gt;data); &#125; &#125; - 层次遍历：自上而下，自左向右 - 首先，将二叉树的祖先节点入队列 - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队 12345678910111213void LayerOrder(BiTreeNode* head)&#123; LQueue Q; Initiate_Queue(&amp;Q); BiTreeNode* p; if (head != NULL) AppendQueue(&amp;Q, head); while (QueueNotEmpty(&amp;Q)) &#123; p = QueueDelete(&amp;Q); cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild); if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild); &#125;&#125; #### 哈夫曼树和哈夫曼编码 - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短 - 树的路径长度是指从根到每个节点的路径长度之和 - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值 - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和 - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度 123456789101112ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0 &#123; if (FBT == NULL) //空树返回0 return 0; else &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点 return FBT-&gt;data * len; else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增 return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1); &#125; &#125; - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct BTreeNode* CreateHuffman(ElemType a[], int n) &#123; int i, j; struct BTreeNode **b, *q; b = malloc(n*sizeof(struct BTreeNode)); for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点 &#123; b[i] = malloc(sizeof(struct BTreeNode)); b[i]-&gt;data = a[i]; b[i]-&gt;left = b[i]-&gt;right = NULL; &#125; for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树 &#123; //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标 int k1 = -1, k2; for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵 &#123; if (b[j] != NULL &amp;&amp; k1 == -1) &#123; k1 = j; continue; &#125; if (b[j] != NULL) &#123; k2 = j; break; &#125; &#125; for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小 &#123; if (b[j] != NULL) &#123; if (b[j]-&gt;data &lt; b[k1]-&gt;data) &#123; k2 = k1; k1 = j; &#125; else if (b[j]-&gt;data &lt; b[k2]-&gt;data) k2 = j; &#125; &#125; //由最小权值树和次最小权值树建立一棵新树，q指向树根结点 q = malloc(sizeof(struct BTreeNode)); q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data; q-&gt;left = b[k1]; q-&gt;right = b[k2]; b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置 b[k2] = NULL;//k2位置为空 &#125; free(b); //删除动态建立的数组b return q; //返回整个哈夫曼树的树根指针 &#125; - 哈夫曼编码 - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树 - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码 - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码 - 哈夫曼编码产生的是最短前缀码 12345678910111213141516171819202122void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0 &#123; static int a[10]; //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一 if (FBT != NULL) //访问到叶子结点时输出其保存在数组a中的0和1序列编码 &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL) &#123; int i; printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data); for (i = 0; i &lt; len; i++) printf(&quot;%d&quot;, a[i]); printf(&quot;\\n&quot;); &#125; else //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a &#123; //的对应元素中，向下深入一层时len值增1 a[len] = 0; HuffManCoding(FBT-&gt;left, len + 1); a[len] = 1; HuffManCoding(FBT-&gt;right, len + 1); &#125; &#125; &#125; ### 图 #### 图的基本概念 - 图由结点的有穷集合的 V 和边的集合 E 组成（`G(V,E)`） - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示 - 路径长度：路径上边或者弧的数目 - 顶点的度：顶点关联边的数目 - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度 - 在有向图中，顶点的度就是两者之和 - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量 - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量 #### 图的存储结构 - 邻接矩阵 - 图的顺序存储结构 - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息 - 无向图中邻接矩阵是个对称矩阵 - 0表示无边，1表示有边 - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费 1234567891011typedef struct&#123; int no; char info;&#125; VertexType;typedef struct&#123; int edges[maxSize][maxSize]; //有权图中int改为float int n,e; //顶点数和边数 VertexType vex[maxSize]; //存放结点信息&#125; MGragh; - 邻接表 - 数组和链表相结合的存储方法，图的链式存储结构 - 图中顶点用一个一维数组存储 - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表 - 顶点表的各个结点由 data 和 Firstedge 两个域表示 - data 是数据域，存储顶点信息 - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点 - 边表结点由 adjvex 和 next 两个域组成 - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标 - next 存储边表中下一个结点指针 - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表 12345678910111213141516typedef struct ArcNode&#123; int adnex; //该边所指向的结点的位置 struct ArcNode * nextarc; //指向下一条边的指针 int info; //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123; char data; //顶点信息 ArcNode* firstarc; //指向第一条边的指针&#125;VNode;typedef struct&#123; VNode adjlist[maxSize]; //邻接表 int n, e; //顶点数和边数&#125; AGraph; //图的邻接表类型 - 十字链表 - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表 - 定点表 - firstin：入边表头指针，指向顶点入边表的第一个结点 - firstout：出边表头指针，指向顶点出边表第一个结点 - 边表 - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标 - headlink 入边表指针域，指向终点相同的下一条边 - taillink 是指边表指针域，指向起点相同的下一条边 - 邻接多重表 - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标 - ilink 指向依附项点 ivex 的下一条边 - jlink 指向依附顶点 jvex 的下一条边 #### 图的遍历算法 - 深度优先遍历（DFS，Depth First Search） - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了 - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问 - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历 1234567891011121314151617bool visited[Max_Vex]; //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123; for (v = 0;v &lt; G.vexnum;++v) visited[v] = false; //初始化标记数组 for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做深度优先遍历 DFS(G, v);&#125;void DFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) DFS(G, w);&#125; - 广度优先遍历（BFS，Breadth First Search） - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点 - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完 - BFS 遍历的方式类似于树的层次遍历 1234567891011121314151617181920212223242526bool visited[Max_Vex]; //定义访问标记数组void BFSTraverse(Graph G)&#123; for (i = 0;i &lt; G.vexnum;++i) visited[v] = false; //初始化标记数组 InitQueue(Q); for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做广度优先遍历 BFS(G, v);&#125;void BFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 while (!isEmpty(Q)) &#123; DeQueue(Q, v); for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) &#123; visit(w); visited[w] = true; EnQueue(Q, w) &#125; //if &#125; //while&#125; #### 最小生成树 - Prim 算法 - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树 - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树 - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树 1234567891011void prim (G,T)&#123; T = ∅; U = &#123;w&#125;; while ((V - U) != ∅ ) &#123; //若图中不含全部顶点 设 (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边; T = T∪ (u，v); //边归入树 U = U∪ &#123;v&#125;; //顶点归入树 &#125;&#125; - Kruskal 算法 - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止 - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图 - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的 - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树 - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合 - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合 1234567891011121314void kruskal（V，T）&#123; T = V; //初始化树，仅含顶点 numS = n; //不连分量的数目 while (numS &gt; 1) &#123; 从 E 中取出权值最小的边（v,u）; if（v 和 u 属于 T 中不同的连通分量） &#123; T = T∪（u，v）;//将此边加入到生成树中； numS--; //不连通的分量减少 1 &#125; &#125;&#125; #### 最短路径 - Dijkstra 算法 - 通常用于求图中某一顶点到其余各顶点的最短路径 - 设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组 - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中） - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度 - Dijkstra 算法步骤 1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$ 2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度） 3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离 4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中 12345678910111213141516171819202122232425262728293031323334353637void Dijkstra(int v0)&#123; bool S[MAXNUM]; // 判断是否已存入该点到S集合中 int n=MAXNUM; for(int i=1; i&lt;=n; ++i) &#123; dist[i] = A[v0][i]; S[i] = false; // 初始都未用过该点 if(dist[i] == MAXINT) prev[i] = -1; else prev[i] = v0; &#125; dist[v0] = 0; S[v0] = true; for(int i=2; i&lt;=n; i++) &#123; int mindist = MAXINT; int u = v0; // 找出当前未使用的点j的dist[j]最小值 for(int j=1; j&lt;=n; ++j) if((!S[j]) &amp;&amp; dist[j]&lt;mindist) &#123; u = j; // u保存当前邻接点中距离最小的点的号码 mindist = dist[j]; &#125; S[u] = true; for(int j=1; j&lt;=n; j++) if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT) &#123; if(dist[u] + A[u][j] &lt; dist[j]) //在通过新加入的u点路径找到离v0点更短的路径 &#123; dist[j] = dist[u] + A[u][j]; //更新dist prev[j] = u; //记录前驱顶点 &#125; &#125; &#125;&#125; - Floyd 算法 - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包 - Floyd-Warshall 算法的时间复杂度为 $O(N^3)$，空间复杂度为 $O(N^2)$ - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离 - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离 - Floyd 算法步骤 - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大 - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它 12345for (k = 1;k &lt;= n;k++) for (i = 1;i &lt;= n;i++) for (j = 1;j &lt;= n;j++) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; #### 拓扑排序 - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边 1. 从 DAG 图中选择一个没有前驱的节点并输出 2. 从图中删除该节点和所有以它为起点的有向边 3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止 12345678910111213141516171819202122232425bool topologicalSort(Graph GL)&#123; EdgeNode* e; int top = 0; //用于栈指针下标 int count = 0; // 用于统计输出顶点的个数 int* stack; // 建栈将入度为 0 的顶点入栈 stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int)); for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈 stack[++top] = i; while (top != 0) &#123; gettop = stack[top--]; printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data); count++; //输出 i 号顶点，并计数 for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123; k = e-&gt;adjvex; if (!(--GL-&gt;adjList[k].in)) //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈 stack[++top] = k; &#125; &#125; if (count &lt; GL-&gt;numVertexes) return false; else return true;&#125; &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下) &lt;!--more--&gt; ### 矩阵与广义表 #### 矩阵 - 矩阵的转置 123456void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) B[j][i] = A[i][j];&#125; - 矩阵相加 123456void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) C[i][j] = A[i][j] + B[i][j];&#125; - 矩阵相乘 12345678910void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; k;++j) &#123; C[i][j] = 0; for int(h = 0;h &lt; n;++h) C[i][j] += A[i][j] * B[i][j]; &#125;&#125; - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵 - 对称矩阵、三角阵、对角矩阵 #### 广义表 - 表元素可以是原子或者广义表的一种线性表的扩展结构 - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数 - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾 - 原子结点有两个域：标志域和数据域 - 广义表结点有三个域：标志域，头指针域与尾指针域 ### 树 #### 树的基本概念 - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成 - 结点不仅包含数据元素，并且包含指向子树的分支 - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值 - 树的高度是树中结点的最大层次，根结点的高度为树的高度 - 树的双亲存储结构：`int tree[maxSize]` - 树的链式存储结构 - 邻接表：孩子存储结构 - 孩子兄弟存储结构 #### 二叉树的概念和性质 - 二叉树的定义 - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2 - 子树有左右顺序之分，不能颠倒 - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层 - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的 - 二叉树的主要性质 1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$ 2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$ 3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$ 4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点： - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\\lfloor i/2\\rfloor$ 的结点为其双亲结点（向下取整） - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点 - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点 5. Catalan()：给定 n 个结点，能够成 $h\\left( n\\right) =\\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$ 棵不同的二叉树 6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\\lfloor log2n\\rfloor+1$ - 二叉树的顺序存储结构最适用于完全二叉树 - 二叉树的链式存储结构 123456typedef struct BTNode&#123; char data; //数据域 struct BTNoode* lchild; struct BTNode* rchild;&#125; BTNode; #### 二叉树的遍历算法 - 先序遍历 12345678910111213141516171819202122232425262728293031323334353637383940/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; printf(&quot;树为空！\\n&quot;); return; &#125; //end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //p 所指节点入栈 printf(&quot;%c &quot;, p-&gt;data); //相当于 visit（p） p = p-&gt;lchild ; //指向 p 的左孩子 &#125;//end if else &#123; //p 所指节点为空，则出栈赋给 p，遍历右子树 StackPop(S, p); p = p-&gt;rchild; //若右孩子有左子树则继续 while 将左孩子入栈 &#125; //end else &#125; //end while free(S);&#125; //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123; if (root) &#123; printf(&quot;%d &quot;, root-&gt;data); preOrder(root-&gt;lchild); preOrder(root-&gt;rchild); &#125;&#125; - 中序遍历 1234567891011121314151617181920212223242526272829303132333435363738/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; //如果是空树 printf(&quot;树为空！\\n&quot;) ; return; &#125;//end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //将节点入栈 p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子 &#125;//end if else &#123; StackPop(S, p); //p 左子树为空则出栈 printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点 p = p-&gt;rchild; //向右子树移动 &#125;//end else &#125;//end while free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123; if (root) &#123; inOrder(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); inOrder(root-&gt;rchild); &#125;&#125; - 后序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123; StackNode* S; BiTNode* cur, * pre;//定义一个栈指针 S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点 if (NULL == root) &#123; printf(&quot;树为空！\\n&quot;); return; &#125;//end if pre = NULL; cur = NULL; StackPush(S, T); //根节点入栈 while (!StackEmpty(S)) &#123; //若栈非空 cur = NULL; StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/ if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) || (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild))) &#123; printf(&quot;%c &quot;, cur-&gt;data); pre = cur; StackPop(S, cur); &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。 else &#123; if (cur-&gt;rchild != NULL) StackPush(S, cur-&gt;rchild); if (cur-&gt;lchild != NULL) StackPush(S, cur-&gt;lchild); &#125;//end else &#125;//end while free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123; if (root) &#123; postOrder(root-&gt;lchild); postOrder(root-&gt;rchild); printf(&quot;%d &quot;, root-&gt;data); &#125; &#125; - 层次遍历：自上而下，自左向右 - 首先，将二叉树的祖先节点入队列 - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队 12345678910111213void LayerOrder(BiTreeNode* head)&#123; LQueue Q; Initiate_Queue(&amp;Q); BiTreeNode* p; if (head != NULL) AppendQueue(&amp;Q, head); while (QueueNotEmpty(&amp;Q)) &#123; p = QueueDelete(&amp;Q); cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild); if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild); &#125;&#125; #### 哈夫曼树和哈夫曼编码 - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短 - 树的路径长度是指从根到每个节点的路径长度之和 - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值 - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和 - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度 123456789101112ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0 &#123; if (FBT == NULL) //空树返回0 return 0; else &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点 return FBT-&gt;data * len; else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增 return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1); &#125; &#125; - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct BTreeNode* CreateHuffman(ElemType a[], int n) &#123; int i, j; struct BTreeNode **b, *q; b = malloc(n*sizeof(struct BTreeNode)); for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点 &#123; b[i] = malloc(sizeof(struct BTreeNode)); b[i]-&gt;data = a[i]; b[i]-&gt;left = b[i]-&gt;right = NULL; &#125; for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树 &#123; //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标 int k1 = -1, k2; for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵 &#123; if (b[j] != NULL &amp;&amp; k1 == -1) &#123; k1 = j; continue; &#125; if (b[j] != NULL) &#123; k2 = j; break; &#125; &#125; for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小 &#123; if (b[j] != NULL) &#123; if (b[j]-&gt;data &lt; b[k1]-&gt;data) &#123; k2 = k1; k1 = j; &#125; else if (b[j]-&gt;data &lt; b[k2]-&gt;data) k2 = j; &#125; &#125; //由最小权值树和次最小权值树建立一棵新树，q指向树根结点 q = malloc(sizeof(struct BTreeNode)); q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data; q-&gt;left = b[k1]; q-&gt;right = b[k2]; b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置 b[k2] = NULL;//k2位置为空 &#125; free(b); //删除动态建立的数组b return q; //返回整个哈夫曼树的树根指针 &#125; - 哈夫曼编码 - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树 - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码 - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码 - 哈夫曼编码产生的是最短前缀码 12345678910111213141516171819202122void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0 &#123; static int a[10]; //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一 if (FBT != NULL) //访问到叶子结点时输出其保存在数组a中的0和1序列编码 &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL) &#123; int i; printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data); for (i = 0; i &lt; len; i++) printf(&quot;%d&quot;, a[i]); printf(&quot;\\n&quot;); &#125; else //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a &#123; //的对应元素中，向下深入一层时len值增1 a[len] = 0; HuffManCoding(FBT-&gt;left, len + 1); a[len] = 1; HuffManCoding(FBT-&gt;right, len + 1); &#125; &#125; &#125; ### 图 #### 图的基本概念 - 图由结点的有穷集合的 V 和边的集合 E 组成（`G(V,E)`） - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示 - 路径长度：路径上边或者弧的数目 - 顶点的度：顶点关联边的数目 - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度 - 在有向图中，顶点的度就是两者之和 - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量 - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量 #### 图的存储结构 - 邻接矩阵 - 图的顺序存储结构 - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息 - 无向图中邻接矩阵是个对称矩阵 - 0表示无边，1表示有边 - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费 1234567891011typedef struct&#123; int no; char info;&#125; VertexType;typedef struct&#123; int edges[maxSize][maxSize]; //有权图中int改为float int n,e; //顶点数和边数 VertexType vex[maxSize]; //存放结点信息&#125; MGragh; - 邻接表 - 数组和链表相结合的存储方法，图的链式存储结构 - 图中顶点用一个一维数组存储 - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表 - 顶点表的各个结点由 data 和 Firstedge 两个域表示 - data 是数据域，存储顶点信息 - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点 - 边表结点由 adjvex 和 next 两个域组成 - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标 - next 存储边表中下一个结点指针 - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表 12345678910111213141516typedef struct ArcNode&#123; int adnex; //该边所指向的结点的位置 struct ArcNode * nextarc; //指向下一条边的指针 int info; //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123; char data; //顶点信息 ArcNode* firstarc; //指向第一条边的指针&#125;VNode;typedef struct&#123; VNode adjlist[maxSize]; //邻接表 int n, e; //顶点数和边数&#125; AGraph; //图的邻接表类型 - 十字链表 - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表 - 定点表 - firstin：入边表头指针，指向顶点入边表的第一个结点 - firstout：出边表头指针，指向顶点出边表第一个结点 - 边表 - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标 - headlink 入边表指针域，指向终点相同的下一条边 - taillink 是指边表指针域，指向起点相同的下一条边 - 邻接多重表 - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标 - ilink 指向依附项点 ivex 的下一条边 - jlink 指向依附顶点 jvex 的下一条边 #### 图的遍历算法 - 深度优先遍历（DFS，Depth First Search） - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了 - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问 - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历 1234567891011121314151617bool visited[Max_Vex]; //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123; for (v = 0;v &lt; G.vexnum;++v) visited[v] = false; //初始化标记数组 for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做深度优先遍历 DFS(G, v);&#125;void DFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) DFS(G, w);&#125; - 广度优先遍历（BFS，Breadth First Search） - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点 - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完 - BFS 遍历的方式类似于树的层次遍历 1234567891011121314151617181920212223242526bool visited[Max_Vex]; //定义访问标记数组void BFSTraverse(Graph G)&#123; for (i = 0;i &lt; G.vexnum;++i) visited[v] = false; //初始化标记数组 InitQueue(Q); for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做广度优先遍历 BFS(G, v);&#125;void BFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 while (!isEmpty(Q)) &#123; DeQueue(Q, v); for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) &#123; visit(w); visited[w] = true; EnQueue(Q, w) &#125; //if &#125; //while&#125; #### 最小生成树 - Prim 算法 - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树 - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树 - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树 1234567891011void prim (G,T)&#123; T = ∅; U = &#123;w&#125;; while ((V - U) != ∅ ) &#123; //若图中不含全部顶点 设 (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边; T = T∪ (u，v); //边归入树 U = U∪ &#123;v&#125;; //顶点归入树 &#125;&#125; - Kruskal 算法 - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止 - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图 - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的 - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树 - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合 - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合 1234567891011121314void kruskal（V，T）&#123; T = V; //初始化树，仅含顶点 numS = n; //不连分量的数目 while (numS &gt; 1) &#123; 从 E 中取出权值最小的边（v,u）; if（v 和 u 属于 T 中不同的连通分量） &#123; T = T∪（u，v）;//将此边加入到生成树中； numS--; //不连通的分量减少 1 &#125; &#125;&#125; #### 最短路径 - Dijkstra 算法 - 通常用于求图中某一顶点到其余各顶点的最短路径 - 设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组 - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中） - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度 - Dijkstra 算法步骤 1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$ 2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度） 3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离 4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中 12345678910111213141516171819202122232425262728293031323334353637void Dijkstra(int v0)&#123; bool S[MAXNUM]; // 判断是否已存入该点到S集合中 int n=MAXNUM; for(int i=1; i&lt;=n; ++i) &#123; dist[i] = A[v0][i]; S[i] = false; // 初始都未用过该点 if(dist[i] == MAXINT) prev[i] = -1; else prev[i] = v0; &#125; dist[v0] = 0; S[v0] = true; for(int i=2; i&lt;=n; i++) &#123; int mindist = MAXINT; int u = v0; // 找出当前未使用的点j的dist[j]最小值 for(int j=1; j&lt;=n; ++j) if((!S[j]) &amp;&amp; dist[j]&lt;mindist) &#123; u = j; // u保存当前邻接点中距离最小的点的号码 mindist = dist[j]; &#125; S[u] = true; for(int j=1; j&lt;=n; j++) if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT) &#123; if(dist[u] + A[u][j] &lt; dist[j]) //在通过新加入的u点路径找到离v0点更短的路径 &#123; dist[j] = dist[u] + A[u][j]; //更新dist prev[j] = u; //记录前驱顶点 &#125; &#125; &#125;&#125; - Floyd 算法 - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包 - Floyd-Warshall 算法的时间复杂度为 $O(N^3)$，空间复杂度为 $O(N^2)$ - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离 - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离 - Floyd 算法步骤 - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大 - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它 12345for (k = 1;k &lt;= n;k++) for (i = 1;i &lt;= n;i++) for (j = 1;j &lt;= n;j++) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; #### 拓扑排序 - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边 1. 从 DAG 图中选择一个没有前驱的节点并输出 2. 从图中删除该节点和所有以它为起点的有向边 3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止 12345678910111213141516171819202122232425bool topologicalSort(Graph GL)&#123; EdgeNode* e; int top = 0; //用于栈指针下标 int count = 0; // 用于统计输出顶点的个数 int* stack; // 建栈将入度为 0 的顶点入栈 stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int)); for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈 stack[++top] = i; while (top != 0) &#123; gettop = stack[top--]; printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data); count++; //输出 i 号顶点，并计数 for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123; k = e-&gt;adjvex; if (!(--GL-&gt;adjList[k].in)) //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈 stack[++top] = k; &#125; &#125; if (count &lt; GL-&gt;numVertexes) return false; else return true;&#125; &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下) &lt;!--more--&gt; ### 矩阵与广义表 #### 矩阵 - 矩阵的转置 123456void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) B[j][i] = A[i][j];&#125; - 矩阵相加 123456void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) C[i][j] = A[i][j] + B[i][j];&#125; - 矩阵相乘 12345678910void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; k;++j) &#123; C[i][j] = 0; for int(h = 0;h &lt; n;++h) C[i][j] += A[i][j] * B[i][j]; &#125;&#125; - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵 - 对称矩阵、三角阵、对角矩阵 #### 广义表 - 表元素可以是原子或者广义表的一种线性表的扩展结构 - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数 - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾 - 原子结点有两个域：标志域和数据域 - 广义表结点有三个域：标志域，头指针域与尾指针域 ### 树 #### 树的基本概念 - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成 - 结点不仅包含数据元素，并且包含指向子树的分支 - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值 - 树的高度是树中结点的最大层次，根结点的高度为树的高度 - 树的双亲存储结构：`int tree[maxSize]` - 树的链式存储结构 - 邻接表：孩子存储结构 - 孩子兄弟存储结构 #### 二叉树的概念和性质 - 二叉树的定义 - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2 - 子树有左右顺序之分，不能颠倒 - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层 - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的 - 二叉树的主要性质 1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$ 2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$ 3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$ 4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点： - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\\lfloor i/2\\rfloor$ 的结点为其双亲结点（向下取整） - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点 - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点 5. Catalan()：给定 n 个结点，能够成 $h\\left( n\\right) =\\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$ 棵不同的二叉树 6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\\lfloor log2n\\rfloor+1$ - 二叉树的顺序存储结构最适用于完全二叉树 - 二叉树的链式存储结构 123456typedef struct BTNode&#123; char data; //数据域 struct BTNoode* lchild; struct BTNode* rchild;&#125; BTNode; #### 二叉树的遍历算法 - 先序遍历 12345678910111213141516171819202122232425262728293031323334353637383940/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; printf(&quot;树为空！\\n&quot;); return; &#125; //end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //p 所指节点入栈 printf(&quot;%c &quot;, p-&gt;data); //相当于 visit（p） p = p-&gt;lchild ; //指向 p 的左孩子 &#125;//end if else &#123; //p 所指节点为空，则出栈赋给 p，遍历右子树 StackPop(S, p); p = p-&gt;rchild; //若右孩子有左子树则继续 while 将左孩子入栈 &#125; //end else &#125; //end while free(S);&#125; //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123; if (root) &#123; printf(&quot;%d &quot;, root-&gt;data); preOrder(root-&gt;lchild); preOrder(root-&gt;rchild); &#125;&#125; - 中序遍历 1234567891011121314151617181920212223242526272829303132333435363738/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; //如果是空树 printf(&quot;树为空！\\n&quot;) ; return; &#125;//end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //将节点入栈 p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子 &#125;//end if else &#123; StackPop(S, p); //p 左子树为空则出栈 printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点 p = p-&gt;rchild; //向右子树移动 &#125;//end else &#125;//end while free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123; if (root) &#123; inOrder(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); inOrder(root-&gt;rchild); &#125;&#125; - 后序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123; StackNode* S; BiTNode* cur, * pre;//定义一个栈指针 S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点 if (NULL == root) &#123; printf(&quot;树为空！\\n&quot;); return; &#125;//end if pre = NULL; cur = NULL; StackPush(S, T); //根节点入栈 while (!StackEmpty(S)) &#123; //若栈非空 cur = NULL; StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/ if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) || (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild))) &#123; printf(&quot;%c &quot;, cur-&gt;data); pre = cur; StackPop(S, cur); &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。 else &#123; if (cur-&gt;rchild != NULL) StackPush(S, cur-&gt;rchild); if (cur-&gt;lchild != NULL) StackPush(S, cur-&gt;lchild); &#125;//end else &#125;//end while free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123; if (root) &#123; postOrder(root-&gt;lchild); postOrder(root-&gt;rchild); printf(&quot;%d &quot;, root-&gt;data); &#125; &#125; - 层次遍历：自上而下，自左向右 - 首先，将二叉树的祖先节点入队列 - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队 12345678910111213void LayerOrder(BiTreeNode* head)&#123; LQueue Q; Initiate_Queue(&amp;Q); BiTreeNode* p; if (head != NULL) AppendQueue(&amp;Q, head); while (QueueNotEmpty(&amp;Q)) &#123; p = QueueDelete(&amp;Q); cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild); if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild); &#125;&#125; #### 哈夫曼树和哈夫曼编码 - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短 - 树的路径长度是指从根到每个节点的路径长度之和 - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值 - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和 - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度 123456789101112ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0 &#123; if (FBT == NULL) //空树返回0 return 0; else &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点 return FBT-&gt;data * len; else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增 return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1); &#125; &#125; - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct BTreeNode* CreateHuffman(ElemType a[], int n) &#123; int i, j; struct BTreeNode **b, *q; b = malloc(n*sizeof(struct BTreeNode)); for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点 &#123; b[i] = malloc(sizeof(struct BTreeNode)); b[i]-&gt;data = a[i]; b[i]-&gt;left = b[i]-&gt;right = NULL; &#125; for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树 &#123; //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标 int k1 = -1, k2; for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵 &#123; if (b[j] != NULL &amp;&amp; k1 == -1) &#123; k1 = j; continue; &#125; if (b[j] != NULL) &#123; k2 = j; break; &#125; &#125; for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小 &#123; if (b[j] != NULL) &#123; if (b[j]-&gt;data &lt; b[k1]-&gt;data) &#123; k2 = k1; k1 = j; &#125; else if (b[j]-&gt;data &lt; b[k2]-&gt;data) k2 = j; &#125; &#125; //由最小权值树和次最小权值树建立一棵新树，q指向树根结点 q = malloc(sizeof(struct BTreeNode)); q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data; q-&gt;left = b[k1]; q-&gt;right = b[k2]; b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置 b[k2] = NULL;//k2位置为空 &#125; free(b); //删除动态建立的数组b return q; //返回整个哈夫曼树的树根指针 &#125; - 哈夫曼编码 - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树 - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码 - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码 - 哈夫曼编码产生的是最短前缀码 12345678910111213141516171819202122void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0 &#123; static int a[10]; //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一 if (FBT != NULL) //访问到叶子结点时输出其保存在数组a中的0和1序列编码 &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL) &#123; int i; printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data); for (i = 0; i &lt; len; i++) printf(&quot;%d&quot;, a[i]); printf(&quot;\\n&quot;); &#125; else //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a &#123; //的对应元素中，向下深入一层时len值增1 a[len] = 0; HuffManCoding(FBT-&gt;left, len + 1); a[len] = 1; HuffManCoding(FBT-&gt;right, len + 1); &#125; &#125; &#125; ### 图 #### 图的基本概念 - 图由结点的有穷集合的 V 和边的集合 E 组成（`G(V,E)`） - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示 - 路径长度：路径上边或者弧的数目 - 顶点的度：顶点关联边的数目 - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度 - 在有向图中，顶点的度就是两者之和 - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量 - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量 #### 图的存储结构 - 邻接矩阵 - 图的顺序存储结构 - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息 - 无向图中邻接矩阵是个对称矩阵 - 0表示无边，1表示有边 - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费 1234567891011typedef struct&#123; int no; char info;&#125; VertexType;typedef struct&#123; int edges[maxSize][maxSize]; //有权图中int改为float int n,e; //顶点数和边数 VertexType vex[maxSize]; //存放结点信息&#125; MGragh; - 邻接表 - 数组和链表相结合的存储方法，图的链式存储结构 - 图中顶点用一个一维数组存储 - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表 - 顶点表的各个结点由 data 和 Firstedge 两个域表示 - data 是数据域，存储顶点信息 - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点 - 边表结点由 adjvex 和 next 两个域组成 - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标 - next 存储边表中下一个结点指针 - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表 12345678910111213141516typedef struct ArcNode&#123; int adnex; //该边所指向的结点的位置 struct ArcNode * nextarc; //指向下一条边的指针 int info; //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123; char data; //顶点信息 ArcNode* firstarc; //指向第一条边的指针&#125;VNode;typedef struct&#123; VNode adjlist[maxSize]; //邻接表 int n, e; //顶点数和边数&#125; AGraph; //图的邻接表类型 - 十字链表 - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表 - 定点表 - firstin：入边表头指针，指向顶点入边表的第一个结点 - firstout：出边表头指针，指向顶点出边表第一个结点 - 边表 - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标 - headlink 入边表指针域，指向终点相同的下一条边 - taillink 是指边表指针域，指向起点相同的下一条边 - 邻接多重表 - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标 - ilink 指向依附项点 ivex 的下一条边 - jlink 指向依附顶点 jvex 的下一条边 #### 图的遍历算法 - 深度优先遍历（DFS，Depth First Search） - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了 - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问 - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历 1234567891011121314151617bool visited[Max_Vex]; //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123; for (v = 0;v &lt; G.vexnum;++v) visited[v] = false; //初始化标记数组 for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做深度优先遍历 DFS(G, v);&#125;void DFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) DFS(G, w);&#125; - 广度优先遍历（BFS，Breadth First Search） - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点 - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完 - BFS 遍历的方式类似于树的层次遍历 1234567891011121314151617181920212223242526bool visited[Max_Vex]; //定义访问标记数组void BFSTraverse(Graph G)&#123; for (i = 0;i &lt; G.vexnum;++i) visited[v] = false; //初始化标记数组 InitQueue(Q); for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做广度优先遍历 BFS(G, v);&#125;void BFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 while (!isEmpty(Q)) &#123; DeQueue(Q, v); for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) &#123; visit(w); visited[w] = true; EnQueue(Q, w) &#125; //if &#125; //while&#125; #### 最小生成树 - Prim 算法 - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树 - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树 - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树 1234567891011void prim (G,T)&#123; T = ∅; U = &#123;w&#125;; while ((V - U) != ∅ ) &#123; //若图中不含全部顶点 设 (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边; T = T∪ (u，v); //边归入树 U = U∪ &#123;v&#125;; //顶点归入树 &#125;&#125; - Kruskal 算法 - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止 - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图 - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的 - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树 - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合 - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合 1234567891011121314void kruskal（V，T）&#123; T = V; //初始化树，仅含顶点 numS = n; //不连分量的数目 while (numS &gt; 1) &#123; 从 E 中取出权值最小的边（v,u）; if（v 和 u 属于 T 中不同的连通分量） &#123; T = T∪（u，v）;//将此边加入到生成树中； numS--; //不连通的分量减少 1 &#125; &#125;&#125; #### 最短路径 - Dijkstra 算法 - 通常用于求图中某一顶点到其余各顶点的最短路径 - 设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组 - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中） - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度 - Dijkstra 算法步骤 1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$ 2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度） 3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离 4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中 12345678910111213141516171819202122232425262728293031323334353637void Dijkstra(int v0)&#123; bool S[MAXNUM]; // 判断是否已存入该点到S集合中 int n=MAXNUM; for(int i=1; i&lt;=n; ++i) &#123; dist[i] = A[v0][i]; S[i] = false; // 初始都未用过该点 if(dist[i] == MAXINT) prev[i] = -1; else prev[i] = v0; &#125; dist[v0] = 0; S[v0] = true; for(int i=2; i&lt;=n; i++) &#123; int mindist = MAXINT; int u = v0; // 找出当前未使用的点j的dist[j]最小值 for(int j=1; j&lt;=n; ++j) if((!S[j]) &amp;&amp; dist[j]&lt;mindist) &#123; u = j; // u保存当前邻接点中距离最小的点的号码 mindist = dist[j]; &#125; S[u] = true; for(int j=1; j&lt;=n; j++) if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT) &#123; if(dist[u] + A[u][j] &lt; dist[j]) //在通过新加入的u点路径找到离v0点更短的路径 &#123; dist[j] = dist[u] + A[u][j]; //更新dist prev[j] = u; //记录前驱顶点 &#125; &#125; &#125;&#125; - Floyd 算法 - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包 - Floyd-Warshall 算法的时间复杂度为 $O(N^3)$，空间复杂度为 $O(N^2)$ - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离 - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离 - Floyd 算法步骤 - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大 - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它 12345for (k = 1;k &lt;= n;k++) for (i = 1;i &lt;= n;i++) for (j = 1;j &lt;= n;j++) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; #### 拓扑排序 - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边 1. 从 DAG 图中选择一个没有前驱的节点并输出 2. 从图中删除该节点和所有以它为起点的有向边 3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止 12345678910111213141516171819202122232425bool topologicalSort(Graph GL)&#123; EdgeNode* e; int top = 0; //用于栈指针下标 int count = 0; // 用于统计输出顶点的个数 int* stack; // 建栈将入度为 0 的顶点入栈 stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int)); for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈 stack[++top] = i; while (top != 0) &#123; gettop = stack[top--]; printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data); count++; //输出 i 号顶点，并计数 for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123; k = e-&gt;adjvex; if (!(--GL-&gt;adjList[k].in)) //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈 stack[++top] = k; &#125; &#125; if (count &lt; GL-&gt;numVertexes) return false; else return true;&#125; 矩阵与广义表矩阵 矩阵的转置 123456void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) B[j][i] = A[i][j];&#125; 矩阵相加 123456void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; n;++j) C[i][j] = A[i][j] + B[i][j];&#125; 矩阵相乘 12345678910void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123; for (int i = 0;i &lt; m;++i) for (int j = 0;j &lt; k;++j) &#123; C[i][j] = 0; for int(h = 0;h &lt; n;++h) C[i][j] += A[i][j] * B[i][j]; &#125;&#125; 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵 对称矩阵、三角阵、对角矩阵 广义表 表元素可以是原子或者广义表的一种线性表的扩展结构 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾 原子结点有两个域：标志域和数据域 广义表结点有三个域：标志域，头指针域与尾指针域 树树的基本概念 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成 结点不仅包含数据元素，并且包含指向子树的分支 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值 树的高度是树中结点的最大层次，根结点的高度为树的高度 树的双亲存储结构：int tree[maxSize] 树的链式存储结构 邻接表：孩子存储结构 孩子兄弟存储结构 二叉树的概念和性质 二叉树的定义 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2 子树有左右顺序之分，不能颠倒 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的 二叉树的主要性质 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$ 在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$ 二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$ 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点： 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\\lfloor i/2\\rfloor$ 的结点为其双亲结点（向下取整） 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点 Catalan()：给定 n 个结点，能够成 $h\\left( n\\right) =\\dfrac{C_{2n}^{n}}{n+1}$ 棵不同的二叉树 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\\lfloor log2n\\rfloor+1$ 二叉树的顺序存储结构最适用于完全二叉树 二叉树的链式存储结构 123456typedef struct BTNode&#123; char data; //数据域 struct BTNoode* lchild; struct BTNode* rchild;&#125; BTNode; 二叉树的遍历算法 先序遍历 12345678910111213141516171819202122232425262728293031323334353637383940/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; printf(&quot;树为空！\\n&quot;); return; &#125; //end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //p 所指节点入栈 printf(&quot;%c &quot;, p-&gt;data); //相当于 visit（p） p = p-&gt;lchild ; //指向 p 的左孩子 &#125;//end if else &#123; //p 所指节点为空，则出栈赋给 p，遍历右子树 StackPop(S, p); p = p-&gt;rchild; //若右孩子有左子树则继续 while 将左孩子入栈 &#125; //end else &#125; //end while free(S);&#125; //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123; if (root) &#123; printf(&quot;%d &quot;, root-&gt;data); preOrder(root-&gt;lchild); preOrder(root-&gt;rchild); &#125;&#125; 中序遍历 1234567891011121314151617181920212223242526272829303132333435363738/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123; StackNode* S; //定义一个栈指针 BitNode* p; //工作指针 S = NULL; p = root; S = InitStack(S); //初始化栈 if (NULL == p) &#123; //如果是空树 printf(&quot;树为空！\\n&quot;) ; return; &#125;//end if while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空 if (p) &#123; StackPush(S, p); //将节点入栈 p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子 &#125;//end if else &#123; StackPop(S, p); //p 左子树为空则出栈 printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点 p = p-&gt;rchild; //向右子树移动 &#125;//end else &#125;//end while free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123; if (root) &#123; inOrder(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); inOrder(root-&gt;rchild); &#125;&#125; 后序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123; StackNode* S; BiTNode* cur, * pre;//定义一个栈指针 S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点 if (NULL == root) &#123; printf(&quot;树为空！\\n&quot;); return; &#125;//end if pre = NULL; cur = NULL; StackPush(S, T); //根节点入栈 while (!StackEmpty(S)) &#123; //若栈非空 cur = NULL; StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/ if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) || (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild))) &#123; printf(&quot;%c &quot;, cur-&gt;data); pre = cur; StackPop(S, cur); &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。 else &#123; if (cur-&gt;rchild != NULL) StackPush(S, cur-&gt;rchild); if (cur-&gt;lchild != NULL) StackPush(S, cur-&gt;lchild); &#125;//end else &#125;//end while free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123; if (root) &#123; postOrder(root-&gt;lchild); postOrder(root-&gt;rchild); printf(&quot;%d &quot;, root-&gt;data); &#125; &#125; 层次遍历：自上而下，自左向右 首先，将二叉树的祖先节点入队列 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队 12345678910111213void LayerOrder(BiTreeNode* head)&#123; LQueue Q; Initiate_Queue(&amp;Q); BiTreeNode* p; if (head != NULL) AppendQueue(&amp;Q, head); while (QueueNotEmpty(&amp;Q)) &#123; p = QueueDelete(&amp;Q); cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild); if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild); &#125;&#125; 哈夫曼树和哈夫曼编码 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短 树的路径长度是指从根到每个节点的路径长度之和 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度 123456789101112ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0 &#123; if (FBT == NULL) //空树返回0 return 0; else &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点 return FBT-&gt;data * len; else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增 return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1); &#125; &#125; 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct BTreeNode* CreateHuffman(ElemType a[], int n) &#123; int i, j; struct BTreeNode **b, *q; b = malloc(n*sizeof(struct BTreeNode)); for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点 &#123; b[i] = malloc(sizeof(struct BTreeNode)); b[i]-&gt;data = a[i]; b[i]-&gt;left = b[i]-&gt;right = NULL; &#125; for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树 &#123; //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标 int k1 = -1, k2; for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵 &#123; if (b[j] != NULL &amp;&amp; k1 == -1) &#123; k1 = j; continue; &#125; if (b[j] != NULL) &#123; k2 = j; break; &#125; &#125; for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小 &#123; if (b[j] != NULL) &#123; if (b[j]-&gt;data &lt; b[k1]-&gt;data) &#123; k2 = k1; k1 = j; &#125; else if (b[j]-&gt;data &lt; b[k2]-&gt;data) k2 = j; &#125; &#125; //由最小权值树和次最小权值树建立一棵新树，q指向树根结点 q = malloc(sizeof(struct BTreeNode)); q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data; q-&gt;left = b[k1]; q-&gt;right = b[k2]; b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置 b[k2] = NULL;//k2位置为空 &#125; free(b); //删除动态建立的数组b return q; //返回整个哈夫曼树的树根指针 &#125; 哈夫曼编码 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码 哈夫曼编码产生的是最短前缀码 12345678910111213141516171819202122void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0 &#123; static int a[10]; //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一 if (FBT != NULL) //访问到叶子结点时输出其保存在数组a中的0和1序列编码 &#123; if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL) &#123; int i; printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data); for (i = 0; i &lt; len; i++) printf(&quot;%d&quot;, a[i]); printf(&quot;\\n&quot;); &#125; else //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a &#123; //的对应元素中，向下深入一层时len值增1 a[len] = 0; HuffManCoding(FBT-&gt;left, len + 1); a[len] = 1; HuffManCoding(FBT-&gt;right, len + 1); &#125; &#125; &#125; 图图的基本概念 图由结点的有穷集合的 V 和边的集合 E 组成（G(V,E)） 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $$ 表示 路径长度：路径上边或者弧的数目 顶点的度：顶点关联边的数目 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度 在有向图中，顶点的度就是两者之和 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量 图的存储结构 邻接矩阵 图的顺序存储结构 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息 无向图中邻接矩阵是个对称矩阵 0表示无边，1表示有边 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费 1234567891011typedef struct&#123; int no; char info;&#125; VertexType;typedef struct&#123; int edges[maxSize][maxSize]; //有权图中int改为float int n,e; //顶点数和边数 VertexType vex[maxSize]; //存放结点信息&#125; MGragh; 邻接表 数组和链表相结合的存储方法，图的链式存储结构 图中顶点用一个一维数组存储 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表 顶点表的各个结点由 data 和 Firstedge 两个域表示 data 是数据域，存储顶点信息 firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点 边表结点由 adjvex 和 next 两个域组成 adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标 next 存储边表中下一个结点指针 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表 12345678910111213141516typedef struct ArcNode&#123; int adnex; //该边所指向的结点的位置 struct ArcNode * nextarc; //指向下一条边的指针 int info; //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123; char data; //顶点信息 ArcNode* firstarc; //指向第一条边的指针&#125;VNode;typedef struct&#123; VNode adjlist[maxSize]; //邻接表 int n, e; //顶点数和边数&#125; AGraph; //图的邻接表类型 十字链表 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表 定点表 firstin：入边表头指针，指向顶点入边表的第一个结点 firstout：出边表头指针，指向顶点出边表第一个结点 边表 tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标 headlink 入边表指针域，指向终点相同的下一条边 taillink 是指边表指针域，指向起点相同的下一条边 邻接多重表 ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标 ilink 指向依附项点 ivex 的下一条边 jlink 指向依附顶点 jvex 的下一条边 图的遍历算法 深度优先遍历（DFS，Depth First Search） 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历 1234567891011121314151617bool visited[Max_Vex]; //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123; for (v = 0;v &lt; G.vexnum;++v) visited[v] = false; //初始化标记数组 for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做深度优先遍历 DFS(G, v);&#125;void DFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) DFS(G, w);&#125; 广度优先遍历（BFS，Breadth First Search） 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完 BFS 遍历的方式类似于树的层次遍历 1234567891011121314151617181920212223242526bool visited[Max_Vex]; //定义访问标记数组void BFSTraverse(Graph G)&#123; for (i = 0;i &lt; G.vexnum;++i) visited[v] = false; //初始化标记数组 InitQueue(Q); for (v = 0;v &lt; G.vexnum;++v) if (!visited[v]) //如果 v 未被访问，那么从 v 起，开始做广度优先遍历 BFS(G, v);&#125;void BFS(Graph G, int v)&#123; visit(v); visited[v] = true; //定义为已访问 while (!isEmpty(Q)) &#123; DeQueue(Q, v); for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w)) if (!visited[w]) &#123; visit(w); visited[w] = true; EnQueue(Q, w) &#125; //if &#125; //while&#125; 最小生成树 Prim 算法 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树 1234567891011void prim (G,T)&#123; T = ∅; U = &#123;w&#125;; while ((V - U) != ∅ ) &#123; //若图中不含全部顶点 设 (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边; T = T∪ (u，v); //边归入树 U = U∪ &#123;v&#125;; //顶点归入树 &#125;&#125; Kruskal 算法 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止 Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图 普里姆算法和克鲁斯卡尔算法都是针对于无向图的 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合 1234567891011121314void kruskal（V，T）&#123; T = V; //初始化树，仅含顶点 numS = n; //不连分量的数目 while (numS &gt; 1) &#123; 从 E 中取出权值最小的边（v,u）; if（v 和 u 属于 T 中不同的连通分量） &#123; T = T∪（u，v）;//将此边加入到生成树中； numS--; //不连通的分量减少 1 &#125; &#125;&#125; 最短路径 Dijkstra 算法 通常用于求图中某一顶点到其余各顶点的最短路径 设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中） 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度 Dijkstra 算法步骤 初始时，S 只包含源点，即 S＝{v}，v 的距离为 0，U 包含除 v 外的其他顶点，即:U={其 余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$ 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度） 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离 重复步骤 b 和 c 直到所有顶点都包含在 S 中 12345678910111213141516171819202122232425262728293031323334353637void Dijkstra(int v0)&#123; bool S[MAXNUM]; // 判断是否已存入该点到S集合中 int n=MAXNUM; for(int i=1; i&lt;=n; ++i) &#123; dist[i] = A[v0][i]; S[i] = false; // 初始都未用过该点 if(dist[i] == MAXINT) prev[i] = -1; else prev[i] = v0; &#125; dist[v0] = 0; S[v0] = true; for(int i=2; i&lt;=n; i++) &#123; int mindist = MAXINT; int u = v0; // 找出当前未使用的点j的dist[j]最小值 for(int j=1; j&lt;=n; ++j) if((!S[j]) &amp;&amp; dist[j]&lt;mindist) &#123; u = j; // u保存当前邻接点中距离最小的点的号码 mindist = dist[j]; &#125; S[u] = true; for(int j=1; j&lt;=n; j++) if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT) &#123; if(dist[u] + A[u][j] &lt; dist[j]) //在通过新加入的u点路径找到离v0点更短的路径 &#123; dist[j] = dist[u] + A[u][j]; //更新dist prev[j] = u; //记录前驱顶点 &#125; &#125; &#125;&#125; Floyd 算法 Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包 Floyd-Warshall 算法的时间复杂度为 $O(N^3)$，空间复杂度为 $O(N^2)$ Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离 Floyd 算法步骤 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它 12345for (k = 1;k &lt;= n;k++) for (i = 1;i &lt;= n;i++) for (j = 1;j &lt;= n;j++) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; 拓扑排序 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边 从 DAG 图中选择一个没有前驱的节点并输出 从图中删除该节点和所有以它为起点的有向边 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止 12345678910111213141516171819202122232425bool topologicalSort(Graph GL)&#123; EdgeNode* e; int top = 0; //用于栈指针下标 int count = 0; // 用于统计输出顶点的个数 int* stack; // 建栈将入度为 0 的顶点入栈 stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int)); for (i = 0; i &lt; GL-&gt;numVertexes; i++) if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈 stack[++top] = i; while (top != 0) &#123; gettop = stack[top--]; printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data); count++; //输出 i 号顶点，并计数 for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123; k = e-&gt;adjvex; if (!(--GL-&gt;adjList[k].in)) //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈 stack[++top] = k; &#125; &#125; if (count &lt; GL-&gt;numVertexes) return false; else return true;&#125; 排序排序的基本概念 排序：将原本无序的序列重新排列成有序序列的过程，这个序列中的每一项可能是单独的数据元素，也可能是一条记录 记录由多个数据元素组成的，既可以按照记录的主关键字排序（主关键字唯一标识一条记录），也可以按照记录的次关键字排序 稳定性：当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关键字的相对位置，如果没有发生变化就是稳定的，否则就是不稳定的 排序算法的分类 插入类的排序：直接插入、折半插入、希尔排序 交换类的排序：冒泡排序、快速排序 选择类的排序：简单选择、堆选择 归并类的排序：二路归并 基数类的排序：多关键字排序 插入类的排序 插入排序 123456789101112void InsertSort(int* h, size_t len)&#123; if(h==NULL) return; if(len&lt;=1) return; int i,j; //i是次数，也即排好的个数;j是继续排 for(i=1;i&lt;len;++i) for(j=i;j&gt;0;--j) if(h[j]&lt;h[j-1]) Swap(h[j],h[j-1]); else break; return;&#125; 希尔排序 缩小增量排序：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序 随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 123456789101112void ShellSort(int* h, size_t len)&#123; if(h==NULL) return; if(len&lt;=1) return; for(int div=len/2;div&gt;=1;div/=2) for(int k=0;k&lt;div;++k) for(int i=div+k;i&lt;len;i+=div) for(int j=i;j&gt;k;j-=div) if(h[j]&lt;h[j-div]) Swap(h[j],h[j-div]); else break; return;&#125; 交换类的排序 快速排序 123456789void QuickSort(SeqList R，int low，int high) &#123; //对 R[low..high]快速排序 int pivotpos； //划分后的基准记录的位置 if (low &lt; high) &#123; //仅当区间长度大于 1 时才须排序 pivotpos = Partition(R，low，high)； //对 R[low..high]做划分 QuickSort(R，low，pivo t pos-1)； //对左区间递归排序 QuickSort(R，pivotp o s+1，high)； //对右区间递归排序 &#125;&#125; //QuickSort 冒泡排序 通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置 1234567891011void BubbleSort(int* h, size_t len)&#123; if(h==NULL) return; if(len&lt;=1) return; //i是次数，j是具体下标 for(int i=0;i&lt;len-1;++i) for(int j=0;j&lt;len-1-i;++j) if(h[j]&gt;h[j+1]) Swap(h[j],h[j+1]); return;&#125; 选择类的排序 选择排序 初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕 每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置 1234567891011121314151617void SelectionSort(int* h, size_t len)&#123; if(h==NULL) return; if(len&lt;=1) return; int minindex,i,j; //i是次数，也即排好的个数;j是继续排 for(i=0;i&lt;len-1;++i) &#123; minindex=i; for(j=i+1;j&lt;len;++j) &#123; if(h[j]&lt;h[minindex]) minindex=j; &#125; Swap(h[i],h[minindex]); &#125; return;&#125; 堆排序 堆实际上是一棵完全二叉树，堆的每一个父节点都大于（或小于）其子节点，堆的每个左子树和右子树也是一个堆 最大堆（大顶堆）：堆的每个父节点都大于其孩子节点；最小堆（小顶堆）：堆的每个父节点都小于其孩子节点 堆的第一个元素要么是最大值（大顶堆），要么是最小值（小顶堆），这样在排序的时候（假设共 n 个节点），直接将第一个元素和最后一个元素进行交换，然后从第一个元素开始进行向下调整至第 n-1 个元素。所以，如果需要升序，就建一个大堆，需要降序，就建一个小堆 123456789101112void HeapSort(SeqIAst R)&#123; //对 R[1..n]进行堆排序，不妨用 R[0]做暂存单元 int i； BuildHeap(R)； //将 R[1-n]建成初始堆 for (i = n;i &gt; 1； i -) &#123; //对当前无序区 R[1..i]进行堆排序，共做 n-1 趟 R[0] = R[1]; R[1] = R[i]; R[i] = R[0];//将堆顶和堆中最后一个记录交换 Heapify(R，1 ，i-1); //将 R[1..i-1]重新调整为堆，仅有 R[1]可能违反堆性质 &#125; //endfor &#125; //HeapSort 二路归并排序 MERGE-SORT：利用归并的思想实现的排序方法，采用经典的分治（divide-and-conquer）策略 递归拆分子序列，将两个已经有序的子序列合并成一个有序序列 12345678910void MergeSortDC(SeqList R，int low，int high) &#123;//用分治法对 R[low..high]进行二路归并排序 int mid； if(low&lt;high)&#123; //区间长度大于 1 mid=(low+high)/2； //分解 MergeSortDC(R，low，mid); //递归地对 R[low..mid]排序 MergeSortDC(R，mid+1，high)； //递归地对 R[mid+1..high]排序 Merge(R，low，mid，high)； //组合，将两个有序区归并为一个有序区 &#125; &#125;//MergeSortDC 基数排序 不需要比较关键字的大小，根据关键字中各位的值，通过对排序的N个元素进行若干趟分配与收集来实现排序的 时间复杂度为 $O\\left( d\\left( n+r_{d}\\right) \\right)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687int GetMaxDight(int* h, int len)&#123; if(h==NULL) return 0; if(len&lt;1) return 0; int max=h[0]; for(int i=1;i&lt;len;++i) &#123; if(h[i]&gt;max) max=h[i]; &#125; int digit=1; while(max/10!=0) &#123; max/=10; ++digit; &#125; return digit;&#125;int GetReminder(int value,int digit)&#123; int div=1; for(int i=1;i&lt;digit;++i) div*=10; return value/div%10;&#125;void RadixSort_LSD(int* h, int len)&#123; if(h==NULL) return; if(len&lt;=1) return; int digit=GetMaxDight(h,len); //printf(&quot;MaxDigit:%d\\n&quot;, digit); int count[10]=&#123;0&#125;; int *tmp=(int*)calloc(len,sizeof(int)); for(int d=1;d&lt;=digit;++d) &#123; memset(count,0,sizeof(count)); for(int i=0;i&lt;len;++i) &#123; count[GetReminder(h[i],d)]++; &#125; //求右边界 for(int i=1;i&lt;10;++i) &#123; count[i]+=count[i-1]; &#125; for(int i=len-1;i&gt;=0;--i) &#123; int r=GetReminder(h[i],d); int index=count[r]; tmp[index-1]=h[i]; count[r]--; &#125; memcpy(h,tmp,len*sizeof(int)); &#125; free(tmp);&#125;void RadixSort_LSD_Reverse(int* h, int len)&#123; if(h==NULL) return; if(len&lt;=1) return; int digit=GetMaxDight(h,len); //printf(&quot;MaxDigit:%d\\n&quot;, digit); int count[10]=&#123;0&#125;; int *tmp=(int*)calloc(len,sizeof(int)); for(int d=1;d&lt;=digit;++d) &#123; memset(count,0,sizeof(count)); for(int i=0;i&lt;len;++i) &#123; count[GetReminder(h[i],d)]++; &#125; //printf(&quot;haha\\n&quot;); //求右边界 for(int i=8;i&gt;=0;--i) &#123; count[i]+=count[i+1]; &#125; for(int i=len-1;i&gt;=0;--i) &#123; int r=GetReminder(h[i],d); int index=count[r]; tmp[index-1]=h[i]; count[r]--; &#125; memcpy(h,tmp,len*sizeof(int)); &#125; free(tmp);&#125; 排序知识点总结 快速排序、希尔排序、归并排序、堆排序的平均时间复杂度都是 $O\\left( n\\log _{2}n\\right)$，其他都是 $O(n^2)$ 快速排序的空间复杂度为 $O\\left( \\log {2}n\\right)$，归并排序的空间复杂度为 $O\\left( n\\right)$，基数排序的空间复杂度为 $O\\left( r{d}\\right)$，其他都是 $O(1)$ 快速排序、希尔排序、简单选择排序、堆排序是不稳定的，其他都是稳定的 交换类和选择类的排序，经过一趟排序能够保证一个关键字到达最终位置 简单选择排序和折半插入排序的关键字比较次数和原始序列无关 交换类的排序趟数和原始序列有关 直接插入按顺序查找的方式，而折半插入按折半查找的方式排序 借助于比较进行排序的算法在最坏情况下的时间复杂度至少为 $O\\left( n\\log _{2}n\\right)$ 查找查找的基本概念 给定一个值 K，在含有 n 个记录的表中找出关键字等于 K 的记录叫查找，记录即为关键字 通常把查找过程中对关键字的平均比较次数（也称平均查找长度）作为衡量一个查找算法优劣的标准 平均查找长度 $ASL=\\sum ^{n}{i=1}p{i}\\times c_{i}$ $p{i}$ 为查找第 i 个记录的概率，$c{i}$ 为找到第 i 个记录所需要进行比较的次数（查找长度） 顺序查找 用待查找的关键字和给定序列中的各元素的关键字从左到右（或从右到左）依次进行比较，直到成功或失败 存储结构通常是顺序结构，也可是链式结构 123456789101112131415161718192021222324252627282930313233343536//顺序表的查找（不带监视哨）int SeqSearch(SSTable S, DataType x)&#123; int i = 0; while (i &gt; s.length &amp; S.list[i].key != x.key) i++; if (s.list[i].key == x.key) return i + 1; return 0;&#125;//顺序表的查找（带监视哨）int SeqSearch2(SSTable S, DataType x)&#123; int i = S.length; //将关键字存放在0位置处,防止越界 /*哨兵的主要作用就是在查找循环中监视下标i是否越界 一旦越界(i=0),因为可以和自己进行比较,循环判定条件 不成立就使得查找循环结束,就可以达到忽略判定边界条件的目的*/ s.list[o].key = x.key; while (s.list[i].key != x.key) i--; return i; // 实际上,一切为简化边界条件而引入的附加结点(元素)均可称为哨兵&#125;//顺序表的查找（链表实现）Node* Search(Lnode* head, int key)&#123; LNode* p = head-&gt;next; while (p != NUll) &#123; if (P-&gt;data == key) return p; p = p-&gt;next; &#125; return NULL;&#125; 二分查找 要求线性表是有序的 在给定序列是有序表的前提下，将表中间位置处的关键字和查找关键字比较，相 等则查找成功 否则从中间位置将表分成前后两个子表，如果中间位置处的关键字大于 查找关键字，则进一步查找前子表，否则查找后子表 重复以上过程，直到找到满足条件的记录，此时查找成功，或直到子表不存在为止，表示查找失败 123456789101112int BSearch(int arr[], int low, int high, int key) &#123; while (low &lt;= high) &#123; int mid = (low + high) / 2; if (arr[mid == key]) return mid; else if (arr[mid] &gt; key) high = mid - 1; else low = mid + 1; &#125; return -1;&#125; 二叉排序树（BST） 二叉排序树要么是空树,要么是满足下列要求的树 若它的左子树不空，则左子树上所有的关键字的值均小于根节点关键字值 若它的右子树不空，则右子树上所有的关键字的值均大于根节点关键字值 左右子树又各是一棵二叉排序树 Binary Search Tree 又被叫做二叉搜索树 or 二叉查找树 在对某个关键字进行查找的时候，首先和二叉排序树的根节点进行比较，若相等则査找成功 由于二叉排序树本身的性质，若该关键字小于根节点值，则再与其左子树进行比较,否则和其右子树进行比较，直到找到与之相等的节点，则查找成功 若待比较的位置来到空指针处，则表示査找失败，返回失败的标记 12345678910111213141516171819202122232425//非递归算法BTNode* BSTSearch(BTNode* p, int key) &#123; while (p != NULL) &#123; if (key == p-&gt;key) return p; else if (key &lt; p-&gt;key) p = p-&gt;lChild; else p = p-&gt;rChild; &#125; return NULL;&#125;//递归算法BTNode* BSTSearch2(BTNode* p, int key) &#123; if (p == NULL) return NULL; else&#123; if (key == p-&gt;key) return p; else if (key &lt; p-&gt;key) return BSTSearch2(p-&gt;lChild, key); else return BSTSearch2(p-&gt;rChild, key); &#125;&#125; 平衡二叉树（AVL 树） 平衡二叉树是一种特殊的二叉排序树，其左右子树都是平衡二叉树且左右子树高度之差的绝对值不超过1 一个节点的平衡因子为其左子树的高度减去右子树的高度，对于平衡二叉树，树中所有结点的平衡因子取值只可能是-1、0、1 若向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性，则首先要找出插入新节点后失去平衡的最小子树，然后再调整这颗子树使之成为平衡子树 当失去平衡的最小子树被调整为平衡子树后，无需调整原有其他所有的不平衡子树 最小不平衡子树：是以距离插入结点最近且以平衡因子绝对值大于1的结点作为跟的子树，又称为失去平衡的最小子树 散列表 Hash：根据给定的关键字来计算出关键字在表中的地址 Hash table（哈希表）：是根据关键码值（Key value）而直接进行访问的数据结构，=通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表 给定表 M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希表，函数 f(key) 为哈希函数 键（key）：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分 槽（slot/bucket）：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器 哈希函数（hash function）：将 key 映射 map 到数据应该存放的槽 slot 所在位置的函数 哈希冲突（hash collision）：哈希函数将两个不同的键映射到同一个索引的情况 12345678910111213141516171819202122int h1(int x)&#123; return (x%5);&#125;int h2(char* x)&#123; int i,sum; for(sum=0, i=0; x[i] != &#x27;\\0&#x27;; i++) sum += (int)x[i]; return (sum%5);&#125;int ELFhash(char*key)&#123; unsigned long h=0; while(*key) &#123; h = (h &lt;&lt; 4) + *key++; unsigned long g = h &amp; 0xF0000000L; if(g) h ^= g &gt;&gt; 24; h &amp;= ~g; &#125; return h % MOD;&#125; 散列表的性能分析（查找成功时的平均查找长度）：找到表中已有表项的平均次数 装填因子是关键字个数和表长度的比值 常用算法补充 动态规划算法 处理多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态 这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线） 动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处 1234567891011121314for (j = 1; j &lt;= m; j = j + 1) // 第一个阶段 xn[j] = 初始值;for (i = n - 1; i &gt; = 1; i = i - 1)// 其他n-1个阶段 for (j = 1; j &gt;= f(i); j = j + 1)//f(i)与i有关的表达式 xi[j] = j = max&#123; g(xi - 1[j1:j2]), ...... , g(xi - 1[jk:jk + 1]) &#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for (i = 2; i &lt;= n - 1; i = i + 1)&#123; t = t - xi - 1[ji]; for (j = 1; j &gt;= f(i); j = j + 1) if (t = xi[ji]) break;&#125; 贪心算法 在对问题求解时，总是做出在当前看来是最好的选择，局部最优解 整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的 贪心算法建立哈夫曼树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct BTreeNode&#123; int data; struct BTreeNode* left; struct BTreeNode* right;&#125;btreenode;//建立哈夫曼树btreenode *CreateHuffman(int a[],int n)&#123; int i; btreenode *s[n+1], *ss; for(int i = 0;i&lt;n;i++)&#123; s[i] = new btreenode; //初始化s指针数组，使每个指针元素指向a数组中对应的元素结点 s[i]-&gt;data = a[i]; //将树拆成森林，每棵树都只有一个根节点 s[i]-&gt;left = s[i]-&gt;right = NULL; &#125; for(int i = 1;i&lt;n;i++)&#123; //进行 n-1次循环建立哈夫曼树 int k = -1,t; //k表示森林中具有最小权值的树根结点的下标，t为次最小的下标 for(int j = 0;j&lt;n;j++)&#123; //k初始指向森林中第一棵树，t指向第二棵 if(s[j]&amp;&amp;k==-1)&#123; k = j; continue; &#125; if(s[j])&#123; t = j; break; &#125; &#125; for(int i = t;i&lt;n;i++)&#123; //从当前森林中求出最小权值树和次最小 ； if(s[i])&#123; if(s[i]-&gt;data&lt;s[k]-&gt;data)&#123; //比最小树小 t = k; k = i; &#125; else if(s[i]-&gt;data&lt;s[t]-&gt;data)&#123; //比次小树小 t = i; &#125; else&#123; ; &#125; &#125; &#125; //由最小权值树和次最小权值树建立一棵新树，ss指向树根结点(以后依次建立) ss = new btreenode; //ss = (btreenode *)malloc(sizeof(btreenode)) ss-&gt;data = s[k]-&gt;data+s[t]-&gt;data; ss-&gt;left = s[k]; ss-&gt;right = s[t]; s[k] = ss; //关键点:将ss赋给s[k](k为上述找到的最小树下标,但这是s[k]代表的值已改变，同时把s[t]失效的置空, //在这里起向下一个判断的作用if(s[j])&#123;t = j;break;&#125; s[t] = NULL; &#125; free(s); //释放分配空间 return ss;&#125;//求哈夫曼树的带权路径长度int WeightPathLength(btreenode* FBT, int len)&#123; //参数len为树的层数 if(!FBT)&#123; return 0; &#125; else&#123; if(FBT-&gt;left ==NULL&amp;&amp;FBT-&gt;right ==NULL)//访问到叶子结点 return FBT-&gt;data*len; else&#123; //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增 return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);//一定要记得加1 &#125; &#125;&#125;//哈夫曼编码void HuffManCoding(btreenode* FBT, int len)&#123; //参数len为树的层数 static int a[20]; //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减1 if(FBT)&#123; //访问到叶子结点时输出其保存在数组a中的0和1序列编码 if(FBT-&gt;left == NULL&amp;&amp;FBT-&gt;right == NULL)&#123; printf(&quot;结点权值为%d的编码:&quot;,FBT-&gt;data); for(int i = 0;i&lt;len;i++)&#123; printf(&quot;%d&quot;,a[i]); &#125; printf(&quot;\\n&quot;) ; &#125; else&#123; //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组 //a的对应元素中，向下深入一层时len值增1 a[len] = 0; HuffManCoding(FBT-&gt;left,len+1); a[len] = 1; HuffManCoding(FBT-&gt;right,len+1); &#125; &#125;&#125;int main()&#123; btreenode *s; int n; printf(&quot;从键盘输入待构造的哈夫曼树中带权叶子结点数n：&quot;); while(true)&#123; scanf(&quot;%d&quot;,&amp;n); if(n&gt;0)&#123; break; &#125; else&#123; printf(&quot;-------输入不合法,请重新输入!!\\n&quot;); &#125; &#125; int *a = (int *)malloc(n *sizeof(int)); printf(&quot;从键盘输入%d个整数作为权值:&quot;,n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); s = CreateHuffman(a,n); printf(&quot;哈夫曼树的带权路径长度：&quot;); printf(&quot;%d\\n&quot;, WeightPathLength(s, 0)); printf(&quot;树中每个叶子结点的哈夫曼编码：\\n&quot;); HuffManCoding(s,0); return 0;&#125;","categories":[{"name":"计算机科学与技术","slug":"计算机科学与技术","permalink":"http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"白话机器学习算法","slug":"白话机器学习算法","date":"2021-10-30T16:00:00.000Z","updated":"2022-05-23T09:45:09.080Z","comments":true,"path":"白话机器学习算法/","link":"","permalink":"http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/","excerpt":"机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。白话机器学习算法一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。","text":"机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。白话机器学习算法一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。 一、基础知识我们为何需要数据科学？因为借助现代计算机和高级算法，我们能够从大型数据集中发现隐藏的趋势，能够充分利用发现的趋势做预测，能够计算每种结果出现的概率，能够快速获取准确结果。 数据科学的研究有 4 个主要步骤： 准备待分析的数据。 根据研究需求挑选合适的算法，为数据建立模型。 对算法的参数进行调优，优化模型。 根据准确度评价模型。 准备数据数据格式：数据点、数据集。 变量（variable）：用于描述数据点，又叫属性、特征或维度，变量选择是一个试错的过程，需要根据反馈结果不断更换变量，选取那些最有希望的变量，以待进一步分析。 二值变量（binary variable）：最简单的变量类型，只有2个可选值 分类变量（categorical variable）：用来表示有2个以上选择的情况 整型变量（integer variable）：用来表示整数 连续变量（continuous variable）：用来表示小数 特征工程（feature engineering）是将原始数据转化成更好的表达问题本质的特征的过程，使得将这些特征运用到预测模型中能提高对不可见数据的模型预测精度。 解决数据缺失的方法：近似、计算、移除。 选择算法无监督学习（unsupervised learning）是依靠算法从数据中找出隐藏的模式，主要有 k 均值聚类、主成分分析、关联规则、社会网络分。通过间接手段，可以对无监督学习模型输出的结果进行验证。 监督学习（supervised learning）是基于数据中已有的模式做预测，主要有回归分析、k 最近邻、支持向量机、决策树、随机森林（random forest）、神经网络等。 强化学习（reinforcement learning）使用数据中的模式做预测，并根据越来越多的反馈结果不断改进。 我们除了要了解算法使用的任务类型外，还要了解各种算法对不同数据类型的分析能力，以及结果的本质。 参数调优（parameter tuning）不同的算法有不同的调节参数，即便是同一个算法，如果参数调的不一样，所产生的结果也各不相同。 过拟合模型：过度敏感，把数据中的随机波动当成持久模式，对当前数据有着很高的预测准确度，但是对未知数据的预测准确度较差（泛化能力不强）。 欠拟合模型（underfitting）：过于愚钝，很可能会忽视数据中的重要趋势，这会导致模型对当前数据和未知数据的预测准确度下降。 理想拟合：算法能在识别主要趋势和忽视微小变化之间找到平衡，使最终得到的模型非常适合做预测。 对于大多数模型而言，过拟合（overfitting）是常见问题，所以增加预测模型的复杂度能最大限度的减少预测误差，但容易出现预测边界过度复杂。可以通过正则化（regularization）引入惩罚参数，通过人为增大预测误差，对模型复杂度的增加进行惩罚，从而使算法同时考虑复杂度和准确度使模型保持简单，有助于提高模型的泛化能力。 评价模型使用一些评价指标来比较模型的预测准确度：预测准确率、混淆矩阵和均方根误差（root mean squared error） 分类指标（classification） 预测准确率：正确预测所占的比率，无法通过预测准确率得知预测误差是如何产生的 混淆矩阵（confusion matrix）：在预测准确率的基础上添加假正类型和假负类型，辨别预测误差数 回归指标：由于回归预测使用连续值，因此误差一般被量化成预测值和实际值之差，惩罚随误差大小而不同。 均方根误差：将每个误差都取平方，放大大误差，这使得均方根误差对异常值极其敏感，对这些值的惩罚力度也更大，避免较大的误差。 验证：评估模型对新数据的预测准确度，避免过拟合模型在面对当前数据表现良好而面对新数据时可能表现糟糕的情况。在评估模型时并不一定非要使用新数据，而是可以把当前的数据集划分成训练集（training dataset）和测试集（test dataset）。训练集用来生成和调整预测模型，测试集用来充当新数据并评估模型的预测准确度，最好的模型针对测试集所做的预测一定是最准确的。为了使验证（validation）过程行之有效，需要不带偏差的把数据点随机分派到数据集和测试集中。 交叉验证（cross-validation）：使用同一个数据集进行训练和测试，避免因为原始数据集很小而无法留出足够的数据形成测试集的情况。把数据集划分成若干组用来对模型进行反复测试，在单次迭代中除了某一组外其他各组都被用来训练预测模型，然后留下来的那组被用来测试模型，这个过程重复进行直到每一个组都测试过模型，并且只测试过一次。 二、k 均值聚类（k-means clustering）定义群组群组数量要足够大，以便提取有意义的模式用作商业决策参考，还要足够小，能够确保各个群组之间有明显的区别。 使用陡坡图（scree plot）确定合适的群组数量，陡坡图可以展现群组内散度随群组数量增加而降低的过程。陡坡图曲线的拐弯处表示最佳群组数量，此处的群组内散度较为合理。 通过检查群组成员与群组中心点的距离判断该群组的有效性，群组最好由密集的数据点组成。 猜测每个群组的中心点，因为暂时不能确定通过猜测得到的中心点是否正确，所以称它们为伪中心点。 把每个数据点分配给最近的伪中心点。 根据群组成员的分布调整为中心点的位置。 重复步骤 2 和步骤 3 直至群组成员不再发生变化。 聚类也可以在更多的维度上进行，虽然多维度分析很难进行可视化，但是可以借助程序计算数据点和群组中心点在多维度情形下的距离。 局限性每个数据点只能属于一个群组：恰好位于两个群组中间的数据点无法确定应属于哪个群组。 群组被假定是正圆形的：若群组的实际形状是椭圆形，那么位于椭圆两端的数据点可能被划入邻近的其他群组。 群组被假定是离散的：k 均值聚类既不允许群组重叠，也不允许它们相互嵌套。 弥补局限性的方法：先用 k 均值聚类方法大致了解数据结构，再综合运用其他更高级的方法进行深入分析。 小结k 均值聚类用于把相似的数据点划入同一个群组，群组数量 k 必须事先指定。给数据点分组时，首先把各个数据点分配到距离最近的群组中，然后调整群组中心点的位置，重复这2个步骤直到群组中的成员不再发生变化。k 均值聚类最适用于正圆形、非重叠的群组。 三、主成分分析（principal component analysis）主成分主成分分析用于找出最能区分数据点的变量，这种变量被称为主成分，数据点会沿着主成分的维度最大限度地分散开。主成分可以用已有的一个或多个变量表示。标准化（standardization）类似于使用百分位数表示每个变量，以此将所有变量统一到一个标准尺度上。采用主成分分析之后，可以不再通过试错法组合变量，而是通过精确计算各个变量的权重来获得最优变量组合。 确定主成分数量由于主成分来源于原始变量，因此用来区分数据点的可用信息会受到原始变量个数的制约，为了让结果更简单、更通用，应该只选择前几个主成分进行可视化和后续分析。将主成分按照其对数据点的区分效果进行排列，随着主成分个数增多，区分数据点的效果会变差，陡坡图曲线的拐弯处往往体现了最佳主成分数量。对当前的数据样本进行解释时，使用的主成分越少，泛化能力就越强。 局限性散度最大化：主成分分析有个重要假设，即数据点最分散的维度是最有用的 解释成分：主成分分析必须对其产生的成分进行解释，但有时可能很难解释变量按某种方式进行组合的原因 正交成分：主成分分析算法成分之间存在正交关系，然而真实信息维度之间可能不存在正交关系 弥补局限性的方法：独立成分分析（不需要假设正交关系，在确定成分时还无需考虑数据的散度） 小结主成分分析是一种降维技巧，它使得我们可以使用较小的变量来描述数据，这些变量即为主成分。每个主成分都是原始变量的某种加权组合，最好的主成分可以用来改进数据分析和可视化。当信息最丰富的几个维度拥有最大的数据散度，并且彼此正交时，主成分分析能有最佳效果。 四、关联规则（association rule）支持度、置信度和提升度识别关联规则的常用指标有3个：支持度、置信度和提升度。支持度是某个项集出现的频率，可以人为设定一个支持度阈值，当某个项集的支持度高于这个阈值时，就把它称为频繁项集。置信度是当 X 项出现时 Y 项同时出现的频率，记为 {X-&gt;Y} ，但它可能会错估某个关联规则的重要性。提升度是 X 项和 Y 项一同出现的频率，同时考虑这两项各自出现的频率。 1&#123;X-&gt;Y&#125; 的提升度 = &#123;X-&gt;Y&#125; 的置信度 / &#123;Y&#125; 的支持度 先验原则（apriori principal）先验原则是指如果某个项集出现的不频繁那么包含它的任何更大的项集必定也出现的不频繁。 寻找具有高支持度的项集： 列出只包含一个元素的项集。 计算每个项集的支持度，保留那些满足最小支持度阈值条件的项集，淘汰不满足的项集。 项候选项集中增加一个元素，并利用在步骤2中保留下来的项集产生所有可能的组合。 重复步骤2和步骤3，为越来越大的项集确定支持度，直到没有待检查的新项集。 寻找具有高置信度或高提升度的关联规则：因为置信度和提升度都是基于支持度计算出来的，因此一旦识别出具有高支持度的项集，寻找关联规则就不会那么费劲了。 局限性计算成本高：当库存量很大或者支持度阈值很低时，候选项集仍然会很多。 假关联：当元素的数量很大时，偶尔会出现假关联，为了确保所发现的关联规则具有普遍性，应该对他们进行验证。 弥补局限性的方法：使用高级数据结构对候选项集进行更高效的分类，从而减少比较的次数。 小结关联规则用于揭示某一元素出现的频率以及它与其他元素的关系。 识别关联规则的常用指标有3个： {X} 的支持度表示 X 项出现的频率。 {X-&gt;Y} 的置信度表示当 X 项出现时，Y 项同时出现的频率。 {X-&gt;Y} 的提升度表示 X 项和 Y 项一同出现的频率，并且考虑每项各自出现的频率。 利用先验原则可以淘汰一大部分非频繁项集，从而大大地加快搜索频繁相机的速度。 五、社会网络分析Louvain 方法（Louvain method）通过对节点分组可以找出网络中存在的群组，研究这些群组有助于理解网络各部分的区别和联系。 Louvain 方法用来在网络中找出群组，它会尝试使用不同的聚类配置来做如下两种事： 同一群组中各个节点间的边数和强度最大化。 把属于不同群组的节点间的边数和强度最小化。 模块度用于表示上述两件事的完成程度，模块度越高，群组越理想。 为了获得理想的聚类配置，Louvain 方法会不断迭代： 把每个节点看作一个群组，即一开始群组数和节点数相同。 把一个节点重新分配给对提高模块度有最大帮助的群组，如果无法进一步提高，模块度节点保持不动，针对每个节点重复这个过程直到不能再分配。 把步骤2中发现的每个群组作为一个节点构建出一个粗粒度网络，并且把以前的群间边合并成连接新结点且带权重的边。 重复步骤2和步骤3直到无法再重新分配和合并。 Louvain 方法先发现小群组，然后在适当的情况下合并它们，帮助我们找出更重要的群组，但它有一定的局限性。 重要但较小的群组可能会被合并：需要检查在中间迭代阶段被发现的群组，如果有必要就把它们保留下来。 有多种可能的聚类配置：若网络中包含重叠或嵌套的群组，需要依据其他信息源对群组予以验证。 PageRank 算法（PageRank algorithm）虽然群组可以反映出相互作用高度集中的区域，但是这些相互作用可能受占主导地位的节点支配，群组则围绕着这些主导节点形成，为了找出占主导地位的节点，需要对节点进行排序。PageRank 算法是谷歌公司最初用来为网页排名的算法之一，以 Larry Page 的姓氏命名。 在PageRank 算法中，决定一个网页排名的因素有如下3个： 链接数量：被其他网页链接的次数越多，该网页的访问者可能就越多 链接强度：这些链接被访问的次数越多，该网页的流量就越大 链接来源：如果被其他有较高排名的网页链接，那么该网页的排名也会升高 尽管 PageRank 算法易于使用，但它有偏向于旧节点的局限性：如果一个新网页包含非常棒的内容但一开始访问者人数很少，那么它的排名就比较低，可以定期更新 PageRank 值，让新网页随着自身知名度的提高获得提高排名的机会。 小结社会网络分析可用于绘制和分析多个实体之间的关系。Louvain 方法用于在一个网络中找出群组，具体做法是将群组内部的相互作用最大化，同时把群组之间的相互作用最小化，当群组大小相同且相互分离时，该方法的效果最佳。PageRank 算法根据链接的数量强度以及来源对网络中的节点进行排序，这个算法有助于找出网络中占主导地位的节点，但对链接数不太多的新节点并不友好。 六、回归分析（regression analysis）趋势线趋势线是做预测时常用的工具，他们很容易生成，也很容易理解。一般的趋势往往只涉及单个预测变量，这个变量用来产生预测结果，不过通过添加更多预测变量可以改善预测结果。回归分析不但可以通过考虑更多预测变量改善预测结果，还可以比较各个预测变量的强弱。 梯度下降法（gradient decent）在回归分析中预测变量的权重是主要参数，通过解方程可以求得最优权重。梯度下降法先初步猜测合适的权重组合，再通过一个迭代过程，把这些权重应用于每个数据点做预测，然后调整权重以减少整体预测误差。这个过程类似于一步步走到山底下，每走一步梯度下降法都要判断从哪个方向下是最陡峭的，然后朝着那个方向重新校准权重，最终到达最低点，这个点的预测误差最小（经过优化的回归趋势线与梯度上的最低点相对应）。除了回归之外，梯度下降法也能用来优化其他模型中的参数，比如支持向量机和神经网络。 梯度下降法的结果可能会受到初始参数值（下山起点）的影响，若起点下方恰好有一个小凹坑，那么梯度下降法可能会将其误认为是最优点，为了降低陷入这种凹坑的风险，可以使用随机梯度下降法，每次迭代并不是采用所有的数据点，而是只从其中选取一个来调整参数，引入多变性，有助于算法逃离凹坑。 回归系数在为回归预测变量求得最佳权重之后，需要对它们进行解释。回归系数是回归预测变量权重，它表示某个预测变量相比于其他预测变量的影响大小。预测变量的度量单位不同也会影响对回归系数的解释，因此应该在做回归分析之前先对预测变量的度量单位进行标准化，经过标准化之后预测变量的系数被称为标准化回归系数。 相关系数（correlation coefficient）相关系数：当只存在一个预测变量时，该预测变量的标准化回归系数。 关联方向：相关系数为正表示预测变量和结果变化的方向一致，为负则表示两者变化方向相反。 关联强度：r 值越接近于 -1 或 1，预测变量的作用就越大，若值为 0 则表示预测变量和结果之间不存在关系。 因为相关系数表示单个预测变量的绝对强度，所以相比于回归系数，相关系数在对预测变量进行排序时更可靠。 局限性对异常值敏感：回归分析平等地对待所有的数据点，只要存在几个有异常值的数据点，就会给趋势线造成很大的影响，因此在做进一步分析之前，可以先使用散点图找出异常值。 多重共线性问题（multicollinearity）：如果回归模型包含高度相关的预测变量，就会造成相关预测变量权重失真，因此可以使用更高级的技术，如套索回归或岭回归。 弯曲的趋势：需要对预测变量的值进行转换，或使用支持向量机等其他算法。 并不说明存在因果关系。 小结回归分析用于寻找最佳拟合线（best-fit line），使得尽可能多的数据点位于这条线上或附近，趋势线由带权重的组合预测变量得到，这些权重被称为回归系数，表示某个预测变量相对于其他预测变量的影响强度。 以下情况下，回归分析的效果最好： 预测变量之间的关系不强 无异常值 趋势可以用直线表示 七、k 最近邻算法（k-Nearest Neighbors）和异常检测k 最近邻算法k 最近邻算法根据周围数据点的类型对某个数据点进行分类（物以类聚，人以群分）。在 k 最近邻算法中，参数 k 表示周围数据点的个数，选择 k 值的过程叫做参数调优，它对预测的准确度起着至关重要的作用； 使用不同的 k 值进行拟合：如果 k 值太小，数据点只与最近的邻居匹配，并且随机造成所产生的误差也会被放大；如果 k 值太大，数据点会尝试与更远的邻居匹配，其中隐含的模式会被忽略；只有当 k 值恰到好处时，数据点才会参考合适数量的邻居，使得误差相互抵消，有利于揭示数据中隐藏的趋势。 为实现理想拟合并把误差降到最低，可以使用交叉验证法对参数 k 进行调优，对于二分类问题，可以把 k 设置成一个奇数，以避免出现平局的情况，除了用来为数据点分类，k 最近邻算法还可以通过合计周围数据点的值来预测连续值，通过使用加权平均值，能够进一步改善预测结果，离数据点越近的邻居，其值越能反映该数据点的真实值，因此赋给它的权重应该更大。 异常检测k 最近邻算法不仅可以用来预测数据点的类别和取值，还可以用来识别异常，比如检测欺诈行为。在异常检测的过程中还可能会有新发现，比如发现之前被忽略的预测变量。 事实上任何能够产生预测模型的算法都可以用来检测异常，比如在回归分析中，如果某个数据点明显偏离最佳拟合线，那么就会被识别为异常点。异常数据点既可能因缺失预测变量所致，也可能因预测模型缺少足够的训练数据所致。一旦找到异常数据点，就要将它们从数据集中移除，然后再训练预测模型，减少数据中包含的噪声，进而提高模型的准确度。 局限性类别不平衡：可以使用加权投票法来取代少数服从多数原则，确保较近数据点类别的权重比较远的更大。 预测变量过多：在多个维度上识别和处理近邻会导致你计算量大增，需要降维（dimension reduction）。 小结k 最近邻算法根据周围数据点的类型对某个数据点进行分类，k 表示用作参考的数据点的个数，可以使用交叉验证法来确定。当预测变量数目不多，并且类别大小差别不大时，k 最近邻算法才能产生非常好的效果。不准确的分类可能会被标记为潜在异常。 八、支持向量机（support vector machine）勾画最佳分界线支持向量机的主要目标是得到一条能用于分组的最佳分界线，需要注意的是，能用于分组的分界线可能有很多条。为了找出最佳分界线，首先需要从一组中找出距离另一组最近的外围数据点，然后在两组的外围数据点之间画出最佳分界线，由于这些外围数据点在寻找最佳分界线的过程中起了支持作用，因此叫做支持向量。 支持向量机的一个优点是计算速度很快，仅依靠外围数据点就能找到决策边界，这种对数据点子集的依赖也有缺点，这是因为决策边界对支持向量的位置比较敏感，选取不同的数据点作为训练数据，相应支持向量的位置也不同。 支持向量机算法有一个关键特征——缓冲带，缓冲带允许一定数量的训练数据点位于错误的一边，由此得到一条更软的分界线。缓冲带对异常值有更强的耐扰性，因此对新数据有更强的泛化能力。缓冲带通过调整惩罚参数得到，这个参数决定了对分类误差的宽容度，惩罚参数越大，宽容度就越大，缓冲带也就越宽。为了让模型对当前数据和新数据有较高的预测准确度，可以使用交叉验证法求得最佳惩罚参数。 支持向量机的另一个强项是找到决策边界的凸弧，它在发现错综复杂的凸弧时有着更出众的计算效率。支持向量机的秘诀是核技巧（kernel trick），支持向量机不会直接在在数据平面上绘制有凸弧的分界线，而是会首先把数据映射到高维空间，然后在高维空间中将数据点用直线分开，这些直线容易计算，并且当映射回低维空间时，也很容易转化成曲线。 支持向量机具备在高维空间操纵数据的能力，使得它在分析有多个变量的数据集时大受欢迎。常见应用场景包括遗传信息破译以及文本情感分析。 局限性小数据集：由于支持向量机依靠支持向量确定决策边界，因此样本量少，用来对分界线进行准确定位的数据也少。 多组数据：支持向量机每次只能对两组进行分类，如果存在2个以上的组，则需要对每一组都应用支持向量机（多类支持向量机）。 两组之间存在大量重叠：靠近边界的数据点可能更容易发生分类错误，而且支持向量机没有给出每个数据点遭遇错误分类的概率，但可以通过数据点到决策边界的距离来估计其被正确分类的可能性。 小结支持向量机用来把数据点分为两组，其方法是在两组的外围数据点（支持向量）的中间画一条分界线，支持向量机对异常值有较好的容忍度，它通过一个缓冲带允许少量数据点位于错误的一边，此外他还通过核技巧高效地求得带凸弧的决策边界。当需要把大样本中的数据点分为两组时，支持向量机能够发挥最佳作用。 九、决策树（decision tree）生成决策树递归拆分（recursive partitioning）： 确定一个二元选择题，它能够把数据点拆分成两组，并最大限度地提高每组数据点的同质性。 针对每个叶结点重复步骤1，直到满足终止条件。 终止条件可能有多个，可以使用交叉验证法进行选取：每个叶节点的数据全属于同一类或有相同的值，叶节点包含的数据点少于5个，进一步分支会超出阈值并且不能提高同质性。 由于递归拆分只用最佳二元选择题来生成决策树，因此不显著的变量并不会影响结果，而且二元选择题往往围绕着最重要的值划分数据点，所以决策树对异常值有较强的耐扰性。决策树易于可视化，使我们更容易评估预测变量及其相互作用。 局限性不稳定：决策树是通过把数据点分组生成的，数据中的细微变化可能影响拆分结果，并导致生成的决策树截然不同。 容易产生过拟合：决策树每次拆分数据点时都力求找到最佳拆分方式。 不准确：一开始就是用最佳二元选择题拆分数据点并不能保证结果最准确。 弥补局限性的方法：每次拆分时可以不采用最佳拆分方式，而是尽量让决策树多样化，然后综合不同的决策树产生的预测结果，让最终预测结果具有更好的稳定性和准确性。 决策树的多样化方法随机森林：随机选择不同的二元选择题，生成多棵决策树，然后综合这些决策树的预测结果。 梯度提升（gradient boosting）：有策略地选择二元选择题，以逐步提高决策树的预测准确度，然后将所有的预测结果的加权平均数作为最终结果。 虽然随机森林的和梯度提升能够产生更准确的预测结果，但是它们往往比较复杂并且很难进行可视化（黑盒）。 小结决策树通过询问一系列二元选择题来做预测，若想生成决策树，就要不断拆分数据样本以获得同质组，直到满足终止条件，这个过程被称为递归拆分。虽然决策树易于使用和理解，但是容易造成过拟合问题，导致出现不一致的结果，为了尽量避免出现这种情况，可以采用随机森林等替代方法。 十、随机森林集成模型集成方法（ensembling）：通过组合有不同优缺点的模型来提高预测准确度的方法。 集成模型：通过组合许多模型的预测结果得到的预测模型，在组合模型时，既可以遵循少数服从多数的原则，也可以取平均值。随机森林是决策树的集成模型。 相比于子模型，集成模型的预测准确度更高，这是因为准确的预测模型会彼此强化，错误的则会彼此抵消，为了达到这种效果，集成模型的子模型一定不能犯同类错误，换言之，子模型必须是不相关的。 自助聚集法（bootstrap aggregating）自助聚集法是用来生成数千棵不相关的决策树的系统化方法，这些树彼此有明显的不同。为使决策树之间的关联度最小化，每棵树都由训练数据集的一个随机子集产生，并且使用的是预测变量的一个随机子集，这让生成的决策树各不相同，但仍然保留了一定的预测能力。通过限制每次拆分时所用的预测变量，能够生成各不相同的决策树，从而避免发生过拟合问题。为进一步降低发生过拟合问题的可能性，可以增加随机森林中决策树的数量，使模型更通用、更准确。 局限性随机森林由随机生成的决策树组成，并不存在明确的预测规则，这种不可解释性可能会带来一些伦理问题，因此随机森林适用于那些预测准确度比可解释性更重要的场合。 小结随机森林的预测结果往往比单棵决策树更准确，这是因为它充分利用了两种技术：自助聚集法和集成方法。自助聚集法通过随机限制数据拆分过程所用的变量来生成一系列不相关的决策树，集成方法则把决策树的预测结果组合在一起。虽然随机森林的预测结果不具有可解释性，但仍然可以根据对预测结果的贡献度大小对各个预测变量进行排序。 十一、神经网络（neural network）神经网络的诞生数据存储和共享技术取得进步，为训练神经网络提供了海量数据，有助于改善神经网络的性能。计算能力越来越强大，GPU的运行速度最快能达到CPU的150倍，能为在大数据集上训练神经网络提供强大的支持。算法获得改进。 神经网络的构成输入层：该层处理输入图像的每个像素。为提高预测准确度，可以使用卷积层。卷积层并不处理单个像素，而是识别像素组合的特征，这种分析只关注特征是否出现而不关注出现的位置。所以即使某些关键特征偏离了中心，神经网络仍然能够正确识别，这种特性叫做平移不变性（translational invariance）。 隐藏层：在像素进入神经网络之后，通过层层转换不断提高和那些标签已知的图像的相似度。标签已知是指神经网络以前见过这些图像，虽然转换得越多，预测准确度就会越高，但是处理时间就会明显增加，一般来说几个隐藏层就足够了/每层的神经元数量要和图像的像素数成比例。 输出层：该层产生最终预测结果，在这一层中神经元可以只有一个，也可以和结果一样多。 损失层：该层通常位于最后，并提供有关输入是否识别正确的反馈，如果不正确则给出误差量。在训练神经网络的过程中，损失层至关重要，若预测准确，来自于损失层的反馈会强化产生该预测结果的激活路径。若预测错误，则错误会沿着路径逆向返回，这条路径上的神经元的激活条件就会被重新调整，以减少错误，这个过程称为反向传播（back propagation）。 通过不断重复这个训练过程，神经网络会学习输入信号和正确输出标签之间的联系，并且把这些联系作为激活规则（activation rule）编入每个神经元，因此为了提高神经网络的预测准确度，需要调整管理激活规则的部件。 激活规则为了产生预测结果，需要沿着一条路径依次激活神经元，每个神经元的激活过程都由其激活规则所控制，激活规则指定了输入信号的来源和强度，在神经网络的训练过程中激活规则会不断调整。良好的激活规则有助于产生准确的预测结果，其关键在于确定合适的权重和阈值，另外神经网络的其他参数也需要调整，比如隐藏层的数量、每层的神经元数量等。可以使用梯度下降法优化这些参数。 局限性需要大样本：神经网络的复杂性使之能够识别带有复杂特征的输入，但前提是我们能为他提供大量训练数据，如果训练集太小就会出现过拟合问题。可以通过以下方法降低过拟合风险： 二次取样（subsampling）：为了降低神经元对噪声的敏感度，需要对神经网络的输入进行平滑化处理，即针对信号样本取平均值。 畸变：当缺少训练数据时，可以通过向每幅图像引入畸变，来产生更多数据，每幅畸变图像都可以作为新的输入，以此扩大训练数据的规模，畸变应该能够反映原数据集的特征（弹性变形）。 丢弃（dropout）：为解决小的神经元集群之间彼此产生过度依赖，可以在训练期间随机丢弃一半的神经元，这些遭丢弃的神经元将处于未激活的状态，剩下的神经元则正常工作，下一次训练丢弃一组不同的神经元，迫使不同的神经元协同工作，从而揭示训练样本所包含的更多特征。 计算成本高：训练一个由几千个神经元组成的神经网络可能需要很长时间，一个简单的解决方法是升级硬件另一个解决方法是调整算法，用稍低一些的预测准确度换取更快的处理速度： 随机梯度下降法：为了更新某一个参数，经典的梯度下降法在一次迭代中使用所有的训练样本，当数据集很大时这样做会耗时，随机梯度下降法是在每次迭代中只用一个训练样本来更新参数，虽然使用这个方法得到的最终参数可能不是最优的，但是准确度不会太低。 小批次梯度下降法：虽然使用随机梯度下降法能够提升速度，但最终参数可能不准确，算法也可能无法收敛，导致某个参数上下波动，小批次梯度下降法是每次迭代使用训练样本的一个子集。 全连接层：随着加入的神经元越来越多，路径的数量呈指数增长，为避免查看所有可能的组合，可以使初始层（处理更小、更低级的特征）的神经元部分连接，只有最后几层（处理更大、更高级的特征）才对相邻层的神经元进行全连接。 不可解释：神经网络由多层组成，每层都有几百个神经元，这些神经元有不同的激活规则控制，这使得我们很难准确地找到产生正确预测结果的输入信号组合。但和回归分析不同，回归分析能明确地识别重要的预测变量，并比较它们的强度，神经网络的特性使之难以证明其使用得当，在涉及伦理问题时尤其如此。 尽管存在上述局限性，但是神经网络本身拥有的强大能力，使之得以应用于虚拟助手、自动驾驶等前沿领域，随着算法不断改进以及计算能力不断提升，神经网络将在物联网时代发挥关键作用。 小结神经网络由多个神经元组成，训练期间，第1层的神经元首先被输入数据激活，然后将激活状态传播到后续各层的神经元，最终在输出层产生预测结果。一个神经元是否被激活取决于输入信号的来源和强度，这由其激活规则指定，激活规则会根据预测结果的反馈不断调整，这个过程被称为反向传播。在大数据集和先进的计算硬件可用的情况下，神经网络的表现最好，然而预测结果在大部分的时候都是无法解释的。 十二、A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）A/B 测试的局限性测试结果具有偶然性：为提高测试结果的可信度可以增加受测人数，但是会导致另一个问题。 潜在的收入损失：如果把受测顾客增加一倍，那么看到糟糕广告的人数也会增加一倍，这有流失的顾客的风险。 这两个问题体现了 A/B 测试中的两个权衡因素：探索和利用。 epsilon 递减策略（epsilon-decreasing strategy）epsilon 指的是探索时间与总时间的比例，随着对效果较好的广告越来越有信心，我们使 epsilon 值递减，这个方法属于强化学习的范畴。 A/B 测试由探索和利用前后两个阶段组成，而在 epsilon 递减策略中，探索阶段和利用阶段是分散的，并且一开始时探索得多一些，越接近尾声，探索得越少。 多臂老虎机假设有两台老虎机 A 和 B 可供选择，玩2000个回合，每个回合要么赢1美元，要么没有收益，老虎机 A 的返还率为50%，老虎机 B 的则为40%，但我们事先并不知道这些信息，问要怎么玩才能多赢钱？ 全探索：如果随机选择老虎机，平均会赢900美元。 A/B 测试：用前200个回合探索哪台老虎机的返还率更高，然后在剩下的1800个回合中选择这台老虎机，平均会赢976美元，但由于两台老虎机的返还率接近，由此存在误判的可能性（误判概率8%）。 为降低误判的风险，可以把A/B 测试的探索范围扩大到500个回合，这样做可以把误判概率降到1%，但是平均中奖金额也会减少到963美元。 epsilon 递减策略：如果采用 epsilon 递减策略边探索边利用，平均会赢984美元，并且误判概率为4%，通过增加探索比例（增加 epsilon 值）能够降低误判概率，但仍会减少平均中奖金额。 全利用：如果一开始就掌握内部消息并选择返还率最高的老虎机 A，平均会赢1000美元，但这个假设不现实。 由此看到，在不掌握内部消息的情况下，采用 epsilon 递减策略的收益最高，而且由于存在收敛性这一数学特征，由此 epsilon 递减策略能确保在回合数足够多的情况下找出返还率最高的老虎机。 胜者为先：范加尔在曼联采用了一个非常规策略来决定罚点球的球员，第一个被指定罚点球的球员会负责到底，除非他没有打进球，接下来新换的球员继续负责罚点球，如果没有罚进就再换一名球员，依此类推。 频繁地换老虎机，会导致探索过多而利用过少，只比随机选择老虎机稍好一些，而且胜者为先策略只根据上一次的结果来评估老虎机，这忽略了老虎机之前的表现。 epsilon 递减策略的局限性采用 epsilon 递减策略的关键在于控制好 epsilon 值，如果 epsilon 值递减的过慢，就会失去利用老虎机的机会，而如果递减得过快，就可能会选错老虎机。epsilon 值的最佳递减速度主要取决于两台老虎机返还率的相似程度，采用汤普森取样方法，可以计算 epsilon 值。 epsilon 递减策略还依赖于如下假设：返还率恒定不变；返还率与上一次游戏无关；玩游戏和观察返还率之间的延迟极小。 小结多臂老虎机问题的实质是如何以最佳方式分配资源。一种策略是先探索可用选项，然后把所有剩余资源分配给表现最佳的选项，这个策略叫做 A/B 测试，另一个策略是给表现最佳的选项，逐渐分配更多的资源，这个策略叫做 epsilon 递减策略。虽然 epsilon 递减策略在大多数情况下能够提供比 A/B 测试更高的回报，但是确定资源分配的最佳更新速度并非易事。 十三、更多评价指标分类指标接受者操作特征曲线下面积（曲线下面积）：这个指标允许我们在最大化正例率和最小化假正例率之间做权衡 正例率：被模型正确预测为正类别的样本所占的比例 正例率 = 正例数 / ( 正例数 + 假负例数 ) 假正例率：被模型错误预测为正类别的样本所占的比例 假正例率 = 假正例数 / ( 假正例数 + 负例数 ) 在极端情况下，可以把所有样本全部预测为正类别，以此实现正例率最大化（正例率为1），虽然这样做可以避免出现假负例但会明显增加假正例 接受者操作特征曲线（ROC 曲线）体现了最大化正例率和最小化假正例率之间的权衡 模型性能通过 ROC 曲线下方的面积来衡量，所以该指标被称为曲线下面积，模型的准确度越高，曲线越靠近左上角 完美的预测模型会产生一条曲线下面积为1的曲线（曲线下面积等于整个图形的面积） 对数损失指标利用置信度来校正其对预测误差的惩罚，具体来说，模型对错误预测的置信度越高，惩罚就越重，由于对数损失指标根据对预测结果的置信度来调整惩罚程度，因此它通常用于错误预测极其有害的情况。 回归指标平均绝对误差：平等的惩罚所有预测误差，具体做法是对所有数据点的预测值和实际值之差取平均值。除了考虑误差大小之外，还可以通过均方根对数误差把误差方向纳入考虑范围。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.zhuangzhihao.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"开发团队调度软件实现","slug":"开发团队调度软件","date":"2021-10-08T16:00:00.000Z","updated":"2022-05-05T12:51:41.713Z","comments":true,"path":"开发团队调度软件/","link":"","permalink":"http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/","excerpt":"在学习完 Java 基础编程的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。","text":"在学习完 Java 基础编程的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。 软件需求 软件启动时，根据给定的数据创建公司部分成员列表（数组） 根据菜单提示，基于现有的公司成员，组建一个开发团队以开发一个新的项目 组建过程包括将成员插入到团队中，或从团队中删除某成员，还可以列出团队中现有成员的列表 开发团队成员包括架构师、设计师和程序员 需求分析 软件采用单级菜单方式工作，当软件运行时，主界面显示公司成员的列表 当选择“添加团队成员”菜单时，将执行从列表中添加指定（通过 ID）成员到开发团队的功能 如果添加操作因某种原因失败，将显示失败信息（失败原因视具体原因而不同） 当选择“删除团队成员”菜单时，将执行从开发团队中删除指定（通过 TeamID）成员的功能 当选择“团队列表”菜单时，将列出开发团队中的现有成员 软件设计结构 软件由 view、service、domain 三个模块组成 com.atguigu.team.view 模块为主控模块，负责菜单的显示和处理用户操作 com.atguigu.team.service 模块为实体对象（Employee 及其子类如程序员等）的管理模块，NameListService 和 TeamService 类分别用各自的数组来管理公司员工和开发团队成员对象 domain 模块为 Employee 及其子类等 JavaBean 类所在的包 com.atguigu.team.domain 模块中包含了所有实体类 其中 Programmer 及其子类，均会领用 Equipment 创建项目基本组件 创建 TeamSchedule 项目，按照设计要求创建所有包，将项目提供的几个类复制到相应的包中 view 包中：TSUtility.java service包中：Data.java 按照设计要求，在 com.atguigu.team.domain 包中，创建 Equipment 接口及其各实现子类代码 按照设计要求，在 com.atguigu.team.domain 包中，创建 Employee 类及其各子类代码 检验代码的正确性 键盘访问的实现 项目 view 包中提供了 TSUtility.java 类，提供了以下静态方法，可用来方便地实现键盘访问 public static char readMenuSelection()：该方法读取键盘，如果用户键入’1’-’4’中的任意字符，则方法返回。返回值为用户键入字符 public static void readReturn()：该方法提示并等待，直到用户按回车键后返回 public static int readInt()：该方法从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值 public static char readConfirmSelection()：从键盘读取‘Y’或’N’，并将其作为方法的返回值 Equipment 接口及其实现子类的设计 根据需要提供各属性的 get/set 方法以及重载构造器 实现类实现接口的方法，返回各自属性的信息 Employee 类及其子类的设计 memberId 用来记录成员加入开发团队后在团队中的 ID Status 是项目 service 包下自定义的类，声明三个对象属性，分别表示成员的状态 FREE-空闲 BUSY-已加入开发团队 VOCATION-正在休假 equipment 表示该成员领用的设备 bonus 表示奖金 stock 表示公司奖励的股票数量 可根据需要为类提供各属性的 get/set 方法以及重载构造器 Status 类 Status 枚举类位于 com.atguigu.team.service 包中，封装员工的状态 1234567891011121314151617package com.atguigu.team.service;public class Status &#123; private final String NAME; private Status(String name) &#123; this.NAME = name; &#125; public static final Status FREE = new Status(&quot;FREE&quot;); public static final Status VOCATION = new Status(&quot;VOCATION&quot;); public static final Status BUSY = new Status(&quot;BUSY&quot;); public String getNAME() &#123; return NAME; &#125; @Override public String toString() &#123; return NAME; &#125;&#125; 实现 service 包中的类 按照设计要求编写 NameListService 类 在 NameListService 类中临时添加一个 main 方法中，作为单元测试方法 在方法中创建 NameListService 对象，然后分别用模拟数据调用该对象的各个方法，以测试是否正确 测试应细化到包含了所有非正常的情况，以确保方法完全正确 重复以上3步，完成 TeamService 类的开发 NameListService 类的设计 负责将 Data 中的数据封装到 Employee[] 数组中，同时提供相关操作 Employee[] 的方法 employees 用来保存公司所有员工对象 NameListService() 构造器 根据项目提供的 Data 类构建相应大小的 employees 数组 再根据 Data 类中的数据构建不同的对象，包括 Employee、Programmer、Designer 和 Architect 对象，以及相关联的 Equipment 子类的对象 将对象存于数组中 Data类位于 com.atguigu.team.service 包中 getAllEmployees()：获取当前所有员工 返回：包含所有员工对象的数组 getEmployee(id : int)：获取指定ID的员工对象 参数：指定员工的 ID 返回：指定员工对象 异常：找不到指定的员工 在 service 子包下提供自定义异常类：TeamException 另外，可根据需要自行添加其他方法或重载构造器 TeamService 类的设计 关于开发团队成员的管理：添加、删除等 counter 为静态变量，用来为开发团队新增成员自动生成团队中的唯一 ID，即 memberId（应使用增1的方式） MAX_MEMBER：表示开发团队最大成员数 team数组：用来保存当前团队中的各成员对象 total：记录团队成员的实际人数 getTeam() ：返回当前团队的所有对象 返回：包含所有成员对象的数组，数组大小与成员人数一致 addMember(e: Employee)：向团队中添加成员 参数：待添加成员的对象 异常：添加失败，TeamException 中包含了失败原因 removeMember(memberId: int)：从团队中删除成员 参数：待删除成员的 memberId 异常：找不到指定 memberId 的员工，删除失败 另外，可根据需要自行添加其他方法或重载构造器 实现 view 包中类 按照设计要求编写 TeamView 类，逐一实现各个方法，并编译 执行 main 方法中，测试软件全部功能 TeamView 类的设计 listSvc 和 teamSvc 属性：供类中的方法使用 enterMainMenu()：主界面显示及控制方法 以下方法仅供 enterMainMenu() 调用： listAllEmployees()：以表格形式列出公司所有成员 getTeam()：显示团队成员列表操作 addMember()：实现添加成员操作 deleteMember()：实现删除成员操作","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[]},{"title":"从 2020 年的视角看线性代数","slug":"从2020的视角看线性代数","date":"2021-09-19T16:00:00.000Z","updated":"2022-06-07T13:50:02.013Z","comments":true,"path":"从2020的视角看线性代数/","link":"","permalink":"http://blog.zhuangzhihao.top/%E4%BB%8E2020%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","excerpt":"2020 年 MIT 数学教授 Gilbert Strang 录制了一个关于线性代数的学习和教学的一个新的、启发性的课程，从矩阵 A 的列空间和组合这些列的乘法 Ax 开始，包括了线性代数的概览、正交向量、特征值和特征向量、以及奇异值和奇异向量等方面的内容。","text":"2020 年 MIT 数学教授 Gilbert Strang 录制了一个关于线性代数的学习和教学的一个新的、启发性的课程，从矩阵 A 的列空间和组合这些列的乘法 Ax 开始，包括了线性代数的概览、正交向量、特征值和特征向量、以及奇异值和奇异向量等方面的内容。 矩阵的列空间常用矩阵$A_{0}=\\begin{bmatrix}1 &amp; 3 &amp; 2 \\4 &amp; 12 &amp; 8 \\2 &amp; 6 &amp; 4\\end{bmatrix}$ $A_{0}$ 所有的行向量在同一个方向并且所有的列向量在同一个方向 $A_{1}=\\begin{bmatrix}1 &amp; 4 &amp; 2 \\4 &amp; 1 &amp; 3 \\5 &amp; 5 &amp; 5\\end{bmatrix}$ $A_{1}$ 第一行加第二行等于第三行 对称矩阵 $S_{2}=\\begin{bmatrix}2 &amp; -1 \\-1 &amp; 2\\end{bmatrix}$ $S_{3}=\\begin{bmatrix}1 &amp; -1 &amp; 0 \\-1 &amp; 2 &amp; -1 \\0 &amp; -1 &amp; 1\\end{bmatrix}$ $S_{4}=\\begin{bmatrix}2 &amp; -1 &amp; 0 \\-1 &amp; 2 &amp; -1 \\0 &amp; -1 &amp; 2\\end{bmatrix}$ 正交矩阵 $Q_{5}=\\begin{bmatrix}\\cos \\theta &amp; -\\sin \\theta \\sin\\theta &amp; \\cos \\theta\\end{bmatrix}$ $A_{6}=\\begin{bmatrix}3 &amp; 0 \\4 &amp; 5\\end{bmatrix}$ A 的列空间（列的所有线性组合）将矩阵乘以向量 $Ax=\\begin{bmatrix} 1 &amp; 4 &amp; 5 \\ 3 &amp; 2 &amp; 5 \\ 2 &amp; 1 &amp; 3 \\end{bmatrix}\\begin{bmatrix} x{1} \\ x{2} \\ x{3} \\end{bmatrix}=\\begin{bmatrix} 1 \\ 3 \\ 2 \\end{bmatrix}x{1}+\\begin{bmatrix} x \\ 2 \\ 1 \\end{bmatrix}x{2}+\\begin{bmatrix} 5 \\ 5 \\ 3 \\end{bmatrix}x{3}$ $Ax$ 为一种特殊的列的线性组合 $A$ 的列空间 = $C(A)$ = 所有 $Ax$ 向量 = 各列的所有线性组合 $C(A)$ 是一个平面 列空间的基$A=CR=\\begin{bmatrix}1 &amp; 4 \\3 &amp; 2 \\2 &amp; 1\\end{bmatrix}\\begin{bmatrix}1 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 1\\end{bmatrix}$ 行秩 = 列秩 = r = 2 C 是平面的两个独立列向量，而 R 则表示了 A 是如何通过 C 中的两个向量重组 A 的 R 的 r 行是行空间的一组基 $A = CR$ 表明 A 的行秩等于列秩 C 的 r 列相互线性独立（由定义可知） A 的每一列都是（C 的）这 r 列的线性组合（因为 A = CR） R 的 r 行相互线性独立（这 r 列包含了 r × r 的矩阵 I ） A 的每一行都是（C 的）这 r 行的线性组合（因为 A = CR） 核心内容 C 的 r 列组成了 A 的列空间的基：维度 r R 的 r 列组成了 A 的行空间的基：维度 r 基包含两个向量 A 的秩等于 r = 2 $n − r = 3 − 2 = 1$ 计数定理 $Ax = 0$ 有一组解 $x = (1, 1, −1)$ 有 $n − r$ 组独立解可使 $Ax = 0$ 成立 秩为 1 的矩阵 A如果 A 的任意一列均为第一列的若干倍，那么 A 的每一行均为某行的若干倍 用 A = CR 来证明 C 当中的一列 $v$ ⇒ R 当中的一行 $w$ $A=\\left[ v\\right] ^{\\left[ w\\right] }$ ⇒ 每一行都是 $w$ 的倍数 A = CR 的优良性质C 的列直接来源于 A：体现了此公式的内涵 R 变成了A 的行化简阶梯形 “行秩 = 列秩”这一结论变得显然：C = 列的基，R = 行的基 A = CR 不好的性质C 和 R 可能是病态矩阵 如果 A 是可逆的，则有 C = A 和 R = I ⇒ A = AI，原地打转 线性代数概览线性方程组若 $Ax = 0$ 则有 $\\begin{bmatrix} 1 \\ \\vdots \\ m \\end{bmatrix}\\left[ x\\right]=\\begin{bmatrix} 0 \\ \\vdots \\ 0 \\end{bmatrix}$，x 与 A 的各列均正交 每个处于 A 的零空间当中的 x 都与 A 的行空间正交 每个处于 $A^T$ 的零空间当中的 y 都与 A 的列空间正交 $N\\left( A\\right) \\bot C\\left( A^{T}\\right) $ 与 $N\\left( A^{T}\\right) \\bot C\\left( A\\right) $ 两对正交子空间，其中一对子空间的维度之和等于 n，另一对等于 m 宏观视角下的线性代数 一对子空间处于 $R{n}$ 之中，另一对处于$R{m}$ 当中 从行空间变换为列空间——由此可知 A 是可逆的 列与行相乘（六组因式）A = BC = 秩为 1 的矩阵之和（列乘以行：外积） 对矩阵相乘的全新理解（高层次），每次拿一列乘以一行是低层次的 $A=\\begin{bmatrix} 2 &amp; 3 \\ 4 &amp; 7 \\end{bmatrix}=\\begin{bmatrix} 1 &amp; 0 \\ 2 &amp; 1 \\end{bmatrix}\\begin{bmatrix} 2 &amp; 3 \\ 0 &amp; 1 \\end{bmatrix}=LU$ （将矩阵拆分成上下两个三角矩阵） $2x+3y=7$ ， $4x+7y=15$ ⇒ $x=2,y=1$ 若两行发生交换，则 $PA = LU$ （P 指的是排列矩阵） 用消元来解Ax = b（因式 A = LU）下三角矩阵 L 乘以上三角矩阵 U 正交向量正交向量 – 矩阵 – 子空间$X^{T}y=0,y^{T}x=0,\\left( x+y\\right) ^{T}\\left( x+y\\right)=x^{T}{x}+y^{T}{y}$ （直角三角形） $Q=\\dfrac{1}{3}\\begin{bmatrix} -1 &amp; 2 \\ 2 &amp; -1 \\ 2 &amp; 2 \\end{bmatrix}$ ，$Q^{T}Q=I,QQ^{T}\\neq I$ ，$QQ^TQQ^T = QQ^T$ 正交矩阵特征值和特征向量奇异值和奇异向量","categories":[{"name":"慕课MOOC","slug":"慕课MOOC","permalink":"http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"}],"tags":[]},{"title":"微分学重点","slug":"微分学重点","date":"2021-09-04T16:00:00.000Z","updated":"2022-06-07T13:27:45.319Z","comments":true,"path":"微分学重点/","link":"","permalink":"http://blog.zhuangzhihao.top/%E5%BE%AE%E5%88%86%E5%AD%A6%E9%87%8D%E7%82%B9/","excerpt":"微分学重点的十二章关于导数的课程深入挖掘了微积分的子领域，“微分”。 与微积分重点的课程一样，MIT 数学教授 Gilbert Strang 解释了每个主题如何应用于现实生活中，是对微积分重点的补充，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。","text":"微分学重点的十二章关于导数的课程深入挖掘了微积分的子领域，“微分”。 与微积分重点的课程一样，MIT 数学教授 Gilbert Strang 解释了每个主题如何应用于现实生活中，是对微积分重点的补充，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。 极限和连续极限定义：当 $n\\rightarrow \\infty$ 时，$a_{n}\\rightarrow A$ 洛必达法则：假设 $f(x)$ 和 $g(x)$ 都收敛于 0 \\dfrac{f\\left( x\\right) }{g\\left( x\\right) }=\\dfrac{\\dfrac{\\Delta f}{\\Delta x}}{\\dfrac{\\Delta g}{\\Delta x}}\\rightarrow \\dfrac{s}{t}可导必然连续，连续不一定可导 连续定义：对任取 $\\varepsilon$，都能找到 $\\delta$，满足如果 $\\left| x-a\\right| &lt;\\delta$，则 $\\left| f\\left( x\\right) -f\\left( a\\right) \\right| &lt;\\varepsilon$ $sinx$ 和 $cosx$ 的导数用 $sin$ 和 $cos$ 表示勾股定理 $a^2+b^2=c^2$ $\\rightarrow$ $\\dfrac{a^{2}}{c^{2}}+\\dfrac{b^{2}}{c^{2}}=1$ $\\left( \\cos \\theta \\right) ^{2}+\\left( \\sin \\theta \\right) ^{2}=1$ \\dfrac{d}{dx}\\sin x=\\dfrac{\\Delta \\left( \\sin x\\right) }{\\Delta x}=\\dfrac{\\sin \\left( x+\\Delta x\\right) -\\sin x}{\\Delta x} 因为 $\\sin \\left( x+\\Delta x\\right) =\\sin x\\cos \\Delta x+\\cos x\\sin \\Delta x$ 所以原式 = $\\dfrac{sinx\\left( \\cos \\Delta x-1\\right) }{\\Delta x}+\\dfrac{\\cos x\\sin \\Delta x}{\\Delta x}$ 又因为 $\\dfrac{\\cos \\left( \\Delta x-1\\right) }{\\Delta x}\\rightarrow 0$ 且 $\\dfrac{\\sin \\Delta x}{\\Delta x}\\rightarrow 1$ 所以 $\\dfrac{d}{dx}\\sin x=\\cos x$ \\dfrac{d}{dx}\\cos x=\\dfrac{\\Delta \\left( \\cos x\\right) }{\\Delta x}=\\dfrac{\\cos \\left( x+\\Delta x\\right) -\\cos x}{\\Delta x} 因为 $\\cos \\left( x+\\Delta x\\right) =\\cos x\\cos \\Delta x-\\sin x\\sin \\Delta x$ 所以原式 = $\\dfrac{cos\\left( \\cos \\Delta x-1\\right) }{\\Delta x}-\\dfrac{\\sin x\\sin \\Delta x}{\\Delta x}$ 所以 $\\dfrac{d}{dx}\\cos x=-\\sin x$ $sinx$ 和 $cosx$ 的导数 $\\dfrac{d}{dx}\\sin x=\\cos x$ $\\dfrac{d}{dx}\\cos x=-\\sin x$ 乘法法则和除法法则p(x)=f(x)g(x) $\\dfrac{\\Delta p}{\\Delta x}=\\dfrac{f\\Delta g}{\\Delta x}+\\dfrac{g\\Delta f}{\\Delta x}+\\dfrac{\\Delta f{\\Delta }g}{\\Delta x}$ 乘法法则：$\\dfrac{dp}{dx}=f\\left( x\\right) \\dfrac{dg}{dx}+g\\left( x\\right) \\dfrac{df}{dx}$ $\\dfrac{d}{dx}x^{n}=nx^{n-1}$ $y=x^2sinx$：$\\dfrac{dy}{dx}=x^{2}\\cos x+2xsinx$ q(x)=\\dfrac{f(x)}{g(x)} $f(x)=g(x)q(x)$ $\\dfrac{df}{dx}=g\\left( x\\right) \\dfrac{dq}{dx}+q\\left( x\\right) \\dfrac{dg}{dx}=g\\left( x\\right) \\dfrac{dq}{dx}+\\dfrac{f\\left( x\\right) }{g\\left( x\\right) }\\dfrac{dg}{dx}$ $g\\left( x\\right) \\dfrac{df}{dx}-f\\left( x\\right) \\dfrac{dg}{dx}=g(x)^{2}\\dfrac{dq}{dx}$ 除法法则：$\\dfrac{dq}{dx}=\\dfrac{g\\left( x\\right) \\dfrac{df}{dx}-f\\left( x\\right) \\dfrac{dg}{dx}}{g\\left( x\\right) ^{2}}$ 链式法则函数链（复合函数）：$y=g(x)$，$z=f(y)$ 求导：$\\dfrac{dz}{dx}=\\dfrac{dz}{dy}\\dfrac{dy}{dx}$ $sin(3x)$ 的导数：$3cos(3x)$ $\\dfrac{1}{\\sqrt{1-x^{2}}}$ 的导数：$\\left( -\\dfrac{1}{2}\\left( 1-x^{2}\\right) ^{-3}\\right) -2x=x\\left( 1-x^{2}\\right) ^{-\\dfrac{3}{2}}$ $e^{-\\dfrac{x^{2}}{2}}$ 的导数：$-x\\cdot e^{-\\dfrac{x^{2}}{2}}$ 二阶导数：$\\left( -x\\right) \\left( -xe^{-\\dfrac{x^{2}}{2}}\\right) +\\left( e^{-\\dfrac{x^{2}}{2}}\\right) \\left( -1\\right)=(x^2-1)\\cdot e^{-\\dfrac{x^{2}}{2}}$ 反函数 $f^{-1}\\left( y\\right)$ 与对数函数 $x=lny$$y=f(x)$ 的反函数：$x=f^{-1}(y)$，原函数和反函数关于 $y=x$ 对称 $y=e^{x}$ 的反函数：$x=lny$ 对数函数的性质 $\\ln(xy) =\\ln x+\\ln y$ $ln(y^n)=nlny$ $\\dfrac{d}{dy}\\left( \\ln y\\right) =\\dfrac{1}{y}$ 对数函数 $lny$ 和反三角函数 $sin^{-1}(y)$ 的导数令 $y=e^x$ $\\ln \\left( e^{x}\\right) =x$ 两边求导 $\\dfrac{d}{dy}\\left( \\ln y\\right) e^{x}=1$ $\\dfrac{d}{dy}\\left( \\ln y\\right) =\\dfrac{1}{e^{x}}=\\dfrac{1}{y}$ $x=\\sin ^{-1}y=\\arcsin y$ $y=\\sin \\left( \\sin ^{-1}y\\right)$ 两边求导 $1=\\cos \\left( \\sin ^{-1}y\\right) \\dfrac{d\\sin ^{-1}y}{dy}$ $1=\\sqrt{1-y^{2}}\\dfrac{d}{dy}\\sin ^{-1}y$ $\\dfrac{d}{dy}\\sin ^{-1}y=\\dfrac{1}{\\sqrt{1-y^{2}}}$ 同理：$\\dfrac{d}{dy}\\cos ^{-1}y=\\dfrac{-1}{\\sqrt{1-y^{2}}}$，$\\dfrac{d}{dy}\\tan ^{-1}\\left( y\\right) =\\dfrac{1}{1+y^{2}}$ 增长率和对数图线性增长：$cx,x^{2},x^{3},\\ldots$ 指数增长：$2^{x},e^{x},10^{x},\\ldots$ 阶乘：$2^{x},e^{x},10^{x},\\ldots$ 对数图 线性拟合 $y=Ax^{n}\\rightarrow \\log y=\\log A+n\\log x$ $y=B\\cdot 10^{cx}\\rightarrow \\log y=\\log B+cx$ 线性近似和牛顿法取 $x=a$，已知 $\\dfrac{df}{dx}=f’\\left( a\\right) =\\lim _{x\\rightarrow a}\\dfrac{f\\left( x\\right) -f\\left( a\\right) }{x-a}$，求 $f(x)$ 线性近似：函数在 a 点一阶泰勒展开 $f’\\left( a\\right) \\approx \\dfrac{f\\left( x\\right) -f\\left( a\\right) }{x-a}$ $f\\left( x\\right) \\approx f\\left( a\\right) +\\left( x-a\\right) f’\\left( a\\right)$ 牛顿法 令 $F(x)=0$ $x-a\\approx \\dfrac{-F\\left( a\\right) }{F’\\left( a\\right) }$ 近似法求 $\\sqrt{9.06}$ $f\\left( x\\right) =\\sqrt{x}=x^{\\dfrac{1}{2}}$ $f’\\left( x\\right) =\\dfrac{1}{2}x^{-\\dfrac{1}{2}}=\\dfrac{1}{\\sqrt[2] {x}}$ 取 $a=9$，$f(a)=\\sqrt9=3$，$f’(a)=\\dfrac{1}{6}$ $\\sqrt{9.06}\\approx 3+\\left( 9.06-9\\right) \\dfrac{1}{6}=3.01$ 近似法求 $e^{0.01}$ $f\\left( x\\right) =e^{x}$（$x=0.01$） 取 $a=0$，$f(a)=e^0=1$，$f’(a)=e^0=1$ $e^{x}=e^{0=01}=1+\\left( 0.d-0\\right) \\cdot 1=1.01=1+x$ 牛顿法求 $\\sqrt{9.06}$ $F\\left( x\\right) =x^{2}-9.06=0$ 取 $a=3$，$F(a)=9-9.06=-0.06$，$F’(a)=2a=6$ $x-3\\approx \\dfrac{0.06}{6}=0.01$ 幂级数和欧拉公式泰勒级数：$f\\left( x\\right) =f\\left( 0\\right) +f’\\left( 0\\right) \\dfrac{x}{1}+f’’\\left( 0\\right) \\dfrac{x^{2}}{2}+\\ldots +f^{\\left( n\\right) }\\left( 0\\right) \\dfrac{x^{n}}{n!}$ $x^n$ 的 n 阶导：$n!$ 使用泰勒级数展开的幂级数 $e^{x}=1+x+\\dfrac{1}{2}x^{2}+\\dfrac{1}{6}x^{3}+\\ldots +\\dfrac{1}{n!}x^{n}$ $\\sin x=x-\\dfrac{x^{3}}{3!}+\\dfrac{x^{5}}{5!}\\ldots$ 奇级数 $\\cos x=1-\\dfrac{x^{2}}{2!}+\\dfrac{x^{4}}{4!}\\ldots$ 偶级数 欧拉公式：将 $e^x$ 级数中的 $x$ 考虑为虚数 $i$ $e^{ix}=1+ix+\\dfrac{1}{2!}\\left( ix\\right) ^{2}+\\dfrac{1}{3!}\\left( ix\\right) ^{3}+\\ldots$ 实数、虚数分离：$e^{ix}=\\left( 1-\\dfrac{1}{2!}x^{2}+\\ldots \\right) +i\\left( x-\\dfrac{1}{3!}x^{3}+\\ldots \\right)$ 因此：$e^{ix}=\\cos x+i\\sin x$ 同理：$e^{-ix}=\\cos x-i\\sin x$ 几何级数：$\\dfrac{1}{1-x}=1+x+x^{2}+x^{3}+\\ldots ( \\left| x\\right| &lt; 1)$ 将几何级数逐项积分：$-ln \\left( 1-x\\right) =x+\\dfrac{x^{2}}{2}+\\dfrac{x^{3}}{3}+\\dfrac{x^{4}}{4}+\\ldots ( \\left| x\\right| &lt; 1)$ 关于运动的微分方程微分方程就是函数的导数和函数本身之间存在的关系 常系数二阶线性微分方程：$m\\dfrac{d^{2}y}{dt^{2}}+2r\\dfrac{dy}{dt}+ky=0$ $m=0$ 时，$\\dfrac{dy}{dt}=ay\\rightarrow y=ce^{at}$ $r=0$ 时，$\\dfrac{d^{2}y}{dt^{2}}=-\\omega ^{2}y$ （$\\omega ^{2}= \\dfrac{k}{m}$）$\\rightarrow y=C\\cos \\omega t+D\\sin \\omega t$ 令 $y=e^{\\lambda t}$ 满足方程 $m\\lambda ^{2}e^{\\lambda t}+2r\\lambda e^{\\lambda t}+ke^{\\lambda t}=0$ $m\\lambda ^{2}+2r\\lambda +k=0$ $\\lambda =\\dfrac{-r\\pm \\sqrt{r^{2}-km}}{m}$ $y=Ce^{\\lambda {1}t}+De^{\\lambda {2}t}$ 若 $\\lambda {1}=\\lambda {2}$，$y=Ce^{\\lambda t}+Dte^{\\lambda t}$ 当 $m=1,r=3,k=10$ 时，$1y’’+6y’+10y=0$ $\\lambda ^{2}+6\\lambda +10=0$ $\\lambda =-3\\pm i$ $y\\left( t\\right) =Ce^{\\left( -3+i\\right) t}+De^{\\left( -3-i\\right) t}$ 由欧拉公式：$y\\left( t\\right) =Ae^{-3t}\\cos t+Be^{-3t}\\sin t$ 关于增长的微分方程微分方程 $\\dfrac{dy}{dt}=cy$，对于任意 A 有解 $y\\left( t\\right) =Ae^{ct}$ $y\\left( t\\right) =y\\left( 0\\right) e^{ct}$ 增加初始常数：$\\dfrac{dy}{dt}=cy+s$ $\\dfrac{d}{dt}\\left( y+\\dfrac{s}{c}\\right) =c\\left( y+\\dfrac{s}{c}\\right)$ $y\\left( t\\right) =-\\dfrac{s}{c}+\\left( y\\left( 0\\right) +\\dfrac{s}{c}\\right) e^{ct}$ 人口增长方程：$\\dfrac{dP}{dt}=cP-sP^{2}$，$c$ 为增长率而 $s$ 为竞争因素 令 $y=\\dfrac{1}{P}$，$\\dfrac{dy}{dt}=-\\dfrac{\\dfrac{dP}{dt}}{P^{2}}=\\dfrac{\\left( cP+sP^{2}\\right) }{P^{2}}=s-cP=s-cy$ $y\\left( t\\right) =\\dfrac{s}{c}+Ae^{-ct}=\\dfrac{s}{c}+\\left( y\\left( 0\\right) -\\dfrac{s}{c}\\right) e^{-ct}$ $\\dfrac{1}{p\\left( t\\right) }-\\dfrac{s}{c}=\\left( \\dfrac{1}{p(0)}-\\dfrac{s}{c}\\right) e^{-ct}$ 人口增长方程二阶导数：$\\dfrac{d^{2}P}{dt^{2}}=\\dfrac{d}{dt}\\left( cP-sP^{2}\\right) =\\left( c-2sP\\right) \\dfrac{dP}{dt}$ $p=\\dfrac{c}{2s}$ 时，$\\dfrac{d^{2}P}{dt^{2}}=0$（拐点，增长率开始放缓） 微分学总结六函数 积分 导数 $\\dfrac{x^{n+1}}{\\left( n+1\\right) },n\\neq -1$ $x^n$ $nx^{n-1}$ $-cosx$ $sinx$ $cosx$ $sinx$ $cosx$ $-sinx$ $\\dfrac{e^{cx}}{c}$ $e^{cx}$ $ce^{cx}$ $x\\ln x-x$ $lnx$ $\\dfrac{1}{x}$ 斜坡函数 分段函数 $\\delta$ 函数 六法则加法法则：和的导数等于导数的和 $af\\left( x\\right) +bg\\left( x\\right) \\rightarrow a\\dfrac{df}{dx}+b\\dfrac{dg}{dx}$ 乘法法则：上乘下导加下乘上导 $f\\left( x\\right) g\\left( x\\right) \\rightarrow f\\left( x\\right) \\dfrac{dg}{dx}+g\\left( x\\right) \\dfrac{df}{dx}$ 除法法则：下平方分之下乘上导减上乘下导 $\\dfrac{f\\left( x\\right) }{g\\left( x\\right) }\\rightarrow \\dfrac{g\\left( x\\right) \\dfrac{df}{dx}-f\\left( x\\right) \\dfrac{dg}{dx}}{g\\left( x\\right) ^{2}}$ 链式法则 $f\\left( g\\left( x\\right) \\right) \\rightarrow \\dfrac{df}{dy}\\dfrac{dy}{dx}$ 反函数的导数等于原函数的导数分之一 $x=f^{-1}\\left( y\\right) \\rightarrow \\dfrac{dx}{dy}=\\dfrac{1}{\\dfrac{dy}{dx}}$ 洛必达法则：$\\dfrac{0}{0}$ 或 $\\dfrac{\\infty }{\\infty }$ $\\dfrac{f\\left( x\\right) }{g\\left( x\\right) }\\rightarrow \\dfrac{\\dfrac{dt}{dx}}{\\dfrac{dg}{dx}}$ 六定理微积分基本定理 如果函数 $f(x)=\\int _{a}^{x}s\\left( t\\right) dt$，那么函数的导数为 $\\dfrac{df}{dx}=s\\left( x\\right) $ 如果函数的导数为 $\\dfrac{df}{dx}=s\\left( x\\right) $，那么导数的积分（原函数）为 $\\int _{a}^{b}s\\left( x\\right) dx=f\\left( b\\right) -f\\left( a\\right) $ 介值定理（全值定理） 对于 $a\\leq x\\leq b$ 区间上的连续函数 一定能取到最大值 $M$ 和最小值 $m$，使得 $[M,m]$ 中的任意值都存在函数上的点与之对应 连续函数的一个区间内的函数值肯定介于最大值 $M$ 和最小值 $m$之间 中值定理 如果函数 $f(x)$ 在闭区间 $[a,b]$ 上连续，在开区间 $(a,b)$ 内可导，那么在 $(a,b)$ 内至少有一点 $\\varepsilon $，使 $f\\left( b\\right) -f\\left( a\\right) =f\\left( \\varepsilon \\right) \\left( b-a\\right) $ 成立 泰勒级数 $f\\left( x\\right) =f\\left( a\\right) +f’\\left( a\\right) \\left( x-a\\right) +\\dfrac{1}{2}f’’\\left( a\\right) \\left( x-a\\right) ^{2}+\\ldots =\\sum ^{\\infty }_{n=0}\\dfrac{1}{n!}f^{\\left( n\\right) }\\left( a\\right) \\left( x-a\\right) ^{n}$ 若级数截断于 $\\left( x-a\\right) ^{n}$ 项，余项为：$\\dfrac{1}{\\left( n+1\\right) !}f^{\\left( n+1\\right) }\\left( c\\right) \\left( x-a\\right) ^{\\left( n+1\\right) }$ 当 $a=0$ 时，$f\\left( x\\right)=\\sum ^{\\infty }_{n=0}\\dfrac{1}{n!}f^{\\left( n\\right) }\\left( 0\\right) \\left( x\\right) ^{n}$ 二项式定理 帕斯卡三角： $(1+x)^p=1+px+\\dfrac{P\\left( p-1\\right) }{\\left( 2\\right) \\left( 1\\right) }x^{2}+\\dfrac{p\\left( p-1\\right) \\left( p-2\\right) }{\\left( 3\\right) \\left( 2\\right) \\left( 1\\right) }x^{3}+\\ldots $","categories":[{"name":"慕课MOOC","slug":"慕课MOOC","permalink":"http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"}],"tags":[]},{"title":"微积分重点","slug":"微积分重点","date":"2021-08-31T16:00:00.000Z","updated":"2022-06-25T02:43:26.608Z","comments":true,"path":"微积分重点/","link":"","permalink":"http://blog.zhuangzhihao.top/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B9/","excerpt":"微积分重点（Highlights of Calculus）是 MIT 数学教授 Gilbert Strang 对于微积分中的精华和重点出的一个生动、简短的课程，帮助我们重新审视微积分，课程主要涉及单变量微积分的总览。","text":"微积分重点（Highlights of Calculus）是 MIT 数学教授 Gilbert Strang 对于微积分中的精华和重点出的一个生动、简短的课程，帮助我们重新审视微积分，课程主要涉及单变量微积分的总览。 一、微积分总览微积分是函数（1）和函数（2）之间的桥梁，例如距离f\\left( t\\right)和速度\\dfrac{df}{dt}；高度y\\left( x\\right)和斜率\\dfrac{dy}{dx}。 匀速情况下，速度=\\dfrac{距离}{时间}，即斜率=\\dfrac{垂直}{水平}，即s=\\dfrac{f}{t}。若要求中间一段时间或距离的速度，s=\\dfrac{\\Delta f}{\\Delta t}。 匀变速情况下，函数图像均为曲线，微分学就是已知距离-时间函数求速度-时间函数，积分学就是已知速度-时间函数求距离-时间函数。 速度-时间函数s=at下面积\\dfrac{1}{2}t\\left( at\\right)就是距离-时间函数\\dfrac{1}{2}at^{2}，速度s=\\dfrac{df}{dt}就是f=\\int s\\left( t\\right) dt的导数。 二、导数总览已知距离f\\left( t\\right)如何求速度\\dfrac{df}{dt}，即已知高度y\\left( x\\right)如何求斜率 \\dfrac{dy}{dx}？ 三个重要函数的斜率： 幂函数y=x^{n}的斜率是\\dfrac{dy}{dx}=nx^{n-1}； 三角函数y=\\sin x的斜率是\\dfrac{dy}{dx}=\\cos x； 指数函数y=e^{x}的斜率是\\dfrac{dy}{dx}=e^{x}。 y=x^2斜率的平均斜率是$\\dfrac{\\left( \\Delta x\\right) ^{2}}{\\Delta x}$，即$\\dfrac{\\Delta y}{\\Delta x}$，瞬时斜率是$\\dfrac{dy}{dx}$；$\\dfrac{\\Delta y}{\\Delta x}=\\dfrac{\\left( x+\\Delta x\\right) ^{2}}{\\Delta x}\\dfrac{-x^{2}}{}=\\dfrac{2xax+\\left( \\Delta x\\right) ^{2}}{\\Delta x}=2x+\\Delta x$。 求导：$\\dfrac{dy}{dx}=\\lim\\dfrac{\\Delta y}{\\Delta x}=2x$。 任意 $x$ 处，$y=\\sin x 的斜率\\rightarrow \\dfrac{dy}{dx}=\\cos x$。 三、极值及二阶导数二阶导数：导数的导数。一阶导数用于确认极值点，二阶导数表明曲线弯曲方向。 二阶导数的例子：加速度 距离 $f\\left( t\\right)$ 、速度 $\\dfrac{df}{dt}$、加速度 $\\dfrac{d^{2}f}{dt^{2}}$。 高度 $y=x^2$ 、斜率 $\\dfrac{dy}{dx}=2x$、弯曲性 $\\dfrac{d^{2}f}{dt^{2}}=2$。 $sinx$ 的二阶导数为 $-sinx$。 凸函数和凹函数：$f’’ &gt;0$ 为凸，表示向上弯曲，相对的凹为 $f’’ &lt;0$。 拐点：二阶导数为 0 的点，表示弯曲方向改变。 对于函数 $y=x^{3}-x^{2}$ $\\rightarrow$ $y’=3x^{2}-2x$，$y’’=6x-2$： 求极值点：令 $y’=3x^{2}-2x=0$，$x= 0或x=\\dfrac{2}{3}$。 $x=0$ 处，二阶导数为负，取局部最大值（极大值）。 $x=\\dfrac{2}{3}$ 处，二阶导数为正，取局部最小值（极小值）。 应用：求上班的最短时间。设高速总长 $b$，家垂直上高速距离为 $a$，没走的高速距离为 $x$。 $时间t=\\dfrac{b-x}{60}+\\dfrac{\\sqrt{a^{2}+x^{2}}}{30}$，取时间方程的导数，然后令导数为 0 来求最小值。 $f’=-\\dfrac{1}{60}+\\dfrac{1}{30}\\cdot \\dfrac{1}{2}\\cdot \\dfrac{2x}{\\sqrt{a^{2}+x^{2}}}=0$ $\\rightarrow$ $x=\\dfrac{a}{\\sqrt{3}}$。 最值的一般求法：比较所有驻点（$f’=0$）处及边界点函数值，得到最大或最小值即函数最值。 $f’’$ 的符号可通过 $f’$ 的单调性求出：$x&gt;0$ 时，$f’(x)&gt;f’(0)$ ，斜率变化率为正，$f’’&gt;0$。 四、指数函数 $e^x$最简单的微分方程：$y=\\dfrac{dy}{dx}$。 指数函数：通过微积分构造的函数。 重要性质一：指数函数的导数就是其自身 函数初始点：$y=e^{0}=1$ $\\dfrac{x^{n}}{n!}$ 斜率的导数为 $\\dfrac{x^{n-1}}{\\left( n-1\\right) !}$ 指数级数：$e^{x}=1+x+\\dfrac{x^{2}}{2!}+\\dfrac{x^{3}}{3!}+\\ldots +\\dfrac{x^{n}}{n!}+\\ldots$ 重要性质二：$e^{x}\\cdot e^{X}=e^{x+X}$ $e$ 等于 $x=1$ 时指数级数的值：$e=1+1+\\dfrac{1}{2}+\\dfrac{1}{6}+\\ldots \\dfrac{1}{n!}+\\ldots\\approx 2.71828\\ldots$ 指数函数的图像： 由重要性质二可得：$e^{-x}=\\dfrac{1}{e^{x}}$ 应用：计算存款复利，假设利率为 100%，1 美元存一年得到 2 美元或更多，将一年分为 n 份付利息，得到 $\\left( 1+\\dfrac{1}{n}\\right) ^{n}$，$n\\rightarrow \\infty$ 时最终趋近于 $e$。 解常微分方程：$\\dfrac{dy}{dx}=cy$ $\\rightarrow$ $y\\left( x\\right) =e^{cx}$ 五、积分总览函数二 $\\dfrac{dy}{dx}=nx^{n-1}$ 是函数一 $y=x^{n}$ 的导数，函数一 $y=\\dfrac{x^{n+1}}{n+1}$ 是函数二 $\\dfrac{dy}{dx}=x^{n}$ 的积分。 求原函数：$y\\left( x\\right) =\\int s\\left( x\\right) dx$。 求积分方法A：反过来看什么函数的导数能得到要积分的函数。 例：通过代数方法求函数一： 相加求和：\\sum \\Delta y=y_{终}-y_{始}。 例：通过微积分方法求函数一：同时乘除 $\\Delta x$：\\sum \\left( \\dfrac{\\Delta y}{\\Delta x}\\right) \\Delta x=y_{终}-y_{始}。 在 $\\Delta x\\rightarrow 0$ 的极限情况下，求和转化为积分：$\\int \\dfrac{dy}{dx}dx$。 求积分方法B：$积分=函数一=函数二图像下的面积$：斜率为 $s=2-2x$，对应的高度 $y=2x-x^2$。","categories":[{"name":"慕课MOOC","slug":"慕课MOOC","permalink":"http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"}],"tags":[]},{"title":"基于 Python 和 OpenCV 实现人脸识别","slug":"Python-OpenCV人脸识别","date":"2021-08-02T16:00:00.000Z","updated":"2022-05-16T06:06:26.919Z","comments":true,"path":"Python-OpenCV人脸识别/","link":"","permalink":"http://blog.zhuangzhihao.top/Python-OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/","excerpt":"Open Source Computer Vision Library（OpenCV）是一个跨平台的计算机视觉库，可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV 用 C++ 语言编写，但本次实战项目使用的是 python-opencv 库实现的，主要是为了初步了解人脸识别的步骤和算法后面的原理。源代码保存在 Github 仓库 中。","text":"Open Source Computer Vision Library（OpenCV）是一个跨平台的计算机视觉库，可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV 用 C++ 语言编写，但本次实战项目使用的是 python-opencv 库实现的，主要是为了初步了解人脸识别的步骤和算法后面的原理。源代码保存在 Github 仓库 中。 项目背景人脸识别介绍对人类来说，人脸识别很容易：我们的大脑有专门的神经细胞针对不同的场景或运动特征作出反应，视觉皮层再以某种方式把不同的信息来源转化成可用的模型。 自动人脸识别就是研究如何从一幅图像中提取有意义的特征，形成可用的模型，然后对他们进行一些分类，因此基于几何特征的人脸的人脸识别可能是最直观的识别人脸的方法。但即使是使用最先进的算法，标记点的确定也是很复杂的，单靠几何特征不能提供足够的信息用于人脸识别。 特征脸方法：把面部图像看作是一个点，从高维图像空间找到它在低维空间的表示，使用主元分析（Principal Component Analysis，PCA）可以找拥有最大方差的轴，但轴的最大方差不一定包含任何有鉴别性的信息。 使用线性鉴别（Linear Discriminant Analysis，LDA）的特定类投影方法：使类内方差最小的同时，使类外方差最大。 仅仅使用的局部特征描述图像的方法避免输入的图像的高维数据：提取的特征对于局部遮挡、光照变化、小样本等情况更强健。如：盖伯小波：Gabor Waelets，离散傅立叶变换：Discrete Cosinus Transform（DCT），局部二值模式：Local Binary Patterns（LBP）。 OpenCV 介绍从 OpenCV 2.4 开始，加入了新的类 FaceRecognizer，可以使用它便捷地进行人脸识别实验。 FaceRecognizer 类目前包含三种人脸识别方法： 基于 PCA 变换的人脸识别：EigenFaceRecognizer。 基于 Fisher 变换的人脸识别：FisherFaceRecognizer。 基于局部二值模式的人脸识别：LBPHFaceRecognizer。 特征脸（Eigenfaces）：图像表示的问题是他的高维问题，如果数据有任何差异，可以通过寻找主元来知道主要信息，把一些可能相关的变量转换成一个更小的不相关的子集。 一个高维数据集经常被相关变量表示，因此只有一些的维上数据才是有意义的（包含最多的信息），PCA 方法寻找数据中拥有最大方差的方向（主成分）。计算特征值和对应的特征向量，对特征值进行递减排序，特征向量和它顺序一致。 k 个主成分也就是 k 个最大的特征值对应的特征向量。 把所有的训练数据投影到 PCA 子空间 -&gt; 把待识别图像投影到 PCA 子空间 -&gt; 找到训练数据投影后的向量和待识别图像投影后的向量最近的那个。 FisherFaces：基于线性判别分析（Linear Discriminant Analysis，LDA）理论，在降维的同时考虑类别信息，基于特征脸的方法，找到使数据中最大方差的特征线性组合。在低维表示下，相同的类应该紧紧的聚在一起，而不同的类别尽量距离越远。 局部二值模式直方图（Local Binary Patterns Histograms）：不把整个图像看成一个高维向量，仅用局部特征来描述一个物体，通过这种方式提取特征，获得一个低维隐式。对图像的像素和它局部周围像素进行对比后的结果进行求和，把这个像素作为中心，对相邻像素进行阈值比较。如果中心像素的亮度大于等于他的相邻像素，标记为 1，否则标记为 0（用二进制数字来表示每个像素）。 OpenCV 的基本使用读取图片12345678910#导入模块import cv2 as cv#读取图片img=cv.imread(&#x27;lena.jpg&#x27;) #加载图片路径中不能有中文#显示图片cv.imshow(&#x27;read_img&#x27;,img)#等待键盘输入 单位毫秒 传入0 则就是无限等待cv.waitKey(3000)#释放内存 由于OpenCV底层是C++编写的cv.destroyAllWindows() 图片灰度转换12345678910import cv2 as cvimg=cv.imread(&#x27;lena.jpg&#x27;)cv.imshow(&#x27;BGR_img&#x27;,img)#将图片灰度转换gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY)cv.imshow(&#x27;gray_img&#x27;,gray_img)#保存图片cv.imwrite(&#x27;gray_lena.jpg&#x27;,gray_img)cv.waitKey(0)cv.destroyAllWindows() 修改图片尺寸12345678910111213import cv2 as cvimg=cv.imread(&#x27;lena.jpg&#x27;)cv.imshow(&#x27;img&#x27;,img)print(&#x27;原来图片的形状&#x27;,img.shape)# 修改图片尺寸resize_img=cv.resize(img,dsize=(600,560))print(&#x27;修改后图片的形状：&#x27;,resize_img.shape)cv.imshow(&#x27;resize_img&#x27;,resize_img) #输入q时退出while True: if ord(&#x27;q&#x27;)==cv.waitKey(0): breakcv.destroyAllWindows() 画图123456789101112import cv2 as cvimg=cv.imread(&#x27;lena.jpg&#x27;)#绘制矩形，左上角坐标(x,y) 矩形的宽度和高度(w,h)x,y,w,h=100,100,100,100cv.rectangle(img,(x,y,x+w,y+h),color=(0,255,255),thickness=3) #BGR#绘制圆形，圆点的坐标center，半径radiusx,y,r=200,200,100cv.circle(img,center=(x,y),radius=r,color=(0,0,255),thickness=2)#显示图片cv.imshow(&#x27;rectangle_img&#x27;,img)cv.waitKey(0)cv.destroyAllWindows() 人脸检测Haarcascades提取出图像的细节对产生稳定分类结果和跟踪结果很有用，这些提取的结果被称为特征。 虽然任意像素都可以能影响多个特征，但特征应该比像素少得多，两个图像的相似程度可以通过它们对应特征的欧氏距离来度量。 Haar 特征是一种用于实现实时人脸跟踪的特征，每一个 Haar 特征都描述了相邻图像区域的对比模式，如边、顶点和细线都能生成具有判别性的特征。 官方 demo下载：https://sourceforge.net/projects/opencvlibrary/files/4.5.3/opencv-4.5.3-vc14_vc15.exe/download。 build 中是 OpenCV 使用时要用到的一些库文件。 sources 中是 OpenCV 官方提供的 demo 示例源码。 sources/data/haarcascades 文件夹包含了所有 OpenCV 的人脸检测的 XML 文件，可用于检测静止图像、视频和摄像头所得到图像中的人脸。 静态人脸检测123456789101112131415import cv2 as cvdef face_detect_demo(): #将图片转换为灰度图片 gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY) #加载特征数据 face_detector=cv.CascadeClassifier(&#x27;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#x27;) faces=face_detector.detectMultiScale(gray) for x,y,w,h in faces: cv.rectangle(img,(x,y),(x+w,y+h),color=(0,255,0),thickness=2) cv.imshow(&#x27;result&#x27;,img)#加载图片img=cv.imread(&#x27;lena.jpg&#x27;)face_detect_demo()cv.waitKey(0)cv.destroyAllWindows() 检测多张人脸1234567891011121314151617181920import cv2 as cvdef face_detect_demo(): #将图片灰度 gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY) #加载特征数据 face_detector = cv.CascadeClassifier( &#x27;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#x27;) faces = face_detector.detectMultiScale(gray) for x,y,w,h in faces: print(x,y,w,h) cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2) cv.circle(img,center=(x+w//2,y+h//2),radius=w//2,color=(0,255,0),thickness=2) #显示图片 cv.imshow(&#x27;result&#x27;,img)#加载图片img=cv.imread(&#x27;face3.jpg&#x27;)#调用人脸检测方法face_detect_demo()cv.waitKey(0)cv.destroyAllWindows() 检测视频中的人脸1234567891011121314151617181920212223import cv2 as cvdef face_detect_demo(img): #将图片灰度 gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY) #加载特征数据 face_detector = cv.CascadeClassifier(&#x27;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#x27;) faces = face_detector.detectMultiScale(gray) for x,y,w,h in faces: cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2) cv.circle(img,center=(x+w//2,y+h//2),radius=(w//2),color=(0,255,0),thickness=2) cv.imshow(&#x27;result&#x27;,img)#读取视频cap=cv.VideoCapture(&#x27;video.mp4&#x27;)while True: flag,frame=cap.read() print(&#x27;flag:&#x27;,flag,&#x27;frame.shape:&#x27;,frame.shape) if not flag: break face_detect_demo(frame) if ord(&#x27;q&#x27;) == cv.waitKey(10): breakcv.destroyAllWindows()cap.release() 人脸识别用一系列分好类的图像来训练程序，并基于这些图像来进行识别，每个识别都具有转置信（confidence）评分，因此可在实际应用中通过对其设置阈值来进行筛选。 训练数据train() 函数中有两个参数：图像数组和标签数组，这些标签表示进行识别时候某人人脸的ID 。 需要安装 opencv-contrib-python 模块。 1234567891011121314151617181920212223242526272829303132333435import osimport cv2 as cvimport sysfrom PIL import Imageimport numpy as npdef getImageAndLabels(path): facesSamples=[] ids=[] imagePaths=[os.path.join(path,f) for f in os.listdir(path)] #检测人脸 face_detector = cv.CascadeClassifier( &#x27;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#x27;) #遍历列表中的图片 for imagePath in imagePaths: #打开图片 PIL_img=Image.open(imagePath).convert(&#x27;L&#x27;) #将图像转换为数组 img_numpy=np.array(PIL_img,&#x27;uint8&#x27;) faces = face_detector.detectMultiScale(img_numpy) #获取每张图片的id id=int(os.path.split(imagePath)[1].split(&#x27;.&#x27;)[0]) for x,y,w,h in faces: facesSamples.append(img_numpy[y:y+h,x:x+w]) ids.append(id) return facesSamples,idsif __name__ == &#x27;__main__&#x27;: #图片路径 path=&#x27;./data/jm/&#x27; #获取图像数组和id标签数组 faces,ids = getImageAndLabels(path) #获取训练对象 recognizer = cv.face.LBPHFaceRecognizer_create() recognizer.train(faces,np.array(ids)) #保存文件 recognizer.write(&#x27;trainer/trainer.yml&#x27;) 基于 LBPH 的人脸识别LBPH（Local Binary Pattern Histogram）将检测到的人脸分为小单元，并将其与模型中的对应单元进行比较，对每个区域的匹配值产生一个直方图。由于这种方法的灵活性，LBPH 是唯一允许模型样本人脸和检测到的人脸在形状、大小上可以不同的人脸识别算法。 调整后的区域中调用 predict()函数，该函数返回两个元素的数组：第一个元素是所识别个体的标签，第二个是置信度评分。 所有的算法都有一个置信度评分阈值，置信度评分用来衡量所识别人脸与原模型的差距，0 表示完全匹配，可能有时不想保留所有的识别结果，则需要进一步处理，因此可用自己的算法来估算识别的置信度评分。 一个好的 LBPH 识别参考值要低于50，任何高于80的参考值都会被认为是低的置信度评分。 1234567891011121314151617181920212223import cv2 as cvimport numpy as npimport os# 加载训练数据集文件recognizer = cv.face.LBPHFaceRecognizer_create()recognizer.read(&#x27;trainer/trainer.yml&#x27;)# 准备识别的图片faceCascade = cv.CascadeClassifier( &#x27;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#x27;)font = cv.FONT_HERSHEY_SIMPLEXid = 0img = cv.imread(&#x27;19.pgm&#x27;)gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY)faces = faceCascade.detectMultiScale(gray_img)for x, y, w, h in faces: cv.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2) # 人脸识别 id, confidence = recognizer.predict(gray_img[y:y + h, x:x + w]) print(&#x27;标签id:&#x27;, id, &#x27;置信评分：&#x27;, confidence)cv.imshow(&#x27;result&#x27;, img)cv.waitKey(0)cv.destroyAllWindows() 摄像头人脸识别摄像头调试1234567891011#导入opencv模块import cv2#捕捉帧，笔记本摄像头设置为0即可capture = cv2.VideoCapture(0)#循环显示帧while(True): ret, frame = capture.read() #显示窗口第一个参数是窗口名，第二个参数是内容 cv2.imshow(&#x27;frame&#x27;, frame) if cv2.waitKey(1) == ord(&#x27;q&#x27;): #按q退出 break 摄像头人脸识别123456789101112131415161718192021import cv2import numpy as npface_cascade = cv2.CascadeClassifier( &quot;opencv\\sources\\data\\haarcascades\\haarcascade_frontalface_default.xml&quot;)eye_cascade = cv2.CascadeClassifier(&quot;opencv\\sources\\data\\haarcascades\\haarcascade_eye.xml&quot;)cap = cv2.VideoCapture(0)while True: ret, img = cap.read() gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_cascade.detectMultiScale(gray, 1.1, 5) if len(faces) &gt; 0: for faceRect in faces: x, y, w, h = faceRect cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2) roi_gray = gray[y:y + h // 2, x:x + w] roi_color = img[y:y + h // 2, x:x + w] eyes = eye_cascade.detectMultiScale(roi_gray, 1.1, 1, cv2.CASCADE_SCALE_IMAGE, (2, 2)) for (ex, ey, ew, eh) in eyes: cv2.rectangle(roi_color, (ex, ey), (ex + ew, ey + eh), (0, 255, 0), 2) cv2.imshow(&quot;img&quot;, img) if cv2.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;): break","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.zhuangzhihao.top/categories/Python/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://blog.zhuangzhihao.top/tags/OpenCV/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2021-07-04T16:00:00.000Z","updated":"2022-05-05T09:10:37.555Z","comments":true,"path":"冒泡排序/","link":"","permalink":"http://blog.zhuangzhihao.top/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"偶然刷到一篇名为《一半人写不出冒泡排序，你的同龄人都躺下了》的文章，其中提到轮子哥毕业去参加面试的时候，第一轮笔试考察冒泡排序，结果现场的一半学生都没写出来。冒泡排序（Bubble Sort），是一种最基础的、最简单直观的交换排序，之所以叫做冒泡排序，是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样。","text":"偶然刷到一篇名为《一半人写不出冒泡排序，你的同龄人都躺下了》的文章，其中提到轮子哥毕业去参加面试的时候，第一轮笔试考察冒泡排序，结果现场的一半学生都没写出来。冒泡排序（Bubble Sort），是一种最基础的、最简单直观的交换排序，之所以叫做冒泡排序，是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样。 一、冒泡排序的思想从头开始两两比较，把较大的元素与较小的元素进行交换，每轮把当前最大的一个元素存入到数组当前的末尾。每一趟比较只能确定将一个数归位，如果有 n 个数进行排序，要进行 n-1 趟操作。算法时间复杂度复杂度 O(n) 。 二、冒泡排序的实现步骤 定义一个外部循环控制冒泡的轮数（数组.length-1） 定义一个内部循环控制每轮依次往后比较几个位置（数组.length-i-1） 如果当前位置的元素值 &gt; 后一个位置的元素值，两者交换 三、Java 版代码实现1234567891011121314151617public class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;5, 2, 3, 1&#125;; for (int i = 1; i &lt;= arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 四、Python 版代码实现123456def bubbleSort(arr): for i in range(1, len(arr)): for j in range(0, len(arr) - i): if arr[j] &gt; arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://blog.zhuangzhihao.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"Java 实现双色球系统","slug":"双色球","date":"2021-06-30T16:00:00.000Z","updated":"2022-05-05T11:23:41.955Z","comments":true,"path":"双色球/","link":"","permalink":"http://blog.zhuangzhihao.top/%E5%8F%8C%E8%89%B2%E7%90%83/","excerpt":"双色球是最常见的一种彩票。双色球投注区分为红球号码区和蓝球号码区，红球号码范围为01～33，蓝球号码范围为01～16。双色球每期从33个红球中开出6个号码，从16个蓝球中开出1个号码作为中奖号码，双色球玩法即是竞猜开奖号码的6个红球号码和1个蓝球号码，顺序不限。","text":"双色球是最常见的一种彩票。双色球投注区分为红球号码区和蓝球号码区，红球号码范围为01～33，蓝球号码范围为01～16。双色球每期从33个红球中开出6个号码，从16个蓝球中开出1个号码作为中奖号码，双色球玩法即是竞猜开奖号码的6个红球号码和1个蓝球号码，顺序不限。 一、系统原理和设计随机一组中奖号码：中奖号码由6个红球和1个蓝球组成。定义随机方法用于返回一组中奖号码（7个数据），返回的形式是一个整型数组。 随机的6个中奖的红球号码不能重复：每次随机一个红球号码后去数组中判断是否存在，如果存在则需要重新随机一个数字直到不重复为止。 用户输入一组双色球号码：定义一个方法录入用户输入的6个红球和1个蓝球号码，该方法最终需要返回一个数组，数组中就是用户录入的号码（7位）。 中奖情况判断：定义一个方法接收中奖号码的数组，用户选号的数组，根据命中红球数和篮球数判断最终的中奖情况并输出详情和中奖金额。 统计红球的命中数量：遍历用户的每个选号，然后遍历中奖号码的数组，看当前选号是否在中奖号码中存在，存在则命中数量加1。 二、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class DoubleChromosphere &#123; public static void main(String[] args) &#123; // 随机6个红球号码（1-33，不能重复），随机一个蓝球号码（1-16），用数组装起来作为中奖号码 int[] luckNumbers = createLuckNumber(); // printArray(luckNumbers); // 录入用户选中的号码 int[] userNumbers = userInputNumbers(); // 判断中奖情况 judge(luckNumbers, userNumbers); &#125; public static void judge(int[] luckNumbers, int[] userNumbers )&#123; // 判断是否中奖 // 定义2个变量分别存储红球命中的个数，以及蓝球命中的个数 int redHitNumbers = 0; int blueHitNumbers = 0; // 判断红球命中了几个，开始统计 for (int i = 0; i &lt; userNumbers.length - 1; i++) &#123; for (int j = 0; j &lt; luckNumbers.length - 1; j++) &#123; // 每次找到了相等了，意味着当前号码命中了 if(userNumbers[i] == luckNumbers[j])&#123; redHitNumbers ++ ; break; &#125; &#125; &#125; // 蓝球号码是否命中 blueHitNumbers = luckNumbers[6] == userNumbers[6] ? 1 : 0; System.out.println(&quot;中奖号码是：&quot; ); printArray(luckNumbers); System.out.println(&quot;您投注号码是：&quot; ); printArray(userNumbers); System.out.println(&quot;您命中了几个红球：&quot; + redHitNumbers); System.out.println(&quot;您是否命中蓝球：&quot; + ( blueHitNumbers == 1 ? &quot;是&quot;: &quot;否&quot; ) ); // 判断中奖情况 if(blueHitNumbers == 1 &amp;&amp; redHitNumbers &lt; 3)&#123; System.out.println(&quot;恭喜您，中了5元小奖！&quot;); &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 3 || blueHitNumbers == 0 &amp;&amp; redHitNumbers == 4)&#123; System.out.println(&quot;恭喜您，中了10元小奖！&quot;); &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 4 || blueHitNumbers == 0 &amp;&amp; redHitNumbers == 5)&#123; System.out.println(&quot;恭喜您，中了200元！&quot;); &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 5)&#123; System.out.println(&quot;恭喜您，中了3000元大奖！&quot;); &#125;else if(blueHitNumbers == 0 &amp;&amp; redHitNumbers == 6)&#123; System.out.println(&quot;恭喜您，中了500万超级大奖！&quot;); &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 6)&#123; System.out.println(&quot;恭喜您，中了1000万巨奖！可以开始享受人生，诗和远方！！&quot;); &#125;else &#123; System.out.println(&quot;感谢您为福利事业做出的突出贡献！！&quot;); &#125; &#125; public static int[] userInputNumbers()&#123; // 动态初始化一个数组，长度为7 int[] numbers = new int[7]; Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; numbers.length - 1; i++) &#123; System.out.println(&quot;请您输入第&quot;+(i + 1)+&quot;个红球号码（1-33、不重复）：&quot;); int data = sc.nextInt(); numbers[i] = data; &#125; // 录入一个蓝球号码 System.out.println(&quot;请您输入一个蓝球号码（1-16）：&quot;); int data = sc.nextInt(); numbers[numbers.length - 1] = data; return numbers; &#125; public static void printArray(int[] arr)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println(); &#125; public static int[] createLuckNumber()&#123; // 定义一个动态初始化的数组，存储7个数字 int[] numbers = new int[7]; // 遍历数组，为每个位置生成对应的号码。(注意：遍历前6个位置，生成6个不重复的红球号码，范围是1-33) Random r = new Random(); for (int i = 0; i &lt; numbers.length - 1; i++) &#123; // 为当前位置找出一个不重复的1-33之间的数字 while (true) &#123; int data = r.nextInt(33) + 1; // 注意：必须判断当前随机的这个号码之前是否出现过，出现过要重新随机一个，直到不重复为止，才可以存入数组中去 // 定义一个flag变量，默认认为data是没有重复的 boolean flag = true; for (int j = 0; j &lt; i; j++) &#123; if(numbers[j] == data) &#123; // data当前这个数据之前出现过，不能用 flag = false; break; &#125; &#125; if(flag) &#123; // data这个数据之前没有出现过，可以使用了 numbers[i] = data; break; &#125; &#125; &#125; // 为第7个位置生成一个1-16的号码作为蓝球号码 numbers[numbers.length - 1] = r.nextInt(16) + 1; return numbers; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[]},{"title":"Java 基础编程总结","slug":"Java基础","date":"2021-06-19T16:00:00.000Z","updated":"2022-06-07T13:47:41.011Z","comments":true,"path":"Java基础/","link":"","permalink":"http://blog.zhuangzhihao.top/Java%E5%9F%BA%E7%A1%80/","excerpt":"Java 语言是 SUN (Stanford University Network) 公司于1995年推出的一门高级编程语言，舍弃了 C 语言中容易引起错误的指针（以引用取代）、运算符重载（operator overloading）、多重继承 （以接口取代）等特性，增加了垃圾回收器等功能，具有面向对象、健壮性、跨平台性等特性。我选择的 Java课程为尚学堂 Java 零基础入门教程，但由于我个人不是零基础入门，所以这篇笔记不含编程入门和语言概述，仅包含 Java 基础编程知识的总结。","text":"Java 语言是 SUN (Stanford University Network) 公司于1995年推出的一门高级编程语言，舍弃了 C 语言中容易引起错误的指针（以引用取代）、运算符重载（operator overloading）、多重继承 （以接口取代）等特性，增加了垃圾回收器等功能，具有面向对象、健壮性、跨平台性等特性。我选择的 Java课程为尚学堂 Java 零基础入门教程，但由于我个人不是零基础入门，所以这篇笔记不含编程入门和语言概述，仅包含 Java 基础编程知识的总结。 运行机制Java 虚拟机 JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器 对于不同的平台，有不同的虚拟机，只有某平台提供了对应的 Java 虚拟机，Java 程序才可在此平台运行 Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行” 垃圾回收 Java 语言消除了程序员回收无用内存空间的责任：提供一种系统级线程跟踪存储空间的分配情况，并在 JVM 空闲时，检查并释放那些可被释放的存储空间 垃圾回收在 Java 程序运行过程中自动进行，程序员无法精确控制和干预 JRE 与 JDK Java Development Kit 是提供给 Java 开发人员使用的 Java 开发工具包，其中包含了 Java 的开发工具，也包括了 JRE Java Runtime Environment 包括 Java 虚拟机（Java Virtual Machine）和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可 JDK = JRE + 开发工具集（例如 Javac 编译工具等），JRE = JVM + Java SE 标准类库 通过 javac 命令编译 Java 文件 通过编译器将 Java 源文件编译成 JVM 可以识别的字节码文件 1javac Test.java //此时有了可执行的 java 程序 通过 java 命令运行生成的 class 文件 1java Test //通过运行工具 java.exe 对字节码文件进行执行 一个源文件可以声明多个 class，但最多只能有一个 public 类，而且 public 类名必须与文件名相同 注释 被注释的文字不会被 JVM 解释执行，多行注释里面不允许有多行注释嵌套 12//单行注释/* 多行注释/* 文档注释 1234/** * @author java程序的作者** * @version 源文件的版本** */ 注释内容可以被 JDK 提供的 javadoc 所解析，生成该程序的说明文档 命名规范 标识符（Identifier）不可以数字开头，不能包含空格，严格区分大小写，长度无限制 包名：所有字母都小写 类名、接口名：所有单词的首字母大写 变量名、方法名：第一个单词首字母小写，第二个单词开始每个单词首字母大写 常量名：所有字母都大写，每个单词用下划线连接 变量 变量是程序中最基本的存储单元，包含变量类型、变量名和存储的值 先声明，后使用：&lt;数据类型&gt; &lt;变量名称&gt; 赋值：&lt;变量名称&gt; = &lt;值&gt;，&lt;数据类型&gt;&lt;变量名&gt;= &lt;初始化值&gt; 成员变量：在类体内，方法体外声明的变量 以 static 修饰的是类变量，不以 static 修饰的是实例变量 局部变量：在方法体内部声明的变量 方法、构造器中定义的变量成为实参 局部变量除形参外，都需显式初始化 基本数据类型 整型：byte \\ short \\ int \\ long（整型常量默认为 int 型，声明 long 型常量须后加 l 或 L） 浮点型：float \\ double（浮点型常量默认为双精度，声明 float 型常量须后加 f 或 F） 字符型：char（使用 Unicode 编码，‘\\uXXXX’） 布尔型：boolean（true 用1表示，false 用0表示） 引用数据类型 类：class 接口：interface 字符串：String（“aaaa”） 数组：array 数据类型转换 byte、short、char之间不会相互转换，在计算时首先转换为 int 类型 boolean 类型不能与其它数据类型运算，不可以转换为其它的数据类型 任何基本数据类型的值和 String 进行连接运算时，基本数据类型的值将自动转化为 String 类型 强制转换符：(byte)(a+b) 通过基本类型对应的包装类则可以实现把字符串转换成基本类型：String a = “43”; inti= Integer.parseInt(a); 运算符 算术运算符 赋值运算符 当 = 两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理 支持连续赋值 扩展赋值运算符：+=, -=, *=, /=, %= 比较运算符（关系运算符） 比较运算符的结果都是 boolean 型 逻辑运算符 &amp;：逻辑与，|：逻辑或，！：逻辑非 &amp;&amp; ：短路与，||：短路或，^ ：逻辑异或 单&amp;时，左边无论真假右边都进行运算；双&amp;时，如果左边为假，那么右边不参与运算 ||时：当左边为真，右边不参与运算 位运算符 位运算符操作的都是整型的数据变量 &lt;&lt; : 在一定范围内，每向左移一位，相当于 \\* 2 &gt;&gt; : 在一定范围内，每向右移一位，相当于 / 2 &gt;&gt;&gt;：无符号右移 &amp;：与运算，|：或运算，^ ：异或运算，~：取反运算 三元运算符 (条件)？a : b 条件表达式的结果为 boolean 类型 三元运算符是可以嵌套的 只有单目运算符、三元运算符、赋值运算符是从右向左运算的 流程控制分支结构 if-else 条件表达式 必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量 1234567891011if(条件表达式)&#123;执行表达式1&#125;else if&#123;执行表达式2&#125;else if(条件表达式)&#123;执行表达式3&#125;...else&#123;执行表达式n&#125; 输入语句 导包：import java.util.Scanner; Scanner 的实例化 调用 Scanner 类的相关方法来获取指定的变量 123456789import java.util.Scanner;class ScannerTest&#123; public static void main(String[] args)&#123; Scanner scan = new Scanner(System.in); //声明一个Scanner int num = scan.nextInt(); //获取变量 System.out.println(num); &#125;&#125; switch-case 结构 switch 结构中的表达式只能是如下的六种数据类型：byte、short、char、int、枚举类型 （JDK5.0）、String类型（JDK7.0） case 之后只能声明常量，不能声明范围 12345678910switch(表达式)&#123;case 常量1: 执行语句1; //break; //break关键字是可选的case 常量2: 执行语句2;...default: 执行语句n:&#125; 循环结构 for 循环 初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔 可以有多个变量更新，用逗号分隔 123for(初始化; 循环条件; 迭代)｛ 循环体;｝ while 循环 for 循环和 while 循环可以相互转换 12345初始化while(循环条件)｛ 循环体; 迭代;&#125; do-while 循环 至少执行一次循环体 12345初始化do&#123; 循环体; 迭代;&#125;while(循环条件); for、while、do…while 均可以作为外层循环或内层循环 break 用于终止某个语句块的执行，continue 用于跳过其所在循环语句块的一次执行，继续下一次循环 break 只能用于 switch 语句和循环语句中，continue 只能用于循环语句中 continue 出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 与 break 和 continue 不同的是，return 直接结束整个方法 数组 数组属于引用类型的变量，数组的元素既可以是基本数据类型，也可以是引用数据类型 创建数组对象会在内存中开辟一整块连续的空间，数组的长度一旦确定就不能修改 数组是有序排列的 123456789101112//静态初始化：数组的初始化和数组元素的赋值操作同时进行ids = new int[]&#123;1001,1002,1003,1004&#125;; //动态初始化：数组的初始化和数组元素的赋值操作分开进行String[] names = new String[5]; //通过角标的方式调用数组指定位置的元素names[0] = &quot;张学良&quot;; //如果数组超过角标会通过编译，运行失败//获取数组的长度Syst遍历数组em.out.println(names.length);//遍历数组for(int i = 0;i &lt; names.length;i++)&#123; System.out.println(names[i]); &#125; 二维数组 从数组底层的运行机制来看，其实没有多维数组，可以看作 array1 作为 array2 的元素而存在 12345678910111213141516//静态初始化int[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;//动态初始化String[][] arr2 = new String[3][];//调用数组的指定位置的元素System.out.println(arr1[0][1]);//获取数组的长度System.out.println(arr4.length);System.out.println(arr4[0].length);//遍历二维数组for(int i = 0;i &lt; arr4.length;i++)&#123; for(int j = 0;j &lt; arr4[i].length;j++)&#123; System.out.print(arr4[i][j] + &quot; &quot;); &#125; System.out.println();&#125; 类和对象类与对象的创建 属性：类中的成员变量，行为：类中的成员方法 Field = 属性 = 成员变量 = 域、字段，Method = 成员方法 = 函数 创建类 = 类的实例化 = 实例化类 如果创建类一个类的多个对象，则每个对象都独立的拥有一套非 static 的类的属性 所有的对象实例以及数组都要在堆（Heap）上分配：此内存区域的唯一目的就是存放对象实例 虚拟机栈（Stack）用于存储局部变量：局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，是对象在堆内存的首地址），方法执行完，自动释放 方法区（MethodArea）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 123456789//类的正文要用&#123; &#125;括起来修饰符 class 类名&#123; //修饰符为 public：类可以被任意访问 属性声明; 方法()声明;&#125; //调用属性对象.属性;//调用方法对象.方法(); 类中属性的使用 属性（成员变量）和局部变量 属性直接定义在类的一对 &#123;&#125; 内 。局部变量声明在方法内、方法形参、构造器形参、构造器内部 在声明属性时可以使用权限修饰符指明其权限（private、public、缺省、protected），局部变量不可以使用权限修饰符 类的属性都有默认初始化值，局部变量没有默认初始化值，在调用局部变量之前，一定要显式赋值（形参在调用时，赋值即可） 属性加载到堆空间中（非 static），局部变量加载到栈空间 类中方法的使用 Math类：sqrt()、random() Scanner类：nextXxx() Arrays类：sort()、binarySearch()、toString()、equals() 1234//方法的声明权限修饰符 返回值类型 方法名(形参列表)&#123; 方法体&#125; 如果方法有返回值，则必须在方法声明时指定返回值的类型，在方法中使用 return 关键字来返回指定类型的变量或常量 匿名对象的使用 创建对象时，没有显式的赋值给一个变量名，即为匿名对象 匿名对象只能调用一次，换行直接销毁匿名对象 方法重载（overload） 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可 判断是否重载与方法的返回值类型、权限修饰符、形参变量名、方法体都无关 1234//与 void show(int a,char b,double c)&#123;&#125; 构成重载int show(int a,double c,char b)&#123;&#125;void show(int a,double c,char b)&#123;&#125;//void show(int a,double c,char b)&#123;&#125; 不与上方构成重载，因为参数类型相同 可变个数的形参 JavaSE 5.0 中提供了 Varargs (variable number of arguments) 机制，允许直接定义能和多个实参相匹配的形参，从而可以用一种更简单的方式来传递个数可变的实参 可变个数形参的格式：数据类型 ... 变量名 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载（二者不可共存） 可变个数形参在方法中的形参中，必须声明在末尾 可变个数形参在方法中的形参中，最多只能声明一个可变形参 123456public void show(String... strs) &#123; for (int i = 0; i &lt; strs.length; i++) &#123; System.out.println(strs[i]); &#125;&#125;//public void show(String[] strs)&#123;&#125; 与上一方法不可共存 方法参数的值传递机制 如果变量是基本数据类型，此时实参赋值给形参的是实参真是存储的数据值 如果变量是引用数据类型，此时实参赋值给形参的是实参存储数据的地址值 12345678public class ArrayPrint &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3&#125;; //传进去的是一个Object的对象 System.out.println(arr); //地址值 char[] arr1 = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; //传进去的是一个数组，里面遍历数据了 System.out.println(arr1); //abc &#125;&#125; 递归（recursion）方法 一个方法体内调用它自身 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环 属性赋值的过程 默认初始化值 显式初始化 构造器中赋值 通过 对象.方法 或 对象.属性 的方式赋值 封装与隐藏 高内聚：类的内部数据操作细节自己完成，不允许外部干涉 低耦合：仅对外暴露少量的方法用于使用 将类的属性私有化（private），同时提供 public 方法来 get 和 set 123456789101112131415161718192021222324252627282930313233343536373839404142public class AnimalTest &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.name = &quot;大黄&quot;; a.show(); a.setLegs(-6); a.show(); System.out.println(a.name); System.out.println(a.getLegs()); &#125;&#125;//类的设置class Animal&#123; String name; private int age; private int legs;//对于属性的设置public void setLegs(int l)&#123; if(l &gt;= 0 &amp;&amp; l % 2 == 0)&#123; legs = l; &#125;else&#123; legs = 0; &#125;&#125;//对于属性的获取public int getLegs()&#123; return legs;&#125; public void eat()&#123; System.out.println(&quot;动物进食&quot;);&#125; public void show()&#123; System.out.println(&quot;name = &quot; + name + &quot;,age = &quot; + age + &quot;,legs = &quot; + legs);&#125; //提供关于属性 age 的 get 和 set 方法public int getAge()&#123; return age;&#125;public void setAge(int a)&#123; age = a; &#125;&#125; 权限修饰符 public、protected、default（缺省）、private 置于类的成员定义前，用来限定对象对该类成员的访问权限 对于 class 的权限修饰只可以用 public 和 default public 类可以在任意地方被访问，default 类只可以被同一个包内部的类访问 构造器（constructor） 构造器的作用：初始化类的对象（属性），并返回对象的地址 如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器 无参数构造器：初始化的对象时，成员变量的数据均采用默认值 有参数构造器：在初始化对象的时候，同时可以为对象进行赋值 一旦定义了有参数构造器，无参数构造器就没有了，此时就需要自己写无参数构造器了 一个类中至少会有一个构造器，一个类中若定义多个构造器，则彼此构成重载 12权限修饰符 类名(形参列表) &#123; &#125;//创建类的对象：new + 构造器 JavaBean 的使用 JavaBean 是一种 Java 语言写成的可重用组件 JavaBean 符合如下标准：类是公共的、有一个无参的公共的构造器 、有属性，且有对应的 get、set 方法 123456789101112131415161718public class Customer &#123; private int id; private String name; public Customer()&#123; &#125; public void setId(int i)&#123; id = i; &#125; public int getId()&#123; return id; &#125; public void setName(String n)&#123; name = n; &#125; public String getName()&#123; return name; &#125;&#125; UML 类图 + 表示 public 类型，- 表示 private 类型，# 表示 protected 类型 this 关键字 this 用来修饰和调用属性、方法、构造器 在类的方法中，可以使用 this.属性 或 this.方法 调用当前对象属性和方法（通常情况下选择省略），特殊情况下，如果方法的形参和类的属性同名必须显式使用 this.变量 ，表明此变量是属性而非形参 在类的构造器中，可以使用 this.属性 或 this.方法 调用当前对象属性和方法（通常情况下选择省略），特殊情况下，如果构造器的形参和类的属性同名必须显式使用 this.变量 ，表明此变量是属性而非形参 this 调用构造器 可以在类的构造器中，显式使用 this(形参列表) 调用本类中重载的其他的构造器 构造器中不能通过 this(形参列表) 的方式调用自己。 如果一个类中声明了 n 个构造器，则最多有 n -1 个构造器中使用了this(形参列表) this(形参列表) 必须声明在类的构造器的首行 在类的一个构造器中，最多只能声明一个 this(形参列表)&quot; package 关键字 为了更好的实现项目中类的管理，提供包的概念 使用 package 声明类或接口所属的包，声明在源文件的首行 每 “.” 一次就代表一层文件目录。 同一个包下，不能命名同名接口或同名类；不同包下，可以命名同名的接口、类 1234567java.lang //包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能java.net //包含执行与网络相关的操作的类和接口java.io //包含能提供多种输入/输出功能的类java.util //包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数java.text //包含了一些 java 格式化相关的类java.sql //包含了 java 进行 JDBC 数据库编程的相关类/接口java.awt //包含了构成抽象窗口工具集（abstractwindowtoolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。B/S C/S MVC 设计模式 MVC 是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，数据模型层 这种将程序输入输出、数据处理以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性 模型层 model 主要处理数据 数据对象封装 model bean/domain 数据库操作类 model.dao 数据库 model. db 控制层 controller 处理业务逻辑 应用界面相关 controller.activity 存放 fragment/controller.fragment 显示列表的适配器 controller.adapter 服务相关的 controller.service 抽取的基类 controller.base 视图层 vieW 显示数据 相关工具类 view.utils 自定义 vIew/view.ul import 关键字 在源文件中显式的使用 import 结构导入指定包下的类、接口，声明在包的声明和类的声明之间 如果导入的类或接口是 java.lang 包下的，或者是当前包下的，则可以省略此 import 语句 如果在代码中使用不同包下的同名的类，需要使用类的全类名的方式指明调用的是哪个类 已经导入 java.a 包下的类时，如果需要使用 a 包的子包下的类的话，仍然需要导 import static：调用指定类或接口下的静态的属性或方法 继承性 一旦子类 A 继承父类以后，子类 A 中就获取了父类 B 中声明的结构（属性、方法） 如果父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只有因为封装性的影响，使得子类不能直接调用父类的结构而已 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的拓展 子类和父类的关系不同于子集与集合的关系 123class A extends B&#123;&#125;//A：子类、派生类、subclass//B：父类、超类、基类、superclass Java 中关于继承性的规定 一个类可以被多个类继承 类的单继承性：一个类只能有一个父类 子父类是相对的概念。 子类直接继承的父类，称为直接父类。间接继承的父类，称为间接父类。 子类继承父类后，就获取了直接父类以及所有间接父类中声明的属性和方法 如果没有显式的声明一个类的父类的话，则此类继承于 java.lang.Object 类 所有的 java 类具有 java.lang.Object 类声明的功能（直接或间接继承） 方法的重写（override/overwrite） 重写：子类继承父类以后，可以对父类中的方法进行覆盖操作 重写以后，当创建子类对象以后，通过子类对象去调用子父类中同名同参数方法时，执行的是子类重写父类的方法（即在程序执行时，子类的方法将覆盖父类的方法） 123权限修饰符 返回值类型 方法名(形参列表)&#123; //方法体&#125; 类重写的方法的方法名和形参列表必须和父类被重写的方法的方法名、形参列表相同 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限 子类不能重写父类中声明为 private 权限的方法 子类方法抛出的异常不能大于父类被重写的方法抛出的异常 子类与父类中同名同参数的方法必须同时声明为非 static 的（即为重写），或者同时声明为 static 的（不是重写），因为 static 方法是属于类的，子类无法覆盖父类的方法 方法的重载与重写 方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现 重写 Overriding 是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现 如果在子类中定义某方法与其父类有相同的名称和参数，该方法被重写 Overriding 子类的对象使用这个方法时，将调用子类中的定义，对它而言父类中的定义被屏蔽了 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载 Overloading 返回值类型 父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型只能是 void 父类被重写的方法的返回值类型是 A 类型，则子类重写的方法的返回值类型可以是 A 类或 A 类的子类 父类被重写的方法的返回值类型如果是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型 super 关键字 super：父类的，可以用来调用属性、方法、构造器 可以在子类的方法或构造器中，通过 super.属性 或 super.方法 显式的调用父类中声明的属性或方法（通常情况下省略这个） 当子类和父类中定义了同名的属性时，要想在子类中调用父类中声明的属性，则必须显式的使用 super.属性 表明调用的是父类中声明的属性 当子类重写了父类中的方法后，想在子类的方法中调用父类中被重写的方法时，必须显式的使用 super.方法 表明调用的是父类中被重写的方法 super 调用构造器 可以在子类的构造器中显式的使用 super(形参列表) 调用父类中声明的指定的构造器 super(形参列表) 的使用必须声明在子类构造器的首行 在类的构造器中，针对于 this(形参列表) 或 super(形参列表) 只能二选一，不能同时出现 在构造器的首行，既没有显式的声明 this(形参列表) 或 super(形参列表) 则默认的调用的是父类中的空参构造器 super() 在类的多个构造器中，至少有一个类的构造器使用了 super(形参列表) 调用父类中的构造器 子类对象实例化过程 从结果上看 子类继承父类以后，就获取了父类中声明的属性或方法 创建子类的对象中，在堆空间中，就会加载所有父类中声明的属性 从过程上看 通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类构造器， 直到调用了 java.lang.Object 类中空参的构造器为止 正因为加载过所有的父类结构，所以才可以看到内存中有父类中的结构，子类对象可以考虑进行调用 虽然创建子类对象时调用了父类的构造器，但自始至终就创建过一个对象，即为 new 的子类对象 多态性 父类的引用指向子类的对象（或子类的对象赋值给父类的引用） 多态的使用：当调用子父类同名同参数方法时，实际调用的是子类重写父类的方法（虚拟方法调用） 有了对象多态性以后，在编译期，只能调用父类声明的方法，但在执行期实际执行的是子类重写父类的方法 编译时，看左边，看的是父类的引用（父类中不具备子类特有的方法） 运行时，看右边，看的是子类的对象（实际运行的是子类重写父类的方法） 多态性的使用前提：类的继承关系、方法的重写 对象的多态性只适用于方法，不适用于属性（编译和运行都看左边） 多态是运行时行为 虚拟方法 重载是指允许存在多个同名方法，而这些方法的参数不同，编译器根据方法不同的参数表，对同名方法的名称做修饰 对于编译器而言，这些同名方法就成了不同的方法，它们的调用地址在编译期就绑定了 Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为早绑定或静态绑定 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为晚绑定或动态绑定 不要犯傻，如果它不是晚绑定，它就不是多态。—— Bruce Eckel 向下转型 使用强制类型转换符调用子类所特有的属性和方法 可能出现 ClassCastException 异常 进行向下转型之前，先进行 instanceof 的判断，返回 true 就进行向下转型，返回 false 不进行向下转型 12345if (p2 instanceof Man) &#123; Man m2 = (Man) p2; m2.earnMoney(); System.out.println(&quot;Man&quot;);&#125; Object 类的使用 Object 类是所有 Java 类的根父类 如果在类的声明中未使用 extends 关键字指明其父类，则默认父类为 java.lang.Object 类 Object 类中的功能（属性、方法）具有通用性 方法：equals()、toString()、getClass()、hashCode()、clone()、finalize()、wait() 、notify()、notifyAll() Object类只声明了一个空参的构造器 final、finally、finalize的区别 被 final 修饰符（关键字）修饰的类，不能再派生出新的子类，不能作为父类而被子类继承 一个类不能既被 abstract 声明，又被 final 声明 将变量或方法声明为 final，可以保证他们在使用的过程中不被修改 被声明为 final 的变量必须在声明时给出变量的初始值，而在以后的引用中只能读取 被 final 声明的方法也同样只能使用，即不能被子类重写 final 修饰局部变量（尤其是使用 final 修饰形参）时，表明此形参是一个常量，当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值 static final 用来修饰全局常量 finally 是在异常处理时提供 finally 块来执行任何清除操作，不管有没有异常被抛出、捕获，finally块都会被执行 try 块中的内容是在无异常时执行到结束 catch 块中的内容是在 try 块内容发生 catch 所声明的异常时跳转到 catch 块中执行 finally 块则是无论异常是否发生都会执行 finally 块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在 finally 块中 Java技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作 这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的 它是在 object 类中定义的，因此所有的类都继承了它，子类覆盖 finalize() 方法以整理系统资源或者被执行其他清理工作 finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的 == 操作符与 equals 方法 == 运算符可以使用在基本数据类型变量和引用数据类型变量中 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等（类型不一定要相同） 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同（两个引用是否指向同一个对象实体） equals() 是一个方法，而非运算符，只能适用于引用数据类型 123public boolean equals(Object obj)&#123; return (this == obj);&#125; //Object 类中 equals() 的定义，和 == 的作用相同 重写 equals() 方法 对称性、自反性、传递性、一致性 123456789101112131415161718@Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Customer other = (Customer) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; //重写原则，比较两个对象的实体内容（name和age）是否相同 toString() 输出一个引用对象时，实际上就是调用当前对象的 toString() 自定义类如果重写 toString() 方法：当调用此方法时，返回对象的实体内容 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 包装类（Wrapper）JUnit 单元测试 选中当前项目工程 -&gt; 右键 build path-&gt; add libraries-&gt; JUnit 4 创建一个 Java 类进行单元测试。 此时的Java类要求：此类是公共的、此类提供一个公共的无参构造器、此类中声明单元测试方法 此时的单元测试方法：方法的权限是 public，没有返回值，没有形参 此单元测试方法上需要声明注解：@Test 并在单元测试类中调用：import org.junit.Test; 声明好单元测试方法以后，就可以在方法体内测试代码 写好代码后 -&gt; 双击单元测试方法名 -&gt; 右键 run as -&gt; JUnit Test 如果执行结果无错误，则显示是一个绿色进度条，反之，错误即为红色进度条 包装类的使用 Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征 byte -&gt; Byte，short -&gt; Short，int -&gt; Integer，long -&gt; Long，float -&gt; Float，double -&gt; Double，boolean -&gt; Boolean，char -&gt; Character 其中 Byte、Short、Integer、Long、Float、Double 的父类是 Number 包装类与基本数据类型相互转换 基本数据类型 -&gt; 包装类（装箱） 通过构造器：Integer t = new Integer(11); 通过字符串参数：Float f = new float(&quot;32.1F&quot;); 自动装箱 包装类 -&gt; 基本数据类型（拆箱） 调用包装类的方法：xxxValue() 自动拆箱 String 类 -&gt; 基本数据类型 调用相应的包装类的 parseXxx(String) 静态方法 通过包装类构造器: boolean b = new Boolean (&quot;true&quot;); 基本数据类型 -&gt; String 类 String 类的 valueof (3.4f) 方法 2.23.4+”” 包装类 -&gt; String 类 包装类对象的 toString() 方法 调用包装类的 toString(形参) 方法 String 类 -&gt; 包装类：装箱 Static 关键字static 的使用 使用 static 修饰属性：静态变量（类变量） 实例变量：创建类的多个对象，每个对象都独立的拥有了一套类中的非静态属性，当修改其中一个非静态属性时，不会导致其他对象中同样的属性值的修饰 静态变量：创建类的多个对象，多个对象共享同一个静态变量，当通过静态变量去修改某一个变量时，会导致其他对象调用此静态变量时，是修改过的 静态变量随着类的加载而加载，可以通过 类.静态变量 的方式进行调用 静态变量的加载要早于对象的创建，由于类只会加载一次，则静态变量在内存中也只会存在一次，存在方法区的静态域中 1System.out.Math.PI; static 修饰方法 使用 static 修饰方法：静态方法 静态方法中，只能调用静态的方法或属性，非静态的方法中，可以调用所有的方法或属性 在静态的方法内，不能使用 this 关键字、super 关键字 操作静态属性的方法，通常设置为 static ，工具类中的方法，习惯上声明为 static （Math、Arrays、Collections） 单例（Singleton）设计模式 取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例 饿汉式：对象加载时间过长，但线程安全的 懒汉式：延迟对象的创建 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决 Singleton 设计模式的应用场景 网站的计数器 应用程序的日志应用，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加 数据库连接池，因为数据库连接是一种数据库资源。 项目中读取配置文件的类，一般也只有一个对象，没有必要每次使用配置文件数据，都生成一个对象去读取 Application、Windows 的 Task Manager、Recycle Bin 代码块（初始化块） 用来初始化类、对象 代码块如果有修饰的话，只能使用 static 静态代码块：初始化类的信息 内部可以有输出语句 随着类的加载而执行，而且只执行一次 如果一个类中，定义了多个静态代码块，则按照声明的先后顺序执行 静态代码块的执行，优先于非静态代码块的执行 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 非静态代码块：可以在创建对象时，对对象的属性等进行初始化 内部可以有输出语句 随着对象的创建而执行 每创建一个对象，就执行一次非静态代码块 如果一个类中，定义了多个非静态代码块，则按照声明的先后顺序执行 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法 对属性可以赋值的位置 默认初始化、显式初始化、构造器中初始化 有了对象以后，可以通过 对象.属性 或 对象.方法 的方式进行赋值 在代码块中赋值 抽象类与抽象方法 Java 允许类设计者指定超类声明一个方法但不提供实现，该方法的实现由子类提供 这样的方法称为抽象方法，有一个或更多抽象方法的类称为抽象类 abstract 关键字的使用 abstract 修饰抽象类 此类不能实例化 抽象类中一定有构造器，便于子类实例化时调用 开发中都会提供抽象类的子类，让子类对象实例化，实现相关的操作 abstract 修饰抽象方法 抽象方法：只有方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类，但抽象类中可以没有抽象方法 abstract 不能用来修饰变量、代码块、构造器 abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类 模板方法设计模式（TemplateMethod） 抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式 模板模式：在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了，但是某些部分易变，易变部分可以抽象出来，供不同子类实现 常见的模板方法设计模式 数据库访问的封装 Junit 单元测试 JavaWeb 的 Servlet 中关于 doGet/doPost 方法调用 Hibernate 中模板程序 Spring 中 JDBCTemlate、HibernateTemplate 等 接口（interface） 接口是抽象方法和常量值定义的集合，用 interface 来定义 接口中的所有成员变量都默认是由 public static final 修饰的，接口中的所有抽象方法都默认是由 public abstract 修饰的 接口中没有构造器，意味着接口不可以实例化 JDK8 后除了全局常量和抽象方法之外，还可以定义静态方法、默认方法 接口和类是并列的两个结构 接口通过让类去实现 implements 使用，如果实现类覆盖了接口中的所有方法，则此实现类就可以实例化，如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类 Java 类可以实现多个接口 ，弥补了 Java 单继承性的局限性，接口与接口之间是继承,而且可以多继承 接口的具体使用，体现多态性 ，主要用途就是被实现类实现，实际可以看作是一种规范 代理模式（Proxy） 代理设计就是为其他对象提供一种代理以控制对这个对象的访问 分类 静态代理（静态定义代理类） 动态代理（动态生成代理类）：JDK 自带的动态代理 应用场景 安全代理：屏蔽对真实角色的直接访问。 远程代理：通过代理类处理远程方法调用（RMI） 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 接口和抽象类之间的对比 区别点 抽象类 接口 定义 包含抽象方法的类 主要是抽象方法和全局常量的集合 组成 构造方法、抽象方法、普通方法、常量、变量 常量、抽象方法、默认方法、静态方法 使用 子类继承抽象类（extends） 子类实现接口（implements） 关系 抽象类可以实现多个接口 接口不能继承抽象类，但允许继承多个接口 常见设计模式 模板方法 简单工厂、工厂方法、代理模式 对象 都通过对象的多态性产生实例化对象 局限 抽象类有单继承的局限 接口没有此局限 实际 作为一个模板 是作为一个标准或是表示一种能力 选择 如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限 Java 8 中关于接口的改进 静态方法 使用 static 关键字修饰，可以通过接口直接调用静态方法，并执行其方法体 经常在相互一起使用的类中使用静态方法，可以在标准库中找到像 Collection/Collections 或者 Path/Paths 这样成对的接口和类 默认方法 默认方法使用 default 关键字修饰，可以通过实现类对象来调用 在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性，如：java 8 API 中对 Collection、List、Comparator 等接口提供了丰富的默认方法 内部类 Java 中允许将一个类 A 声明在另一个类 B 中，则类 A 就是内部类，类 B 就是外部类 成员内部类 作为外部类的成员，调用外部类的结构，可以被static修饰，可以被4种不同的权限修饰 作为一个类，类内可以定义属性、方法、构造器等，可以被 final 修饰，表示此类不能被继承。言外之意，不使用 final，就可以被继承，可以 abstract 修饰 匿名内部类 匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例 一个匿名内部类一定是在 new 的后面，用其隐含实现一个接口或实现一个类 匿名内部类必须继承父类或实现接口 ，=只能有一个对象，匿名内部类对象只能使用多态形式引用 123new 父类构造器（实参列表）|实现接口()&#123; //匿名内部类的类体部分&#125; 局部内部类 方法内、代码块内、构造器内 局部内部类的方法中（如：show）如果调用局部内部类所声明的方法（如：method）中的局部变量（如：num）的话，要求此局部变量声明为 final 的 jdk 8及之后的版本可以省略 final 的声明 异常 将程序执行中发生的不正常情况称为异常，开发过程中的语法错误和逻辑错误不是异常 Error：Java 虚拟机无法解决的严重问题，如：JVM系统内部错误、资源耗尽等严重情况 StackOverflowError 和 OutOfMemoryError：一般不编写针对性的代码进行处理 Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理 空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界 解决方法：遇到错误就终止程序的运行，或在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理 捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生，如：除数为0，数组下标越界等 异常分类 运行时异常 编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常 java.lang.RuntimeException 类及它的子类都是运行时异常 对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响 编译时异常 编译器要求必须处置的异常，即程序在运行时由于外界因素造成的一般性异常 编译器要求 Java 程序必须捕获或声明所有编译时异常 对于这类异常，如果程序不处理，可能会带来意想不到的后果 try-catch-finally try 用 try{…} 语句块选定捕获异常的范围，将可能出现异常的代码放在 try 语句块中 catch(Exceptiontypee) 在 catch 语句块中是对异常对象进行处理的代码，每个 try 语句块可以伴随一个或多个 catch 语句，用于处理可能产生的不同类型的异常对象 捕获异常的有关信息与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法 getMessage() 获取异常信息，返回字符串 printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置，返回值 void finally 通过 finally 语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理 不论在 try 代码块中是否发生了异常事件、catch 语句是否执行、catch语 句是否有异常、catch 语句中是否有 return，finally 块中的语句都会被执行 像数据库连接、输入输出流、网络编程 Socket 等资源，JVM 是不能自动的回收的，我们需要自己手动的进行资源的释放，此时的资源释放，就需要声明在 finally 中 finally 语句和 catch 语句是任选的 1234567891011try&#123; //可能出现异常的代码&#125;catch(异常类型1 变量名1)&#123; //处理异常的方式1&#125;catch(异常类型2 变量名2)&#123; //处理异常的方式2&#125;...finally&#123; //一定会执行的代码&#125; throws 声明抛出异常是 Java 中处理异常的第二种方式 如果一个方法中的语句执行时可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理 在方法声明中用 throws 语句可以声明抛出异常的列表，throws 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类 throws + 异常类型 写在方法的声明处，指明此方法执行时，可能会抛出的异常类型 用户自定义异常类 一般用户自定义异常类都是 RuntimeException 的子类 自定义异常类通常需要编写几个重载的构造器，需要提供 serialVersionUID 自定义的异常通过throw抛出 如何自定义异常类 继承于现有的异常结构：RuntimeException 、Exception 提供全局常量：serialVersionUID 提供重载的构造器 课程代码 课程代码已上传 Github 仓库","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[]},{"title":"Data Science Methodology","slug":"Data-Science-Methodology","date":"2021-05-29T16:00:00.000Z","updated":"2022-05-05T12:55:36.311Z","comments":true,"path":"Data-Science-Methodology/","link":"","permalink":"http://blog.zhuangzhihao.top/Data-Science-Methodology/","excerpt":"Despite the recent increase in computing power and access to data over the last couple of decades, our ability to use the data within the decision making process is either lost or not maximized at all too often, we don’t have a solid understanding of the questions being asked and how to apply the data correctly to the problem at hand. This course provided by IBM shares a methodology that can be used within data science, to ensure that the data used in problem solving is relevant and properly manipulated to address the question at hand. The following are the notes I took during this course.","text":"Despite the recent increase in computing power and access to data over the last couple of decades, our ability to use the data within the decision making process is either lost or not maximized at all too often, we don’t have a solid understanding of the questions being asked and how to apply the data correctly to the problem at hand. This course provided by IBM shares a methodology that can be used within data science, to ensure that the data used in problem solving is relevant and properly manipulated to address the question at hand. The following are the notes I took during this course. Data Science Methodologies Methodology: a system of methods used in a particular area of study. CRISP-DM: the Cross Industry Process for Data Mining methodology. The CRISP-DM methodology is a process aimed at increasing the use of data mining over a wide variety of business applications and industries. The intent is to take case specific scenarios and general behaviors to make them domain neutral. CRISP-DM is comprised of six steps with an entity that has to implement in order to have a reasonable chance of success. Business Understanding、Data Understanding、Data Preparation、Modeling、Evaluation、Deployment CRISP-DM is a highly flexible and cyclical model. Flexibility is required at each step along with communication to keep the project on track. At any of the six stages, it may be necessary to revisit an earlier stage and make changes. The key point of this process is that it’s cyclical. From Problem to Approach Business Understanding Establishing a clearly defined question starts with understanding the goal of the person asking the question Seek clarification (where is the goal) -&gt; Support the goal -&gt; Get stakeholder “buy-in” and support Case Study: Apply concepts, Define Goals and objectives, Pilot project kickoff, Identify the business requirements Analytic Approach Once a strong understanding of the question is established, the analytic approach can be selected. This means identifying what type of patterns will be needed to address the question most effectively The correct approach depends on business requirements for the model If the question is to determine probabilities of an action, Use a predictive model If the question is to show relationships, Use a descriptive model if the question requires a yes/no answer, Use a classification model It is only when the problem to be addressed is defined, that the appropriate analytic approach for the problem can be selected in the context of the business requirements Case Study: Decision tree classification (Predictive model) From Requirements to Collection Data Requirements The Data Requirements stage of the data science methodology involves identifying the necessary data content, formats and sources for initial data collection. Prior to undertaking the data collection and data preparation stages of the methodology, it’s vital to define the data requirements for decision-tree classification. This includes identifying the necessary data content, formats and sources for initial data collection Case Study: Select the cohort, Define the data Data Collection Once the data ingredients are collected, then in the data collection stage, the data scientist will have a good understanding of what they will be working with Techniques such as descriptive statistics and visualization can be applied to the data set, to assess the content, quality, and initial insights about the data. Gaps in data will be identified and plans to either fill or make substitutions will have to be made When collecting data, it is alright to defer decisions about unavailable data, and attempt to acquire it at a later stage Case Study: Gather available data, Merge data From Understanding to Preparation Data Understanding Descriptive statistics: Univariate statistics, Pairwise correlations, Histogram Data quality: Missing value, Invalid or misleading values Iterative data collection and understanding: Refined definition of “CHF admission” Data understanding is iterative; you learn more about your data the more you study it Sorting data is not part of the Data Understanding stage Data Preparation Cleansing data Transforming data Feature engineering is the process of using domain knowledge of the data to create features that make the machine learning algorithms work Feature engineering is critical when machine learning tools are being applied to analyze the data The Data Preparation stage is in fact the most time-consuming phase of a data science project Using training sets From Modeling to Evaluation Modeling Descriptive Analytics Predictive Analytics A training set is used to build a predictive model Understand the question at hand -&gt; Select an analytic approach or method to solve the problem -&gt; Obtain, understand, prepare and model the data Evaluation Diagnostic measures: Predictive model, Descriptive model, Statistical significance Diagnostic tool for classification model evaluation Classification model performance True-Positive Rate vs False-Positive Rate Optimal model at maximum separation Model evaluation can have two main phases: a diagnostic measures phase and statistical significance testing The purpose of statistical significance tests: Modeling and evaluation are iterative processes From Deployment to Feedback Deployment Understand the results Gather application requirements After the model is evaluated and the data scientist is confident it will work, it is deployed and put to the ultimate test The refined model must be redeployed This process should be repeated as often as necessary Feedback Assessing model performance Refine model: Review and refine intervention actions Redeployment: Continue modeling, deployment, feedback and refinement throughout the life of the Intervention program The data science methodology is highly iterative, ensuring the refinement at each stage in the game","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[]},{"title":"IntelliJ IDEA 的配置与使用总结","slug":"IDEA配置","date":"2021-05-19T16:00:00.000Z","updated":"2022-05-05T12:58:50.613Z","comments":true,"path":"IDEA配置/","link":"","permalink":"http://blog.zhuangzhihao.top/IDEA%E9%85%8D%E7%BD%AE/","excerpt":"IntelliJ IDEA 被公认为是最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、创新的GUI 设计等方面的功能可以说是超常的。相较于 Eclipse 而言，IDEA 增加了强大的整合能力、好用的快捷键和代码模板以及精准搜索，一些新的特性非常有必要学习熟悉。我目前使用的是 IDEA Ultimate 2021.2 版本，本篇笔记也是对最新版 IDEA 项目的创建、模板的使用、断点调试、数据库的关联、插件的下载、Maven及版本控制工具的配置等内容的一些总结。","text":"IntelliJ IDEA 被公认为是最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、创新的GUI 设计等方面的功能可以说是超常的。相较于 Eclipse 而言，IDEA 增加了强大的整合能力、好用的快捷键和代码模板以及精准搜索，一些新的特性非常有必要学习熟悉。我目前使用的是 IDEA Ultimate 2021.2 版本，本篇笔记也是对最新版 IDEA 项目的创建、模板的使用、断点调试、数据库的关联、插件的下载、Maven及版本控制工具的配置等内容的一些总结。 安装目录 bin：容器，执行文件和启动参数等 idea.exe.vmoptions：VM 配置文件 idea.properties：IDEA 属性配置文件 help：快捷键文档和其他帮助文档 jre64：64 位 java 运行环境 lib：IDEA 依赖的类库 license：各个插件许可 plugin：插件 设置目录config 目录 IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等个性化配置 system 目录 缓存、索引、容器文件输出等 Project IntelliJ IDEA 没有类似 Eclipse 的工作空间的概念（ Workspaces），最大单元就是 Project Eclipse 中 Workspace 相当于 IDEA 中的 Project Project 下的 src 类似于 Eclipse 下的 src 目录，用于存放代码 Project 下的 .idea 和 projectname.iml 文件都是 IDEA 工程特有的，类似于 Eclipse 工程下的 .settings、.classpath、.project 等 Module Eclipse 中 Project 相当于 IDEA 中的 Module 在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module 一个 Project 可以有多个 Module。目前主流的大型项目都是分布式部署的， 结构都是类似这种多 Module 结构 常用配置 Editor -&gt; General Change font size with Ctrl + Mouse Wheel Editor -&gt; General -&gt; Auto Import Add unambiguous imports on the fly Optimize imports on the fly Editor -&gt; General -&gt; Appearance Show line numbers Show method separators Editor -&gt; General -&gt; Code Completion 取消 Match Case Editor -&gt; General -&gt; Editor Tabs 取消 Show tabs in one row Editor -&gt; File and Code Templates -&gt; Includes 1234/** @author Bezhuang@create $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;TIME&#125; */ Editor -&gt; File Encodings Global / Project / Default encoding: UTF-8 Transparent native-to-ascii conversion Build, Execution, Deployment -&gt; Compiler Build project automatically（如果电脑带不动取消） Compile independent modules in parallel Keymap 快捷键 实现效果 Ctrl + X 删除当前行 Ctrl +D 复制当前行 Alt+Insert（右键Generate） get、set方法，构造函数等 Ctrl+Alt+T try catch（Alt+enter选择） CTRL+ALT+T 把选中的代码放在 TRY&#123;&#125; IF&#123;&#125; ELSE&#123;&#125; 里 Ctr+shift+U 大小写之间转化 ALT+回车 导入包，自动修正 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+E 最近更改的代码 Alt + 左右键 多窗口 Ctrl + 鼠标点击 快速找到成员变量的出处 Shift+F6 重构/重命名 (包、类、方法、变量、甚至注释等) CTRL+Q 查看当前方法的声明 Ctrl+Alt+V new 对象();（自动创建变量） Ctrl+O 重写方法 Ctrl+I 实现方法 ALT+/ 代码提示 Ctrl+Shift+R 在当前项目中替换指定内容 Ctrl+E 最近编辑的文件列表 Ctrl+P 显示方法参数信息 Ctrl+Shift+Insert 查看历史复制记录 Templates Live Templates 可以自定义，而 Postfix Completion 不可以 psvm -&gt; public static void main(String[] args) sout -&gt; System.out.println() soutp -&gt; System.out.println(&quot;方法形参名 = &quot; + 形参名); soutv -&gt; System.out.println(&quot;变量名 = &quot; + 变量); soutm -&gt; System.out.println(&quot;当前类名.当前方法&quot;); “abc”.sout -&gt; System.out.println(&quot;abc&quot;); fori -&gt; for 循环 iter -&gt; 增强 for 循环 itar -&gt; 普通 for 循环 list -&gt; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.for -&gt; for(String s:list)&#123;&#125; list.fori -&gt; 正序遍历 list.forr -&gt; 倒序遍历 ifn -&gt; if(xxx = null) inn -&gt; if(xxx != null) xxx.nn xxx.null prsf -&gt; private static final psf -&gt; public static final psfi -&gt; public static final int psfs -&gt; public static final String 创建 Java Web Module 右键 -&gt; add Framework Support 配置本地 Tomcat 环境变量 系统环境变量中新建 CATALINA_HOME 环境变量 修改 Path ： %CATALINA_HOME%\\lib、%CATALINA_HOME%\\bin、%CATALINA_HOME%\\lib\\servlet-api.jar Tomcat 文件夹下打开 Terminal：catalina run 启动 Tomcat 关联数据库 IDEA 的 Database 对于常使用的 ORM 框架，如 Hibernate、 Mybatis有很好的支持，比如配置好了 Database 之后，IDEA 会自动识别 domain 对象与数据表的关系，也可以通过 Database 的数据表直接生成 domain 对象等 版本控制 IntelliJ IDEA 对版本控制的支持是以插件化的方式来实现的 IntelliJ IDEA 自带了 Github 插件，方便 Checkout 和管理 Github 项目 File -&gt; Setting -&gt; VCS (version control system) VCS -&gt; Get from Version Control 断点调试Debug 的设置 File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Debugger Java -&gt; Transport: Shared memory 断点调试快捷键 step over：进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 step into：进入下一步，如果当前行断点是一个方法，则进入当前方法体内 force step into：进入下一步，如果当前行断点是一个方法，则进入当前方法体内 step out：跳出 resume program：恢复程序运行，但如果该断点下面代码还有断点则停在下一个断点上 stop：停止 mute breakpoints：点中，使得所有的断点失效 view breakpoints：查看所有断点 条件断点 调试的时候，在循环里增加条件判断，可以极大的提高效率 在断点处右击调出条件断点，可以在满足某个条件下，实施断点 选择行后 CTRL + u，可以在查看框中输入编写代码时的其他方法 配置 Maven 自动化构建工具：Make -&gt; Ant -&gt; Maven -&gt; Gradle Maven 使用了一个标准的目录结构和一个默认的构建生命周期，用于自动化构建和依赖管理 构建环节 清理：表示在编译代码前将之前生成的内容删除 编译：将源代码编译为字节码 测试：运行单元测试用例程序 报告：测试程序的结果 打包：将 java 项目打成 jar 包，或将 Web 项目打成 war 包 安装：将 jar 或 war 生成到 Maven 仓库中 部署：将 jar 或 war 从 Maven 仓库中部署到 Web 服务器上运行 File -&gt; Settings -&gt; Maven：选择自己Maven 的目录和 settings 文件，然后配置自己的本地仓库 repository Maven 目录下有对应的生命周期，其中常用的是：clean、compile、package、install 其他设置 生成 javadoc Tools -&gt; Generate JavaDoc Locale（输入语言类型）：zh_CN Other command line arguments: -encoding UTF-8 -charset UTF-8 缓存和索引的清理 IntelliJ IDEA 首次加载项目的时候，都会创建索引，而创建索引的时间跟项目的文件多少成正比 IntelliJ IDEA 的缓存和索引主要是用来加快文件查询，从而加快各种查找、代码提示等操作的速度 某些特殊条件下，IntelliJ IDEA 的缓存和索引文件也是会损坏的，可以清理缓存和索引 File -&gt; Invalidate Caches / Restart 插件 File -&gt; Settings -&gt; Plugins https://plugins.jetbrains.com/","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://blog.zhuangzhihao.top/tags/IDEA/"}]},{"title":"Tools for Data Science","slug":"Tools-for-Data-Science","date":"2021-05-14T16:00:00.000Z","updated":"2022-05-05T13:06:40.629Z","comments":true,"path":"Tools-for-Data-Science/","link":"","permalink":"http://blog.zhuangzhihao.top/Tools-for-Data-Science/","excerpt":"In this course provided by IBM, I learned about Jupyter Notebooks, JupyterLab, RStudio IDE, Git, GitHub, and Watson Studio, what each tool is used for, what programming languages they can execute, their features and limitations. With the tools hosted in the cloud on Skills Network Labs, I can now run simple code in Python, R or Scala. The following are the notes I took during this course.","text":"In this course provided by IBM, I learned about Jupyter Notebooks, JupyterLab, RStudio IDE, Git, GitHub, and Watson Studio, what each tool is used for, what programming languages they can execute, their features and limitations. With the tools hosted in the cloud on Skills Network Labs, I can now run simple code in Python, R or Scala. The following are the notes I took during this course. Languages of Data Science Python General Purpose language with Large standard library Scientific computing libraries like Pandas, NumPy, SciPy and Matplotlib For artificial intelligence it has PyTorch, TensorFlow, Keras and Scikit-learn Python can be used for Natural Language Processing (NLP) using the Natural Language Toolkit (NLTK) R Language Python is Open Source, R is Free Software Open Source Initiative (OSI) champions open source while the Free Software Foundation (FSF) defines free software Open Source is more business focused while Free Software is more focused on a set of values R is most often used by statisticians, mathematicians and data miners for developing statistical software, graphing and data analysis The array-oriented syntax makes it easier to translate from math to code R has become the world’s largest repository of statistical knowledge Common mathematical operations like matrix multiplication work straight out of the box R has stronger object-oriented programming facilities than most statistical computing languages SQL (Structured Query Language) SQL = SQL was initially developed at IBM, first appeared in 1974 Useful in handling structured data, i.e. data incorporating relations among entities and variables The SQL language is subdivided into several language elements, including clauses, expressions, predicates, queries, and statements Knowing SQL will help you do many different jobs in data science, including business and data analyst, and it’s a must in data engineering. When performing operations with SQL, you access the data directly ( without any need to copy it beforehand). This can speed up workflow executions considerably. SQL is the interpreter between you and the database SQL is an American National Standards Institute, or “ANSI,” standard, which means if you learn SQL and use it with one database, you will be able to easily apply that SQL knowledge to many other databases. MySQL, IBM Db2, PostgreSQL, Apache OpenOffice Base, SQLite, Oracle, MariaDB, Microsoft SQL Server Java Java is a tried and true general purpose object oriented programming language Huge adoption in the enterprise space, designed to be fast and scalable Java applications are compiled to bytecode and run on JVM Tools include Weka (data mining), Java-ML (ml library), Apache MLlib (scalable ml) and Deeplearning4j Hadoop manages data processing and storage for big data applications running in clustered systems Scala Scala is a general purpose programming language that provides support for functional programming Designed as an extension to Java, it is inter-operable with Java as it also runs on JVM The name Scala comes from “Scalable Language” Apache Spark is a fast and general-purpose cluster computing system. It provides APIs that make parallel jobs easy to write, and an optimized engine that supports general computation graphs. Spark includes Shark, which is a query engine; MLlib, for machine learning; GraphX, for graph processing; and Spark Streaming. Apache Spark was designed to be faster than Hadoop C++ Another general purpose language, C++ is an extension of C Improve processing speed, enables system programming and gives you broader control over the application Many organizations rely on C++ to develop programs that feed data to customers in real-time TensorFlow is a deep learning library MongoDB is a NoSQL database for big data management Caffe is a deep learning algorithm repository Javascript A core technology for the WWW, A general purpose language that extended beyond the browser with Node.js and other server side approaches TensorFlow.js makes machine learning and deep learning possible in Node.js and in the browser, It is adopted by other open source libraries including brain.js and machinelearn.js R-js makes linear algebra possible in Typescript Julia Designed at MIT for high-performance numerical analysis and computational science Same speedy development like Python or R while producing programs that run as fast as C or Fortran programs would It’s compiled, calls C, Go, Java, MATLAB, R, Fortran and Python libraries and has refined parallelism A young language with a lot of promise in the data science industry JuliaDB is a particularly useful application of Julia for data science. It’s a package for working with large persistent data sets. Data Science Tools Data Management tools: persisting and retrieving data Open Source: MySQL, PostgreSQL, MongoDB, Apache CouchDB, Apache Cassandra, Hadoop File System, Ceph(Cloud File systems), Elasticsearch Commercial: Oracle Database, Microsoft SQL Server, IBM Db2 SaaS(cloud based): Amazon DynamoDB, Cloudant(based on CouchDB), Db2 Data Integration and Transformation tools: ETL(extract, transform, load) Open Source: Apache AirFlow, KubeFlow, Apache Kafka, Apache Nifi, Apache SparkSQL, NodeRED Commercial: Informatica, IBM InfoSphere DataStage, Talend Cloud Based(ELT): Informatica, IBM Data Refinery Data Visualization tools Open Source: Hue, Kibana, Apache Superset Commercial: Tableau, Microsoft Power BI, IBM Cognos Analytics Cloud Based: Datameer, IBM Cognos Analytics Model Building: creating a machine learning or deep learning model using an appropriate algorithm Commercial: SPSS Modeler, SAS Enterprise Miner Cloud Based: IBM Watson Machine Learning, Google Cloud Model Deployment tools: make machine learning or deep learning model consumable Open Source: Apache PredictionIO, Seldon, Mleap, TensorFlow Service, TensorFlow lite Commercial: SPSS Collaboration and Deployment Service Model Monitoring and Assessment tools: keep track of prediction performance Open Source: ModelDB, Prometheus, IBM AI Fairness 360 open source toolkit, IBM Adversarial Robustness 360 Toolbox, IBM AI Explainability 360 Toolkit Cloud Based: Amazon SageMaker Model Monitor, Watson OpenScale Code Asset Management tools: versioning and other collaborative features to facilitate teamwork Open Source: git, Github, GitLab, Bitbucket Data Asset Management tools: supports replication, backup, and access right management Open Source: Apache Atlas, ODPi Egeria, Kylo Commercial: Informatica, IBM InfoSphere Information Governance Development Environments (IDE): help data scientistd to implement, execute, test and deploy their work Open Source: Jupyter notebook, Jupyter lab, Apache Zeppelin, R Studio, Spyder Execution Environments: where data processing, model training and deployment take place Open Source: Apache Spark, Apache Flink, Ray Fully Integrated Visual Tools Open Source: KNIME, Orange Cloud Based: Watson Studio, Open Scale, Azure Machine Learning, H2O Driverless AI Packages, APIs, Data Sets and Models Libraries for Data Science Scientifics Computing Libraries: Pandas, NumPy Visualization Libraries: Matplotlib, Seaborn Machine Learning and Deep Learning: Scikit-learn, Keras Deep Learning Libraries: TensorFlow, PyTorch Apache Spark Scala-Libraries: Vegas(statistical data visualization), BigDL R-Libraries: Ggplot2 Application Programming Interfaces (API) REST APIs (Representational, State, Transfer): used to interact with web services REST APIs have a set of rules regarding communication, input or request, output or response Data Sets A data set is a structured collection of data Tabular data: CSV (comma separated values) Hierarchical data, Network data Raw files: images and audio Data Ownership Private data: Confidential, Private or personal information, Commercially sensitive Open data: Scientific institutions, Governments, Organizations, Companies, Publicly available Kaggle, datacatalogs.org, Google data set search CDLA: Community Data License Agreement Data Asset eXchange Curated collection of data sets Data Science friendly licences Machine Learning Models Data can contain a wealth of information, Machine learning (ML) models identify patterns in data A model must be trained on data before it can be used to make predictions Supervised, unsupervised and reinforcement learning are types of ML Supervised Learning: Data is labeled and model trained to make correct predictions Regression: Predict real numerical values Classification: Classify things into categories Unsupervised Learning: Data us not labeled, model tries to identify patterns without external help Common learning problems: clustering and anomaly detection Reinforcement Learning: Conceptually similar to human learning processes Deep Learning: Tries to loosely emulate how the human brain works Applications in: Natural Language Processing, Image, audio and video analysis, Time series forecasting Requires typically very large datasets of labeled data and is compute intensive TensorFlow, Pytorch, Keras, ONNX model zoo The Model Asset Exchange MAX use pre-trained or custom-trainable state-of-the-art models reduces time to value Model-serving microservices expose standardized REST API Jupyter Notebook and JupyterLab Jupyter Notebook is a tool for recording Data Science experiments, it allows data scientist to combine text and code block in a single file, it generates plots and tables within the file JupyterLab is an interactive environment for Jupyter Notebooks, it allows for real time editing and is compatible with several file formats. It is open source A notebook kernel is a computational engine that executes the code contained in a Notebook file Jupyter implements a two-process model, with a kernel and a client The client is the interface offering the user the ability to send the code to a kernel. The client is the browser when using a Jupyter notebook. The kernel executes the code and returns the result to the client for display RStudio IDE R is a statistical programming language. It is a powerful tool for data processing and manipulation, statistical inference, data analysis, and Machine Learning algorithms. R supports importing data from different sources: Flat files, Databases, Web, Statistical software Rstudio is an integrated development environment that helps improve and increase productivity with the R language 1234library (datasets)data(iris)View(iris) unique(iris$Species) Popular R Libraries for Data Science dplyr : Data Manipulation stringr : String Manipulation ggplot : Data Visualization caret : Machine Learning install.packages(&quot;package name&quot;, repos = &quot;https://cran.r-project.org&quot;, type= &quot;source&quot;) : install packages Data Visualization in R ggplot - used for data visualizations such as histograms, bar charts, scatterplots etc. It allows adding layers and components on a single visualization Plotly - an R package can be used to create web-based data visualizations that can be displayed or saved as individual HTML files Lattice - a data visualization tool that is used to implement complex, multi-variable data sets, a high-level data visualization library; it can handle many of the typical graphics without needing many customizations Leaflet - very useful in creating interactive plots Using the plot function 123456# Define the cars vector with 5 valuescars &lt;- c(1,4,6,5,10)# Gragh the cars vector with all defaultsplot(caars, type=&quot;o&quot;)# Create a titletitle(main=&quot;Cars vs Index&quot;) Using ggplot 1234567891011121314151617181920212223242526library(datasets)# Load Datadata(mtcars)# View first 5 rowshead(mtcars, 5)#load ggplot packagelibrary(ggplot2)# create a scatterplot of displacement (disp) and miles per gallon (mpg)ggplot(aes(x=disp,y=mpg,),data=mtcars)+geom_point()# Add a titleggplot(aes(x=disp,y=mpg,),data=mtcars)+geom_point()+ggtitle(&quot;displacement vs miles per gallon&quot;)# change axis nameggplot(aes(x=disp,y=mpg,),data=mtcars)+geom_point()+ggtitle(&quot;displacement vs miles per gallon&quot;) + labs(x = &quot;Displacement&quot;, y = &quot;Miles per Gallon&quot;)#make vs a factormtcars$vs &lt;- as.factor(mtcars$vs)# create boxplot of the distribution for v-shaped and straight Engineggplot(aes(x=vs, y=mpg), data = mtcars) + geom_boxplot()# Add color to the boxplots to help differentiateggplot(aes(x=vs, y=mpg, fill = vs), data = mtcars) + geom_boxplot(alpha=0.3) + theme(legend.position=&quot;none&quot;)# reate the histogram of weight wtggplot(aes(x=wt),data=mtcars) + geom_histogram(binwidth=0.5)# GGally is an extension of ggplot2library(GGally)ggpairs(iris, mapping=ggplot2::aes(colour = Species)) Github A version control system allows you to keep track of changes to your documents Git is free and open source software distributed under the GNU General Public License Git is a distributed version control system and is accessible anywhere in the world SSH protocol is a method for secure remote login from one computer to another Repository contains project folders that are set up for version control Fork is a copy of a repository Pull request is the way you request that someone reviews and approves your changes before they become final Working directory contains the files and subdirectories on your computer that are associated with a Git repository Basic Git Commands 123456789git initgit add *git statusgit commitgit resetgit loggit branchgit checkoutgit merge Working with Branches A branch is a snapshot of your repository to which you can make changes Master Branch is the official version of the project, The child branch creates a copy of the master branch Edits and changes are made in the child branch. Tests are done to ensure quality before merging to the Master Branch Branches allow for simultaneous development and testing by multiple team members Pull Requests (PR) are a way of proposing changes to the main branch. Ideally, another team member reviews the changes and approves it to be merged to the Master branch IBM Tools for Data Science Watson Studio is an integrated platform of tools, services, and data that helps companies accelerate their shift to become data-driven organizations Watson Knowledge Catalog unites all information assets into a single metadata-rich catalog, based on Watson’s understanding of relationships between assets and how they’re being used and socialized among users in existing projects Main features: Find data, Catalog data, Govern data, Understand data, Power data Science, Prepare data, Connect data, Deploy anywhere Data refinery simplifies data cleansing, shaping and preparation tasks by providing graphical tools for analyzing and preparing data SPSS based products include easy to use graphical interfaces for wide varieties of statistical and machine learning algorithms and data transformations SPSS Modeler flows include some data management capabilities, as well as tools for data preparation, visualization, and model building SPSS Modeler is a data mining and text analytics software application used to build predictive models and conduct other analytics tasks. It has a visual interface that enables users to leverage statistical and data mining algorithms without programming SPSS Statistics is a statistical and machine learning software application and is widely used in academia, government agencies, and large enterprises used to build predictive models, perform statistical analysis of data, and conduct other analytic tasks. It has a visual interface, which enables users to leverage statistical and data mining algorithms without programming, although the interface is very different from Modeler Model Deployment with Watson Machine Learning Open standards for model deployment: PMML(Predictive Model Markup Language), PFA(Portable Format for Analytics from DMG) ONNX: Open Neural Network eXchange Auto AI help simplify an AI lifecycle management, it provides a graphical interface to create and deploy machine learning models with real time visualizations IBM Watson Openscale is a product that includes several important features Fairness, Explainability, Model Monitoring, Business Impact","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"R Language","slug":"R-Language","permalink":"http://blog.zhuangzhihao.top/tags/R-Language/"}]},{"title":"云上搭建基于 Anaconda 的 Jupyter 数据科学环境","slug":"云上搭建Jupyter Notebook","date":"2021-05-08T16:00:00.000Z","updated":"2022-05-23T10:37:14.686Z","comments":true,"path":"云上搭建Jupyter Notebook/","link":"","permalink":"http://blog.zhuangzhihao.top/%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAJupyter%20Notebook/","excerpt":"Jupyter Notebook 是基于浏览器网页的用于交互计算的应用程序，支持 Python、R、Julia 和 Scala 等多种语言，在数据科学相关领域有着非常大的用途。JupyterLab 是基于 web 的集成开发环境，包含了 Jupyter Notebook 所有功能的同时还支持操作终端、编辑 markdown 文本、打开交互模式、查看 csv 文件及图片等功能，最近在学习的 IBM 数据科学专项课程也都是基于 Jupyter Lab 的，在阿里云主机上部署 Jupyter 环境也能使研究和学习更加方便。","text":"Jupyter Notebook 是基于浏览器网页的用于交互计算的应用程序，支持 Python、R、Julia 和 Scala 等多种语言，在数据科学相关领域有着非常大的用途。JupyterLab 是基于 web 的集成开发环境，包含了 Jupyter Notebook 所有功能的同时还支持操作终端、编辑 markdown 文本、打开交互模式、查看 csv 文件及图片等功能，最近在学习的 IBM 数据科学专项课程也都是基于 Jupyter Lab 的，在阿里云主机上部署 Jupyter 环境也能使研究和学习更加方便。 一、安装Anaconda通过清华源安装最新版本 Anaconda： 123wget http://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.11-Linux-x86_64.shbash Anaconda3-2020.11-Linux-x86_64.sh# 狂按Enter&gt;&gt;yes&gt;&gt;继续狂按Enter安装 Anaconda 默认安装在 /root/anaconda3 目录下。 配置环境变量： 1234vim ~/.bashrc# 添加下面两行内容#added by Anaconda3 4.4.0 installerexport PATH=&quot;/root/anaconda3/bin:$PATH&quot; 激活 Anaconda 环境并测试： 12source ~/.bashrcconda --version 添加清华镜像源，并搜索时显示通道地址： 12conda config --add channels &#x27;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&#x27;conda config --set show_channel_urls yes 创建 jupyter notebook 运行环境： 123conda create -n jupyter_notebook python=3# source activate jupyter_notebook 激活环境# source deactivate 退出环境 二、安装配置Jupyter通过 Anaconda 安装 Jupyter Notebook： 12conda install jupyter notebook# 输入jupyter notebook --ip=127.0.0.1 --allow-root 可运行则为安装成功 生成 Jupyter Notebook 配置文件： 1jupyter notebook --generate-config 设置 Jupyter Notebook 密码： 123456ipythonIn [1]: from notebook.auth import passwdIn [2]: passwd()Enter password: Verify password: Out[2]: &#x27;加密字符串&#x27; 修改配置文件： 123456vim /root/.jupyter/jupyter_notebook_config.py#修改如下行c.NotebookApp.ip = &#x27;*&#x27;c.NotebookApp.password = &#x27;加密字符串&#x27;c.NotebookApp.open_browser = Falsec.NotebookApp.allow_root = True 启动 Jupyter Notebook： 1jupyter notebook 启动 Jupyter Lab： 1jupyter lab 远程访问方式：公网ip地址:8888 通过 SSH 端口映射到本地： 1ssh -L8888:localhost:8888 root@106.15.200.147 访问方式：localhost:8888 三、注意事项Jupyter Notebook 只适用于单用户登录，如果想搭建多用户的 Jupyter 的话，要使用 JupyterHub 进行搭建。 阿里云默认不打卡 8888 端口，需要在服务器管理控制台中设置开放端口。 添加 JAVA 环境支持安装 JDK（过程略），下载 Java 内核压缩包 ijava，上传到服务器，使用 unzip 命令解压。 安装 Java 内核： 1python install.py --sys-prefix 查看 Jupyter 内核支持： 123456jupyter kernelspec list&#x27;&#x27;&#x27;Available kernels: java /root/anaconda3/share/jupyter/kernels/java python3 /root/anaconda3/share/jupyter/kernels/python3&#x27;&#x27;&#x27;","categories":[{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.zhuangzhihao.top/tags/Linux/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://blog.zhuangzhihao.top/tags/Jupyter/"}]},{"title":"阿里云云计算助理工程师认证","slug":"阿里云云计算助理工程师认证","date":"2021-05-03T16:00:00.000Z","updated":"2022-06-07T13:34:47.666Z","comments":true,"path":"阿里云云计算助理工程师认证/","link":"","permalink":"http://blog.zhuangzhihao.top/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%91%E8%AE%A1%E7%AE%97%E5%8A%A9%E7%90%86%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%AE%A4%E8%AF%81/","excerpt":"阿里云基础认证（ACA - Alibaba Cloud Certified Associate）是面向使用阿里云基础产品的专业技术认证，主要涉及阿里云的计算、存储、网络、安全类的核心产品。 阿里云云计算助理工程师的培训和认证的过程能够提升个人对云计算产品技术的理解，可以对这些产品进行基本的日常管理，也可以基于这些产品进行应用的部署，从而证明个人在云计算领域的专业能力，获得更多就业机会。","text":"阿里云基础认证（ACA - Alibaba Cloud Certified Associate）是面向使用阿里云基础产品的专业技术认证，主要涉及阿里云的计算、存储、网络、安全类的核心产品。 阿里云云计算助理工程师的培训和认证的过程能够提升个人对云计算产品技术的理解，可以对这些产品进行基本的日常管理，也可以基于这些产品进行应用的部署，从而证明个人在云计算领域的专业能力，获得更多就业机会。 阿里云简介云计算的概念传统IT部署方式：自建机房（耗时耗力、人员和设备等成本高、不利于扩容等）。 云计算是一种新的服务模式（计算资源池、网络资源池、存储资源池）。 云计算按照拥有者和使用者的不同主要分为三种部署模式： 专有云：也叫私有云，属于企业内部自行构建的云环境 公有云：云服务商提供云计算服务，用户通过互联网进行连接和使用 混合云：企业内部云与共有云互通，具有私有云的私密性兼具公有云的灵活性 云计算根据对用户所提供的服务不同划分了多种不同的服务模式： IaaS：基础设施即服务，为用户直接提供计算资源、存储资源、网络资源等，用户需要自行构建自身系统，可操控性最高，一般云服务商都会提供该服务模式。 PaaS：平台即服务，为开发者提供按需开发环境，主要针对开发者用户提供一个开发、测试等使用云环境。 SaaS：软件即服务，为用户提供给按需软件服务，云服务商管理和提供软件，用户直接使用云服务商软件。 阿里云云产品阿里云创立于2009年，是全球领先的云计算及人工智能科技公司，提供了丰富的产品类型以满足用户各场景的使用需求。 弹性计算：云服务器、高性能计算HPC、弹性编排。 存储服务：云存储、智能存储、混合云存储。 网络：云上网络、跨地域网络、混合云网络。 数据库：关系型数据库、NoSQL数据库、数据库生态工具。 CDN与边缘：CDN、SCDN、DCDN。 安全：云安全、业务安全。 阿里云体系架构：数据中心 -&gt; Linux -&gt; 通用云服务市场&amp;行业解决方案。 阿里云基础架构地域（Region）：阿里云基于地理位置进行划分，资源创建成功后不能修改地域。不同地域提供的阿里云资源也会略有不同。 可用区（Zone）：同一地域内，电力和网络互相独立的物理区域。同一可用区内实例之间的网络延时更小。 每个地域完全独立。每个可用区完全隔离，但同一个地域内的可用区之间使用低时延链路相连。 选择地域时，需要考虑地理位置、阿里云产品之间的关系、资源的价格、经营许可备案等因素，根据目标用户所在的地理位置选择地域。 选择可用区时，需要考虑在同一地域内可用区与可用区之间内网互通，可用区之间能做到故障隔离，以及是否将实例放在同一可用区内，主要取决于对容灾能力和网络延时的要求。 完整的服务体系包括自助服务、技术支持、服务运营、培训认证、生态服务、电话支持。 阿里云弹性计算ECS的概念云服务器（Elastic Compute Service）是阿里云提供的性能卓越、稳定可靠、弹性扩展的IaaS（Infrastructure as a Service）级别云计算服务。云服务器ECS免去了采购IT硬件的前期准备，实现计算资源的即开即用和弹性伸缩。 阿里云ECS持续提供创新型服务器，解决多种业务需求，助力企业的业务发展，稳定、弹性、高安全、高性能、易用性、可拓展性强。 阿里云ECS在部署前需要进行规划，需要考虑的因素： 地域和可用区：地域一旦成功创建实例后，无法更换地域。 高可用性：通过快照实现数据备份，通过跨可用区、部署集、负载均衡（Server Load Balancer）等实现应用容灾。 安全方案：使用ECS的安全组，控制ECS实例的出入网访问策略以及端口监听状态。 网络规划：自行规划私网IP，全面支持新功能和新型实例规格。 ECS适用场景： 企业官网或轻量的 Web 应用。 多媒体以及高并发应用或网站，与对象存储OSS搭配。 高I/O要求数据库。 访问量波动剧烈的应用或网站。 大数据及实时在线或离线分析。 机器学习和深度学习等AI应用，例如GPU计算型实例。 云服务器 ECS 相对于普通 IDC 的优点： 易用性：在线更换操作系统，Web在线管理。 安全性：三副本数据设计，用户自定义快照，快速自动恢复，有效阻止MAC欺骗和ARP攻击，有效防护DDoS攻击，端口入侵扫描、挂马扫描、漏洞扫描等。 灵活性：在线升级配置、带宽升降自由、在线使用负载均衡。 ECS的实例规格实例：一台云服务器ECS实例等同于台虚拟机，包含vCPU、内存、操作系统、网络、磁盘等最基础的计算组件，可以方便地定制，更改实例的配置。 实例规格：根据业务场量，ECS实例可以分为多个规格族，同一个规格族里，根据vCPU和内存的配置，可以分为多种不同的规格，不同实规格具有不同vCPU和内存等配置，包含物理CPU型号、主频等。某些软件或应用对实例规格的配置有要求。 系统存储：一台ECS实例必须包合一块系统盘，用来存储操作统和核心配置，镜像主要用于初始化系统盘，决定ECS实例的操作系统和初始软件配置。 网络类型：ECS实例区分网络类型，实例在相同的网络中，例如一个VPC，可以使用私网地址通过内网通信。 实例的生命周期：创建实例 -&gt; 准备中 -&gt; 启动中 -&gt; 运行中 -&gt; 停止中 -&gt; 已停止 -&gt; 删除实例。 为应对不同业务场景，阿里云ECS提供多种实例规格族： 通用型（g系列）、计算型（c系列）、内存型（r系列）、大数据型（d系列）。 本地SSD型（i系列）、高主频计算型（hfc、hfg、hfr系列）。 弹性裸金属服务器（神龙）弹性裸金属服务器（ECS Bare Metal Instance）基于阿里云完全自主研发的下一代虚拟化技术而打造的新型计算类服务器产品，兼具虚拟机的弹性和物理机的性能及功能特性。与上一代虚拟化技术相比，下一代虚拟化技术不仅保留了普通云服务器的弹性体验，而且保留了物理机的性能与特性，全面支持嵌套虚拟化技术。 EMB弹性裸金属服务器特点： 弹性裸金属服务器融合了物理机与云服务器的各自优势，实现超强超稳的计算能力。业务应用可以直接访问弹性裸服务器的处理器和内存，无需任何虚拟化开销。 弹性裸金属服务器通过自研芯片和自研Hypervisor系统软件，打造了全球领先的深度融合物理机和虚拟机特性的创新型计算架构。能与阿里云产品家族中的其他计算产品无缝对接。 EMB 弹性裸金属服务器优势： 用户独占计算资源。 加密计算：芯片级可信执行环境。 兼容多种专有云：具有再次虚拟化的能力。 异构指令集处理器支持：零成本支持ARM等其他指令集处理器。 EMB 相对于物理机和 ECS 的优点： ECS不具备免性能损失、免特性损失、免资源争抢等计算特性。 物理机不支持云存储特性、不支持网络兼容等特性。 弹性裸金属服务器适用场景：游戏场景、金融加密场景、SCC超级计算集群。 ECS的使用基础配置（付费模式、地域和可用区、实例规格）-&gt; 网络与安全（专用网络、公网IP、安全组）-&gt; 系统配置（登录凭证、登录密码）。 ECS镜像提供了创建ECS实例所需的信息。镜像文件相当于副本文件，包含了一块或多块云盘中的所有数据，官方提供公共镜像、自定义镜像、共享镜像和镜像市场。 ECS的连接方式：Workbench、VNC、putty等客户端工具、SSH命令连接或SSH Control Lite、JuiceSSH等App，除VNC外，其它连接方式均要求待连接实例分配了固定公网IP或EIP 。 阿里云存储服务OSS的概念常见的存储结构： 块存储：以数据块为存储单位，需要分区格式化才能使用（直接访问存储DAS、存储区域网络SAN等）。 文件存储：以文件为存储单位，由文件存储服务器NAS提供文件访问服务（CIFS、NFS等）。 对象存储：以对象为存储单位，扁平化结构（大数据存储）。 阿里云对象存储OSS（Object Storage Service）是阿里云提供的海量、安全、低成本、高可靠的云存储服务，可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 存储类型（Storage Class）：OSS提供标准、低频访问、归档三种存储类型，全面覆盖从热到冷的各种数据存储场景。 存储空间（Bucket）：用于存储对象（Object）的容器，所有对象都必须隶属于某个存储空间。 对象（Object）：OSS存储数据的基本单元，也被称为OSS的文件。对象由元信息（Object Meta）、用户数据（Data）和文件名（Key）组成。 地域（Region）：OSS的数据中心所在物理位置，可以根据费用、请求来源等选择合适的地域创建Bucket。 访问域名（Endpoint）：OSS对外服务的访问域名。 访问密钥（AccessKey）：AK，访问身份验证中用到的AccessKey Id和AccessKey Secret。 OSS 的优势和适用场景： 方便、快捷的使用方式：提供标准的RESTful API接口、丰富的SDK包、客户端工具、控制台，不限制存储空间大小，支持数据生命周期管理。 强大、灵活的安全机制：灵活的鉴权、授权机制，提供用户级别资源隔离机制和多集群同步机制 丰富、强大的增值服务：图片处理、音视频转码，互联网访问加速、内容加速分发CDN 数据冗余机制：OSS采用数据冗余存储机制，OSS Object操作具有强一致性 阿里云OSS 相对于自建对象存储的优点：可靠、安全、低成本、智能存储。 OSS的使用阿里云OSS将数据文件以对象（Object）的形式上传到存储空间（Bucket）中：创建一个或者多个存储空间，向每个存储空间中添加一个或多个文件，通过获取已上传文件的覅之进行文件的分享和下载，通过修改存储空间的读写权限（ACL）来设置访问权限，通过阿里云管理控制台、各种便捷工具以及丰富的SDK包执行基本和高级OSS操作。 开通阿里云OSS服务后，需要首先创建存储空间（Bucket）来存储文件。Bucket 名称具有唯一性。 区域（创建后无法更换）：如需要通过ECS内网访问OSS，需选择与ECS相同的地域。 存储类型：标准存储（经常访问）、低频访问（长期存储、较少访问）、归档存储（长期存储、极少访问）。 同城冗余存储：用户数据以冗余的方式存储在同一区域的3个可用区（AZ）中。 读写权限分为私有（private）、公共读（public-read）、公共读写（public-read-write）。 创建了存储空间（Bucket）后，可以上传任何类型的文件（Object）到存储空间中，可使用OSS图形化管理工具ossbrowser将文件上传至OSS，可使用OSS命令行工具ossutil将文件上传至OSS，OSS提供多种语言的API和SDK包，快速进行二次开发。 块存储的概念 块存储是阿里云为云服务器ECS提供的块设备产品，具有高性能和低延时的特点，支持随机读写 可以像使用物理硬盘一样格式化并建立文件系统来使用块存储，满足大部分同意业务场景下的数据存储需求 衡量块存储产品的性能指标主要包括IOPS、吞吐量和访问时延 IOPS（Input/Output Operation per Second）：每秒能处理的I/O个数，表示块存储处理读写（输入/输出）的能力，单位为次 吞吐量（Throughput）：单位时间内可以成功传输的数据数量，单位为MB/s 访问时延（Latency）：块存储处理一个I/O需要的实践，单位为s、ms或微秒 容量（Capacity）：容量是指存储空间大小，单位为TiB、GiB、MiB或者KiB，容量无法衡量块存储性能 阿里云块存储的数据安全：读写稳定性（分布存储）、主动备份（快照）、数据擦除机制、数据加密（AES-256） 块存储的分类 云盘：数据块级别的块存储产品。云盘采用多副本的分布式机制，具有低时延、高性能、持久性、高可靠等性能，支持随时创建、扩容以及释放 本地盘：基于云服务器ECS所在物理机（宿主机——上的本地硬盘设备，为ECS实例提供本地存储访问能力。为对存储I/O性能和海量存储性价比有极高要求的业务场景而设计的产品。具有低时延、高随机IOPS、高吞吐量、高性价比等优势 本地盘来自单台物理机，数据可靠性取决于物理机的可靠性，存在单点故障风险 云盘类似硬盘，可以对挂载到ECS实例上的云盘做分区、格式化、创建文件系统等操作，并持久化存储数据 云盘根据性能分类 ESSD云盘：基于新一代分布式块存储架构的超高性能云盘产品，结合25GE网络和RDMA技术，单盘可提供高达100万的随机读写能力和更低的单路时延能力 SSD云盘：具备稳定的高随机读写性能、高可靠性的高性能云盘产品 高效云盘：具备高性价比、中等随机读写性能、高可靠性的云盘产品 普通云盘：具备高可靠性、一般随机读写性能的云盘产品 云盘的数据类型 系统盘：不可共享访问。初始化系统盘时，由镜像确定操作系统类型和应用数据，系统盘一定是云盘。只能随实例创建，生命周期与挂载的ECS实例相同 数据盘：常用于存储应用数据，可以与ECS实例同时创建，也可以单独创建。数据盘可以时云盘，也可以是其他类型块存储（本地盘），单台ECS实例上限16 一块云盘只能挂载到同一地域、同一可用区的一台ECS实例 块存储与对象存储 阿里云数据存储场景产品：块存储、对象存储OSS、文件存储NAS | | 块存储 | OSS || ———— | —————————————————————————————————————————— | ———————————————————————————— || 数据模型 | 文件系统是一种典型的树状索引结构 | 分布式的对象存储服务，Key-Value对形式 || 数据获取 | 先访问文件夹目录再在该目录下查找文件 | 根据Object的名称（Key）唯一的获取该Object的内容 || 优势 | 支持文件的修改，文件夹的操作 | 支持海量的用户并发访问 || 劣势 | 受限于单个设备的性能，访问越深的目录消耗的资源越大，操作拥有很多文件的目录也会非常慢 | Object不支持修改，哪怕修改一个字节也需要重新上传整个目录 | 块存储的使用 云服务器ECS不支持单独创建系统盘 数据盘只能挂载同一可用区的ECS 不支持合并多块云盘，提前做好云盘数量和容量的规划 已创建的多块云盘，不建议制作LVM（Logic Volume Manager）逻辑卷 挂载数据盘 可以将单独创建的云盘、从ECS实例上卸载下来的系统盘挂载到ECS实例上，作为数据盘使用 被挂载的实例和云盘在同一可用区 被挂载的实例状态为运行中（Running）或已停止（Stopped），不能为已锁定（Locked） 云盘的状态为待挂载（Available） 随ECS实例一起创建的云盘，和为包年包月实例创建的包年包月数据盘无需挂载 一块云盘只能挂载到一台ECS实例上，一台ECS实例最多能挂载16块云盘作数据盘用 分区格式化数据盘 阿里云块存储支持的分区格式包括MBR（Master Boot Record）和GPT（Globally Unique Identifier Partition Table） MBR只支持处理不大于2TiB的容量，且只支持划分4个分区，如果需要使用大于2TiB的数据盘，必须采用GPT格式 | 操作系统 | 分区工具 | 分区格式 | 文件系统 || ———— | ——————- | ———— | —————————————— || Windows | 磁盘管理 | MBR、GPT | NTFS、fat || Linux | fdisk、parted | MBR、GPT | vfat、ext3、ext4、xfs、btrfs | 在Linux系统中，分区和格式化后还需要使用mount命令将分区挂载至空白目录，并将新分区挂载信息写入至 /etc/fstab 文件中 具体操作 123456789101112fdisk –l //查看分区信息fdisk /dev/vdb //分区管理命令p //查看分区表信息n //创建分区w //保存分区表partx //同步磁盘信息mkfs.ext4 /dev/vdb1 //格式化分区为ext4格式mkdir /mnt/data //创建空白目录挂载新磁盘分区mount /dev/vdb1 /mnt/data //挂载分区至空白目录df –h | grep vdb1 //查看分区挂载信息echo “/dev/vdb1 /mnt/data ext4 defaults 0 0” &gt;&gt; /etc/fstab //设置开机自动挂载mount –a //验证/etc/fstab文件的正确性 卸载云盘 12umount /dev/vdb1 //在ECS中卸载分区vim /etc/fstab //在文档中将自己新增挂载记录删除 最后在控制台卸载云盘 在MBR磁盘管理中主分区、扩展分区和逻辑分区的区别 主分区：一块硬盘最多只能创建4个，可以放置任何类型数据 扩展分区：一块硬盘最多只能创建1个，不能放置任何数据，需要进一步划分逻辑分区后才能使用 逻辑分区：基于扩展分区进行创建，空间由扩展分区划分出来，可以放置普通数据，不能存放计算机的启动引导文件 阿里云网络VPC的概念 专有网络VPC（Virtual Private Cloud）是基于阿里云构建的一个隔离的网络环境，专有网络之间逻辑上彻底隔离 VPC主要提供两个能力： 用户可以自定义网络拓扑，包括选择自由IP地址范围、划分网段、配置路由表和网关等 通过专线或VPN与原有数据中心连接，云上和云下的资源使用同一个网络地址规划，实现应用的平滑迁移上云 VPC组成部分：一个路由器、至少一个私网网段、至少一个交换机 路由器（VRouter）：专有网络的枢纽 交换机（VSwitch）：组成专有网络的基础网络设备，用来连接不同的云资源 私网网段：在创建专有网络和交换机时，您需要以CIDR地址块的形式指定专有网络使用的私网网段 VPC连接 公网连接技术 ECS固定公网IP：支持使用共享流量包，将公网IP转换外EIP后也可以使用共享带宽 弹性公网IP（EIP）：可以动态和VPC ECS实例绑定和解绑，支持实例访问公网（SNAT）和被公网访问（DNAT），可使用共享流量包和共享带宽 NAT网关：支持多台VPC ECS实例访问公网（SNAT）和被公网访问（DNAT） 负载均衡：基于端口提供四层和七层负载均衡，支持用户从公网通过负载均衡（SLB）访问ECS。在DNAT方面，负载均衡是基于端口的负载均衡，即一个负载均衡的一个端口可以对应多台ECS。负载均衡通过对多台ECS进行流量分发，可以扩展应用系统对外的服务能力，并通过消除单点故障提升应用系统的可用性 VPC之间的互通（VPC可以有效的实现网络的隔离） 云企业网：支持多个不同地域、不同账号的VPC连接起来，构建互联网络（一网通、低时延高速率、就近接入与最短链路互通、链路冗余及容灾、系统化管理） VPN网关：通过在两个VPC之间创建IPsec连接，建立加密通信通道（安全、高可用、低成本、配置简单） 本地IDC和云上专有网络打通，构建混合云架构（上云） 高速通道：通过物理专线接入使VPC与本地IDC网络互通（低延迟、专线连接安全可靠） VPN网关：通过建立IPsec-VPN，将本地IDC网络和云上VPC连接起来；或通过建立SSL-VPN，将本地客户端远程接入VPC 云企业网：与本地IDC互通支持将要互通的本地IDC关联的边界路由器（VBR）加载到已创建的云企业网实例，构建互联网络；或多VPC与IDC互通支持将要互通的多个网络实例（VPC和VBR）加载到已创建的云企业网实例，构建企业级互联网络 接入网关：线下机构（IDC/分支机构/门店等）接入阿里云数据中心，轻松构建混合云，实现线下机构的互通（即插即用、网络拓扑变化自适应快速收敛、就近接入、加密互联） VPC的基础架构 VPC逻辑架构 基于隧道技术和软件定义网络SDN（Software Defined Network）技术，阿里云的研发在硬件网关和自研交换机设备的基础上实现了VPC产品 VPC包含交换机、网关和控制器三个重要的组件。交换机和网关组成了数据通路的关键路径，控制器使用自研的协议下发转发表到网关和交换机，完成了配置通路的关键路径 网络规划 VPC是地域级别的资源，不能跨地域部署，当有多地域部署系统的需求时，就必须使用多个VPC。多业务系统隔离如果在一个地域的多个业务系统需要通过VPC进行严格隔离。 交换机的规划：即使只使用一个VPC，也尽量使用至少两个交换机，并且将两个交换机分布在不同可用区，这样可以实现跨可用区容灾 网段的规划：交换机的网段必须是其所属VPC网段的子集 SLB的概念 负载均衡（Server Load Balancer）是将访问流量根据转发策略分发到后端多台云服务器（ECS实例）的流量分发控制服务。负载均衡扩展了应用的服务能力，增强了应用的可用性 通过设置虚拟服务地址，将添加的同一地域的多台ECS实例虚拟成一个高性能、高可用的后端服务池，并根据转发规则，将来自客户端的请求分发给后端服务器池中的ECS实例 默认检查云服务器池中的ECS实例的健康状态，自动隔离异常状态的ECS实例，消除了单台ECS实例的单点故障，提高了应用的整体服务能力。此外，负载均衡还具备抗DDoS攻击的能力，增强了应用服务的防护能力 SLB的组成部分 负载均衡实例（Server Load Balancer Instances），一个负载均衡实例是一个运行的负载均衡服务，用来接收流量并将其分配给后端服务器 监听（Listeners），用来检查客户端请求并将请求转发给后端服务器，监听也会对后端服务进行健康检查 后端服务器（Backend Servers），一组接受前端请求的ECS实例 SLB的产品优势：高可用、可扩展、低成本、安全、高并发 SLB的原理 SLB的基础架构 负载均衡采用集群部署，提供四层（TCP协议和UDP协议）和七层（HTTP和HTTPS协议）的负载均衡，可实现会话同步，以消除服务器单点故障，提升冗余，保证服务的稳定性 七层：采用Tengine实现负载均衡 四层：采用开源软件LVS（Linux Virtual Server）+ keepalived 的方式实现负载均衡 SLB中提供的功能 调度算法：轮询、加权轮询（WRR）、加权最小连接数（WLC）和一致性哈希（CH）调度算法 健康检查：检查后端服务器的运行状况 会话保持：在会哈的生命周期内，可以将同一客户端的请求转发到同一台后端服务器上 访问控制：支持添加黑名单和白名单，灵活控制客户端访问 高可用：将流量转发给多个可用区的后端服务器 安全防护：结合云顿，可提供5Gbps的防DDos攻击能力 SLB的应用场景：应用于高访问量的业务，扩展应用程序、消除单点故障、同城容灾（多可用区）、跨地域容灾 SLB的配置 创建负载均衡实例 -&gt; 添加监听 -&gt; 添加后端服务器 -&gt; 域名解析 SLB使用的注意事项 规划实例地域（提供主备可用区） 选择实例的网络类型（公网或私网） 选择协议类型：四层监听将直接转发给后端服务器，不会修改标头，七层监听原理上是反向代理的一种实现 准备后端服务器（不支持跨地域部署） 后端服务器不需要配置公网IP地址（固定和弹性都不需要），外面客户访问通过SLB的公网IP地址进行访问，后端服务器添加的公网IP目的为了方便管理和控制后端服务器 AS的概念 弹性伸缩（Auto Scaling）可以根据业务需求和策略设置伸缩规则，在业务需求增长时自动增加ECS实例以保证计算能力，在业务需求下降时自动减少ECS实例以节约成本 弹性伸缩不仅适合业务量不断波动的应用程序，同时也适合业务量稳定的应用程序 AS的使用场景 弹性扩张：自动完成底层资源升级，避免访问时延和超负荷运行 弹性收缩：自动完成底层资源释放，避免资源浪费 弹性自愈：提供健康检查功能 AS的原理 AS的工作流程：创建伸缩组、伸缩配置、伸缩规则、伸缩触发任务 伸缩出发任务按照各自触发生效的条件来触发伸缩活动 系统自动通过ExecuteScalingRule接口触发伸缩活动，并在该接口中指定需要执行的伸缩规则的阿里云资源唯一标识符（Ari） 根据Rule Ari获取伸缩规则、伸缩组和伸缩配置信息 自动创建ECS实例并配置负载均衡和RDS 伸缩活动完成后启动伸缩组的冷却功能 AS的伸缩模式：定时模式、动态模式、固定数量模式、自定义模式、健康模式、多模式并行 AS的配置 AS的使用流程：创建伸缩组 -&gt; 创建伸缩配置 -&gt; 其用伸缩组 -&gt; 创建伸缩规则 -&gt; 创建定时任务 -&gt; 创建报警任务 AS使用的功能限制 弹性伸缩不支持纵向扩展，即不支持自动提升或降低ECS实例的vCPU、内存、带宽等配置 部署在伸缩组内ECS实例上的应用必须是无状态并且可横向扩展的 伸缩组内ECS实例可能会被自动释放，因此不适合保存会话记录、应用数据、日志等信息 弹性伸缩不支持自动将ECS实例添加到Memcache实例的访问白名单 弹性伸缩AS是调整ECS服务器的数量，SLB是提供负载均衡服务 一个完整的AS服务，需要后端服务器与SLB结合提供负载均衡访问，然后再由AS来调整SLB的后端服务器的数量 阿里云云数据库PolarDB的概念 PolarDB是阿里云自研的下一代关系型云数据库，有三个独立的引擎。分别可以100%兼容 MySQL、100%兼容 PostgreSQL、高度兼容 Oracle语法，存储容量最高可达100TB，单库最多可扩展到16个节点，适用于企业多样化的数据库应用场景 PolarDB既融合了商业数据库稳定可靠、高性能、可扩展的特征,又具有开源云数据库简单开放、自我迭代的优势 PolarDB采用存储和计算分离的架构，所有计算节点共享一份数据，提供分钟级的配置升降级、秒级的故障恢复、全局数据一致性和免费的数据备份容灾服务 PolarDB特点 集群架构，计算与存储分离：PolarDB采用多节点集群的架构,集群中有一个Writer节点（主节点）和多个Reader节点（读节点） 读写分离：当应用程序使用集群地址时，PolarDB MySQL/ PostgreSQL通过内部的代理层（Proxy）对外提供服务，应用程序的请求都先经过代理，然后才访问到数据库节点 集群：一个集群包含一个主节点以及最多15个只读节点（最少一个，用于提供Active-Active高可用） 节点：一个独立占用物理内存的数据库服务进程，节点ID以pi开头 数据库：在节点下创建的逻辑单元，一个节点可以创建多个数据库，数据库在节点内的命名唯一 PolarDB的优势 容量大、高性价比、分钟级弹性、读一致性、毫秒级延迟（物理复制）、无锁备份 云数据库PolarDB既融合了商业数据库稳定可靠、高性能、可扩展的特性，又具有开源云数据库简单开放、自我迭代的优势 PolarDB的产品架构及特点：一写多读、计算与存储分离、读写分离、高速链路互联、共享分布式存储、数据多副本 RDS的概念 阿里云关系型数据库RDS（Relational Database service）是一种稳定可靠、可弹性伸缩的在线数据库服务。基于阿里云分布式文件系统和SSD盘高性能存储，RDS支持MySQL、SQL Server、PostgreSQL、PPAS（Postgre Plus Advanced Server，高度兼容Oracle数据库）和 MariaDB TX引擎，并且提供了容灾、备份、恢复、监控、迁移等方面的全套解决方案 RDS相关概念：实例（虚拟化的数据库服务器）、数据库引擎、网络类型（VPC）、产品系列、规格族、存储类型 地域和可用区概念与其他阿里云产品中的定义相同 RDS vs 自建数据库：便宜易用、高性能（参数优化和SQL优化建议）、高可用、高安全性 RDS的产品选型 产品系列 基础版：单节点实例，计算与存储分离架构 高可用版：一主一备高可用架构 集群版：仅SQL Server提供，基于AlwaysOn技术实现，支持横向扩展集群读能力 三节点企业版：仅MySQL提供，一主两备的三节点架构，通过多副本同步复制确保数据的强一致性，金融级可靠 实例规格族 共享型：独享被分配的内存，与同一物理机上的其他共享型实例共享CPU和存储资源 通用型：复用率小于共享型实例 独享型：具有完全独享的CPU和内存，独占物理机型 存储类型 本地SSD盘：与数据库引擎位于同一节点的SSD盘，低I/O延时 SSD云盘：基于分布式存储架构的弹性块存储设备，实现计算与存储分离 ESSD云盘：SSD云盘结合25GE网络和RDMA技术 RDS的可靠性、持久性和读写性能满足产品SLA承诺 PolarDB MySQL的管理步骤 创建数据库集群 -&gt; 设置集群白名单 -&gt; 创建数据库账号 -&gt; 查看连接地址 -&gt; 连接数据库集群 数据库集群账号：高权限账号（只能通过控制台创建管理）、普通账号（可通过SQL语句创建管理） 集群连接地址（支持私网和公网）：集群地址、主地址（总是连接到主节点） PolarDB MySQL的连接 PolarDB MySQL集群支持使用DMS（Data Management Service）和通用MySQL客户端连接 DMS是阿里云提供的图形化的数据管理工具，它是一种集数据管理、结构管理、访问安全、BI图表、数据趋势、数据轨迹、性能与优化和服务器管理于一体的数据管理服务。 支持对关系型数据库（MySQL、SQL Server、PostgreSQl等）和NoSQL数据库（MongoDB、 Redis等）的管理，同时还支持Linux服务器管理 可以使用任何通用的客户端连接PolarDB集群，例如HeidiSQL 命令行连接 1mysql -h&lt;连接地址&gt; -P&lt;端口&gt; -u&lt;用户名&gt; -p&lt;密码&gt; -D&lt;数据库&gt; PolarDB MySQL的数据管理 数据迁移/同步方案 云数据库PolarDB提供了多种数据迁移同步方案，可满足不同上云、迁云、同步的业务需求，可以在不影响业务的情况下平滑将数据库迁移、同步至阿里云云数据库PolarDB上 通过使用阿里云数据传输服务（DTS），可以实现PolarDB的结构迁移、全量迁移和实时同步 多种迁移类型：结构对象迁移、全量数据迁移和增量数据迁移 DTS的特点 DTS具备极高的链路稳定性和数据可靠性 数据传输支持同/异构数据源之间的数据交互，提供数据迁移/订阅/同步交互功能 支持节点的故障容灾，可实现链路的秒级恢复 支持断点续传，可有效解决因硬件、网络等异常导致的传输中断 DTS支持RAM主子账号体系，用户可以使用子账号创建并管理DTS实例，提高企业安全性 阿里云CDNCDN的概念 CDN解决的问题：最后一公里传输质量、弹性带宽、低成本、减少源站压力、节省源站带宽成本 阿里云内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。阿里云CDN分担源站压力，避免网络拥塞，确保在不同区域、不同场景下加速网站内容的分发，提高资源访问速度。 阿里云CDN将源站资源缓存至阿里云遍布全球的加速节点上，当终端用户请求访问和获取该资源时，无需回源，系统自动调用离终端用户最近的CDN节点上已缓存的资源。 CDN相关产品：对象存储OSS、视频直播点播、阿里云云解析、云服务器ECS、负载均衡（IP地址） 阿里云CDN的主要优势：稳定快速、性价比高、简单易用、高效智能 CDN的工作原理 CDN的衡量指标：延时、下载速度、打开速度、丢包率、回源率、缓存命中率 回源率分为回源请求数比和回源流量比 回源请求数比指边缘节点对于没有缓存、缓存过期（可缓存）和不可缓存的请求占全部请求记录的比例，越低则性能越好 回源流量比是回源请求文件大小产生的流量和请求本身产生的流量，比值越低，性能越好 回源流量比 = 回源旑量 / (回源流量 + 用户请求访问的流量) 由于业务场景和业务类型的不同，即使选择了相同配置的CDN服务，实际产生的加速效果也不相同 CDN中常见名词 CNAME记录：Canonical Name，别名，用来把一个域名解析到另一个域名，再由另一个域名提供IP地址 CNAME域名：接入CDN，在阿里云控制台添加域名后，阿里云CDN将分配一个CNAME域名 DNS：Domain Name System，域名解析服务，DNS的作用是把域名转换成为网络可以识别的IP地址 边缘节点：在阿里云中，边缘节点、CDN节点、Cache节点、缓存节点、加速节点、阿里云节点、节点等都指阿里云边缘节点 源站指实际业务的服务器，源站类型可以选择OSS域名、IP、源站或函数计算域名 回源：CDN节点未缓存请求资源或缓存资源已到期时，回源站获取资源，返回给客户端 CDN的业务使用场景分为静态内容加速、动态内容加速和安全加速。其中，阿里云CDN只针对于静态内容加速的使用，动态内容加速需使用阿里云全站加速，安全加速需使用阿里云安全加速 阿里云CDN的业务场景：图片小文件、大文件下载、视音频点播、全站加速、安全加速 CDN的使用 开通CDN服务 -&gt; 添加加速域名 -&gt; 配置CNAME -&gt; 停止CDN服务 如果需要使用CDN加速指定网站上的业务，则需要将该网站作为源站，为其创建加速域名，CDN通过加速域名将源站上的资源缓存到CDN的加速节点，实现资源访问加速 加速域名注意事项 加速名一殷使用子域名或泛域名 支持泛域名加速,不支持中文域名加谜速 加速域名不允许重复添加 如果泛域名未被添加到任何CDN账号下,则其支持多个CDN账号添加不同的子域名 加速内容必须合法且符合CDN业务规范 域名添加成功后，阿里云CDN会分配对应的CNAME地址。如果想启用CDN加速服务，则需要将加速域名指向CNAME地址，访问加速域名的请求才能转发到CDN节点上，达到加速效果 不同的DNS服务商修改CNAME记录方式略有不同，请参考相应DNS服务商进行配置 当不想使用CDN加速服务时，可以在CDN控制台上删除指定加速域名。删除加速域名后，不会产生任何费用 阿里云云上安全防护云计算常见威胁 针对网络中的一个运行系统而言，网络安全是指网络系统的硬件、软件及其系统中的信息受到保护。包括系统连续、可靠、正常地运行，网络服务不中断，系统中的信息不因偶然的或恶意的行为而遭到破坏、更改或泄露 网络安全的威胁：病毒、木马、网络攻击、人为篡改、自然灾害 传统集中式管理方式有很大安全问题，云计算的多租户、分布性、对网络和服务提供者的依赖性为安全问题带来新的挑战。除了传统信息系统的安全问题外，云计算由于其本身的特点，带来了新的安全威胁 云计算安全风险：数据丢失或泄露、系统和技术漏洞、账号与身份管理不善、数据集中的安全问题、API安全存疑、DoS攻击泛滥 云上安全是由阿里云和用户共同负责构建云安全环境 阿里云安全体系：云盾、云产品安全、云操作系统安全、安全运维 阿里云DDoS防护 分布式拒绝服务（Distributed denial of service，简称DDoS）将多台计算机联合起来作为攻击平台，通过远程连接利用恶意程序，对一个或多个目标发起DDoS攻击，消耗目标服务器性能或网络者宽，从而造成服务器无法正常地提供服务 DDoS攻击会对业务造成：重大经济损失、数据泄露、恶意竞争 阿里云DDoS原生防护是一款针对阿里云ECS、SLB、Web应用防火墙、EP等产品直接提升DDoS防御能力的安全产品。相比于DDoS高防，DDoS原生防护可以直接把防御能力加载到云产品上，不需要更换IP，也没有四层端口、七层域名数等限制。同时，DDoS原生防护部署简易，购买后只需要绑定需要防护的云产品的IP地址即可使用 DDoS高防（Anti-DDoS）是阿里云提供的DDoS攻击代理防护服务。当用户的互联网服务器遭受大流量的DDoS攻击时，DDoS高防可以保护其应用服务持续可用。DDσS高防通过DNS解析调度流量到阿里云高防网络，代理接入阿里云DDoS防护系统，抵御流量型和资源耗尽型DDoS攻击 DDoS高防支持通过DNS解析和IP直接指向两种引流方式，实现网站域名和业务端口的接入防护，根据用户在DDoS高防服务中为业务配置的转发规则，DDoS高防将业务的DNS域名解析或业务IP指向DDoS高防实例IP或CNAME地址进行引流 来自公网的访问流量都将优先经过高防机房，恶意攻击流量将在高防流量清洗中心进行清洗过滤，正常的访问流量通过端口协议转发的方式返回给源站服务器，从而保障源站服务器的稳定访问 使用DDoS高防防护网站流程：添加网站业务转发规则 -&gt; 接入网站业务流量 -&gt; 设置网站业务防护策略 -&gt; 查看网站业务防护数据 DDoS高防除了可以防御最常用的网站类业务，同时也支持防护非网站业务 Web应用防火墙 云盾web应用防火墙（Web Application Firewall，简称WAF）基于云安全大数据能力，用于防御SQL注入、XSS跨站脚本、常见Web服务器插件漏洞、木马上传、非授权核心资源访问等OWASP常见攻击，并过滤海量恶意CC攻击，避免您的网站资产数据泄露，保障网站的安全与可用性 云盾web应用防火墙具有部署简易、防护及时精确、大数据驱动、高可靠等优势 使用Web应用防火墙之前，必须将要防护的网站接入web应用防火墙。网站接入默认使用DNS配置模式，需要在web应用防火墙添加琙名，设置网站流量的转发信息，并修改域名的DNS解析设置，将网站流量解析到web应用防火墙进行防护 开通Web应用防火墙服务后,可以使用DNS配置模式或透明代理模式将网站接入web应用防火墙进行防护 云安全中心 云安全中心是一个实时识别、分析、预警安全威胁的统安全管理系统，通过防勒索、防病毒、防篡改、合规检査等安全能力，实现威胁检测、响应、溯源的自动化安全运营闭环，保护云上资产和本地服务器并满足监管合规要求 云安全中心提供基础版、基础杀毒版、高级版和企业版多个版本 云安全中心产品优势：安全事件告警和检索、漏洞和基线配置检测、安全风险量化和预测、安全可视化界面、支持病毒云查杀、符合多项国际安全认证标准 资产安全状态通过云安全中心Agent插件收集和检测得出 Agent插件：云安全中心提供的本地安全插件，必须在要防护的服务器上安装该插件才能使用云安全中心的服务 阿里云云监控 云监控（Cloud monitor）是一项针对阿里云资源和互联网应用进行监控的服务，云监控为云上用户提供开箱即用的企业级开放型一站式监控解决方案。云监控涵盖IT设施基础监控和外网网络质量拔测监控，是基于事件、自定义指标和日志的业务监控，全方位提供更高效、全面、省钱的监控服务 云监控结合阿里云云计算平台强大的数据分析能力，提供云服务监控、站点监控和自定义监控，云产品、业务保驾护航，主要有天然集成、数据可视化、监控数据处理、灵活报警等优势 云监控的应用场景：云服务监控、系统监控、及时处理异常场景、及时扩容场景、站点监控、自定义监控 主机监控的应用 混合云场景下监控解决方案云监控通过插件采集用户服务器监控数据，该插件支持安装在非ECS服务器上，解决云上下双重环境的基础监控问题 企业级用户的监控解决方案主机监控提供应用分组功能，支持将阿里云不同地域的服务器分配在同一分组中，真正从业务角度管理服务器。同时，提供分组维度的报警功能管理能力，一次规则设置可以作用全组，极大提升监控运维效率和管理体验 自定义监控 提供了自由定义监控项及报警规则的功能 可以针对自己关心的业务指标进行监控，将采集到的监控数据上报至云监控，由云监控来进行数据处理，并根据处理结果进行报警 事件监控与自定义监控的区别：事件监控用于解决非连续的事件类型数据监控数据上报、查询与报警的场景，而自定义监控用于解决周期性持续采集的时间序列监控数据上报、查询与报警的场景 模拟CPU占用场景 12345// 安装压力测试工具yum install –y stress// 执行压力测试命令stress --cpu 8 --io 4 --vm 2 --vm-bytes 128M --timeout 10m// 查看用户的邮箱，将会收到报警邮件 阿里云云监控支持非阿里云主机的监控，需要手动安装插件","categories":[{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"What is Data Science?","slug":"What-is-Data-Science","date":"2021-05-01T16:00:00.000Z","updated":"2022-05-05T13:06:47.850Z","comments":true,"path":"What-is-Data-Science/","link":"","permalink":"http://blog.zhuangzhihao.top/What-is-Data-Science/","excerpt":"The art of uncovering the insights and trends in data has been around since ancient times. The ancient Egyptians used census data to increase efficiency in tax collection and they accurately predicted the flooding of the Nile river every year. Since then, people working in data science have carved out a unique and distinct field for the work they do. This field is data science. This course provided by IBM gives me a chance to get an overview of what data science is today. The following are the notes I took during this course.","text":"The art of uncovering the insights and trends in data has been around since ancient times. The ancient Egyptians used census data to increase efficiency in tax collection and they accurately predicted the flooding of the Nile river every year. Since then, people working in data science have carved out a unique and distinct field for the work they do. This field is data science. This course provided by IBM gives me a chance to get an overview of what data science is today. The following are the notes I took during this course. Defining Data Science Data science is the field of exploring, manipulating, and analyzing data, and using data to answer questions or make recommendations. Data Science can help organizations to understand their environments, analyze existing issues, and reveal previously hidden opportunities. Data scientists can use powerful data visualization tools to help stakeholders understand the nature of the results, and the recommended action to take. Data Science is changing the way we work; it’s changing the way we use data and it’s changing the way organizations understand the world. There are many paths to a career in data science; most, but not all, involve a little math, a little science, and a lot of curiosity about data. New data scientists need to be curious, judgmental and argumentative. Data Science: The Sexiest Job in the 21st Century What Do Data Scientists Do? A day in the Life of a Data Scientist: to discover optimum solutions to existing problems Old problems, new problems, Data Science solutions Identify the problem and establish a clear understanding of it. Gather the data for analysis. Identify the right tools to use. Develop a data strategy. Case studies are also helpful in customizing a potential solution. Data Science Topics and Algorithms Regression、Data visualization、Artificial neural networks、Structured data Using complicated machine learning algorithms does not always guarantee achieving a better performance. Accessing algorithms, tools, and data through the Cloud enables Data Scientists to stay up-to-date and collaborate easily. Big Data and Data Mining Foundations of Big Data Big Data refers to the dynamic, large and disparate volumes of data being created by people, tools, and machines. It requires new, innovative, and scalable technology to collect, host, and analytically process the vast amount of data gathered in order to derive real-time business insights that relate to consumers, risk, profit, performance, productivity management, and enhanced shareholder value. The V’s of Big Data: Velocity、Volume、Variety、Veracity、Value Hadoop and other tools, combined with distributed computing power, are used to handle the demands of Big Data. Big Data is driving digital transformation Most of the components of data science, such as probability, statistics, linear algebra, and programming, have been around for many decades but now we have the computational capabilities to apply combine them and come up with new techniques and learning algorithms. Data Science Skills &amp; Big Data Data Mining: the process of automatically searching and analyzing data, discovering previously unrevealed patterns. It involves preprocessing the data to prepare it and transforming it into an appropriate format. Deep Learning and Machine Learning Data Science is the process and method for extracting knowledge and insights from large volumes of disparate data, it’s a broad term encompass the entire data processing methodology. AI includes everything that allows computers to learn how to solve problems and make intelligent decisions. Machine learning is a subset of AI that uses computer algorithms to analyze data and make intelligent decisions based on what it is learned without being explicitly programmed. Machine learning algorithms are trained with large sets of data and they learn from examples. They do not follow rules-based algorithms. Machine learning is what enables machines to solve problems on their own and make accurate predictions using the provided data. Deep learning is a specialized subset of machine learning that uses layered neural networks to simulate human decision-making. Deep learning algorithms can label and categorize information and identify patterns. It is what enables AI systems to continuously learn on the job and improve the quality and accuracy of results by determining whether decisions were correct. A neural network in AI is a collection of small computing units called neurons that take incoming data and learn to make decisions over time. Neural networks are often layer-deep and are the reason deep learning algorithms become more efficient as the data sets increase in volume, as opposed to other machine learning algorithms that may plateau as data increases. Machine Learning has many applications, from recommender systems that provide relevant choices for customers on commercial websites, to detailed analysis of financial markets. (Predictive analytics、Decision trees、Bayesian Analysis、Naive Bayes、Recommendations) Regression Data Science in Business Data Science helps physicians provide the best treatment for their patients, and helps meteorologists predict the extent of local weather events, and can even help predict natural disasters like earthquakes and tornadoes. That companies can start on their data science journey by capturing data. Once they have data, they can begin analyzing it. Applications of Data Science: Recommendation engine、Siri、Google The purpose of the final deliverable of a Data Science project is to communicate new information and insights from the data analysis to key decision-makers. Careers and Recruiting in Data Science Data Scientists need programming, mathematics, and database skills, many of which can be gained through self-learning. Companies recruiting for a Data Science team need to understand the variety of different roles Data Scientists can play, and look for soft skills like storytelling and relationship building as well as technical skills. Curiosity is one of the most important skills that a data scientist should possess. High school students considering a career in Data Science should learn programming, math, databases, and most importantly practice their skills. The Report Structure The length and content of the final report will vary depending on the needs of the project. The structure of the final report for a Data Science project should include a cover page, table of contents, executive summary, detailed contents, acknowledgements, references and appendices. The report should present a thorough analysis of the data and communicate the project findings.","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[]},{"title":"搭建 LAMP 环境安装部署 Wordpress","slug":"云上搭建WordPress","date":"2021-04-30T16:00:00.000Z","updated":"2022-05-23T10:37:34.342Z","comments":true,"path":"云上搭建WordPress/","link":"","permalink":"http://blog.zhuangzhihao.top/%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAWordPress/","excerpt":"最近购买了阿里云学生机（轻量应用服务器，单核2G内存），预装载CentOS 7.6。官方推荐Putty连接，我使用的SSH软件为Xshell，用Xftp传输文件。第一次接触云服务器，在云主机上搭建 LAMP 环境并部署 Wordpress 博客应用，仅供测试参考。","text":"最近购买了阿里云学生机（轻量应用服务器，单核2G内存），预装载CentOS 7.6。官方推荐Putty连接，我使用的SSH软件为Xshell，用Xftp传输文件。第一次接触云服务器，在云主机上搭建 LAMP 环境并部署 Wordpress 博客应用，仅供测试参考。 连接服务器 打开Xshell，填写主机IP、用户名（root）、密码 命令行出现：Welcome to Alibaba Cloud Elastic Compute Service ! 安装Apache HTTP服务 Apache是世界使用排名第一的Web服务器端软件，它可以运行在几乎所有广泛使用的计算机平台上，Apache由于其跨平台和安全性被广泛使用 安装Apache服务及其扩展包 1yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysql 启动Apache服务 1systemctl start httpd.service 访问IP地址，出现Apache测试页面 Apache默认监听80端口 安装 MySQL 数据库 使用wordpress搭建云上博客，需要使用MySQL数据库存储数据 下载并安装MySQL官方的Yum Repository 12345wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm//三行分开输入yum -y install mysql57-community-release-el7-10.noarch.rpmyum -y install mysql-community-server 启动 MySQL 数据库 1systemctl start mysqld.service 查看MySQL运行状态（显示Active: active） 1systemctl status mysqld.service 查看MySQL初始密码 1grep &quot;password&quot; /var/log/mysqld.log 登陆MySQL数据库 1mysql -u root -p 修改MySQL密码 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;新密码&#x27;; 创建wordpress数据库 12create database wordpress; show databases; #查看数据库是否已创建 输入exit退出数据库 安装PHP语言环境 WordPress是使用PHP语言开发的博客平台，PHP是全世界最好的语言(→_→) 安装PHP环境 1yum -y install php php-mysql gd php-gd gd-devel php-xml php-common php-mbstring php-ldap php-pear php-xmlrpc php-imap 创建PHP测试页面 1echo &quot;&lt;?php phpinfo(); ?&gt;&quot; &gt; /var/www/html/phpinfo.php 重启Apache服务 1systemctl restart httpd 访问IP地址/phpinfo.php，显示PHP测试页面 安装配置Wordpress 安装Wordpress 1yum -y install wordpress 进入/usr/share/wordpress目录 1cd /usr/share/wordpress 修改wp-config.php指向路径为绝对路径 1ln -snf /etc/wordpress/wp-config.php wp-config.php 使用ll查看修改后的目录结构 在Apache的根目录/var/www/html下，创建一个wp-blog文件夹 1mkdir /var/www/html/wp-blog 移动wordpress到Apache根目录 1mv * /var/www/html/wp-blog/ 修改wp-config.php配置文件 123sed -i &#x27;s/database_name_here/wordpress/&#x27; /var/www/html/wp-blog/wp-config.phpsed -i &#x27;s/username_here/root/&#x27; /var/www/html/wp-blog/wp-config.phpsed -i &#x27;s/password_here/数据库密码/&#x27; /var/www/html/wp-blog/wp-config.php 查看文件配置是否修改成功 1cat -n /var/www/html/wp-blog/wp-config.php 重启Apache服务 1systemctl restart httpd 测试Wordpress 访问IP地址/wp-blog/wp-admin/install.php 访问IP地址/wp-blog/即为WordPress页面","categories":[{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"IBM Data Analyst Capstone Project","slug":"IBM-Data-Analyst-Capstone-Project","date":"2021-04-02T16:00:00.000Z","updated":"2022-06-07T14:02:55.713Z","comments":true,"path":"IBM-Data-Analyst-Capstone-Project/","link":"","permalink":"http://blog.zhuangzhihao.top/IBM-Data-Analyst-Capstone-Project/","excerpt":"In this course provided by IBM, I will assume the role of an Associate Data Analyst who has recently joined the organization and be presented with a business challenge that requires data analysis to be performed on real-world datasets. The capstone project will culminate with a presentation of your data analysis report, with an executive summary for the various stakeholders in the organization. I believe this project is a great opportunity to showcase Data Analytics skills, and demonstrate proficiency to potential employers. The following are the notes I took during this course.","text":"In this course provided by IBM, I will assume the role of an Associate Data Analyst who has recently joined the organization and be presented with a business challenge that requires data analysis to be performed on real-world datasets. The capstone project will culminate with a presentation of your data analysis report, with an executive summary for the various stakeholders in the organization. I believe this project is a great opportunity to showcase Data Analytics skills, and demonstrate proficiency to potential employers. The following are the notes I took during this course. Data CollectionCollecting Data Using APIs The HTTP protocol allows you to send and receive information through the web including webpages, images, and other web resources. Uniform resource locator(URL): the most popular way to find resources on the web Scheme: http:// Internet address or Base URL: www.ibm.com Route location on the web server: /images/IDSNlogo.png Request Request start line = GET method + location of the resource /index.html + HTTP version Request header passes additional information with an HTTP request Response Response start line = version number HTTP/1.0 + a status code (200) meaning success, + a descriptive phrase (OK). Response header contains useful information Response body containing the requested file an HTML document Requests in Python 12345678910111213141516171819202122232425import requestsimport os from PIL import Imagefrom IPython.display import IFrame#GET request //# Use single quotation marks for defining stringurl=&#x27;https://www.ibm.com/&#x27; r=requests.get(url)#status of the requestr.status_code #view request headers //r.request.bodyprint(r.request.headers) #HTTP response headerheader=r.headers #obtain the dateheader[&#x27;date&#x27;] #obtain the type of dataheader[&#x27;Content-Type&#x27;] r.encoding#view textr.text[0:100] #write content(image)path=os.path.join(os.getcwd(),&#x27;image.png&#x27;)with open(path,&#x27;wb&#x27;) as f: f.write(r.content)Image.open(path) Get Request with URL Parameters You can use the GET method to modify the results of your query 1234567url_get=&#x27;http://httpbin.org/get&#x27;#To create a Query string, add a dictionary.payload=&#123;&quot;name&quot;:&quot;Joseph&quot;,&quot;ID&quot;:&quot;123&quot;&#125; r=requests.get(url_get,params=payload)r.url #&#x27;http://httpbin.org/get?name=Joseph&amp;ID=123&#x27;#key args in JSON formatr.json()[&#x27;args&#x27;] Post Requests the POST request sends the data in a request body 12345url_post=&#x27;http://httpbin.org/post&#x27;r_post=requests.post(url_post,data=payload)r_post.url r_post.request.bodyr_post.json()[&#x27;form&#x27;] Collecting Data Using Webscraping Review of Webscraping 12345678910111213from bs4 import BeautifulSoup # this module helps in web scrapping.import requests # this module helps us to download a web pageurl = &quot;http://www.ibm.com&quot;# get the contents of the webpage in text format and store in a variable called datadata = requests.get(url).text # create a soup object using the variable &#x27;data&#x27;soup = BeautifulSoup(data,&quot;html5lib&quot;) # in html anchor/link is represented by the tag &lt;a&gt;for link in soup.find_all(&#x27;a&#x27;): print(link.get(&#x27;href&#x27;))# in html image is represented by the tag &lt;img&gt;for link in soup.find_all(&#x27;img&#x27;): print(link.get(&#x27;src&#x27;)) Scrape data from html table 123456789101112131415url = &quot;https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DA0321EN-SkillsNetwork/labs/datasets/HTMLColorCodes.html&quot;# get the contents of the webpage in text format and store in a variable called datadata = requests.get(url).text soup = BeautifulSoup(data,&quot;html5lib&quot;)# in html table is represented by the tag &lt;table&gt;table = soup.find(&#x27;table&#x27;) # in html table row is represented by the tag &lt;tr&gt;for row in table.find_all(&#x27;tr&#x27;): # in html a column is represented by the tag &lt;td&gt; cols = row.find_all(&#x27;td&#x27;) # store the value in column 3 as color_name color_name = cols[2].getText() # store the value in column 4 as color_code color_code = cols[3].getText() print(&quot;&#123;&#125;---&gt;&#123;&#125;&quot;.format(color_name,color_code)) Exploring Data Load the dataset 123import pandas as pddataset_url = &quot;https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DA0321EN-SkillsNetwork/LargeData/m1_survey_data.csv&quot;df = pd.read_csv(dataset_url) Explore the dataset 12345678910111213#Display the top &amp; bottom 5 rows and columns from your datasetdf.head() df.tail()#The number of rows in the dataset.df.shape[0] #The number of columns in the dataset.df.shape[1] #Print the datatype of all columns.df.dtypes #Print the mean age of the survey participants.df[&quot;Age&quot;].mean()#Print how many unique countries are there in the Country column.df[&quot;Country&quot;].nunique() Data Wrangling Load the dataset 12import pandas as pddf = pd.read_csv(&quot;https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DA0321EN-SkillsNetwork/LargeData/m1_survey_data.csv&quot;) Finding Duplicates 1234567#Find how many duplicate rows exist in the dataframe.df.duplicated(keep=&#x27;first&#x27;).sum() #Show duplicated rowsduplicateRows = df[df.duplicated()] duplicateRows #numbers of duplicate values in the column Respondentdf[&quot;Respondent&quot;].duplicated(keep=&#x27;first&#x27;).sum() Removing Duplicates 12345678#Remove the duplicate rows from the dataframe.df.drop_duplicates(ignore_index=True, inplace=True) #Verify if duplicates were actually dropped.df.duplicated(keep=&#x27;first&#x27;).sum() #number of rows and columns leftdf.shape #numbers of unique rows left in the column Respondentdf[&quot;Respondent&quot;].nunique Finding Missing Values 1234#Find the missing values for all columns.df.isnull().sum() #Find out how many rows are missing in the column EdLeveldf[&quot;EdLevel&quot;].isnull().sum() Determine Missing Values 123456#Find the value counts for the column WorkLoc.df[&quot;WorkLoc&quot;].value_counts() #Impute (replace) all the empty rows in the column WorkLoc with the value that you have identified as majority.df[&quot;WorkLoc&quot;].fillna(value=&quot;Office&quot;,inplace=True) #After imputation there should ideally not be any empty rows in the WorkLoc column.df[&quot;WorkLoc&quot;].isnull().sum() Normalizing Data 12345678910111213141516#List out the various categories in the column &#x27;CompFreq&#x27;df[&quot;CompFreq&quot;].unique() #If the CompFreq is Yearly then use the exising value in CompTotaldf[&quot;CompFreq&quot;].replace(to_replace=&quot;Yearly&quot;,value=1,inplace=True) #If the CompFreq is Monthly then multiply the value in CompTotal with 12 (months in an year)df[&quot;CompFreq&quot;].replace(to_replace=&quot;Monthly&quot;,value=12,inplace=True) #If the CompFreq is Weekly then multiply the value in CompTotal with 52 (weeks in an year)df[&quot;CompFreq&quot;].replace(to_replace=&quot;Weekly&quot;,value=52,inplace=True) df[&quot;CompFreq&quot;].unique()df[&quot;CompFreq&quot;].value_counts()#it makes comparison of salaries easy.df[&#x27;NormalizedAnnualCompensation&#x27;] = df[&quot;CompTotal&quot;] * df[&quot;CompFreq&quot;] df[&quot;Respondent&quot;].nunique()df[&quot;ConvertedComp&quot;].describe()df[&quot;ConvertedComp&quot;].hist(figsize=(15,4))df[&#x27;NormalizedAnnualCompensation&#x27;].median() Exploratory Data Analysis Import necessary modules 123456import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns%matplotlib inlinedf = pd.read_csv(&quot;https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DA0321EN-SkillsNetwork/LargeData/m2_survey_data.csv&quot;) Distribution: Determine how the data is distributed 1234567891011121314151617#Plot the distribution curve for the column ConvertedCompplt.figure(figsize=(10,5))sns.distplot(a=df[&quot;ConvertedComp&quot;],bins=20,hist=False)plt.show()#Plot the histogram for the column ConvertedCompplt.figure(figsize=(10,5))sns.distplot(a=df[&quot;ConvertedComp&quot;],bins=20,kde=False)plt.show()#the median of the column ConvertedCompdf[&quot;ConvertedComp&quot;].median()#number of responders identified themselves only as a Mandf[&quot;Gender&quot;].value_counts()#the median number of ConvertedComp of responders identified themselves only as a Womanwoman = df[df[&quot;Gender&quot;] == &quot;Woman&quot;]woman[&quot;ConvertedComp&quot;].median()#five number summary for the column Agedf[&quot;Age&quot;].describe() Outliers 1234567891011121314151617181920212223#Find out if outliers exist in the column ConvertedComp using a box plotplt.figure(figsize=(10,5))sns.boxplot(x=df.ConvertedComp, data=df)plt.show()#Find out the Inter Quartile Range for the column ConvertedCompdf[&quot;ConvertedComp&quot;].describe()#Find out the upper and lower bounds.Q1 = df[&quot;ConvertedComp&quot;].quantile(0.25)Q3 = df[&quot;ConvertedComp&quot;].quantile(0.75)IQR = Q3 - Q1print(IQR)#Identify how many outliers are there in the ConvertedComp columnoutliers = (df[&quot;ConvertedComp&quot;] &lt; (Q1 - 1.5 * IQR)) | (df[&quot;ConvertedComp&quot;] &gt; (Q3 + 1.5 * IQR))outliers.value_counts()less = (df[&quot;ConvertedComp&quot;] &lt; (Q1 - 1.5 * IQR))less.value_counts()more = (df[&quot;ConvertedComp&quot;] &gt; (Q3 + 1.5 * IQR))more.value_counts()#Create a new dataframe by removing the outliers from the ConvertedComp columnRemoveConvertedcomp = df[~(df[&quot;ConvertedComp&quot;] &gt; (Q3 + 1.5 * IQR))]RemoveConvertedcomp.head()RemoveConvertedcomp[&quot;ConvertedComp&quot;].median()RemoveConvertedcomp[&quot;ConvertedComp&quot;].mean() Correlation: Find the correlation between all numerical columns 1df.corr() Data Visualization Work with Database 12345678910111213141516171819202122232425262728293031323334353637!wget https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-DA0321EN-SkillsNetwork/LargeData/m4_survey_data.sqliteimport sqlite3import pandas as pd# open a database connectionconn = sqlite3.connect(&quot;m4_survey_data.sqlite&quot;) # print how many rows are there in the table named &#x27;master&#x27;QUERY = &quot;&quot;&quot;SELECT COUNT(*)FROM master&quot;&quot;&quot;# the read_sql_query runs the sql query and returns the data as a dataframedf = pd.read_sql_query(QUERY,conn)df.head()# print all the tables names in the databaseQUERY = &quot;&quot;&quot;SELECT name as Table_Name FROMsqlite_master WHEREtype = &#x27;table&#x27;&quot;&quot;&quot;# the read_sql_query runs the sql query and returns the data as a dataframepd.read_sql_query(QUERY,conn)#run a group by queryQUERY = &quot;&quot;&quot;SELECT Age,COUNT(*) as countFROM mastergroup by ageorder by age&quot;&quot;&quot;pd.read_sql_query(QUERY,conn)#Describe a tabletable_name = &#x27;master&#x27; # the table you wish to describeQUERY = &quot;&quot;&quot;SELECT sql FROM sqlite_masterWHERE name= &#x27;&#123;&#125;&#x27;&quot;&quot;&quot;.format(table_name)df = pd.read_sql_query(QUERY,conn)print(df.iat[0,0]) Visualizing Distribution of Data Relationship Composition Comparison Dashboard Creation IBM Cognos Dashboard Embedded (CDE) is an AI-fueled business intelligence service that supports the entire data analytics cycle, from discovery to operationalization. It provides users with data discovery capabilities to visually explore and interact with their data to identify the key insights for improving data driven decisions. Users can perform data discovery and then quickly assemble that information into interactive, visually appealing dashboards; all without the need of formal training. Add a Cognos Dashboard Embedded (CDE) service and upload external data files to your project (supports CSV file only) General navigation around the CDE user interface (UI), start a new dashboard with a template in CDE, populate it with a data visualization as well as save the dashboard. Presentation of Findings Data collected, cleaned and organized -&gt; Report (paper style report or slideshow presentation) Elements Of A Successful Data Findings Report Outline Cover Page Executive Summary: briefly explain the details of the project and should be considered a stand-alone document Table of Contents Introduction: explains the nature of the analysis, states the problem, and gives the questions that were to be answered by performing the analysis Methodology: explains the data sources that were used in the analysis and outlines the plan for the collected data Results: goes into the detail of the data collection, how it was organized, and how it was analyzed, also contain the charts and graphs that would substantiate the results and call attention to the more complex or crucial findings Discussion: engage the audience with a discussion of your implications that were drawn from the research Conclusion: reiterate the problem given in the introduction and gives an overall summary of the findings, also state the outcome of the analysis and if any other steps would be taken in the future Appendix: contain information that really didn’t fit in the main body of the report, but you deemed it was still important enough to include Factors to remember in accurately conveying your message Make sure charts and graphs are not too small and are clearly labeled Use the data only as supporting evidence Share only one point from each chart Eliminate data that does not support the key message Final Presentation Assignments Visit my Github Repository","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.zhuangzhihao.top/tags/SQL/"}]},{"title":"Data Analysis With Python","slug":"Data-Analysis-with-Python","date":"2021-03-26T16:00:00.000Z","updated":"2022-05-05T12:55:25.675Z","comments":true,"path":"Data-Analysis-with-Python/","link":"","permalink":"http://blog.zhuangzhihao.top/Data-Analysis-with-Python/","excerpt":"This Data Analysis with Python course provided by IBM is designed to teach future data analysts how to prepare data for analysis, perform simple statistical analysis, create meaningful data visualizations, predict future trends from data through a number of lecture, lab, and assignments using Python libraries. The following are the notes I took during this course.","text":"This Data Analysis with Python course provided by IBM is designed to teach future data analysts how to prepare data for analysis, perform simple statistical analysis, create meaningful data visualizations, predict future trends from data through a number of lecture, lab, and assignments using Python libraries. The following are the notes I took during this course. Importing Datasets Data, Dataset &amp; Attributes in the dataset Python Packages for Data Science Scientifics Computing Libraries: Pandas, NumPy, SciPy Visualization Libraries: Matplotlib, Seaborn Algorithmic Libraries: Scikit-learn, Statsmodels Importing Data: Format &amp; File Path of dataset 123456import pandas as pdurl = &quot;&quot;df = pd.read_csv(url, header = None) #create dataframedf.head(n) #shows the first n rows while df.tail(n) shows the bottom n rowspath = &quot;&quot;df.to_csv(path) #exporting dataframe, you can also use df.to_json() / df.to_excel() / df.to_sql() Data Types df.dtypes Checks datatypes df.describe(include=&quot;all&quot;) Returns a statistical summary df.info() Provides a concise summary of dataframe Accessing Databases with Python (DB-API) Data Wrangling Pre-processing Data in Python = Data Cleaning = Data Wrangling Dealing with Missing Values Drop: df.dropna(subset=[&quot;column_name&quot;], axis=0, inplace=True) Replace: df.replace(missing_value, new_value) Mean: df[&quot;column_name&quot;].mean() Data Formatting 123df[&quot;city-mpg&quot;] = 235/df[&quot;city-mpg&quot;]df.rename(columns=(&quot;city_mpg&quot;: &quot;city-L/100km&quot;), inplace=True)df[&quot;city-L/100km&quot;]=df[&quot;city-L/100km&quot;].astype(&quot;float&quot;) dataframe.astype() Converts data type Data Normalization Simple Feature scaling: $x{new}=\\dfrac{x{old}}{x_{max}}$ 1df[&quot;length&quot;]=df[&quot;length&quot;]/df[&quot;length&quot;].max() Min - Max: $x{new}=\\dfrac{x{old}-x{min}}{x{max}-x_{min}}$ 1df[&quot;length&quot;]=(df[&quot;length&quot;]-df[&quot;length&quot;].min())/(df[&quot;length&quot;].max()-df[&quot;length&quot;].min()) Z-score (Standard Score): $x{new}=\\dfrac{x{old}-\\mu}{\\sigma }$ z-score values typically range between [-3,3] 1df[&quot;length&quot;]=(df[&quot;length&quot;]-df[&quot;length&quot;].mean())/df[&quot;length&quot;].std() Binning: Converts numeric into categorical variables by Grouping them in a set of “bins” 123bins=np.linspace(min(df[&quot;price&quot;]),max(df[&quot;price&quot;]),4)group_names=[&quot;Low&quot;,&quot;Medium&quot;,&quot;High&quot;]df[&quot;price-binned&quot;]=pd.cut(df[&quot;price&quot;],bins,labels=group_names,include_lowest=True) Turning categorical variables into quantitative variables Convert categorical variables into dummy variables (0 or 1) pd.get_dummies(df[&#39;fuel&#39;]) Exploratory Data Analysis (EDA) EDA is preliminary step in data analysis to summarize main characteristics of the data, gain better understanding of the data set, uncover relationships between different variables, and extract important variables for the problem we’re trying to solve. Descriptive Statistics Describe basic features of data Giving short summaries about the sample and measures of the data df.describe Summarize statistics, value_counts() Summarize the categorical data 1wheels_counts=df[&quot;wheels&quot;].value_counts().to_frame() Box Plot 1sns.boxplot(x=&quot;wheels&quot;,y=&quot;price&quot;,data=df) Scatter Plot 123456y=df[&quot;price&quot;]x=df[&quot;engine-size&quot;]plt.scatter(x,y)plt.title(&quot;Scatterplot of Engine Size vs Price&quot;)plt.xlabel(&quot;Engine Size&quot;)plt.ylabel(&quot;Price&quot;) GroupBy The groupby method is used on categorical variables, groups the data into subsets according to the different categories of that variable. 123df_test=df[[&#x27;drive-wheels&#x27;,&#x27;body-style&#x27;,&#x27;price&#x27;]]df_grp=df_test.grop[by([&#x27;drive-wheels&#x27;,&#x27;body-style&#x27;], as_index= False).mean()df_grp Pivot table 1df_pivot=df_grp.pivot(index=&#x27;drive-wheels&#x27;,columns=&#x27;body-style&#x27;) Heatmap 123plt.pcolor(df_pivot,cmap=&#x27;RdBu&#x27;)plt.colorbar()plt.show() Correlation Correlation measures to what extent different variables are interdependent Correlation doesn’t imply causation Linear Relationship 123import seaborn as snssns.regplot(x=&quot;engine-size&quot;,y=&quot;price&quot;,data=df)plt.ylim(0,) Correlation - Statistics Pearson Correlation: Measure the strength of the correlation between two features (Correlation coefficient &amp; P-value) Correlation coefficient close to +1: Large Positive relationship, close to -1: Large Negative relationship, close to 0: No relationship P-value &lt; 0.001: Strong certainty in the result, &lt; 0.05: Moderate certainty in the result, &lt; 0.1: Weak certainty in the result, &gt; 0.1: No certainty in the result 1pearson_coef, p_value=stats.pearsonr(df[&#x27;horsepower&#x27;],df[&#x27;price&#x27;]) Correlation-Heatmap Chi-Square: Test for Association The Chi-square test is intended to test how likely it is that an observed distribution is due to chance. It measures how well the observed distribution of data fits with the distribution that is expected if the variables are independent. The Chi-square does not tell you the type of relationship that exists between both variables only that a relationship exists. $X^{2}=\\sum^{n}{i=1}\\dfrac{\\left(O{i}-E{i}\\right)^{2}}{E{i}}$ Degree of freedom = (row-1) * (column-1) 1scipy.stats.chi2_contingency(cont_table, correction = True) Model Development A model can be thought of as a mathematical equation used to predict a value given one or more other values, relating one or more independent variables to dependent variables Usually the more relevant data you have the more accurate your model is Linear regression will refer to one independent variable to make a prediction Multiple Linear Regression will refer to multiple independent variables to make a prediction Simple Linear Regression (SLR) The predictor (independent) variable - x, The target (dependent) variable - y $b{0}$: the intercept, $b{1}$: the slope $y=b{0}+b{1}x$ Fit: $\\left( b{0},b{1}\\right)$ 12345678from sklearn.linear_model import LinearRegressionlm=LinearRegression() #create a linear regression object using the constructorx=df[[&#x27;highway-mpg&#x27;]] #define the predictor variable and target variabley=df[&#x27;price&#x27;]lm.fit(x,y) #fit the modelYhat=lm.predict(X) #obtain a predictionlm.intercept_ #view the interceptlm.coef_ #view the slope Multiple Linear Regression (MLR) One continuous target (Y) variables, Two or more predictor (X) variables $\\widehat{Y}=b{0}+b{1}x{1}+b{2}x{2}+b{3}x{3}+b{4}x_{4}$ $b{0}$: interception (x=0), $b{1}$: the coefficient or parameter of $x{1}$, $b{2}$: the coefficient of parameter $x_{2}$ and so on 12345Z=df[[&#x27;horsepower&#x27;,&#x27;curb-weight&#x27;,&#x27;engine-size&#x27;,&#x27;highway-mpg&#x27;]] #extract predictor variables and store them in the variable Z (dataframe)lm.fit(Z, df[&#x27;price&#x27;]) #train the modelYhat=lm.predict(X) #obtain a predictionlm.intercept_ #view the interceptlm.coef_ #view the slope Model Evaluation using Visualization Regression plots are a good estimate of the relationship between two variables, the strength of the correlation, and the direction of the relationship (positive or negative) Regression plot shows a combination of scatterplot and the fitted linear regression line ($\\widehat{Y}$) 123import seaborn as snssns.regplot(x=&quot;highway-mpg&quot;,y=&quot;price&quot;,data=df)plt.ylim(0,) Residual plot represents the error between the actual value 12import seaborn as snssns.resifplot(df[&#x27;highway-mpg&#x27;],df[&#x27;price&#x27;]) Distribution plot counts the predicted value versus the actual value MLR - Distribution plots 123import seaborn as snsax1=sns.displot(df[&#x27;price&#x27;],hist=False,color=&#x27;r&#x27;,label=&#x27;Actual Value&#x27;)sns.distplot(Yhat,hist=False,color=&#x27;b&#x27;,label=&#x27;Fitted Values&#x27;,ax=axl) Polynomial Regression and Pipelines Polynomial regression is a special case of the general linear regression model, useful for describing curvilinear relationships Curvilinear relationship: By squaring or setting higher order terms of the predictor variables Quadrac - 2nd order: $\\widehat{Y}=b{0}+b{1}x{1}+b{2}(x_{1})^2$ Cubic - 3rd order: $\\widehat{Y}=b{0}+b{1}x{1}+b{2}(x{1})^2+b{3}(x_{1})^3$ 123f=np.polyfit(x,y,3) #calculate polynomial of 3rd orderp=np.polyld(f)print(p) #print out the model We could also have multi-dimensional polynomial linear regression: $\\widehat{Y}=b{0}+b{1}x{1}+b{2}x{2}+b{3}x{1}x{2}+b{4}(x{1})^2+b{5}(x{3})^2+..$ 123from sklearn.preprocessing import PolynomialFeaturespr=PolynomialFeatures(degree=2,include_bias=False)x_polly=pr.fit_transform(x[[&#x27;horsepower&#x27;,&#x27;curb-weight&#x27;]]) Pre-processing 1234from sklearn.preprocessing import StandardScalerSCALE=StandardScaler()SCALE.fit(x_data[[&#x27;horsepower&#x27;,&#x27;curb-weight&#x27;]])x_scale=SCALE.transform(x_data[[&#x27;horsepower&#x27;,&#x27;curb-weight&#x27;]]) Pipelines: transform -&gt; prediction 1234567from sklearn.preprocessing import PolynomialFeaturesfrom sklearn.linear_model import LinearRegressionfrom sklearn.preprocessing import StandardScalerfrom sklearn.pipeline import PipelineInput=[(&#x27;Scale&#x27;,StandardScaler()),(&#x27;polynomial&#x27;,PolynomialFeatures(degree=2),(&#x27;mode&#x27;,LinearRegression()))]Pipe.fit(df[[&#x27;horsepower&#x27;,&#x27;curb-weight&#x27;,&#x27;engine-size&#x27;,&#x27;highway-mpg&#x27;]],y) #train the pipeline objectyhat=Pipe.predict(X[[&#x27;horsepower&#x27;,&#x27;curb-weight&#x27;,&#x27;engine-size&#x27;,&#x27;highway-mpg&#x27;]]) Measures for In-Sample Evaluation A way to numerically determine how good the model fits on our data Mean Squared Error (MSE) 12from sklearn.metrics import mean_squared_errormean_squared_error(df[&#x27;price&#x27;],Y_predict_simple_fit) R-squared: The coefficient of determination R-squared is a measure to determine how close the data is to the fitted regression line R^2: the percentage of variation of the target variable (Y) that is explained by the linear model $R^{2}=\\left( 1-\\dfrac{MSE-of-regression-line}{MSE-of-the-average-of-the-data}\\right)$ 12lm.fit(X,Y)lm.score(X,y) Generally the values of the MSE are between 0 and 1 R^2 = 0 indicates your model performs worst Prediction and Decision Making 123lm.fit(df[&#x27;highway-mpg&#x27;],df[&#x27;prices&#x27;]) #Train the modellm.predict(np.array(30.0).reshape(-1,1)) #Predict the pricelm.coef_ #Value of the Slope Residual Plot 123import numpy as npnew_input=np.arrange(1,101,1).reshape(-1,1) #Arrange to generate sequenceyhat=lm.predict(new_input) #Predict new values Numerical measures for Evaluation Comparing MLR and SLR: A lower Mean Square Error does not necessarily imply better fit Mean Square Error for a Multiple Linear Regression Model will be smaller than the Mean Square Error for a Simple Linear Regression model, since the errors of the data will decrease when more variables are included in the model Polynomial regression will also have a smaller Mean Square Error than the linear regular regression Model Evaluation and Refinement In-sample evaluation tells us how well our model will fit the data used to train it Build and train the model with a training set (70% dataset) Use testing set to access the performance of a predictive model (30% dataset) Function train_test_split(): Split data into random train and test subsets x_data: features or independent variables, y_data: dataset target (df[&#39;price&#39;]) x_train, y_train: parts of available data as training set 12from sklearn.model_selection import train_test_splitx_train,x_test,y_train,y_test=train_test_split(x_data,y_data,test_size=0.3,random_state=0) Generalization error is measure of how well our data does at predicting previously unseen data, the error we obtain using our testing data is an approximation of this error. Lots of training data Cross Validation Most common out-of-sample evaluation metrics More effective use of data (each observation is used for both training and testing) Function cross_val_score() 123from sklearn.model_selection import cross_val_scorescores=cross_val_score(lr,x_data,y_data,cv=3)np.mean(scores) Function cross_val_predict() It returns the prediction that was obtained for each element when it was in the test set 12from sklearn.model_selection import cross_val_score #Has a similar interface to cross_cal_score()scores=cross_val_score(lr,x_data,y_data,cv=3) Model Selection: y(x)+noise Underfitting: Where the model is too simple to fit the data. Overfitting: Where the model is too flexible and fits the noise rather than the function Ridge regression A regression that is employed in a Multiple regression model when Multicollinearity occurs Multicollinearity is when there is a strong relationship among the independent variables Ridge regression is very common with polynomial regression 1234from sklearn.linear_model import RidgeRidgeModel=Ridge(alpha=0.1)RidgeModel.fit(X,y)Yhat=RidgeModel.predict(X) Grid Search allows us to scan through multiple free parameters with few lines of code. Hyperparameters: Parameters that are not part of the fitting or training process. (eg. Ridge regression) Scikit-learn has a means of automatically iterating over these hyperparameters using cross-validation called Grid Search Training data、Validation data、Test data 12345678910from sklearn.linear_model import Ridgefrom sklearn.model_selection import GridSearchCVparameters1=[&#123;&#x27;alpha&#x27;:[0.001,0.1,1,10,100,1000,10000,100000,1000000]&#125;]parameters2=[&#123;&#x27;alpha&#x27;:[0.001,0.1,1,10,100],&#x27;normalize&#x27;:[True,False]&#125;]RR=Ridge()Grid1=GridSearchCV(rr,parameters1,cv=4)Grid1.fit(x_data[[&#x27;horsepower&#x27;,&#x27;curb-weight&#x27;,&#x27;engine-size&#x27;,&#x27;highway-mpg&#x27;]],y_data)Grid.best_estimator_scores=Grid.cv_results_scores[&#x27;mean_test_score&#x27;] Project Case Determining the market price of a house given a set of features Final Assignment Notebook Url (May not be accessible from Mainland China) Assignments Visit my Github Repository","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[]},{"title":"2021 阿里云 Java 训练营第三期","slug":"Java高级训练营","date":"2021-03-25T16:00:00.000Z","updated":"2022-06-07T13:46:13.069Z","comments":true,"path":"Java高级训练营/","link":"","permalink":"http://blog.zhuangzhihao.top/Java%E9%AB%98%E7%BA%A7%E8%AE%AD%E7%BB%83%E8%90%A5/","excerpt":"本期训练营是阿里云开发者社区Java训练营的第3期，主要基于最流行的Java Spring Cloud, 结合阿里巴巴淘宝微服务案例，实战模拟淘宝Order微服务，实战演练微服务开发，扩展学习Spring Cloud Alibaba新框架，本篇日志主要记录5天直播Spring cloud微服务开发课中的一些知识点，附实战代码。","text":"本期训练营是阿里云开发者社区Java训练营的第3期，主要基于最流行的Java Spring Cloud, 结合阿里巴巴淘宝微服务案例，实战模拟淘宝Order微服务，实战演练微服务开发，扩展学习Spring Cloud Alibaba新框架，本篇日志主要记录5天直播Spring cloud微服务开发课中的一些知识点，附实战代码。 微服务架构设计与实践 架构演化之路：单体 -&gt; 分层 -&gt; 分布式 -&gt; SOA -&gt; 微服务 微服务架构Microservice 一种新型的软件架构风格，把单个巨型服务应用分解为多个独立微小的服务程序，每个小服务程序运行在独立的进程中 服务与服务之间通过轻量协议通信，通信机制互相协作、互相配合，从而为终端用户提供业务价值 每个小服务可以采用不同的语言、框架、工具独立开发、测试、部署、运维 单独部署、单独伸缩，去中心化：数据中心、管理中心，敏捷性、灵活性、需求变化，更加高效的软件架构模式 微服务优缺点 快速响应需求变化，易于替换，独立进程、开发、部署、测试，无依赖 高度解耦，基于功能进行组织，独立技术栈、服务可以使用不同的语言、系统、平台 协议简单，通信使用语言中立的协议，通常是http 架构复杂，多服务运维难度大，系统部署依赖和服务间通信成本高 敏捷开发、敏捷运维DevOps 微服务典型应用场景：淘宝、支付宝、微信、微博、IOT、游戏、导航 Eureka微服务注册与发现 服务注册与发现：Service Registry and Discovery 大规模微服务集群架构，拥有许多服务实例，客户端要找到自己调用的服务 新服务上线或莫格服务宕机，下线时可以实时监控服务的状态 Spring Cloud Eureka服务发现与注册 Eureka：注册中心，服务发现模块，是Nexflix的核心（开源的项目），竞争对手：ZooKeeper 一个基于REST的中心服务，管理服务，实现云端的服务注册和服务发现 Eureka组件组成：Eureka服务器和Eureka客户端 Spring Cloud Nextflix提供简化开发模板，直接使用Spring Boot创建项目，添加@EnableEurekaServer开发注册服务中心 Spring Eureka注册中心实战 创建Spring Eureka服务注册中心项目，添加@EnableEurekaServer，将Spring Boot应用改造成Eureka服务注册中心，application.properties增加配置，打包项目并运行测试 参考https://spring.io/guides/gs/service-registeration-and-discovery 123456spring.application.name=EurekaServerserver.port=8761eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/#\\u6CE8\\u518C\\u548C\\u67E5\\u8BE2\\u63A7\\u5236eureka.client.fetch-registry=falseeureka.client.register-with-eureka=false Spring Cloud2020 微服务架构 Spring Cloud Netflix Greenwich以上（2.1.X）版本相对成熟，企业使用多，容易落地架构 Spring Cloud Alibaba相对成熟，部分组件可以替换 新版本2020（aka Ilford）可以作为拓展学习，基于Spring Boot2.4及以上版本，Bootstrap默认禁用，慎重选择新版本 开发微服务API 配置Eureka客户端项目 12345spring.application.name=order-microserviceserver.port=8001eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/eureka.client.fetch-registry=falseeureka.client.register-with-eureka=true Feign声明式调用客户端 调用方，简化微服务API调用 Feign是一种声明式、模板化的HTTP客户端，简化HTTP客户端开发 只需要创建一个接口 + @注解（Feign注解和JAX-RS注解） Feign支持可插拔的编码器和解码器，默认集成了Ribbon，并和Eureka结合 Eureka Server、Eureka Client + Feign，mvn package打包 @EnableFeignClients 调用方FeignClient代理接口代码 12345@FeignClient(value=&quot;microservice&quot;)public interface GreetingClient&#123; @RequestMapping(&quot;/greeting&quot;) public String greeting();&#125; 调用方Feign配置 1234567spring.application.name=FeignClientserver.port=9000eureka.client.enabled=trueeureka.client.register-with-eureka=trueeureka.client.fetch-registry=trueeureka.instance.non-secure-port-enabled=trueeureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/ 调用方测试代码 123456789@RestControllerpublic class TestController &#123; @Autowired private GreetingClient clientproxy; @RequestMapping(&quot;/hi&quot;) public String hi() &#123; return clientproxy.hi(); &#125;&#125; Ribbon负载均衡算法 Spring Cloud客户端负载均衡器Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法 Ribbon将Netflix的中间层服务连接在一起 Ribbon客户端组件提供许多配置如连接超时、重试等 配置文件中列出后台所有的机器，Ribbon会自动去连接这些机器（如简单轮询、随即连接等） Spring Cloud使用Ribbon实现自定义的负载均衡算法 默认规则：简单轮询负载均衡RoundRobin 随机负载均衡Random随机选择UP的Server 加权响应时间负载均衡WeightResponseTime 区域感知轮询负载均衡ZoneAware Hystrix微服务监控 Netflix Hystrix熔断器框架保护系统，通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力，防止服务器过载、系统雪崩 Fallback灾备操作，出错以后返回的值 Hystrix中，主要通过线程池来实现资源隔离，Hystrix的信号模式Semaphores隔离资源，熔断代码，@EnableHystrix Hystrix支持dashoboard控制面板监控信息：独立部署http://localhost:9001/hystrix，也可以Zuul，`@EnableHystrixDashboard` 监控数据源：http://localhost:9001/actuator/hystrux.stream Feign可以和Hystrix结合使用，也可以独立使用 Pom依赖：spring-cloud-starter-hystrix、spring-cloud-starter-hystrix-dashboard Spring Cloud Hoxton版本后需要特殊配置 Hystrix底层原理：使用命令模式对命令对象抽象了两个抽象类：HystrixCommand和HystrixObservableCommand 1234567#启用监控熔断限流feign.hystrix.enabled=true#暴露监控数据源地址management.endpoints.web.exposure.include=*#info,health,thread#允许展示监控服务器hystrix.dashboard.proxy-stream-allow-list=localhost,192.168.1.101 Hystrix核心参数 请求最大次数（默认20个请求）circuitBreaker.requestVolumnThreshold 滚动窗口（默认10秒）metrics.rollingStats.timeInMilliseconds 失败百分比（默认&gt;50%）circuitBreaker.errorThreasholdPercentage Zuul网关 Zuul是Netflix开源的微服务网关工具，可以和Eureka、Ribbon、Hystrix等组件配合使用 Spring Cloud对Zuul进行了整合与增强，旨在实现动态路由、监视、弹性和安全性 默认使用Apache HTTP Client作为HTTP客户端，也可以使用RestClient或okhttp3.OkHttpClient Zuul默认会为Eureka注册的服务创建动态路由 Zuul在2.x/3.x的分支中已经引入netty Zuul网关特性 验证和安全 Authentication and Security 跟踪、统计和监控 Insights and Monitoring 动态路由消息到后台集群 Dynamic Routing 压力测试主机递增 Stress Testing 过载保护 Load Shedding 静态消息处理，无需后台集群服务器处理 Static Response handling 多区域弹性伸缩，跨AWS区域路由请求，分散压力，请求处理更接近调用者 Multiregion Resiliency Zuul依赖 spring-cloud-starter-zuul、spring-cloud-starter-eureka 添加注解 @EnableZuulProxy，Zuul内部使用Ribbon实现客户端负载均衡 Spring Cloud Gateway替代Zuul Nacos服务注册与发现 Dynamic Naming and Configuration Service Nacos关键特性：服务发现和服务健康监测、动态配置服务、动态DNS服务、服务及其元数据管理 相对于Eureka：同时支持AP和CP模型、跨中心同步、k8s基成、分组管理、权重设置 三种部署模式：单机模式、集群模式、多集群模式 Alibaba微服务组件：Sentinel、Nacos、RocketMQ、Dubbo、Seata Sentinel熔断限流 分布式系统的流量防卫兵，流量控制、熔断降级、系统负载保护等多维度保护服务的稳定性 相对于Hystrix支持基于调用关系的限流、流量整形、系统负载保护 123456789spring.application.name: nacos-feign-sentinel#服务器端口server.port:9001spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848#sentinelspring.cloud.sentinel.transport.dashboard=127.0.0.1:8080feign.sentinel.enabled=true#监控数据源要暴露地址management.endpoints.web.exposure.include=* 课程代码 课程代码已上传 Github 仓库","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://blog.zhuangzhihao.top/tags/Spring-Cloud/"}]},{"title":"2021 阿里云 Java 训练营第二期","slug":"Java中级训练营","date":"2021-03-11T16:00:00.000Z","updated":"2022-06-07T13:46:02.622Z","comments":true,"path":"Java中级训练营/","link":"","permalink":"http://blog.zhuangzhihao.top/Java%E4%B8%AD%E7%BA%A7%E8%AE%AD%E7%BB%83%E8%90%A5/","excerpt":"本期训练营是继Java新手训练营后的第2期，课程由阿里云开发者社区提供，同样采用5天不间断直播授课的形式，主要内容为Spring Boot 2.5自动化配置原理、实战开发REST API、MySQL数据库、Redis高并发缓存、MQ消息队列Kafka、安全机制、Docker容器等，本篇日志主要记录实战Spring Boot2.5开发中的一些常用知识点，附实战代码。","text":"本期训练营是继Java新手训练营后的第2期，课程由阿里云开发者社区提供，同样采用5天不间断直播授课的形式，主要内容为Spring Boot 2.5自动化配置原理、实战开发REST API、MySQL数据库、Redis高并发缓存、MQ消息队列Kafka、安全机制、Docker容器等，本篇日志主要记录实战Spring Boot2.5开发中的一些常用知识点，附实战代码。 Java Spring 企业级开发平台 最初来自2002年Rod Jahnson所著书《Expert One-on-One J2EE Design and Development》,最早名字为：Interface21 2003年6月诞生轻量级Java企业级开发工具类库Spring，现在已经发展成为包括开发工具、MVC框架、类库、微服务架构的完整平台（体系） 一个轻量级控制反转（IoC）和面向切面（AOP）的容器框架，一个分层的JavaSE/EE full-stack（一站式）轻量级开源框架 Spring提供IOC、AOP、日志、安全、加密等工具类库，用于解决企业应用开发的复杂性 Spring Framework：Spring工具类框架，其他Spring项目如Spring Boot也依赖于此框架 Spring MVC：Java MVC网站开发框架 Spring Boot：简化Spring应用开发。简化配置文件，使用嵌入式web服务器，含有诸多开箱即用微服务功能，可以和Spring Cloud联合部署 Spring Cloud：微服务框架，为开发者提供分布式系统的配置管理、服务发现、路器、智能路由、微代理、控制总线等开发工具包 Spring Data：数据访问框架，封装了很多种数据及数据库的访问相关技术，包括JDBC、Redis、MongoDB、Neo4J等 Spring REST Shell：可以调用Rest服务的命令行工具，命令行操作Rest服务 Spring Boot发展历史 联合创始人：Rod Jahnson、Juergen Hoeller、Yann Caroff Thomas Risberg&amp;Spring JDBC、Keith Donald&amp;Spring MVC、Adrain Coyler&amp;Spring AOP 2014年4月开始发布Spring Boot2.0的1.0.0版本 配合模板和框架来简化Spring项目开发，轻松创建具有最小或零配置的独立应用程序的方式，它提供默认的代码和注释配置，只需要非常少的配置就能进行Java Spring应用开发 Spring Boot = Auto-Dependency Resolution + Auto-Configuration ＋Management Endpoints + Embedded HTTP Servers (Tomcat, Jetty) Spring Boot 2.5.0加入startup endpoint支持GET请求、info endpoint安全改进、支持Java16等新特性 实战Spring Boot 2.4 在线创建Spring项目 开发环境：Open JDK，Eclipse需要添加Spring Tools 4插件，IDEA自带 start.spring.io 连接失败可使用 start.alibaba.com 源替代 Spring Web（Tomcat）：http://localhost:8080/hello REST API 123456789@RestController@SpringBootApplicationpublic class JavaSpringBoot01HelloWorldDemoApplication &#123; public static void main(String[] args)&#123;SpringApplication.run(JavaSpringBoot01HelloWorldDemoApplication.class, args);&#125; @RequestMapping(&quot;/hello&quot;) //公开http接口，默认端口8080，可在application.properties中修改 public String hello() &#123; String s = &quot;Hello Spring Boot&quot;; return s;&#125;&#125; 修改端口和context path（appilcation.properties文件） 1234spring.application.name=&#x27;JavaSpringBoot212&#x27;server.servlet.contextPath=/SpringBootserver.host=&#x27;localhost&#x27;server.port=&#x27;8080&#x27; 自动化配置Autoconfig底层原理 Spring Boot auto configuration根据classpath的jar依赖自动配置Spring应用 @SpringBootApplication注解 等于三大注解：@EnableAutoConfiguration + @ComponentScan + @Configuration之和 @Configuration将该注解类标记为应用程序上下文的bean来源 @EnableAutoConfiguration告诉Spring Boot自动配置添加bean 通常手动为Spring MVC应用程序添加@EnableWebMvc，但Spring Boot会在类路径上看到spring-webmvc时自动添加该注解，为Web应用添加并启用关键特性，例如设置DispatcherServlet @ComponentScan告诉Spring扫描组件，配置和服务，控制器 Auto-configuration is non-invasive 非侵入式 自动配置也可以被禁用 自动化配置机制核心：spring-boot-autoconfigure.jar + spring.factories Springboot启动（依赖、配置）-&gt; 自动化依赖（解析、加载）-&gt; 自动化配置（工厂模式创建Bean、依赖注入）-&gt; 自动化服务器（内置Web Server、监听） AutoConfigurationPackages.Registrar 注册存储客户端配置包列表的bean，可通过AutoConfigurationPackages.get（BeanFactory）静态方法访问 ImportSelector导入选择器负责引导自动配置机制：@Import(EnableAutoConfigurationImportSelector.class) spring.autoconfigure.exclude 属性控制要排除的自动配置类列表 监控自动注入的Bean 123456789@Bean public CommandLineRunner commandLineRunner(ApplicationContext ctx)&#123; return args -&gt; &#123; System.out.println(&quot;监控Spring Boot 2.0自动注入的Bean:&quot;); String[] beanNames =ctx.getBeanDefinitionNames(); Arrays.sort(beanNames); for (String beanName : beanNames)&#123; System.out.println(&quot;Spring自动注入Bean:&quot;+beanName);&#125; &#125;;&#125; 使用Spring Data连接MySQL数据库 Spring Data快速数据访问框架、强大的repository仓储和自定义对象映射ORM抽象，提供统一的编程模型 通过JavaConfig和自定义XML命名空间轻松实现Spring集成与Spring MVC控制器的高级集成，实验支持跨库持久性 Spring Boot实战MySQL Spring JDBC and JdbcTemplate Spring Data简化连接不同的数据库 Spring Data JPA连接MySQL，默认底层使用Hibernate framework，支持Repository仓储模式 引入最重要的两个包：spring-boot-starter-data-jpa和mysql-connector-jave Spring Data JPA框架 Spring Data JPA简化数据访问层的开发工作，基于Spring和JPA构建存储库的完美支持 支持Querydsl谓词，从而支持类型安全的JPA查询，在引导时验证@Query带注释的查询 支持Domain类的透明审核，分页支持，动态查询执行，集成自定义数据访问代码的能力 支持基于XML的实体映射，引入@EnableJpaRepositories，基于JavaConfig的存储库配置 MongoDB 4.0数据库 阿里巴巴MongoDB高级实战 NoSQL排名第一的分布式数据库，由C++语言编写，特点是高性能、高并发、易部署、易使用、存储数据非常方便（灵活的数据模型），旨在为Web应用提供可扩展的高性能数据存储解决方案 MongoDB开源、跨平台，支持Windows、Linux、OS X和Solaris系统，集成内存缓存，自动分片储存，支持分布式查询和跨文档事务，便于横向扩展 Repository仓储层代码 1234public interface BlogRepository extends MongoRepository&lt;Blog, ObjectId&gt;&#123; public Blog findById(ObjextId id); public void delete(ObjectId id); public List&lt;Blog&gt; findAll();&#125; 启动命令：.\\mongod.exe --port 27017 --dbpath=&quot;../data&quot; --logpath=&quot;../log/mongo.log&quot; 命令行控制 1234show dbsuse databasedb.users.insert(&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;&#125;)db.users.find() 可视化管理工具：Compass、Robo 3T（Robomongo） Redis分布式缓存6.0 三层架构+高并发缓存：前端（UI界面）-&gt; 后台（API接口+Services业务逻辑+DAO数据访问）-&gt; 数据（MongoDB+MySQL/Oracle/SQLServer+Redis） Redis API：org.springframework.data.redis.connection包，RedisConnection，RedisConnectionFactory Interface RedisConnection解析为Redis通信提供核心组件，处理与Redis服务器后端的通信 配置参数：RedisConnectionFactory工厂模式，RedisTemplate：RedisConnection对象，Repository：Connection Pool RedisTemplate Interface：GeoOperations，HashOperations，HyperLogLogOperations，ListOperations，SetOperations，ValueOperations，ZSetOperations Redis默认接口：6379（最好安装在Linux系统） Redis6.0配置文件redis.conf里默认的IP配置，要改掉才能远程链接（改成 bind 0.0.0.0） 安全机制 自定义实现安全验证 Spring Security开源框架 专注于身份验证和授权，保护Spring应用系统的安全标准 提供安全认证服务的框架 Authetication验证和Authorization收起 Apache Shiro开源框架 简单易用的开源Java安全框架，可应用于Web和非Web环境 Basic、Form、OAuth、LDAP、Kerberos、X509、Token验证 WebSecurityConfig：配置安全规则，默认启用basic验证 全站安全验证配置 REST API帮助文档Swagger Spring REST Docs（离线，不好用） Swagger自动化文档工具 一个完整的API生态，工具，规范，代码规范 Swagger依赖：springfox-swagger2， 应用程序性能监控（Admin&amp;Actuator） 环境、bean、版本、内存、日志、指标、配置、JVM、GC 性能监控和管理组件Actuator 使用HTTP Endpoint或JMX，运行状态指标数据收集 默认监控EndPoint：http://localhost:8080/Actuator management.endpoints.web.exposure.include=* Micrometer：多维度指标收集器，语言中立的API（可采集数据图形） Spring Boot Admin Server：开发监控服务端 management.endpoints.health.show-details Docker容器 Spring Boot Docker Hub 阿里云Docker镜像仓库（国内第一）提供Docker Images镜像加速 DockerFIle：Docker镜像配置文件 Build Docker Image with Maven：mvn clean package dockerfile:build 课程代码 课程代码已上传 Github 仓库","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.zhuangzhihao.top/tags/Spring-Boot/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.zhuangzhihao.top/tags/MySQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.zhuangzhihao.top/tags/MongoDB/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.zhuangzhihao.top/tags/Redis/"}]},{"title":"听林纳斯聊聊 Linux 背后的思想","slug":"Linux背后的思想","date":"2021-03-11T16:00:00.000Z","updated":"2022-06-05T14:25:47.633Z","comments":true,"path":"Linux背后的思想/","link":"","permalink":"http://blog.zhuangzhihao.top/Linux%E8%83%8C%E5%90%8E%E7%9A%84%E6%80%9D%E6%83%B3/","excerpt":"Linus Torvalds，一个任何极客都不会陌生的名字，Linux之父、Git之父，大神在计算机领域的影响力可以说是划时代的。那么在这些传奇的背后蕴藏着怎样的思想呢？下面这个Linus2016年时在TED上接受的一次访谈或许能让我们对Linux背后的思想略窥一二。","text":"Linus Torvalds，一个任何极客都不会陌生的名字，Linux之父、Git之父，大神在计算机领域的影响力可以说是划时代的。那么在这些传奇的背后蕴藏着怎样的思想呢？下面这个Linus2016年时在TED上接受的一次访谈或许能让我们对Linux背后的思想略窥一二。 一、传奇的诞生1991年的8月25日，一个刚进入赫尔辛基大学不久的21岁学生在学校的邮箱列表中公开了这样一封邮件：“What would you like to see most in minix —— small poll for my new operation system”，在邮件中他这么写道：“我正在开发一个（免费的）操作系统 …… 这只是出于爱好，不会像gnu那样庞大和专业 …… 我现在已经移植了bash和gcc …… 看起来几个月之内就会有实质性的进展”。1991年9月，他通过大学的FTP服务器发布了这个叫Freax的操作系统，随后它被重新命名为我们今天所熟知的名字：Linux。 时至今日，我想我们已无需再多去赘述Linux产生的影响和它划时代的意义，我更想来聊聊的是Linus另一个对世界影响至深的理念——开源。 Software is like sex, It‘s better when it’s free. —— Linus Torvalds 26年后，当Linus描述起一开始建立Linux项目时的工作情况，他说：“Linux最初并不是一个团队合作的产物”，这个操作系统最初只是作为众多为他自己服务的一系列项目中的一个，仅仅是一个因为个人需要而开发的产物。接下来当项目逐渐成长起来，需要获得别人的一些认可和意见，他才逐渐把源码放开，“我已经在这个项目上努力半年了，快来看看我的成果”。在那时，也没有使用什么开源方法或是改进项目的手段，只是不同的人贡献了一些不同的代码，让你觉得，“噢，我从来没有想过可以这样，这样竟然可以让项目获得改进”。不久之后，Linus将其加入了FSF（ 自由软件基金 ）的 GNU 计划中，使用流行的开源许可证，避免了商业或其他的因素参与导致的负面影响，也同时允许用户合法的免费使用、拷贝并且改动程序。今天，Linux 内核是地球上目前为止最活跃的开源项目，是服务器端处于支配地位的操作系统，是 Android 的基础。世界上所有的超级计算机都跑在 Linux 上，包括 NASA 的集群和SpaceX的引擎。 二、开源的力量最开始的时候，人们并不是向项目直接贡献代码，人们更多的是贡献自己的想法。Linus原本是不喜欢有人打扰自己的工作的，对他来说，哪怕是电脑主机都不需要性能多强劲，只需要做到绝对的安静就好。所以当人们开始评论、开始对代码提供反馈信息的时候，突然就会让人耳目一新，这是一种崭新的时刻，“I Love Other People”！ 不知道为何，好像所有的Geek都不是社交达人，Linus的姐姐（或许是妹妹）说过，他最大的异常特征是从不参与众人的行动，独自沉浸在计算机，沉浸在数学，沉浸在物理学这些他擅长的领域中。不过开源最核心的理念之一就是它非常鼓励不同的人一起合作，不见得需要互相喜欢对方，甚至可能互相都瞧不上，但是大家可以有非常热烈的非常专业的争论，这就是开源的魅力。 早期，Linus是担心商业带来的负面影响的，所以他反对软件专利，认为商业人士是来利用你的工作的。但是，他渐渐发现这些商业人士完成了他完全不感兴趣的事情，在完全基于不同的目标，商业使用开源的方式只是专注技术的大神自己刚好不想走的路，“我关心技术，同时有些人关心UI，但我不会去做UI来拯救我的人生。如果我被困在岛屿上，同时唯一的脱困方式是做一个漂亮的UI，那我肯定会死在那儿的”。Linus自己也承认，如果没有全力投入到开源，并且真得放开手，Linux永远也不可能是现在的样子。可能像谷歌这样的公司利用Linus的开源软件赚了好几亿美元，但对他自己来说，他做了正确的选择。 时至今日，开源机制能够运转良好，其中很重要的一个缘故是代码可以将所有的事情都转化为黑和白（1和0）。通常这样利于作出决定，代码要么执行，要么不执行，因此意味着更少的争议空间。当然，你也能将同样的原则应用到其它领域的一些地方（比如科研、学术），因为黑色和白色混合在一起不只是变成灰色，而是很多不同的颜色。 三、优雅的品味在Coding的领域，你不仅仅只需要打代码，还要对代码有好的品位。我们可以看看下面这个调用单向链表的例子： 你是希望用if语句有一个特殊情况处理一个特殊情况， 12345678910111213void remove_list_entry(entry)&#123; prev = NULL; walk = head; // Walk the list while (walk != entry)&#123; prev = walk; walk = walk-&gt;next; &#125; //Remove the entry by updating the head or the previous entry if(!prev) head = entry-&gt;next; else prev-&gt;next = entry-&gt;next;&#125; 还是直接通过指针变量指向next地址？ 123456789void remove_list_entry(entry)&#123; //The &quot;indirect&quot; pointer points to the address of the thing we&#x27;ll update indirect = &amp;head; //Walk the list,looking for the thing that points to the entry we want to remove while ((*indirect) != entry) indirect = &amp;(*indirect)-&gt;next; *indirect = entry-&gt;next // .. and just remove it&#125; CS 101，当碰到一个问题时，可以通过不同的方式被重写，移除一个特殊的情形恢复正常，就是好的代码。 “Good taste is much bigger than clever or stupid. Good taste is about really seeing the big patterns and kind of instinctively knowing what’s the right way to do things.” 四、脚踏实地人们常常把特斯拉和爱迪生拿来对比。特斯拉是有远见的有疯狂创意的科学家，人们爱特斯拉（不然怎么满大街的毛豆3呢）。爱迪生则是一个常常被批评为乏味的人。但大神更崇尚后者，“Genius is one percent inspiration and 99 percent perspiration”，爱迪生也许不是一个很好的人，但他的努力帮助他完成很多不平凡的事情。 “I am not a visionary, I do not have a five-year plan. I’m an engineer. And I’m perfectly happy with all the people who are walking around and just staring at the clouds and looking at the stars and saying, ‘I want to go there’. But I’m looking at the ground, and I want to fix the pothole that’s right in front of me before I fall in. This is the kind of person I am“。 五、笔者的其他一些废话“I do code for fun, but I also want to code for something meaningful”，纵观整篇访谈，这是让我印象最深的一句话。技术是为了实现目标、解决问题而存在的，我始终相信，我们创造出的每一个程序都应该有自己存在的价值和意义。大家是不是都听过一种说法，CV工程师，复制—&gt;粘贴，每天重复、机械的劳动，就和10年前的文员一样，整天CRUD，却离自己的初心渐行渐远。这是在尊重技术，还是只是为了名和利呢？ 在知乎上看到这样一句话，让人感慨良多，它是这么说的：开源让更多人获取到技术，同时也让该技术和会该技术的劳动力变的廉价，以至于在资本家的眼里，那根本不叫技术。可能这的确是事实，大环境也决并非独立个体所能改变的，我们改变不了攫取价值的资本家，所能做的只是尽力向Linus那样去创造价值、贡献价值，To Make Someting Useful and Meaningful。我想，我们努力奋斗是为了更好地实践、创造和分享，这才是我们应有的初衷，这才是我们存在的意义。 第一次写长文，难免有些生疏，有些语句不通也请见谅。遗憾自己书读的还是不够多，见识还是不够广，唯有加紧努力让拥有的能力赶上自己的心气。访谈的原视频放在下面了，有什么问题欢迎及时指正。 六、TED 访谈视频","categories":[{"name":"观点与感想","slug":"观点与感想","permalink":"http://blog.zhuangzhihao.top/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.zhuangzhihao.top/tags/Linux/"}]},{"title":"51 单片机基础知识总结","slug":"51单片机基础","date":"2021-03-07T16:00:00.000Z","updated":"2022-05-23T09:48:23.927Z","comments":true,"path":"51单片机基础/","link":"","permalink":"http://blog.zhuangzhihao.top/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%9F%BA%E7%A1%80/","excerpt":"单片机（MCU）是典型的嵌入式微控制器，通过在IC芯片上集成运算器、控制器以及IO接口，也就相当于一个小而完善的微型计算机系统。单片机的学习可以和计算机组成原理、汇编语言、微机原理与接口技术和计算机体系结构等计算机专业课程有机结合，加深对于硬件的理解。我使用的是普中51开发板，以下是我在学习和实战过程中对单片机基础知识的整理总结，源代码保存在 Github 仓库中，可供参考。","text":"单片机（MCU）是典型的嵌入式微控制器，通过在IC芯片上集成运算器、控制器以及IO接口，也就相当于一个小而完善的微型计算机系统。单片机的学习可以和计算机组成原理、汇编语言、微机原理与接口技术和计算机体系结构等计算机专业课程有机结合，加深对于硬件的理解。我使用的是普中51开发板，以下是我在学习和实战过程中对单片机基础知识的整理总结，源代码保存在 Github 仓库中，可供参考。 单片机预备知识 电平特性：数字电路只有两种电平（高和低） 单片机TTL电平：高+5V、低0V RS232电平（计算机的串口）：高-12V、低+12V 计算机与单片机之间通讯时需要加电平转换芯片max232 二进制：由数字电路中的两种电平特性决定 十六进制：二进制的简短表示方式（四个二进制转换成一个十六进制），例：0001B -&gt; 1H 二进制的逻辑运算 ”与“运算：· “或”运算：+ ”非“运算：〒 “异或”运算：⊕ 位运算符：&gt;&gt;位右移、&lt;&lt;位左移、&amp;按位与、|按位或、^按位异或、~按位取反 C51数据类型扩充定义 sfr：特殊功能寄存器声明 sfr SCON = 0X98; sfr16：sfr的16位数据声明 sfr16 T2 = 0xCC; sbit：特殊功能位声明 sbit 0V = PSW^2; bit：位变量声明 bit flags 一般来说char定义单个字符，unsigned char定义数组 C51头文件：reg51.h、reg52.h（定义特殊功能寄存器和位寄存器），math.h（定义常用数学计算），ctype.h、stdio.h、stdlib.h、absacc.h 单片机介绍 单板机：将CPU芯片、存储器芯片、I/O接口芯片和简单的I/O设备装配在一块印刷电路板上，将监控程序固化在ROM中，从而构成的单板微型计算机 单片机：在一片集成电路芯片上集成微处理器、存储器、I/O接口电路，从而构成的单芯片微型计算机 Intel MCS-51系列单片机：集成8位CPU、4K 字节 ROM、128字节RAM、4个8位并口、1个全双工串行口、2个16位定时/计数器。寻址范围64K，有控制功能较强的布尔处理器 总线（BUS）：计算机各部件之间传送信息的公共通道 内部总线：CPU内部之间的连线 外部总线：CPU与其他部件之间的连线。外部总线分为：数据总线DB（Data Bus）、地址总线AB（Address Bus）、控制总线CB（Control Bus） CPU：由运算和控制逻辑组成，同时还包括中断系统和部分外部特殊功能寄存器 RAM：用以存放可以读写的数据，如运算的中间结果、最终结果以及欲显示的数据 ROM：用以存放程序、一些原始数据和表格 I/O 口：四个 8 位并行 I/O 口，既可用作输入，也可用作输出 T/C：两个定时/记数器，既可以工作在定时模式，也可以工作在计数模式 五个中断源的中断控制系统 一个全双工 UART（通用异步接收发送器）的串行 I/O 口，用于实现单片机之间或单片机与微机之间的串行通信 片内振荡器和时钟产生电路，石英晶体和微调电容需要外接。最佳振荡频率为 6M—12M 80C51系列：以8051为基核开发出的CMOS工艺单片机，是MCS-51系列中的一个典型品种 中断服务程序 12函数名() interrupt n using m&#123; 函数内部实现; &#125; I/O口定义：sbit beep = P2^3; 单片机最小系统能够运行起来的必要条件： 电源电路 晶振电路（提供时钟脉冲） 复位电路（提供系统复位操作） 对单片机任意IO口的随意操作：1.输出控制电平高低、2.输入检测电平高低 定时器 中断：外部中断、定时器中断、串口中断 串口通信：单片机之间、单片机与计算机间 KEIL C51软件和51硬件仿真器 1234567#include &quot;reg52.h&quot; //0 Error,0 Warningvoid main()&#123; while(1) &#123; &#125;&#125; 点亮发光管 GPIO（genral purpose intput output）：通用输入输出端口，可以通过软件来控制其输入和输出 51单片机芯片的GPIO引脚与外部设备连接起来，从而实现与外部通讯、 控制以及数据采集的功能 STC89C52的引脚 电源引脚：VC、 GND 晶振引脚：XTAL1、XTAL2 复位引脚：RST、VPD，不做其他功能使用 串口功能引脚：TXD、RXD，可以作为下载引脚使用 GPIO 引脚：带有 Px. 字样的均属于 GPIO 引脚 同一时刻，每个引脚只能使用该引脚的一个功能 上下拉电阻的作用： 上拉电阻就是将不确定的信号通过一个电阻拉到高电平，同时此电阻起到一个限流的作用，下拉就是下拉到低电平 OC门要输出高电平，外部必须加上拉电阻 加大普通IO口的驱动能力 起到限流的作用 抵抗电磁干扰 GPIO外围电路 当I/O口被用作输入用途时，读取输入前要保证锁存器状态为 1 当将I/O口由低拉高时，指令执行后需要1~2个机器周期才能使实际的输出变成高电平 51 单片机所有 IO 口都是双向的，即可以作为输入也可以作为输出使用 由于 P0 口是漏极开路的，所以要操作 P0 口必须外接上拉电阻，其他P1、P2、P3 口都内部自带上拉电阻，可以不加，如果要增强 IO 口驱动能力，可以外接上拉电阻 LED：发光二极管，具有单向导电性，通常在LED管脚上串联一个限流电阻 发光二极管发光时两端电压约为1.7V，这个电压又叫做发光二极管的“导通压降” 对于 LED 这种一次性操作的器件来说，可以把控制语句放在while之前来执行 Code表示程序所占用 FLASH 的大小，dat表示数据储存器内部 RAM 占用大小，xdat表示数据储存器外部 RAM 占用大小 程序的大小不是 .hex 文件的大小，而是编译后的 Code 和 dat 之和 LED闪烁（延时函数） 移位函数：左移_crol_()、右移`_cror()`函数（实现LED流水灯） 其他实验 由于篇幅关系，其他实验程序代码放在 Github 仓库中，如需自取","categories":[{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"Data Visualization With Python","slug":"Data-Visualization-with-Python","date":"2021-03-05T16:00:00.000Z","updated":"2022-05-05T12:55:50.962Z","comments":true,"path":"Data-Visualization-with-Python/","link":"","permalink":"http://blog.zhuangzhihao.top/Data-Visualization-with-Python/","excerpt":"One of the key skills of a data scientist is the ability to tell a compelling story, visualizing data and findings in an approachable and stimulating way. Learning how to leverage a software tool to visualize data will helps one understand the data better, and make more effective decisions. The main goal of this Data Visualization with Python course provided by IBM is to use various techniques and several data visualization libraries in Python, namely Matplotlib, Seaborn, and Folium for presenting data visually. The following are the notes I took during this course.","text":"One of the key skills of a data scientist is the ability to tell a compelling story, visualizing data and findings in an approachable and stimulating way. Learning how to leverage a software tool to visualize data will helps one understand the data better, and make more effective decisions. The main goal of this Data Visualization with Python course provided by IBM is to use various techniques and several data visualization libraries in Python, namely Matplotlib, Seaborn, and Folium for presenting data visually. The following are the notes I took during this course. Introduction to Data Visualization Tools Why Build Visuals? For exploratory data analysis Communicate data clearly Share unbiased representation of data Use them to support recommendations to different stakeholders Less is more (more effective, attractive and impactive) Matplotlib (History and Architecture): Created by John Hunter Backend Layer has three built-in abstract interface classes: FigureCavas, Renderer, Event Artist Layer is comprised of one main object - Artist. Title, lines, tick labels, images all correspond to individual Artist instances. Two types of Artist objects: Primitive (Line2D, Rectangle, Circle and Text), Composite (Axis, Tick, Axes and Figure) 12345678910from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas # import FigureCanvasfrim matplotlib.figure import Figure # import Figure artistfig = Figure()canvvas = FigureCanvas(fig)import numpy as np #create 10000 random numbers using numpyx = np.random.randn(10000)ax = fig.add_subplot(111) # create an axes artistax.hist(x, 100) # generate a histogram of the 10000 numbersax.set_title(&#x27;Normal distribution with $\\mu=0, \\sigma=1$&#x27;) # add a title to the figure and save itfig.savefig(&#x27;matplotlib_histogram.png&#x27;) Scripting Layer is comprised mainly of pyplot, ascripting interface that is lighter that the Artist layer. 123456import matplotlib.pyplot as pltimport numpy as npx = np.random.randn(10000)plt.hist(x, 100)plt.title(r&#x27;Normal distribution with $\\mu=0, \\sigma=1$&#x27;) plt.savefig(&#x27;matplotlib_histogram.png&#x27;)plt.show() Basic Plotting with Matplotlib Plot Function 1234567%matplotlib inline # pass in inline as the backend to enforce plots to be rendered within the browserimport matplotlib.pyplot as pltplt.plot(5, 5, &#x27;o&#x27;)plt.ylabel(&quot;Y&quot;)plt.xlabel(&quot;x&quot;)plt.title(&quot;Plotting Example&quot;)plt.show() Matplotlib - Pandas 12df.plot(kind=&quot;line&quot;) # create a line plotdf[&quot;column&quot;].plot(kind=&quot;hist&quot;) # create a histogram Line Plots A line plot is a type of plot which displays information as a series of data points called ‘makers’ connected by straight line segments. Creating line plots 12345678import matplotlib as mplimport matplotlib.pyplot as pltyears = list(map(str, range(1980, 2014)))df_canada.loc[&#x27;Haiti&#x27;, years].plot(kind=&#x27;line&#x27;)plt.title(&#x27;Immigration from Haiti&#x27;)plt.ylabel(&quot;Number of immigrants&quot;)plt.xlabel(&quot;Years&quot;)plt.show() Basic and Specialized Visualization Tools Area Plots (based on line plot) Also known as area chart or area graph, is commonly used to represent cumulated totals using numbers or percentages over time Area plots are stacked by default. 1234567891011import matplotlib as mplimport matplotlib.pyplot as pltyears=list(map(str,range(1980,2014)))df_canada.sort_values([&#x27;Total&#x27;], ascending=False, axis=0, inplace=True)df_top5=df_canada.head()df_top5=df_top5[years].transpose()df_top5.plot(kind=&#x27;area&#x27;)plt.title(&#x27;Immigration trend of top 5 countries&#x27;)plt.ylabel(&quot;Number of immigrants&quot;)plt.xlabel(&quot;Years&quot;)plt.show() Histograms A histogram is a way of representing the frequency distribution of a numeric dataset. 123456789import matplotlib as mplimport matplotlib.pyplot as pltimport numpy as npcount, bin_edges=np.histogram(df_canada[&#x27;2013&#x27;]) # numpy functiondf_canada[&#x27;2013&#x27;].plot(kind=&#x27;hist&#x27;, xticks=bin_edges)plt.title(&#x27;Histogram of Immigration from 195 countries in 2013&#x27;)plt.ylabel(&quot;Number of Countries&quot;)plt.xlabel(&quot;Number of immigrants&quot;)plt.show() Bar Charts Unlike a histogram, a bar chart is a type of plot where the length of each bar is proportional to the value of the item that it represents. It is commonly used to compare the values of a variable at a given point in time. 123456789import matplotlib as mplimport matplotlib.pyplot as pltyears=list(map(str,range(1980,2014)))df_iceland=df_canada.loc[&#x27;Iceland&#x27;,years]df_iceland.plot(kind=&#x27;bar&#x27;)plt.title(&#x27;Icelandic immigrants to Canada from 1980 to 2013&#x27;)plt.ylabel(&quot;Year&quot;)plt.xlabel(&quot;Number of immigrants&quot;)plt.show() Pie Charts A pie chart is a circular statistical graphic divided into slices to illustrate numerical proportion. Arguments against pie charts 123456import matplotlib as mplimport matplotlib.pyplot as pltdf_continents=df_canada.groupby(&#x27;Continent&#x27;, axis=0).sum()df_continents[&#x27;Total&#x27;].plot(kind=&#x27;pie&#x27;)plt.title(&#x27;Immigration to Canada by Continent&#x27;)plt.show() Box Plots A boxplot is a way of statistically representing the distribution of given data through 5 main dimensions. Minimum, First Quartile, Median, Third Quartile, Maximum, Outliers IQR (Inter Quartile Range): between First Quartile and Third Quartile Function = plot, and Parameter = kind with value = &quot;box&quot; 1234567import matplotlib as mplimport matplotlib.pyplot as pltdf_japan=df_canada.loc(&#x27;Japan&#x27;, years).transpose()df_japan.plot(kind=&#x27;box&#x27;)plt.title(&#x27;Box plot of Japanese Immigrants from 1980 to 2013&#x27;)plt.ylabel(&#x27;Number of Immigrants&#x27;)plt.show() Scatter Plots A scatter plot is a type of plot that displays values pertaining to typically two variables against each other. Usually it is a dependent variable to be plotted against an independent variable in order to determine if any correlation between the two variables exists. 1234567import matplotlib as mplimport matplotlib.pyplot as pltdf_total.plot&#123;kind=&#x27;scatter&#x27;,x=&#x27;year&#x27;,y=&#x27;total&#x27;&#125;plt.title(&#x27;Total immigrant population to Canada from 1980 to 2013&#x27;)plt.ylabel(&quot;Year&quot;)plt.xlabel(&quot;Number of immigrants&quot;)plt.show() Bubble Plots A bubble plot is a variation of the scatter plot that displays three dimensions of data (x, y, z). The data points are replaced with bubbles, and the size of the bubble is determined by the third variable ‘z’, also known as the weight. Advanced Visualizations and Geospatial Data Waffle Charts A waffle chart is an interesting visualization that is normally created to display progress toward goals Matplotlib does not have a built-in function to create waffle charts. Word Clouds A Word Cloud is a depiction of the frequency of different words in some textual data Mueller’s word cloud generator Seaborn and Regression Plots Seaborn is a Python visualization library based on Matplotlib 12import seaborn as snsax=sns.regplot(x=&#x27;year&#x27;,y=&#x27;total&#x27;,data=df_total,color=&#x27;green&#x27;,marker=&#x27;+&#x27;) Introduction to Folium and Map Styles Folium is a powerful Python library that helps you create several types of Leaflet maps It enables both the binding of data to a map for choropleth visualizations as well as passing visualizations as markers on the map 12word_map=folium.Map() #define the world mapworld_map #display world map Define the world map centered around Canada with a low zoom level 123456world_map=folium.Map( location=[56.130, -106.35], zoom_start=4, tiles=&#x27;Stamen Terrain&#x27; #or &#x27;Stream Toner&#x27;)world_map #display Maps with Markers 1234567891011canada_map=folium.Map( location=[56.130, -106.35], zoom_start=4)ontario=folium.map.FeatureGroup() #create a feature groupontario.add_child( folium.features.CircleMarker([51.25,-85.32],radius=5,color=&#x27;red&#x27;,fill_color=&#x27;Red&#x27;)) #style the feature groupcanada_map.add_child(ontario) #add the feature group to the mapfolium.Marker([51.25,-85.32],popup=&#x27;Ontario&#x27;).add_to(canada_map) #label the markercanada map Choropleth Maps A choropleth map is a thematic map in which areas are shaded or patterned in proportion to the measurement of the statistical variable being displayed on the map, such as population density or per capita income. Geojson File 1234567891011121314world_map=folium.Map( zoom_start=2, tiles=&#x27;Mapbox Bright&#x27;)world_geo=r&#x27;world_countries.json&#x27; #geojson fileworld_map.choropleth( geo_path=world_geo, data=df_canada, columns=[&#x27;Country&#x27;,&#x27;Total&#x27;], key_on=&#x27;feature.properties.name&#x27;, fill_color=&#x27;YlOrRd&#x27;, legend_name=&#x27;Immigration to Canada&#x27;)world_map Creating Dashboards with Plotly and Dash Dashboard Produce real-time visuals Understand business moving parts Visually track, analyze and display key performance indicators (KPI) Take informed decisions and improve performance. Reduced hours of analyzing Best dashboards answer critical business questions. Python dashboarding tools: Dash from Plotly, Panel, voila, Streamlit, Bokeh, ipywidgets, matplotlib, Flask Plotly Interactive, open-source plotting library Supports over 40 unique chart types Includes chart types like statistical, financial, maps, scientific and 3-dimensional Visualizations can be displayed in Jupyter notebook, saved to HTML files, or can be used in developing Python-built web applications using Dash Plotly Graph Objects: Low-level interface to figures, traces, and layout: plotly.gragh_objects.Figure Plotly express: High-level wrapper for Plotly 1234567891011import plotly.gragh_objects as goimport plotly.express as pximport numpy as npnp.random.seed(10) #set random seed for reproducibilityx=np.arange(12)y=np.random.randint(50, 500, size=12) #create random y valuesfig=go.Figure(data=go.Scatter(x=x,y=y)) #create figure and add trace (scatter)fig.update_layout(title=&#x27;Simple Line Plot&#x27;,xais_title=&#x27;Month&#x27;,yaxis_title=&#x27;Sales&#x27;)fig.show()fig=px.line(x=x,y=y,title=&#x27;Simple Line Plot&#x27;,labels=dict(x=&#x27;Month&#x27;,y=&#x27;Sales&#x27;)) #Entire line chart can be created in a single commandfig.show() Plotly cheatsheet Dash Open-Source User Interface Python library for creating reactive, web-based applications Easy to build GUI Declarative and Reactive Rendered in web browser and can be deployed to servers Inherently cross-platform and mobile ready Both enterprise-ready and a first-class member of Plotly’s open-source tools Dash core components: import dash_core_components as dcc Describe higher-level components that are interactive and are generated with JavaScript, HTML, and CSS through the React.js library Dash HTML components: import dash_html_components as html Component for every HTML tag Callback function is a python function that is automatically called by Dash whenever an input component’s property changes Callback function is decorated with @app.callback decorator 1234@app.callback(Output, Input)def callback_fuction: ...... return some_result Callback decorator function takes two parameters: Input and Output Input and Output to the callback function will have component id and component property Multiple inputs or outputs should be enclosed inside either a list or tuple. Callbacks with one input 12345678910111213141516171819import pandas as pdimport plotly.express as pximport dashimport dash_html_components as htmlimport dash_core_components as dccfrom dash.dependencies import Input, Outputairline_data=pd.read_csv(&#x27;airline.csv&#x27;,encoding=&#x27;ISO-8859-1&#x27;,dtype=&#123;&#x27;Airport&#x27;:str,&#x27;TailNum&#x27;:str&#125;) #read the dataapp=dash.Dash()# Design dash app layoutapp.layout=html.Div(children=[html.H1(&#x27;Airline Dashboard&#x27;,style=&#123;&#x27;textAlign&#x27;:&#x27;center&#x27;,&#x27;color&#x27;:colors[&#x27;text&#x27;],&#x27;font-size&#x27;:40&#125;),html.Div([&#x27;Input:&#x27;,dcc.Input(id=&#x27;input-yr&#x27;,value=&#x27;2010&#x27;,type=&#x27;number&#x27;,style=&#123;&#x27;height&#x27;:&#x27;50px&#x27;,&#x27;font-size&#x27;:35&#125;),],style=&#123;&#x27;font-size&#x27;:40&#125;),html.Br(),html.Br(),html.Div(dcc.Gragh(id=&#x27;bar-plot&#x27;)),])@app.callback(Output(component_id=&#x27;bar-plot&#x27;,component_property=&#x27;figure&#x27;),Input(component_id=&#x27;input-yr&#x27;,component_property=&#x27;value&#x27;))def get_gragh(entered_year): df=airline_data[airline_data[&#x27;Year&#x27;]==int(entered_year)] #select data g1=df.groupby([&#x27;Reporting_Airline&#x27;])[&#x27;Flights&#x27;].sum().nlargest(10).reset_index() #top 10 airline carrier in terms of number of flights fig1=px.bar(g1,x=&#x27;Reporting_Airline&#x27;,y=&#x27;Flights&#x27;,title=&#x27;Top 10 airline carrier in year &#x27;+str(entered_year)+&#x27; in terms of number of flights&#x27;) #plot the gragh fig1.update_layout() return fig1if __name__==&#x27;__main__&#x27;: app.run_server(port=8002,host=&#x27;127.0.0.1&#x27;,debug=True) Assignments Visit my Github Repository","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[]},{"title":"Python Project for Data Science","slug":"Python-Project-for-Data-Science","date":"2021-03-05T16:00:00.000Z","updated":"2022-05-05T13:06:12.663Z","comments":true,"path":"Python-Project-for-Data-Science/","link":"","permalink":"http://blog.zhuangzhihao.top/Python-Project-for-Data-Science/","excerpt":"This Python Project mini-course provided by IBM is intended to demonstrate basic Python skills by performing specific tasks such as extracting data, web scraping, visualizing data, and creating a dashboard. The following are the notes I took during this course.","text":"This Python Project mini-course provided by IBM is intended to demonstrate basic Python skills by performing specific tasks such as extracting data, web scraping, visualizing data, and creating a dashboard. The following are the notes I took during this course. Web Scraping HTML Tags HTML Composition HTML Paragraph Tags: &lt;p&gt;&lt;/p&gt; HTML Anchor Tag &amp; Hyperlink Tag: &lt;a href=&quot;&quot;&gt;&lt;/a&gt; Attributes: href=&quot;&quot; Inspect HTML: F12 Document Tree: &lt;head&gt;&lt;/head&gt;, &lt;body&gt;&lt;/body&gt; HTML Tables: &lt;table&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; BeautifulSoup 123from bs4 import BeautifulSouphtml=&quot;&quot;soup=BeautifulSoup(html, &#x27;html5lib&#x27;) BeautifulSoup: Object 1234567tag_object=soup.titletag_object=soup.h3tag_child=tag_object.b #HTML Treeparent_tag=tag_child.parent #Parent attributesibling_1=tag_object.next_sibling #Next-sibling attributetag_child.attrs #Show attributestag_child.string #Navigable string BeautifulSoup: find_all 12345678table=BeautifulSoup(html, &#x27;html5lib&#x27;)table_row=table.find_all(name=&#x27;tr&#x27;) #Python iterablefirst_row=table_row[0]from i,row in enumerate(table_rows): #Elements print(&quot;row&quot;,i) cells+row.find_all(&quot;td&quot;) for j,cell in enumerate(cells): print(&quot;column&quot;,j,&quot;cell&quot;,cell) Requests &amp; BeautifulSoup in real web page 12345678910import requestsfrom bs4 import BeautifulSouppage=requests.get(&quot;http://...&quot;).textsoup=BeautifulSoup(page, &quot;html.parser&quot;) #Create a BeautifulSoup objectartists=soup.find_all(&#x27;a&#x27;) #Pull all instances of &lt;a&gt; tagfor artist in artists: #Clears data of all tags names=artist.contents[0] fullLink=artist.get(&#x27;href&#x27;) print(names) print(fullLink) Project: Analyzing Stock Performance and Building a Dashboard A stock (also known as equity) is a security that represents the ownership of a fraction of a corporation. The stock ticker is a report of the price of a certain stock, updated continuously throughout the trading session by the various stock market exchanges. Extracting Stock Data Using a Python Library: yfinance Extracting Stock Data Using Web Scraping Project Notebook Assignments Visit my Github Repository","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[]},{"title":"皮卡丘彩虹屁语音包","slug":"Pikachu-rainbow-fart","date":"2021-02-15T16:00:00.000Z","updated":"2022-05-23T10:39:18.553Z","comments":true,"path":"Pikachu-rainbow-fart/","link":"","permalink":"http://blog.zhuangzhihao.top/Pikachu-rainbow-fart/","excerpt":"VSCode Rainbow Fart 是一个在你编程时持续夸你写的牛逼的扩展，可以根据代码关键字播放贴近代码意义的真人语音。皮卡丘彩虹屁语音包（Pikachu-rainbow-fart） 是基于此插件编写的定制化的皮卡丘语音包，项目基于 MIT 协议开源于 Github。","text":"VSCode Rainbow Fart 是一个在你编程时持续夸你写的牛逼的扩展，可以根据代码关键字播放贴近代码意义的真人语音。皮卡丘彩虹屁语音包（Pikachu-rainbow-fart） 是基于此插件编写的定制化的皮卡丘语音包，项目基于 MIT 协议开源于 Github。 Pikachu Rainbow Fart 一、小智的快乐皮卡丘（ピカチュウ）是宝可梦动画人物小智的第一个宝可梦。它小小的嘴巴，黑色的眼睛和萌萌的叫声也使它深受许多神奇宝贝迷的喜爱。借助 VSCode Rainbow Fart 插件，我们可以在编程时持续享受到来自皮卡丘可爱的呼唤声 二、皮卡丘的语言本语音包中包含90余种皮卡丘的声音（在输入关键字时随机播放），以下一些例子仅供参考： 皮卡！ 皮卡—丘 皮皮—卡丘 皮卡皮卡 皮—卡丘 皮—皮卡丘 皮卡卡皮卡 皮卡—皮卡丘 皮—卡皮卡 三、使用介绍 下载 Pikachu-rainbow-fart.zip （或在 Releases 界面下载同名zip包） 从 VSCode 扩展商店 下载并安装 Rainbow Fart 插件 在 VSCode 的命令面板打开 Enable Rainbow Fart 并点击弹出通知上的 Open 按钮 在打开的浏览器页面设置栏点击 导入 选择下载好的 zip 包 点击 授权 ，回到 VSCode 愉快的打代码吧 ヽ(￣▽￣)ﾉ 四、界面预览 五、IntelliJ IDEA支持 从 Jetbrains扩展商店 下载并安装 Rainbow Fart 插件 设置 -&gt; 其他 -&gt; Rainbow Fart -&gt; Custom voice package path 导入 下载好的 zip 包 六、补充申明本语音包是基于 佐伯楽（SaekiRaku） 开发的 VSCode Rainbow Fart 插件的语音拓展包 IDEA 版本插件来自 张志豪 开发的 intellij-rainbow-fart，由于 IDEA 版本插件不支持 wav 格式文件，故所有音频文件已转为 mp3 格式。 支持 C / C++ / JavaScript / Python / Java 语言的大多数关键词和分隔符 语音素材来源于游戏动画阿星 ，所有文件基于 MIT 开源 有其他的问题，欢迎及时来向我反馈。。。","categories":[{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"Databases and SQL for Data Science with Python","slug":"Databases-and-SQL-for-Data-Science","date":"2021-02-14T16:00:00.000Z","updated":"2022-05-05T12:55:59.736Z","comments":true,"path":"Databases-and-SQL-for-Data-Science/","link":"","permalink":"http://blog.zhuangzhihao.top/Databases-and-SQL-for-Data-Science/","excerpt":"Much of the world’s data resides in databases, A working knowledge of databases and SQL is a must to become a data scientist. The emphasis in this course provided by IBM is on hands-on and practical learning. So, I’ll try to record how I work with real databases, real data science tools, real-world datasets and eventually, how I create a database instance in the cloud on the following notes I took during this course.","text":"Much of the world’s data resides in databases, A working knowledge of databases and SQL is a must to become a data scientist. The emphasis in this course provided by IBM is on hands-on and practical learning. So, I’ll try to record how I work with real databases, real data science tools, real-world datasets and eventually, how I create a database instance in the cloud on the following notes I took during this course. Introduction to Databases Structured Query Language (or SQL) is a powerful language which is used for communicating with and extracting data from databases. SQL is among the top 3 skills for a Data Scientist or Data Analysts A database is a repository of data, it provides the functionality for adding, modifying and querying data RDBMS = Relational database management system 5 Basic SQL commands: Create, Insert, Select, Update, Delete Cloud databases: Ease of use and access, Scalability &amp; Economics, Disaster recovery IBM Db2, PostgreSQL, Oracle Cloud, Microsoft Azure, Amazon RDS DBaaS (Database-as-a-Service) provides users with access to database resources in Cloud without the need for setting up hardware and installing software. Relational Model allows for data independence (key advantage) Entities are independent objects which have Attributes Entity-Relationship Model (ER-Model): used as a tool to design RDBMS Mapping Entity Diagrams to Tables: Entities become tables, Attributes get translated into columns Primary Keys and Foreign Keys: A primary key uniquely identifies a specific row in a table and prevents duplication of data. Basic SQL Data Definition Language statements (DDL) and Data Manipulation Language statements (DML) Data Definition Language (DDL) statements are used to define, change, or drop database objects. Common DDL statement types include: CREATE, ALTER, TRUNCATE and DROP Data Manipulation Language (DML) statements are used to read and modify data in tables. CRUD operations: Create, Read, Update and Delete Common DML statement types include: INSERT, SELECT, UPDATE and DELETE CREATE and DROP tables in the database It is quite common to issue a DROP before doing a CREATE in test and development scenarios, but if the table does not already exist and you try to drop it, you will see an error like XXX.YYY is an undefined name. 123456drop table COUNTRY; ## If table already existscreate table COUNTRY( ID int PRIMARY KEY NOT NULL, CCODE char(2) NOT NULL, NAME varchar(60)); Use SELECT queries to retrieve data from the database 1234567select COLUMN1, COLUMN2, ... from TABLE1 ;## orselect * from COUNTRY ;## orselect * from COUNTRY where ID &lt; 5 ;## orselect * from COUNTRY where CCODE = &#x27;CA&#x27;; Use COUNT, DISTINCT, LIMIT, INSERT, UPDATE, DELETE to compose and run basic queries 123456789101112131415161718192021222324252627282930-- 0. Drop table INSTRUCTOR in case it already existsdrop table INSTRUCTOR;-- 1. Create table INSTRUCTORCREATE TABLE INSTRUCTOR (ins_id INTEGER PRIMARY KEY NOT NULL, lastname VARCHAR(15) NOT NULL, firstname VARCHAR(15) NOT NULL, city VARCHAR(15), country CHAR(2) );-- 2A. Insert single row for Rav AhujaINSERT INTO INSTRUCTOR (ins_id, lastname, firstname, city, country) VALUES (1, &#x27;Ahuja&#x27;, &#x27;Rav&#x27;, &#x27;Toronto&#x27;, &#x27;CA&#x27;);-- 2B. Insert the two rows for Raul and HimaINSERT INTO INSTRUCTOR VALUES (2, &#x27;Chong&#x27;, &#x27;Raul&#x27;, &#x27;Toronto&#x27;, &#x27;CA&#x27;), (3, &#x27;Vasudevan&#x27;, &#x27;Hima&#x27;, &#x27;Chicago&#x27;, &#x27;US&#x27;);-- 3. Select all rows in the tableSELECT * FROM INSTRUCTOR;-- 3b. Select firstname, lastname and country where city is TorontoSELECT firstname, lastname, country from INSTRUCTOR where city=&#x27;Toronto&#x27;;-- 4. Change the city for Rav to MarkhamUPDATE INSTRUCTOR SET city=&#x27;Markham&#x27; where ins_id=1;-- 5. Delete the row for Raul ChongDELETE FROM INSTRUCTOR where ins_id=2;-- 5b. Retrieve all rows from the tableSELECT * FROM INSTRUCTOR ; String Patterns, Ranges, Sorting and Grouping Using String Patterns and Ranges The WHERE clause always requires a predicate, which is a condition that evaluates to true, false or unknown. Use the LIKE predicate with string patterns for the search：WHERE &lt;columnname&gt; LIKE &lt;string pattern&gt; 123select F_NAME , L_NAMEfrom EMPLOYEESwhere ADDRESS LIKE &#x27;%Elgin,IL%&#x27; ; Sorting Result Sets ORDER BY: Descending order，Specifying Column Sequence Number 123select F_NAME, L_NAME, DEP_ID from EMPLOYEESorder by DEP_ID desc, L_NAME desc; Grouping Result Sets SELECT DISTINCT() : Eliminating Duplicates GROUP BY HAVING: Restricting the result set 12345select DEP_ID, COUNT(*) AS &quot;NUM_EMPLOYEES&quot;, AVG(SALARY) AS &quot;AVG_SALARY&quot;from EMPLOYEESgroup by DEP_IDhaving count(*) &lt; 4order by AVG_SALARY; Functions, Sub-Queries, Multiple Tables Built-in Database Functions: Using database functions can significantly reduce the amount of data that needs to be retrieved from the database. Aggregate or Column Functions INPUT: Collection of values (e.g. entire column), OUTPUT: Single value SUM(), MIN(), MAX(), AVG() 1select AVG( COST / QUANTITY ) from PETRESCUE where ANIMAL = &#x27;Dog&#x27;; SCALAR and STRING functions Perform operations on every input value ROUND(), LENGTH(), UCASE, LCASE 12select DISTINCT(UCASE(ANIMAL)) from PETRESCUE;select * from PETRESCUE where LCASE(ANIMAL) = &#x27;cat&#x27;; Date and Time Built-in Functions YEAR(), MONTH(), DAY(), DAYOFWEEK(), DAYOFYEAR(), WEEK(), HOUR(), MINUTE(), SECOND() Date or Time Arithmetic 123select SUM(QUANTITY) from PETRESCUE where DAY(RESCUEDATE)=&#x27;14&#x27;;select (RESCUEDATE + 3 DAYS) from PETRESCUE;select (CURRENT DATE - RESCUEDATE) from PETRESCUE; Sub-Queries and Nested Selects Sub-Queries cannot evaluate Aggregate functions like AVG() in the WHERE clause,therefore,use a sub-Select expression Sub-queries in FROM clause substitute the TABLE name with a sub-query called Derived Tables or Table Expressions. 123select * from employees where salary &gt; AVG(salary)select EMP_ID, F_NAME, L_NAME, SALARY from employees where SALARY &gt; (select AVG(SALARY) from employees);select EMP_ID, SALARY, ( select AVG(SALARY) from employees ) AS AVG_SALARY from employees ; Working with Multiple Tables Sub-queries 12select * from employees where DEP_ID IN ( select DEPT_ID_DEP from departments where LOC_ID = &#x27;L0002&#x27; );select DEPT_ID_DEP, DEP_NAME from departments where DEPT_ID_DEP IN ( select DEP_ID from employees where SALARY &gt; 70000 ) ; Implicit JOIN 12select * from employees E, departments D where E.DEP_ID = D.DEPT_ID_DEP;select E.EMP_ID, D.DEP_NAME from employees E, departments D where E.DEP_ID = D.DEPT_ID_DEP JOIN operators（INNER JOIN, OUTER JOIN…） Accessing databases using Python Python ecosystem: NumPy, pandas, matplotlib, SciPy DB-API (Python Database API): Python’s standard API for accessing relational databases. Connection Objects: Database connections, Manage transactions Cursor Objects: Database queries, Scroll through result set, Retrieve results Connection methods: .cursor(), .commit(), .rollback(), .close() Cursor methods: .callproc(), .execute(), .executemany(), .fetchone(), .fetchmany(), .fetchall(), .nextset(), .arraysize(), .close() 1234567891011from dbmodule import connect#Create connection objectConnection = connect(&#x27;databasename&#x27;, &#x27;username&#x27;, &#x27;pswd&#x27;)#Create a cursor objectCursor=connection.cursor()#Run QueriesCursor.execute(&#x27;select * from mytable&#x27;)Results = cursor.fetchall()#Free resourcesCursor.close()Connection.close() Connect to Db2 database (ibm_db API) 123456789101112131415161718192021222324import ibm_db#Replace the placeholder values with your actual Db2 hostname, username, and password:dsn_hostname = &quot;YourDb2Hostname&quot; # e.g.: &quot;dashdb-txn-sbox-yp-dal09-04.services.dal.bluemix.net&quot;dsn_uid = &quot;YourDb2Username&quot; # e.g. &quot;abc12345&quot;dsn_pwd = &quot;YoueDb2Password&quot; # e.g. &quot;7dBZ3wWt9XN6$o0J&quot;dsn_driver = &quot;&#123;IBM DB2 ODBC DRIVER&#125;&quot;dsn_database = &quot;BLUDB&quot; # e.g. &quot;BLUDB&quot;dsn_port = &quot;50000&quot; # e.g. &quot;50000&quot; dsn_protocol = &quot;TCPIP&quot; # i.e. &quot;TCPIP&quot;#Create the dsn connection stringdsn = ( &quot;DRIVER=&#123;0&#125;;&quot; &quot;DATABASE=&#123;1&#125;;&quot; &quot;HOSTNAME=&#123;2&#125;;&quot; &quot;PORT=&#123;3&#125;;&quot; &quot;PROTOCOL=&#123;4&#125;;&quot; &quot;UID=&#123;5&#125;;&quot; &quot;PWD=&#123;6&#125;;&quot;).format(dsn_driver, dsn_database, dsn_hostname, dsn_port, dsn_protocol, dsn_uid, dsn_pwd)#Create database connectiontry: conn = ibm_db.connect(dsn, &quot;&quot;, &quot;&quot;) print (&quot;Connected to database: &quot;, dsn_database, &quot;as user: &quot;, dsn_uid, &quot;on host: &quot;, dsn_hostname)except: print (&quot;Unable to connect: &quot;, ibm_db.conn_errormsg() ) Close the connection 1ibm_db.close(conn) Creating tables, loading data and querying data 123456789101112131415161718192021222324252627#Lets first drop the table INSTRUCTOR in case it exists from a previous attemptdropQuery = &quot;drop table INSTRUCTOR&quot;#Now execute the drop statmentdropStmt = ibm_db.exec_immediate(conn, dropQuery)#Construct the Create Table DDL statement - replace the ... with rest of the statementcreateQuery = &quot;create table INSTRUCTOR(id INTEGER PRIMARY KEY NOT NULL, fname ...)&quot;#Now fill in the name of the method and execute the statementcreateStmt = ibm_db.replace_with_name_of_execution_method(conn, createQuery)#Construct the query - replace ... with the insert statementinsertQuery = &quot;...&quot;#execute the insert statementinsertStmt = ibm_db.exec_immediate(conn, insertQuery)#replace ... with the insert statement that inerts the remaining two rows of datainsertQuery2 = &quot;...&quot;#execute the statementinsertStmt2 = ibm_db.exec_immediate(conn, insertQuery2)#Construct the query that retrieves all rows from the INSTRUCTOR tableselectQuery = &quot;select * from INSTRUCTOR&quot;#Execute the statementselectStmt = ibm_db.exec_immediate(conn, selectQuery)#Fetch the Dictionary (for the first row only) - replace ... with your code...#Fetch the rest of the rows and print the ID and FNAME for those rowswhile ibm_db.fetch_row(selectStmt) != False: print (&quot; ID:&quot;, ibm_db.result(selectStmt, 0), &quot; FNAME:&quot;, ibm_db.result(selectStmt, &quot;FNAME&quot;))updateQuery = &quot;update INSTRUCTOR set CITY=&#x27;MOOSETOWN&#x27; where FNAME=&#x27;Rav&#x27;&quot;updateStmt = ibm_db.exec_immediate(conn, updateQuery)) Retrieve data into Pandas 12345678910111213import pandasimport ibm_db_dbi#connection for pandaspconn = ibm_db_dbi.Connection(conn)#query statement to retrieve all rows in INSTRUCTOR tableselectQuery = &quot;select * from INSTRUCTOR&quot;#retrieve the query results into a pandas dataframepdf = pandas.read_sql(selectQuery, pconn)#print just the LNAME for first row in the pandas data framepdf.LNAME[0]#print the entire data framepdfpdf.shape SQL Magic Cell magics: start with a double %% sign and apply to the entire cell Line magics: start with a single % sign and apply to a particular line in a cell %magicname arguments %sql select * from tablename Analyzing data with Python1234567891011121314151617181920212223#Connect to the database%load_ext sql%sql ibm_db_sa://#Store the dataset in a Tableimport pandaschicago_socioeconomic_data = pandas.read_csv(&#x27;https://data.cityofchicago.org/resource/jcxq-k9xf.csv&#x27;)%sql PERSIST chicago_socioeconomic_data%sql SELECT * FROM chicago_socioeconomic_data limit 5;#How many rows are in the dataset%sql SELECT COUNT(*) FROM chicago_socioeconomic_data;#How many community areas in Chicago have a hardship index greater than 50.0%sql SELECT COUNT(*) FROM chicago_socioeconomic_data WHERE hardship_index &gt; 50.0;#What is the maximum value of hardship index in this dataset%sql SELECT MAX(hardship_index) FROM chicago_socioeconomic_data;#Which community area which has the highest hardship index%sql select community_area_name from chicago_socioeconomic_data where hardship_index = ( select max(hardship_index) from chicago_socioeconomic_data )#Create a scatter plot using the variables per_capita_income_ and hardship_index!pip install seabornimport matplotlib.pyplot as plt%matplotlib inlineimport seaborn as snsincome_vs_hardship = %sql SELECT per_capita_income_, hardship_index FROM chicago_socioeconomic_data;plot = sns.jointplot(x=&#x27;per_capita_income_&#x27;,y=&#x27;hardship_index&#x27;, data=income_vs_hardship.DataFrame()) Using JOIN operations to work with multiple tables Inner Join Outer Join Left Outer Join Right Outer Join Full Outer Join HR Database example 12345678910111213141516171819202122232425262728--- Select the names, job start dates, and job titles of all employees who work for the department number 5 --- select E.F_NAME,E.L_NAME, JH.START_DATE, J.JOB_TITLE from EMPLOYEES as E INNER JOIN JOB_HISTORY as JH on E.EMP_ID=JH.EMPL_ID INNER JOIN JOBS as J on E.JOB_ID=J.JOB_IDENT where E.DEP_ID =&#x27;5&#x27;;--- Perform a Left Outer Join on the EMPLOYEES and DEPARTMENT tables and select employee id, last name, department id and department name for all employees ---select E.EMP_ID,E.L_NAME,E.DEP_ID,D.DEP_NAME from EMPLOYEES AS E LEFT OUTER JOIN DEPARTMENTS AS D ON E.DEP_ID=D.DEPT_ID_DEP; --- Re-write the query to have the result set include all the employees but department names for only the employees who were born before 1980. ---select E.EMP_ID,E.L_NAME,E.DEP_ID,D.DEP_NAME from EMPLOYEES AS E LEFT OUTER JOIN DEPARTMENTS AS D ON E.DEP_ID=D.DEPT_ID_DEP AND YEAR(E.B_DATE) &lt; 1980;--- Perform a Full Join on the EMPLOYEES and DEPARTMENT tables and select the First name, Last name and Department name of all employees. ---select E.F_NAME,E.L_NAME,D.DEP_NAME from EMPLOYEES AS E FULL OUTER JOIN DEPARTMENTS AS D ON E.DEP_ID=D.DEPT_ID_DEP;--- Re-write Query to have the result set include all employee names but department id and department names only for male employees. ---select E.F_NAME,E.L_NAME,D.DEPT_ID_DEP, D.DEP_NAME from EMPLOYEES AS E FULL OUTER JOIN DEPARTMENTS AS D ON E.DEP_ID=D.DEPT_ID_DEP AND E.SEX = &#x27;M&#x27;; Working with Real World Datasets Understand 3 Chicago datasets Load the 3 datasets into 3 tables in a Db2 database Execute SQL queries to answer assignment questions Assignments Visit my Github Repository","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.zhuangzhihao.top/tags/SQL/"}]},{"title":"2021 阿里云 Java 训练营第一期","slug":"Java初级训练营","date":"2021-02-03T16:00:00.000Z","updated":"2022-06-07T13:46:10.255Z","comments":true,"path":"Java初级训练营/","link":"","permalink":"http://blog.zhuangzhihao.top/Java%E5%88%9D%E7%BA%A7%E8%AE%AD%E7%BB%83%E8%90%A5/","excerpt":"在阿里云开发者社区中看到有Java新手训练营（5天突破Java面向对象编程）的课程，采用直播授课的形式，希望能在侠客大佬的指导下有更好的学习效果吧。当然，直播时间有限，所以这篇日志并不是对Java知识点完全系统的梳理，主要记录一些开发中常用的语法和概念和在面试时会遇到的问题，以训练和熟悉特性为主。","text":"在阿里云开发者社区中看到有Java新手训练营（5天突破Java面向对象编程）的课程，采用直播授课的形式，希望能在侠客大佬的指导下有更好的学习效果吧。当然，直播时间有限，所以这篇日志并不是对Java知识点完全系统的梳理，主要记录一些开发中常用的语法和概念和在面试时会遇到的问题，以训练和熟悉特性为主。 Java知识点 Java语言的发展历史 Java语言的优势和特点 OOP面向对象编程概念：对象、Class类、继承、封装、多态 基础语法：数据类型、8大基本类型、数据结构 关键字：int 、class 变量：存储数据 数据类型: String、int、bool、链表List、数组、哈希表、字典 控制语句: if else、while、for 文件操作：调用封装好的类库 File 网络编程：Socket TCP IP、SMTP邮件传输协议等 数据库连接：ADO.NET , JDBC等连接库NoSQL 网站框架：``PHP、ASP、JSP、ASP.NET、Spring MVC、Node Java语言特性 IDE：Eclipse 或者IntelliJ IDEA、MyEclipse JDK（Java Development Kit）：Java开发工具包，包含JAVA的运行环境和开发工具 Java虚拟机（JVM+Java系统类库）、Java编译器、Java调试工具、Java分析工具 安装和配置：JDK环境变量和 classpath Src：源代码文件夹，Source；Bin文件夹：保存编译后的二进制文件 Hello World123456package come.alibiba;public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); //println：输出行 &#125;&#125; Java代码执行顺序 编译原理：Java源代码 词法分析、语法分析 编译后的文件 .class 文件， ByteCode 字节码格式 JVM 类装载器 ClassLoader 装载执行的类文件 代码检验：符合JVM规范和类型安全等 Java中间代码 IR（Intermediate Representation）IL 准备：准备方法表、静态字段等需要的内存空间 JIT 即时编译器执行二次编译 IR 中间代码 转换为机器码 CPU 以 线程Thread 身份执行机器码 Java 9新特性 Jigsaw 项目：模块化，包，仿C#的程序集dll概念 简化了的进程 API 轻量级的 JSON API 钱和货币的相关 API 改善多线程锁争用机制 代码分段缓存 改进的 Stream API 改进的 Javadoc HTTP 2.0 客户端 HTTP/2。WebSocket 多版本兼容JAR Java三个版本 2005年6月，JavaOne大会SUN公司公开Java SE 6（To，Java已经更名以取消其中数字”2“） JavaSE（Java 2 Platform Standard Edition，java标准版） JavaEE（Java 2 Platform,Enterprise Edition，java企业版） JavaME（Java 2 Platform Micro Edition，java平台微型版） Enterprise Java Bean（EJB）Java企业开发规范标准，框架重 Pivotal 公司开发一套 Spring 框架：取代EJB框架，简化Java企业级开发 JVM Java虚拟机 Java虚拟机： 托管执行Java的中间代码 .class，Java Virtual Machine缩写 虚拟机：linux系统，Window系统虚拟计算机 Java编译成中间代码，JIT 即时编译器再次编译为CPU指令 CPU执行 JVM把 .class 文件加载内存，C#编译后文件格式 .dll 二次编译 jit（Just in Time）转换为CPU指令执行 JVM 负责Java代码编译、执行、内存分配、GC回收 C#等价概念 CLR 公共语言运行时，包含C#、VB、F#等 Common Language Runtime 变量 8大基本数据类型 byte 字节 8bit 位，short 短整型 2X8bit，int 整型 4X8bit，long 长整型 8X8bit，float 浮点 4X8bit，double 双精度 8X8bit，char 字符 8bit，boolean 布尔类型 8bit 两大数据类型 基本数据类型（Java 8大基本类型，C#中也有） 引用数据类型（复杂的数据类型，Java，C#中也有） C#中还有一种值类型概念 6大包装类（包装一层）：Boolean、Character、Integer、Long、Float、Double Java的枚举类型 Java 中的枚举是一些常量的集合，Java 1.5 中引入，属于引用类型 java.lang.Enum 大写关键字 Enum，小写关键字 enum Enum 抽象类，所有枚举类型的基类，enum 继承自 Enum 1public enum Season &#123; SPRING, SUMMER, AUTUM, WINTER &#125; 条件和循环语句if条件1234int num = 10000;if (num &gt; 10000000) &#123; System.out.println(&quot;超级富豪程序员&quot;); &#125; else if (num &gt; 1000000) &#123; System.out.println(&quot;富豪程序员&quot;); &#125;else &#123; System.out.println(&quot;码畜&quot;); &#125; switch条件12345678910System.out.println(&quot;输入星期查询&quot;);Scanner sin = new Scanner(System.in);int day = sin.nextInt();switch (day)&#123; case 6: System.out.println(&quot;休息&quot;); break; default: System.out.println(&quot;上班&quot;); break;&#125; for循环，for each循环123int sum = 0;for (int i = 1; i &lt;= 100; i++) &#123; sum = sum + i; &#125; System.out.println(sum);for (String s : list)&#123; System.out.println(s); &#125; //foreach循环 while循环，do while循环123int age = 18;while(age&lt;100) &#123; age=age+1; System.out.println(age); &#125;do&#123; age++; System.out.println(age); &#125;while (age&lt;100) 运算符 算数运算符，二进制位运算符（ &amp; 与，| 或，^异或，〜按位取反），逻辑运算符（&amp;&amp; and，|| or，! not），赋值运算符（/=除和），条件运算符 （三元运算符）(a=1)?1:2 面向对象编程 Object Oriented Programming 软件工程的发展 面向硬件：CPU指令，汇编 -&gt; 面向过程PO：C语言、Pascal -&gt; 面向对象OO：C++、Java、C# -&gt; 面向组件CO：COM -&gt; 面向服务SO：Web服务 Class类代码封装的基本单元，Class封装了数据（变量）和行为（函数功能） Class 描述抽象事务的类型，万物（Object）皆可归为类，对象是类的具体实体 类继承 OOP面向对象的三大特征 继承 Inheritence：子类继承父类的代码。继承是父类和子类之间共享数据和方法的机制，本质就是代码重用，通常把父类称为基类，子类称为派生类，Java和C#单继承，通过接口来实现多重继承，接口可以从多个基接口继承。 封装 Encapsulation：Class + 修饰符封装代码。就是用一个Class把数据和行为代码组合在一起，形成一个对象，面向过程封装Function，在Java和C#中类的工具，对象则是封装的基本单元，访问级别修饰符：Public、Protected、Private 多态性 Polymorphism：同一种行为，多种代码实现。就是指同一个操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，多态性有两种，一种是静态多态（编译时多态），一种是动态多态（运行时多态），方法重载和重写实现。 面向对象OOP核心概念 面向过程编程（POP），Procedure Oriented Programming 函数 Function 改名叫 方法 Method 汇编、C、SQL、C++， Java，JavaScript、C#、Go 对物品 Object 进行分类 Class，万物分类，抽象，Object物体，编程语言：对象 Class 代码封装的更大的单位，类包含功能函数和数据变量 类全局变量：属性、成员，函数外面变量 Class 类：数据 + 行为功能，代码组织更合理，变量+函数， 字段+方法 封装Encapsulation 封装 Encapsulation：相比之前Function功能，把数据和行为功能代码打包在一起，形成一个封闭Class类。代码封装单位。 在C#和Java中，类是支持对象封装的工具，对象则是封装的基本单元。 类和结构是 .NET 和 Java 中的常规类型系统的基本构造，本质上都属于数据结构，封装着一个逻辑单位的数据和行为。 数据和行为是该类或结构的“成员”，它们包含各自的方法、属性和事件等。 Class 默认是 Internal，成员是 Private OOP原则Class类继承 为了更好的代码重用 在Java中，子类可以继承父类，所有的方法都是默认 Virtual 的 12345public class Dog extends Animal&#123; @Override //重写 public void Run() &#123;System.out.println(&quot;Hello dog run...&quot;);&#125;&#125; 构造函数，创建对象，实例化，构造对象，通过对象，调用行为，功能、方法 面向对象行为多态 多态是行为（功能、函数、方法）的多态，指为同名的方法提供不同的实现代码，是面向对象编程的最重要特征 我们不用关心方法的具体实现而仅仅依靠名称来进行调用操作 Abstract 抽象方法和 Virtual 虚方法是多态性的基础 Java和C#提供三种多态能力：接口多态、继承多态、抽象多态 接口：部分约束、合约、约定 123456public interface IBike //声明一个接口 叫功能&#123;void Call();&#125; //定义Call方法public class Cat : IBike //猫类实现接口&#123;public void Call()&#123; Console.WriteLine(&quot;喵喵喵&quot;);&#125; //实现Call方法&#125; 多态的实现方式 重载 Overloading：同一个类中，兄弟方法，方法名相同，参数个数、类型、顺序不同 重写 Override：子类和父类，父子关系，子类重新实现父类中的同名方法 @override 标记到重写的方法上 抽象类 抽象的类型，无法具体化接口，约束合约 1234567package com.frankxulei; //接口表示一种约束，电源接口、USB接口 public interface IFly &#123; void Fly(); &#125; public class Dog extends Animal implements IFly &#123; //继承抽象类和接口 @Override public void Run() &#123; System.out.println(&quot;Hello dog run...&quot;); &#125; @Override public void Fly() &#123; System.out.println(&quot;Hello dog fly...&quot;); &#125; &#125; 抽象类和接口的区别 实例方法：创建对象才能调用的方法 静态方法：Static 修饰的方法，属于类Class，不需要实例化 虚方法：virtual，介于抽象和实体方法之间，可以重写 除了 static、final、private 修饰的所有方法都是抽象类 Abstract 抽象类不可以被实例化，interface 接口也不可以 抽象类只允许单继承，接口可以多继承 Abstract 抽象类有具体方法实现，接口只有方法声明 抽象类使用关键字 extends，接口继承使用 implements 抽象类代表同一类别， 接口代表一种部分约束 虚方法，抽象方法和重写 父类不希望子类重写我 123456789101112131415abstract class Car &#123;public void Run()//虚方法 &#123;Console.WriteLine(&quot;BaseClass.VirtualMethod&quot;);&#125; public abstract void AddPower();&#125; //抽象方法class BMWCar : Car &#123; @override //重写虚方法 public void Run()&#123; Console.WriteLine(&quot;SubClass.VirtualMethod&quot;);&#125; @override public void AddPower()&#123; Console.WriteLine(“加油&quot;); &#125;&#125;class Test&#123; static void Main()&#123;Car baseClass = new BMWCar(); //声明类型为基类，实际类型为子类//由实际类型决定调用子类还是父类方法，实际是SubClass类的对象：SubClass.VirtualMethodbaseClass. Run();baseClass. AddPower(); &#125;&#125;//重写抽象方法 简易计算器 用户输入数据：借用 Scanner 类 选择加减乘除：IF 条件判断 计算结果：数据类型 方法重载 文件编程File文件流和IO读写文件工具类 Java.io 包几乎包含了所有操作输入、输出需要的类，所有这些流类代表了输入源和输出目标 Java.io 包，File文件类库的流支持很多格式（基本类型、对象、本地化字符集等） 一个流可以理解为一个数据的序列，输入流表示从一个源读取数据，输出流表示向一个目标写数据 Java为I/O提供了强大而灵活的支持（类库），使其更广泛地应用到文件传输和网络编程中 123import java.io.FileReader;import java.io.FileWriter;import java.io.IOException; Java IO读写文件工具类 Java读文件，通常会使用 FileInputStream 和 FileReader（也可以单独使用）读文本内容 java写文件中，通常会使用 FileOutputStream 和 FileWriter（也可以单独使用）， FileWriter 只能写文本文件 Java打开/保存开文件对话框 AWT：FileDialog 类 + FilenameFilter 类实现本功能 Swing：JFileChooser 类 + FileFilter 类实现本功能 复杂数据类型数组（Array） 物理上内存空间（数组连续的存储空间）连续，访问速度快，不灵活 相同数据类型的元素按一定顺序排列的集合（一组连续的存储空间），就是把有限个类型相同的变量用一个名字命名，然后用编号区分他们的变量的集合，这个名字成为数组名，编号成为下标。也叫索引 Index 数组是一种数据结构，它包含若干相同类型的变量。 数组元素，通过下标，0开始计数 1234int[10] array1 = new int[10];int[1]=2;int[] array2 = new int[] &#123; 1, 3, 5, 7, 9 &#125;;String[] nameArray = &#123;“C”,”Java”,”C++”&#125;; 数组特点 内存空间连续 数组可以是一维、多维或交错的。 数值数组元素的默认值设置为零，而引用元素的默认值设置为 null 交错数组是数组的数组，因此其元素是引用类型并初始化为 null 数组的索引从0开始：具有n 个元素的数组的索引是从 0 到 n-1 数组元素可以是任何类型，包括数组类型。 C#7.0 元组不限制数组元素类型，数组元素是各种类型 数组访问效率高，但是删除和插入效率低 列表（List） List 链表：空间节点指针连接，链条节点，可变长度，物理上不连续，插入和删除节点性能高，但是查找性能较低 内存空间分离，指针指向下一个节点，灵活、空间大 单链表和双链表 数据列表（ArrayList） Array 数组: 一组连续的物理空间，一组元素，不可变长度，查找性能高，但是插入和删除需要移动位置，性能低 ArrayList：可变长度的数组 使用 ArrayList 类 Add、AddRange 和 ToArray 方法的项代码： 12345public static void Main() &#123; ArrayList myAL = new ArrayList();// 创建和初始化ArrayList. myAL.Add(&quot;The&quot;); //添加一个元素 myAL.AddRange(new string[] &#123; &quot;the&quot;, &quot;lazy&quot;,&quot;dog&quot; &#125;);//添加一组元素&#125; 集合（Set）接口 集合 Set：不包含重复元素的集合，属于 Collection Framework 框架 public interface Set &lt;E&gt;、extends Collection &lt;E&gt; 集合提供一种更灵活的方式使用对象组，内存空间灵活 与数组不同，处理的对象组可根据程序更改的需要动态地增长和收缩 对于某些集合，可以指定键Key，则放入集合中的所有对象，以便可以快速检索对象 集合是类，因此必须 new 新集合后，才能添加元素 123456Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i = 0; i &lt; 100; i++) &#123; set.add(i);&#125;System.out.println(set);TreeSet sortedSet = new TreeSet&lt;Integer&gt;(set); //有序集System.out.println(sortedSet); 哈希映射（HashMap） HashMap，存储键值对（Key/Value）数据，类型定义 java.util.HashMap&lt;K,V&gt; public class HashMap&lt;K,V&gt;、extends AbstractMap&lt;K,V&gt;、implements Map&lt;K,V&gt;, Cloneable, Serializable 继承了抽象类 AbstractMap，基于哈希表的Map接口的实现，并允许 null 值和 null 键。 提供了 get( ) 和 put( ) 方法，HashMap 是无序的，即不会记录插入的顺序 HashMap 与 Hashtable 基本一样，但是不同步，允许为 null 1234HashMap&lt;Integer, String&gt; hashmap = new HashMap&lt;Integer, String&gt;();System.out.println(hashmap.put(1, “C&quot;) ); //添加Key,ValueSystem.out.println(hashmap.put(2, “C++&quot;) ); //添加Key,ValueSystem.out.println(hashmap.put(3, “Java&quot;) ); //添加Key,Value 哈希表（Hashtable） Hashtable 类实现一个哈希表，存储键Key映射到值Value，任何非空（Null）对象都可以用作键或值 为了成功地从哈希表存储和检索对象，用作键的对象必须实现 hashCode 方法和 equals 方法 Hashtable 类包含在 java.util 包中，java.util.Hashtable&lt;K,V&gt; 哈希表（散列表）类似HashMap，但支持多线程安全，哈希表将key/value(键/值对)存储在哈希表中。 在Hashtable中，我们指定一个用作键的对象，以及要与该键关联的值，然后对键进行哈希处理，并将生成的哈希码用作将值存储在表中的索引。 Hashtable 类的初始默认容量为11，而 loadFactor 为0.75。 在Java版本2中，重写了Hashtable类以实现Map接口，并使它成为 Java Collection Framework的成员 1234Hashtable&lt;Integer, String&gt; hashtable = new Hashtable&lt;Integer, String&gt;();System.out.println( hashtable.put(1, “C&quot;) ); //添加Key,ValueSystem.out.println( hashtable.put(2, “C++&quot;) ); //添加Key,ValueSystem.out.println( hashtable.put(3, “Java&quot;) ); //添加Key,Value HashMap 和 HashTable的区别 HashMap Hashtable 非同步synchronized 同步synchronized 不是线程安全 线程安全 允许1个null key 和多个null 值 不允许null key 和null value JDK 1.2引入 早期就有 使用Iterator遍历Hashmap 使用Iterator或Enumeration遍历Hashtable 继承AbstractMap类 继承Dictionary类 并发高 并发低 其他复杂数据类型 枚举（ Enumeration） 向量（ Vector） 栈（ Stack）：先进后出 字典（Dictionary ） 队列（Queue）：先进先出 树（Tree） 泛型Java 泛型机制 Java泛型（ generic Type）是JDK 5 2004年中引入的一个新特性。是万能类型，泛型实现代码和算法的重用 Java泛型方法和泛型类 让类型定义更灵活，以后随意替换具体类型 早期 List&lt;Object&gt; 来接受更多的参数类型，该机制允许程序员在编译时检测到非法的类型，比如重用排序算法，支持各种类型对象的排序 泛型方法在调用时可以接收不同类型的参数 Java泛型使用的机制和C#不同（伪泛型）。编译器会把泛型信息类型擦除。 实际编译的代码不包含类型信息 type erasure ArrayList&lt;E&gt; 和HashMap&lt;k,v&gt;都是典型的泛型类型 泛型定义12345678// Java泛型定义和C#泛型List定义语法一样public class List&lt;T&gt; &#123; private t; public void add(T t) &#123; this.t = t;&#125;public T get() &#123; return t;&#125;&#125; 泛型实战123456System.out.println(&quot;Java泛型实战&quot;);ArrayList&lt;String&gt; listNames = new ArrayList&lt;String&gt;();Class c2 = listNames.getClass();listNames.add(“阿里Java训练营&quot;); listNames.add(“阿里云大学&quot;);System.out.println(c1 == c2);for (String s : listNames) &#123; System.out.println(s); &#125; 数据库ODBC开放数据库连接 微软提出的数据库接口标准：Open Database Connectivity，简称ODBC 开放数据库连接技术，解决不同异构数据库连接的问题，主要是Windows系统来用，支持多种数据库 ODBC 现已成为WOSA（The Windows Open System Architecture）（Windows开放系统体系结构）的主要部分 ODBC基于Windows系统一种数据库访问接口标准，用ODBC 可以访问各类计算机上的DB文件，也可以访问如Excel 表和 ASCII 数据文件这类非数据库对象 Java数据库连接驱动 JDBC JDBC 框架，Java数据库连接技术（Java Database Connectivity），与.NET中的ADO.NET类似 JDBC是Java语言编程中与数据库连接的API，封装了各种数据库访问的API 和基础类库，支持多种数据库连接 NoSQL：Mongodb 公司提供 Java 和 C# 驱动 JDBC 支持的数据库：Oracle、DB2、Sql Server、Sybase、Informix、MySQL、PostgreSQL、access（直连用ODBC） JDBC 很像微软的ADO.NET 和C#的数据库连接技术，可以向数据库传递SQL语句命令，实现各种操作，也可以调用储存过程 SQLHelper 和 MySQLHelper支持Java和C#工具类 现在普遍使用 ORM 框架，底层使用了JDBC和ADO.NET Hibernate（Entity Framework），mybatis（Dapper） JDBC 5大对象 接口和类 DriverManager：驱动管理器，管理数据库驱动程序列表 Driver：处理与数据库服务器的通信，可能由多种驱动 Connection：数据库连接对象。C#的连接对象是 SQLConnection Statement：SQL语句对象，将SQL语句提交数据库。SQLCommand ResultSet：SQL查询这些对象保存查询结果。DataSet、DataReader SQLException：数据库操作异常类型，C#也有 JDBC编程5大步骤 JDBC 连接MySQL 对应的驱动包，工具类 1234567&lt;!--在pom.xml文件中添加驱动dependency--&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt; 手动引用到项目中，Maven自动化构建工具 123456789101112131415161718192021222324252627282930package com.alibaba.AlibabaJava07JDBCMySQLDemo;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Connection;import java.sql.SQLException;public class Test&#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 1.加载驱动 JSP连接MySQL Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 2.连接数据 String url = &quot;jdbc:mysql://localhost:3306/taobao?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;; String username = &quot;root&quot;; String password = &quot;990312&quot;; Connection con = DriverManager.getConnection(url, username, password); // 3.SQL命令 String sql = &quot;select * from users order by Id&quot;; java.sql.Statement statement = con.createStatement(); // 4.执行SQL命令 ResultSet result = statement.executeQuery(sql); // 5.结果处理 while (result.next()) &#123; String id = result.getString(&quot;id&quot;); String name = result.getString(&quot;name&quot;); String psw = result.getString(&quot;password&quot;); System.out.println(id+&quot; : &quot;+ name + &quot; : &quot; + psw); &#125; // 6.结束运行 result.close(); statement.close(); con.close(); &#125; &#125; 加载（注册）数据库驱动库 -&gt; 建立链接 -&gt; 执行SQL语句 -&gt; 处理结果集RecordSet -&gt; 关闭数据库 12345678910111213// 3.SQL命令String sql = &quot;INSERT INTO `users` (`id`,`name`,`password`) VALUES(?,?,?);&quot;;// 4.准备命令PreparedStatement statement = connection.prepareStatement(sql);// 5.设置参数statement.setInt(1, id);statement.setString(2, name);statement.setString(3, password);// 6.执行SQL命令statement.execute();// 7.关闭连接statement.close();connection.close(); JDBC驱动和数据库URL 数据库 JDBC驱动名称 URL格式 MySQL com.mysql.jdbc.Driver jdbc:mysql://hostname/databaseName ORACLE oracle.jdbc.driver.OracleDriver jdbc:oracle:thin:@hostname:portNumber:databaseName PostgreSQL org.postgresql.Driver jdbc:postgresql://hostname:port/dbname DB2 com.ibm.db2.jdbc.net.DB2Driver jdbc:db2:hostname:port Number/databaseName Sybase com.sybase.jdbc.SybDriver jdbc:sybase:Tds:hostname:portNumber/databaseName Java三层架构 UI展示层Presentation Layer：Swing、网页、WP、IOS、安卓 Services 业务逻辑层 DAO 数据访问层 JSP网站开发和Servlet底层原理Web网站开发框架 JQuery、Bootstrap、EasyUI、Angular JS、React.JS、Vue.JS HTML5、CSS3、JavaScript、XML、JSON、Flash Silverlight PHP、ASP、JSP、ASP.NET MVC、Java Spring MVC、Node.js、Spring Boot Web服务器：Tomcat\\Nginx\\IIS ORM数据库连接 JSP动态网站开发框架 PHP 脚本语言，1994 ASP VBScript，1996 Active Server Page JSP JavaScript，1999年 网页中嵌入Java语言 Netscape 网景公司和Sun ASP.NET WebForm 2002 拖控件，网页嵌入 C# JSP动态网站开发技术 JSP与PHP、ASP、ASP.NET等类似，是动态网页开发技术。 JSP（全称Java Server Page）Sun公司，1999发布，由Sun Microsystems公司倡导和许多公司参与共同创建 JSP 技术是以Java语言作为开发语言的，网页嵌入Java代码 ASP是以vb脚本作为开发语言， C#嵌入，文件扩展名为 .asp ASP.NET WebForm 前后分离，嵌入C#，文件扩展名 .aspx JSP 网页本质上Java代码在服务器端处理客户端的HTTP请求 HTML：Hypertext Markup Language 超文本标记语言，HTTP：Hypertext Transfer Protocol 超文本传输协议 JSP文件后缀名为 .jsp ，JSP可以运行在Linux和Windows上 新建一个JSP网站 Eclipse新建一个JSP网站 编写页面内容Hello 阿里巴巴Java训练营 使用Tomcat运行起来 Java写网页 内嵌 Java语言代码 &lt;%Java代码%&gt; 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;Java实战训练营&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img alt=&quot;&quot; src=&quot;Images/mongodb.png&quot;&gt;&lt;% out.println(“阿里巴巴Java实战训练营&quot;); %&gt;&lt;/body&gt;&lt;/html&gt; JSP网页9大内置对象 对象 名词 描述 request 请求 HttpServletRequest类的实例，用户请求 response 应答 HttpServletResponse类的实例，返回应答消息 out 临时输出 PrintWriter类的实例，用于把结果输出到网页流中 session 会话 HttpSession类的实例，会话，记录和当前用户相关的数据 application 应用程序 ServletContext类的实例，与应用上下文有关 config 配置 ServletConfig类的实例 pageContext 页面上下文 PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问 page 页面 类似于Java类中的this关键字 Exception 异常 Exception类的对象，代表发生错误的JSP页面中对应的异常对象 Session跨页面传递数据 Session会话对象 用于用户访问网站期间的临时数据的缓存 购物车 JSP对象的4大作用范围（4大作用域） page scope 页面范围 request scope 请求范围 session scope 会话范围 application scope. 应用程序范围 JSP查询MySQL 新建JSP网页 网页中导入JDBC包 连接MySQL数据库Alibaba 查询用户 显示到页面上 HTML5：标签语言网页内容 CSS3：样式，颜色，大小，位置，Bootstrap JavaScript：脚本语言，JQuery Bootstrap样式 http://www.bootcss.com/ Tweeter提供的免费开源样式 页面直接加入样式引用，在html标签使用样式 &lt;table class=&quot;table&quot;&gt; JSP访问MySQL数据库 包引用只存入Web目录下就可以了 命名空间 123456&lt;%@ page import=&quot;java.io.*,java.util.*,java.sql.*&quot;%&gt;&lt;%@ page import=&quot;javax.servlet.http.*,javax.servlet.*&quot; %&gt;&lt;%@page import=&quot;java.sql.Connection&quot; %&gt;&lt;%@page import=&quot;java.sql.DriverManager&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; prefix=&quot;sql&quot;%&gt; JSP连接MYSQL代码12345678910111213141516171819202122232425262728293031&lt;table class=&quot;table&quot;&gt;&lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;阅读次数&lt;/th&gt;&lt;/tr&gt; &lt;% String driverClass=&quot;com.mysql.jdbc.Driver&quot;; String url=&quot;jdbc:mysql://localhost:3306/taobao&quot;; String user=&quot;root&quot;; String password=&quot;1234qwer&quot;; Connection conn; try&#123; Class.forName(driverClass); conn=DriverManager.getConnection(url,user,password); Statement stmt=conn.createStatement(); String sql=&quot;select * from news order by Id desc&quot;; ResultSet rs=stmt.executeQuery(sql); while(rs.next())&#123; %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=rs.getString(&quot;Id&quot;) %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString(&quot;Title&quot;) %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getInt(&quot;ViewTimes&quot;) %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125; &#125; catch(Exception ex)&#123; ex.printStackTrace(); &#125; %&gt;&lt;/table&gt; JSP实战新闻编辑 用户选择编辑，id传递 编辑页面接收id, 保存到隐藏html元素：hidden 数据查询：新闻数据 赋值给控件：从发布新闻页面拷贝，CSS，HTML5 提交单独页面：独立保存编辑后的信息 Java JSP生命周期 Servlet：Java中用来处理HTTP请求的类 JSP生命周期：从创建到销毁的整个过程，Servlet 生命周期，编译、创建、执行、销毁 JSP生命周期包括：将JSP文件编译成 servlet 开发阶段： 编写JSP页面代码 编译阶段：JSP编译成servlet类，生成 servlet 类class 初始化阶段：加载JSP的servlet类，创建对象，初始化 执行阶段：调用JSP对应的servlet实例的服务方法 销毁阶段：调用JSP对应的servlet实例的销毁方法，销毁对象 部署网站Tomcat9网站Web服务器 Tomcat开源免费的Java Web服务器软件，最初由Sun的软件构架师詹姆斯·邓肯·戴维森开发的， Tomcat是 Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和Oracle其他一些公司及个人共同开发而成 Tomcat支持Servlet 和JSP 规范规范、WebSocket、微软的IIS Web服务器 官方网站：http://tomcat.apache.org/ Tomcat的核心组件（架构） Web容器—-处理静态页面 catalina —- servlet容器——-处理servlet JSP容器，它就是把jsp页面翻译成一般的servlet 课程代码 课程代码已上传 Github 仓库","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://blog.zhuangzhihao.top/tags/Servlet/"},{"name":"JDBC","slug":"JDBC","permalink":"http://blog.zhuangzhihao.top/tags/JDBC/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://blog.zhuangzhihao.top/tags/Tomcat/"}]},{"title":"Python for Data Science, AI & Development","slug":"Python-for-Data-Science","date":"2021-02-03T16:00:00.000Z","updated":"2022-06-07T13:21:16.632Z","comments":true,"path":"Python-for-Data-Science/","link":"","permalink":"http://blog.zhuangzhihao.top/Python-for-Data-Science/","excerpt":"This course provided by IBM will not teach everything about Python, but it gives me the tools to work as a data scientist and enough knowledge to continue to expand Python learning. The following are the notes I took during this course. Since that I’ve learned Python for everybody on Coursera before, so this note will only contain the necessary outlines and newly learned content.","text":"This course provided by IBM will not teach everything about Python, but it gives me the tools to work as a data scientist and enough knowledge to continue to expand Python learning. The following are the notes I took during this course. Since that I’ve learned Python for everybody on Coursera before, so this note will only contain the necessary outlines and newly learned content. Python Basics Types int, float, str, True, False Expressions and Variables Mathematical Operations String Operations Name[1:4], len(), \\n try:，except: Python Data Structures Lists [1, 2, 3] and Tuples (1, 2, 3) ABC[1], Tuples are immutable .extend(), .append(), .split(), .pop(), .del() , .index(), sorted() Append only adds one element to the list Sets &#123;q, w, e&#125; unordered, unique element, set(list), .remove() set2 = set1 &amp; set 3, .union, set2.issubset(set1), .issuperset(), .difference() Dictionaries &#123;&quot;key1&quot;:value1, &quot;key2&quot;: value2&#125; DICT[&#39;Graduation&#39;]=&#39;2022&#39;, .keys(), .values(), &#39;Graduation&#39; in DICT Python Programming Fundamentals Conditions and Branching Comparison Operators ==，Logic Operatorsor AND，Boolean if ():， elif: Loops：range(10,15)，for a in range():，while(): Functions: a function can have multiple parameters def function(input): global [variable] Objects and Classes Every object has a type, a blueprint and a set of methods. An object is an instance of a particular type. Class includes Data attributes and methods dir(NameOfObject): 1234class Circle(object): def __init__(self, radius, color=&#x27;red&#x27;): self.radius = radius; self.color = color; Reading and Writing files with open() 123456789101112with open(&quot;/example1.txt&quot;, &quot;r&quot;) as File1: # &quot;r&quot; for reading file_stuff=File1.read() # file.readlines()can save text to a list print(file_stuff) # file.readline(3)can only read 1 lineprint(File1.closed)with open(&quot;/example2.txt&quot;, &quot;a&quot;) as File2: #&quot;a&quot; for appending File2.write(line) with open(&quot;example1.txt&quot;, &quot;r&quot;) as readfile: # copy file with open(&quot;example2.txt&quot;, &quot;w&quot;): # &quot;w&quot; for writing for line in readfile: writefile.write(line) PandasLoading data with Pandas12345import pandas as pdcsv_path=&quot;file1.csv&quot;df = pd.read_csv(csv_path) # Dataframesdf.head() # Treat the first row as the column namex=df[[&#x27;ColumnA&#x27;]] Select Data from a data frame in Pandas df.loc[&#39;row&#39;, &#39;column&#39;]: &#39;value&#39; loc is primarily label based; when two arguments are used, you use column headers and row indexes to select the data you want. loc can also take an integer as a row or column number. loc will return a KeyError if the requested items are not found. df.iloc[0,0]:&#39;value&#39; iloc is integer-based. You use column numbers and row numbers to get rows or columns at particular positions in the data frame. iloc will return an IndexError if the requested indexer is out-of-bounds. Use loc and iloc to slice data frames and assign the values to a new data frame. z = df.iloc[0:2, 0:3] Working with and Saving data with Pandas df[&#39;ColumnA&#39;].unique()，`df1=df[df[&#39;ColumnA&#39;]&gt;=1980] Save as CSV：df1.to_csv(&#39;new.csv&#39;) NumpyPreparation1234567891011121314151617181920212223242526# Import the librariesimport time import sysimport numpy as np import matplotlib.pyplot as plt%matplotlib inline # Plotting functionsdef Plotvec1(u, z, v): ax = plt.axes() ax.arrow(0, 0, *u, head_width=0.05, color=&#x27;r&#x27;, head_length=0.1) plt.text(*(u + 0.1), &#x27;u&#x27;) ax.arrow(0, 0, *v, head_width=0.05, color=&#x27;b&#x27;, head_length=0.1) plt.text(*(v + 0.1), &#x27;v&#x27;) ax.arrow(0, 0, *z, head_width=0.05, head_length=0.1) plt.text(*(z + 0.1), &#x27;z&#x27;) plt.ylim(-2, 2) plt.xlim(-2, 2)def Plotvec2(a,b): ax = plt.axes() ax.arrow(0, 0, *a, head_width=0.05, color =&#x27;r&#x27;, head_length=0.1) plt.text(*(a + 0.1), &#x27;a&#x27;) ax.arrow(0, 0, *b, head_width=0.05, color =&#x27;b&#x27;, head_length=0.1) plt.text(*(b + 0.1), &#x27;b&#x27;) plt.ylim(-2, 2) plt.xlim(-2, 2) One Dimensional Numpy A numpy array is similar to a list. It’s usually fixed in size and each element is of the same type. 123456789101112import numpy as npa=np.array([0,1,2,3,4])a.size # Get the size of numpy array 5a.ndim # Get the number of dimensions of numpy array 1a.shape # Get the shape/size of numpy array (5,)a.dtype # Check the type of the values stored in numpy arraya[0]=20 # Assign value [20,1,2,3,4]b=a[3:5] # Slicing [3,4]mean = a.mean() # Get the mean of numpy arraystandard_deviation=a.std() # Get the standard deviation of numpy arraymax_b = b.max()min_b = b.min() Numpy Array Operations 12345678910u = np.array([1, 0])v = np.array([0, 1])z = u + v # Numpy Array AdditionPlotvec1(u, z, v) # Plot numpy arrays (equivalent to vector addition)z = 2 * u # Numpy Array Multiplicationz = u * v # Calculate the production of two numpy arraysnp.dot(u, v) # Calculate the dot product 1*0+0*1u + 1 # Add the constant to array [2,1]x = np.array([0, np.pi/2 , np.pi]) # Create the numpy array in radiansy = np.sin(x) # Calculate the sin of each elements A useful function for plotting mathematical functions is linspace Linspace returns evenly spaced numbers over a specified interval. 123x = np.linspace(0, 2*np.pi, num=100) # Makeup a numpy array within [0, 2π] and 100 elements y = np.sin(x) # Calculate the sine of x listplt.plot(x, y) # Plot the result Two Dimensional Numpy123456789101112131415a=[[11,12,13],[21,22,23],[31,32,33]]A = np.array(a) # Convert list to Numpy Array，Every element is the same typeA.ndim # # Show the numpy array dimensions 2A.shape # A.shape (3,3)A.size # # Show the numpy array size 9A[1, 2] # Access the element on the second row and third column 23A[1][2] # Access the element on the second row and third columnA[0][0:2] # Access the element on the first row and first and second columns array([11, 12])A[0:2, 2] # Access the element on the first and second rows third column array([13, 23])Z = X + Y # Add X and YZ = 2 * Y # Multiply Y with 2Z = X * Y # Multiply X with YZ = np.dot(A,B) # Calculate the dot productnp.sin(Z) # Calculate the sine of ZC.T # Get the transposed of C Simple APIsCreate and Use APIs in Python An API lets two pieces of software talk to each other. An essential type of API is a REST API (Representational State Transfer APIs) that allows you to access resources via the internet. Preparation 12345678!pip install nba_apidef one_dict(list_dict): keys=list_dict[0].keys() out_dict=&#123;key:[] for key in keys&#125; for dict_ in list_dict: for key, value in dict_.items(): out_dict[key].append(value) return out_dict Pandas API 123456import pandas as pdimport matplotlib.pyplot as pltdict_=&#123;&#x27;a&#x27;:[11,21,31],&#x27;b&#x27;:[12,22,32]&#125; # create a dictionarydf=pd.DataFrame(dict_) #use the dataframe to communicate with the pandas APIdf.head()df.mean() REST APIs Use the NBA API to determine how well the Golden State Warriors performed against the Toronto Raptors. Use the API do the determined number of points the Golden State Warriors won or lost by for each game. 123456789101112131415161718192021222324from nba_api.stats.static import teams #https://pypi.org/project/nba-api/import matplotlib.pyplot as pltnba_teams = teams.get_teams() #returns a list of dictionaries #The dictionary key id has a unique identifier for each team as a valuenba_teams[0:3]dict_nba_team=one_dict(nba_teams) #create a dictionarydf_teams=pd.DataFrame(dict_nba_team)df_teams.head()df_warriors=df_teams[df_teams[&#x27;nickname&#x27;]==&#x27;Warriors&#x27;]id_warriors=df_warriors[[&#x27;id&#x27;]].values[0][0] #we now have an integer that can be used to request the Warriors informationfrom nba_api.stats.endpoints import leaguegamefinderwget https://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/PY0101EN/Chapter%205/Labs/Golden_State.pklfile_name = &quot;Golden_State.pkl&quot;games = pd.read_pickle(file_name)games.head()games_home=games [games [&#x27;MATCHUP&#x27;]==&#x27;GSW vs. TOR&#x27;] #create two dataframesgames_away=games [games [&#x27;MATCHUP&#x27;]==&#x27;GSW @ TOR&#x27;] #Home&amp;Awaygames_home.mean()[&#x27;PLUS_MINUS&#x27;]games_away.mean()[&#x27;PLUS_MINUS&#x27;]fig, ax = plt.subplots() #plot outgames_away.plot(x=&#x27;GAME_DATE&#x27;,y=&#x27;PLUS_MINUS&#x27;, ax=ax)games_home.plot(x=&#x27;GAME_DATE&#x27;,y=&#x27;PLUS_MINUS&#x27;, ax=ax)ax.legend([&quot;away&quot;, &quot;home&quot;])plt.show() Create Speech to Text Translator Convert an audio file of an English speaker to text using a Speech to Text API 12345678910111213141516171819!pip install PyJWT==1.7.1 ibm_watson wgetfrom ibm_watson import SpeechToTextV1 import jsonfrom ibm_cloud_sdk_core.authenticators import IAMAuthenticatorurl_s2t = &quot;&quot; #URLiam_apikey_s2t = &quot;&quot; #API keysauthenticator = IAMAuthenticator(iam_apikey_s2t) # create a Speech To Text Adapter objects2t = SpeechToTextV1(authenticator=authenticator)s2t.set_service_url(url_s2t)!wget -O PolynomialRegressionandPipelines.mp3 https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%205/data/PolynomialRegressionandPipelines.mp3filename=&#x27;PolynomialRegressionandPipelines.mp3&#x27;with open(filename, mode=&quot;rb&quot;) as wav: response = s2t.recognize(audio=wav, content_type=&#x27;audio/mp3&#x27;)response.resultfrom pandas.io.json import json_normalizejson_normalize(response.result[&#x27;results&#x27;],&quot;alternatives&quot;)responserecognized_text=response.result[&#x27;results&#x27;][0][&quot;alternatives&quot;][0][&quot;transcript&quot;] Translate the English version to a Spanish version using a Language Translator API 1234567891011121314151617181920from ibm_watson import LanguageTranslatorV3url_lt=&#x27;https://gateway.watsonplatform.net/language-translator/api&#x27;apikey_lt=&#x27;&#x27;version_lt=&#x27;2018-05-01&#x27;authenticator = IAMAuthenticator(apikey_lt)language_translator = LanguageTranslatorV3(version=version_lt,authenticator=authenticator)language_translator.set_service_url(url_lt)language_translatorfrom pandas.io.json import json_normalizejson_normalize(language_translator.list_identifiable_languages().get_result(), &quot;languages&quot;)translation_response = language_translator.translate(\\ text=recognized_text, model_id=&#x27;en-es&#x27;)translation_responsetranslation=translation_response.get_result()translationspanish_translation =translation[&#x27;translations&#x27;][0][&#x27;translation&#x27;]spanish_translation translation_new = language_translator.translate(text=spanish_translation ,model_id=&#x27;es-en&#x27;).get_result()translation_eng=translation_new[&#x27;translations&#x27;][0][&#x27;translation&#x27;]translation_eng HTTP and Requests When the client use a web page, browser sends an HTTP request to the server where the page is hosted. The server tries to find the desired resource by default index.html. If request is successful, the server will send the object to the client in an HTTP response, this includes information like the type of the resource, the length of the resource, and other information. The HTTP protocol allows you to send and receive information through the web including webpages, images, and other web resources. Uniform resource locator (URL) is the most popular way to find resources on the web. Request：GET，POST，PUT，DELETE method 12345678910111213141516171819202122232425import requestsimport os from PIL import Imagefrom IPython.display import IFrameurl=&#x27;https://www.ibm.com/&#x27;r=requests.get(url)r.status_code #view the status codeprint(r.request.headers)print(&quot;request body:&quot;, r.request.body)header=r.headers #view the HTTP response headerprint(r.headers)header[&#x27;date&#x27;]header[&#x27;Content-Type&#x27;] #Content-Type indicates the type of datar.encoding #check the encodingr.text[0:100]# Use single quotation marks for defining stringurl=&#x27;https://gitlab.com/ibm/skills-network/courses/placeholder101/-/raw/master/labs/module%201/images/IDSNlogo.png&#x27;r=requests.get(url) #make a get requestprint(r.headers)r.headers[&#x27;Content-Type&#x27;]# An image is a response object that contains the image as a bytes-like objectpath=os.path.join(os.getcwd(),&#x27;image.png&#x27;)with open(path,&#x27;wb&#x27;) as f: f.write(r.content)Image.open(path) Write wget 1!wget -O /resources/data/Example1.txt https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%205/data/Example1.txt Is Equal To: 12345url=&#x27;https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%205/data/Example1.txt&#x27;path=os.path.join(os.getcwd(),&#x27;example1.txt&#x27;)r=requests.get(url)with open(path,&#x27;wb&#x27;) as f: f.write(r.content) Get Request with URL Parameters We append /get in the Route indicate we would like to preform a GET request url_get=&#39;http://httpbin.org/get&#39; A query string is a part of a uniform resource locator (URL), this sends other information to the web server. 123456789payload=&#123;&quot;name&quot;:&quot;Joseph&quot;,&quot;ID&quot;:&quot;123&quot;&#125;r=requests.get(url_get,params=payload)r.urlprint(&quot;request body:&quot;, r.request.body)print(r.status_code)print(r.text)r.headers[&#x27;Content-Type&#x27;]r.json()r.json()[&#x27;args&#x27;] POST is used to send data to a server, but the POST request sends the data in a request body. url_post=&#39;http://httpbin.org/post&#39; This endpoint will expect data as a file or as a form, a from is convenient way to configure an HTTP request to send data to a server. 12345678# To make a POST request we use the post() function, the variable payload is passed to the parameter data r_post=requests.post(url_post,data=payload) print(&quot;POST request URL:&quot;,r_post.url ) #the POST request has no name or value pairsprint(&quot;GET request URL:&quot;,r.url)print(&quot;POST request body:&quot;,r_post.request.body) #compare the POST and GET print(&quot;GET request body:&quot;,r.request.body)r_post.json()[&#x27;form&#x27;] Final ProjectAnalyzing US Economic Data and Building a Dashboard A template notebook is provided in the lab Examine how changes in GDP impact the unemployment rate. 12345678910111213import pandas as pdfrom bokeh.plotting import figure, output_file, show,output_notebookoutput_notebook()# Define the function make_dashboarddef make_dashboard(x, gdp_change, unemployment, title, file_name): output_file(file_name) p = figure(title=title, x_axis_label=&#x27;year&#x27;, y_axis_label=&#x27;%&#x27;) p.line(x.squeeze(), gdp_change.squeeze(), color=&quot;firebrick&quot;, line_width=4, legend=&quot;% GDP change&quot;) p.line(x.squeeze(), unemployment.squeeze(), line_width=4, legend=&quot;% unemployed&quot;) show(p)# The dictionary links contain the CSV files with all the data. links=&#123;&#x27;GDP&#x27;:&#x27;https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/FinalModule_Coursera/data/clean_gdp.csv&#x27;,\\ &#x27;unemployment&#x27;:&#x27;https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/FinalModule_Coursera/data/clean_unemployment.csv&#x27;&#125; Question 1: Create a dataframe that contains the GDP data and display the first five rows of the dataframe. 123csv_path=links[&#x27;GDP&#x27;] # links[&quot;GDP&quot;] contains the path or name of the file.df=pd.read_csv(csv_path)df.head() Question 2: Create a dataframe that contains the unemployment data. Display the first five rows of the dataframe. 123csv_path=links[&#x27;unemployment&#x27;]df=pd.read_csv(csv_path)df.head() Question 3: Display a dataframe where unemployment was greater than 8.5%. 1234csv_path=links[&#x27;unemployment&#x27;]df=pd.read_csv(csv_path)df1=df[df[&#x27;unemployment&#x27;]&gt;8.5]df1 Question 4: Use the function make_dashboard to make a dashboard 123456789101112131415161718# Create your dataframe with column datecsv_path=links[&#x27;GDP&#x27;]gdp_dataframe=pd.read_csv(csv_path)x = pd.DataFrame(gdp_dataframe, columns=[&#x27;date&#x27;])x.head()# Create your dataframe with column change-currentgdp_change = pd.DataFrame(gdp_dataframe, columns=[&#x27;change-current&#x27;])gdp_change.head()# Create your dataframe with column unemploymentcsv_path=links[&#x27;unemployment&#x27;]unemploy_dataframe= pd.read_csv(csv_path)unemployment = pd.DataFrame(unemploy_dataframe, columns=[&#x27;unemployment&#x27;])unemployment.head()# Give your dashboard a string titletitle = &quot;Unemployement stats &amp; GDP&quot;file_name = &quot;index.html&quot;# Fill up the parameters in the following function:make_dashboard(x=x, gdp_change=gdp_change, unemployment=unemployment, title=title, file_name=file_name) My Work Final Assignment Notebook Url (May not be accessible from Mainland China) Assignments Visit my Github Repository","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[]},{"title":"Data Visualization and Dashboards with Excel and Cognos","slug":"Data-Visualization-and-Dashboards","date":"2021-02-01T16:00:00.000Z","updated":"2022-05-05T12:55:43.492Z","comments":true,"path":"Data-Visualization-and-Dashboards/","link":"","permalink":"http://blog.zhuangzhihao.top/Data-Visualization-and-Dashboards/","excerpt":"“A picture is worth 1,000 words”. This Course provided by IBM endows me with the ability to effectively create data visualizations, such as charts or graphs, with Excel and IBM Cognos Analytics, without having to write any code. It also elevates my confidence level in creating intermediate level data visualizations after numerous hands-on labs and the final project. The following are the notes I took during this course.","text":"“A picture is worth 1,000 words”. This Course provided by IBM endows me with the ability to effectively create data visualizations, such as charts or graphs, with Excel and IBM Cognos Analytics, without having to write any code. It also elevates my confidence level in creating intermediate level data visualizations after numerous hands-on labs and the final project. The following are the notes I took during this course. Introduction to Charts Line Charts compare different but related data sets, they can display trends and show how data values change in relation to a continuous variable (e.g. time) Pie Charts can show the breakdown of an entity into its sub-parts and the proportion of the sub-parts in relation to one another. Each portion represents a static value or category. Bar Charts: Stacked bar charts Column Charts can be used quite effectively to show change over time and to compare values side-by-side. Treemaps are useful for displaying complex hierarchies using nested rectangles. Funnel Charts can display a pipeline or different stages of a continuous process. In Scatter Chart, the circle colors represent the categories of data and the circle sizes are indicative of the volume of data. A scatter chart can be great for revealing trends, clusters, patterns, and correlations between data points. Bubble Charts. are useful for comparing a handful of categories to one another in terms of relative significance. Sparklines do not include an axis or coordinates, yet they display trends simply and effectively. These are great for showing the general trend of a variation. A pivot chart is used to show the data series, categories, and chart axes the same way a basic chart is used. Area charts Column charts Use a pivot table or pivot chart to filter data and to expand and collapse data levels. Advanced Charts A tree map chart is used to compare values across hierarchy levels and show proportions within hierarchical levels as rectangles. Tree maps are a good way of displaying lots of data in one graphical asset because they use the color and closeness of proportional shapes within the chart to represent hierarchical data categories. A scatter chart is a type of graph used to compare two sets of numerical data values and show relationships between those sets of numerical values. A scatter chart combines the two sets of values on the x and y axes into single points of data and then displays them in clusters in the chart. A histogram is a graph that shows the distribution of the data grouped into bins. A bar chart is used to compare data while a histogram is used to display distribution of data. A filled map chart is a type of chart used to compare values and show categories across geographical regions. Sparklines are mini charts placed inside single cells to represent a selected range of data. They are typically used to show data trends, such as seasonal increase-decrease, economic cycles, and share, rate, or price fluctuations. A sparkline provides the greatest impact when it is placed close to the data it represents. Creating Dashboards Using Spreadsheets The term dashboard comes from the automotive industry where car designers have put the most important gauges and other display information in a handy graphical display that is easy for the driver to view and understand. Data Analysis dashboards provide key information in one place Dashboards can provide user interaction capabilities like filters, slicers, timelines and map charts Dashboard users get consolidated and visualized insight into their most important business data and KPIs. Dashboard users get a self-service BI interface Dashboards are typically created in a data analysis application by using multiple pivot tables and charts, visualizations and filtering tools. Advanced data analysis and visualization apps: Bokeh, Dash in Python, R-Studio’s Shiny, Tableau, IBM Cognos Analytics Expert Viewpoints Advice: “Less is more”, make visualizations more focused to highlight just one or two important points. Creating Dashboards Using IBM Cognos Analytics Cognos Analytics is an AI-fueled business intelligence platform that supports the entire analytics cycle, from discovery to operationalization. Use Cognos Analytics to create a simple dashboard. Creating calculations and Leveraging navigation paths.","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[]},{"title":"Excel Basics for Data Analysis","slug":"Excel-Basics- for-Data-Analysis","date":"2021-01-30T16:00:00.000Z","updated":"2022-05-05T12:56:08.019Z","comments":true,"path":"Excel-Basics- for-Data-Analysis/","link":"","permalink":"http://blog.zhuangzhihao.top/Excel-Basics-%20for-Data-Analysis/","excerpt":"Excel is an essential tool for working with data - whether for business, marketing, data analytics, or research. Throughout this course provided by IBM, I’ve gained valuable experience in cleansing and wrangling data using functions and then analyze data using techniques like filtering, sorting and creating pivot tables. The following are the notes I took during this course.","text":"Excel is an essential tool for working with data - whether for business, marketing, data analytics, or research. Throughout this course provided by IBM, I’ve gained valuable experience in cleansing and wrangling data using functions and then analyze data using techniques like filtering, sorting and creating pivot tables. The following are the notes I took during this course. Introduction to Spreadsheets for Data Analysis There are several spreadsheet applications available in the marketplace, the most commonly used and fully-featured spreadsheet application is Microsoft Excel. Spreadsheets provide several advantages over manual calculation methods and they help you keep data organized and easily accessible. As a Data Analyst, you can use spreadsheets as a tool for your data analysis tasks. There are several elements that make up a workbook in a spreadsheet application. The ribbon provides access to all the features and tools required to view, enter, edit, manipulate, clean, and analyze data in Excel. There are several ways to navigate around a worksheet and workbook in Excel. How a Data Analyst Uses Spreadsheets: Collecting Data -&gt; Cleaning Data -&gt; Analyzing Data -&gt; Visualizing Data Workbooks are represented as a .XLSX file (Includes Data, Calculations, Functions and other Underlying Elements) Cells contains Text, Numbers, Formulas or Calculation Results Cells are organized in Rows and Columns Excel Keyboard Shortcuts Task Shortcut Close a workbook Ctrl+W Open a workbook Ctrl+O Save a workbook Ctrl+S Copy Ctrl+C Cut Ctrl+X Paste Ctrl+V Undo Ctrl+Z Remove cell contents Delete Bold Ctrl+B Open context menu Shift+F10 Expand or collapse the ribbon Ctrl+F1 Move up one cell in the worksheet Up arrow key Move down one cell in the worksheet Down arrow key Move one cell left in the worksheet Left arrow key Move one cell right in the worksheet Right arrow key Move to the edge of the current data region in the worksheet (e.g. end of column) Ctrl+Arrow key (e.g. Ctrl+Down arrow) Move to the last cell on a worksheet Ctrl+End Move to the beginning of a worksheet Ctrl+Home Extend the selection of cells to the last used cell on a worksheet (lower right corner) Ctrl+Shift+End Move to the cell in the upper-left corner of the window (when Scroll Lock is On) Home+Scroll Lock Move one screen down in a worksheet Page Down Move one screen up in a worksheet Page Up Move one screen to the right in a worksheet Alt+Page Down Move one screen to the left in a worksheet Alt+Page Up Move to the next sheet in a workbook Ctrl+Page Down Move to the previous sheet in a workbook Ctrl+Page Up Edit the active cell and put the cursor at the end of the cell’s contents F2 Enter the current time Ctrl+Shift+colon (:) Enter the current date Ctrl+semi-colon (;) Getting Started Using Spreadsheets There are several features to modify views in Excel, and it is very straightforward to enter and edit data in a spreadsheet. You can move or copy data within a worksheet or between worksheets, and you can use AutoFill to automatically enter data that is in a series or that fits a pattern. You can format both cells and data in Excel. A formula is made up of several component parts, and formulas can perform calculations using numbers directly or by using references to data in the worksheet. Basic formulas: =SUM(), =AVERAGE(), =MIN(), =MAX(), =COUNT(), =MEDIUM() More functions Financial : ACCRINT, INTRATE Logical : AND, IF, OR, NOT Text : CONCAT, FIND, SEARCH Date &amp; Time : NETWORKDAYS, WEEKDAY Lookup &amp; Reference : AREAS, SORTBY, VLOOKUP, HLOOKUP Math &amp; Trig : POWER, SUMIF, SUMPRODUCT Statistical : AVERAGE, COUNTIF, MAX, MEDIAN, MIN You can use the Fill Handle in Excel to quickly copy formulas to other cells. There are several different categories of function you can use for different purposes, and you can search for a function by name, or by category. You can reference cells in the worksheet in your formulas by using relative, absolute, or mixed references. You can make a formula absolute by adding a dollar symbol ($) to a cell reference. If you get errors in your formulas, you can use the error-checking capabilities of Excel to resolve them. Basics of Data Quality and Privacy The Five Traits of Data Quality: Accuracy Completeness Reliability Relevance Timeliness Importing Text: You can use the ‘Text Import Wizard’ to import data from other formats, such as plain text, or comma-separated value files. The Three Fundamentals of Data Privacy: Confidentiality, Collection and Use, Compliance Cleaning Data It’s important to remove any duplicated or inaccurate data, and it’s important to remove any empty rows in your dataset. There are several other types of data inconsistency that you may need to resolve, in order to properly clean your data: Change the case of text Fix date formatting errors Trim whitespace from your data You can use the Flash Fill and Text to Columns features in Excel to manipulate and standardize your data, and functions can also be used to help manipulate and standardize your data. Data Analysis Basics, Filtering and Sorting Data Before shaping your data, you need to visualize the final output, and ask yourself the following questions: How big is the dataset? What type of filtering is required to find the necessary information? How should the data be sorted? What type of calculations are needed? There are several advantages to formatting your data as a table: Automatic calculations even when filtering Column headings never disappear Banded rows to make reading easier Tables will automatically expand when adding new rows The most basic way of shaping your data is to sort and filter it: Sorting data helps you to organize it by a specified criteria, such as numerically, alphabetically, or chronologically. Filtering our data makes it easier to control what data is displayed and what is hidden, based on filtered fields. Functions in Excel are arranged into multiple categories; including mathematical, statistical, logical, financial, and date and time-based. Common functions for a data analyst include: IF, IFS(alternative for nested IF), COUNTIF, SUMIF, VLOOKUP(vertical lookup), HLOOKUP(horizontal lookup), XLOOKUP =IF(AD2&gt;300,&quot;Large&quot;,IF(AD2&gt;100,&quot;Medium&quot;,IF(AD2&gt;0,&quot;Small&quot;))) =IFS(AD2&gt;300,&quot;Large&quot;,AD2&gt;100,&quot;Medium&quot;,AD2&gt;0,&quot;Small&quot;) =COUNTIF(N2:N195,&quot;VISA&quot;) =SUMIF(range, criteria, [sum range]) =SUMIFS ([sum range], range1, criteria1, range2, criteria2, ...) =VLOOKUP (value, table, col_index, [range_lookup]) =HLOOKUP (value, table, row_index, [range_lookup]) Using Pivot Tables Pivot Tables: To obtain usable and presentable insights into your data you need to use Pivot Tables. Pivot tables provide a simple and quick way to summarize and analyze data, to observe trends and patterns in your data and to make comparisons of your data. Pivot tables are dynamic, so as you change and add data to the original dataset on which the pivot table is based, the analysis and summary information changes too. A Data Analyst can use pivot tables to draw useful and relevant conclusions about, and create insights into, an organization’s data in order to present those insights to interested parties within the company. Use this Pivot Table checklist to ensure your data is in a fit state to make a Pivot Table: Format your data as a table for best results. Ensure column headings are correct, and there is only one header row, as these column headings become the field names in a Pivot Table. Remove any blank rows and columns, and try to eliminate blank cells also. Ensure value fields are formatted as numbers, and not text, and ensure date fields are formatted as dates, and not text. Arranging Pivot Tables with Filters and Recommended Tables: You use the Pivot Table Fields pane to add and arrange data fields in your pivot table. Recommended Pivot Tables are a list of suggested different combinations of data that could be used when creating a Pivot Table, based on the data selected in the worksheet. Filters and Slicers: Slicers are on-screen graphical filter objects that enable you to filter your data using buttons, which makes it easier to perform quick filtering of your pivot table data. Timelines are another type of filter tool that enable you to filter specifically on date-related data in your pivot table. This is a much quicker and more effective way of dynamically filtering by date, rather than having to create and adjust filters on your date columns.","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[]},{"title":"Introduction to Data Analytics","slug":"Introduction-to-Data-Analytics","date":"2021-01-23T16:00:00.000Z","updated":"2022-05-05T12:58:58.392Z","comments":true,"path":"Introduction-to-Data-Analytics/","link":"","permalink":"http://blog.zhuangzhihao.top/Introduction-to-Data-Analytics/","excerpt":"The Introduction to Data Analytics course provided by IBM is the first in a series of courses designed to prepare me for a career as a junior data analyst. The course introduces me to the core concepts, processes, and tools I need to gain entry into data analytics. The following are the notes I took during this course.","text":"The Introduction to Data Analytics course provided by IBM is the first in a series of courses designed to prepare me for a career as a junior data analyst. The course introduces me to the core concepts, processes, and tools I need to gain entry into data analytics. The following are the notes I took during this course. Modern Data EcosystemKey Players in the Data Ecosystem An Interconnected, Independent and Continually evolving network Data Sources &amp; Users Emerging technologies shaping the modern data ecosystem Organizations are using data to uncover opportunities and applying that knowledge to differentiate themselves from their competition. Data engineering converts raw data into usable data. Data analytics uses this data to generate insights. Data scientists use data analytics and data engineering to predict the future using data from the past. Business analysts and business intelligence analysts use these insights and predictions to drive decisions that benefit and grow their business. Defining Data Analysis Data analysis is the process of gathering, cleaning, analyzing and mining data, interpreting results, and reporting the findings. Different Types of Data Analytics Descriptive Analytics Diagnostic Analytics Predictive Analytics Prescriptive Analytics (self-driving) The Data Analysis Process Understanding the problem and desired result Setting a clear metric Gathering data Cleaning data Analyzing and Mining data Interpreting results Presenting your findings Data Analytics vs. Data Analysis The Data Analyst RoleResponsibilities of a Data Analyst Acquiring data Creating queries to extract required data Filtering, cleaning, standardizing, and reorganizing data Using statistical tools Using statistical techniques Analyzing patterns Preparing reports and charts Creating appropriate documentation Skills required for Data Analyst Expertise in using spreadsheets (Excel) Proficiency in statistical analysis and visualization tools and software (Power BI, SAS, Tableau) Proficiency in programming languages (R, Python, C++, Java, MATLAB) Good knowledge of SQL, and ability to work with data in relational and NoSQL databases The ability to access and extract data from data repositories (Data marts, Data warehouses, Data lakes, Data pipelines) Familiarity with Big Data processing tools (Hadoop, Hive, Spark) Proficiency in Statistics Analytical skills Problem-solving skills Probing skills Data Visualization skills Project Management skills Collaboration and Communication ability Curiosity and Intuition Data Analysts Ecosystem A data analyst ecosystem includes the infrastructure, software, tools, frameworks, and processes used to gather, clean, analyze, mine, and visualize data. Types of Data Structured data is data that is well organized in formats that can be stored in databases and lends itself to standard data analysis methods and tools Semi-structured data is data that is somewhat organized and relies on meta tags for grouping and hierarchy Unstructured data is data that is not conventionally organized in the form of rows and columns in a particular format Different Types of File Form Delimited text files: .CSV, .TSV Microsoft Excel Open XML Spreadsheet: .XLSX Extensible Markup Language: .XML JavaScript Object Notation: .JSON Sources of Data Relational Databases: Store structured data that can be leveraged for analysis Flat Files: Store data in plain text format, each line or row is one record, delimited text Spreadsheet files: Special type of flat files, organize data in a tabular format (.XLSX) XML files: Contain data values that are identified or marked up using tags APIs and Web Services Web scraping: Extract relevant data from unstructured data Data Streams and feeds (RSS feeds) Languages for Data Professionals Query languages are designed for accessing and manipulating data in a database (SQL) Programming languages are designed for developing applications and controlling application behavior (Python, R, and Java) Shell and Scripting languages (Unix/Linux Shell, and PowerShell) are ideal for repetitive and time-consuming operational tasks SQL: Structured Query Language, Portable and Platform independent Python libraries: Pandas, Numpy and Scipy, Beautifulsoup and Scrapy, Matplotlib and Seaborn, Opency R libraries: Gggplot2 and Plotly Data Repositories and Big Data Platforms A data repository is a general term used to refer to data that has been collected, organized, and isolated so that it can be used for business operations or mined for reporting and data analysis. Data repositories help to isolate data and make reporting and analytics more efficient and credible while also serving as a data archive. RDBMS Databases: Collection of data, or information, designed for the input, storage, search and retrieval, and modification of data DBMS: A set of programs that creates and maintains the database RDBMS: Well-defined structure and schema, Optimized for data operations and querying, Use SQL for querying data A relational database is a collection of data organized into a table structure, where the tables can be linked, or related, based on data common to each. Create meaningful information, Flexibility, Minimize data redundancy, ease of backup and disaster recovery and ACID complaint (reliable) NoSQL Built for speed, flexibility and scale, can be stored in a schema-less form, widely used for processing big data A non-relational database design that provides flexible schemas for the storage and retrieval of data. NoSQL allows data to be stored in a schema-less or free-form fashion. Types: Key-value store (Redis), Document-based (Mongo DB), Column-based (Cassandra), and Graph-based (Neo4J) Key Differences Between RDBMS &amp; NoSQL Relational Databases Non-Relational Data Bases RDBMS schemas rigidly define how all data inserted into the database must be typed and composed NoSQL databases can be schema-agnostic, allowing unstructured and semi-structured data to be stored and manipulated Maintaining high-end,commercial relational database management systems can be expensive Specifically designed for low-cost commodity hardware Support ACID-compliance, which ensures reliability of transactions and crash recovery Most NoSQL databases are not ACID compliant A mature and well-documented technology, which means the risks are more or less perceivable A relatively newer technology Data Marts, Data Lakes, ETL and Data Pipelines A data warehouse is a multi-purpose enabler of operational and performance analytics. A data mart is a sub-section of the data warehouse, built specifically for a particular business function, purpose, or community of users. (Business specific reporting and analytics) A Data Lake is a storage repository that can store large amounts of structured, semi-structured, and unstructured data in their native format, classified and tagged with metadata. (Retain all source data without exclusions) Extract, Transform and Load Process (ETL): Gathering raw data -&gt; Extracting the information needed for reporting and analysis -&gt; Cleaning, standardizing, and transforming data into usable format -&gt; Loading data into a data repository Batch processing, Stream processing, Load verification A data pipeline is a broader term that encompasses the entire journey of moving data from one system to another, including the ETL process. Foundations of Big Data Big data refers to the dynamic, large and disparate volumes of data being created by people, tools and machines. It requires new, innovative and scalable technology to collect, host, and analytically process the vast amount of data gathered in order to drive real-time business insights that relate to consumers, risk, profit, performance, productivity management, and enhanced shareholder value. The V’s of Big Data: Velocity, Volume, Variety, Veracity, Value Big Data Processing Tools Apache Hadoop is a collection of tools that provides distributed storage and processing of big data. (Java based, Node&amp;Cluster, HDFS) Apache Hive is a data warehouse for data query and analysis built on top of Hadoop. Apache Spark is a distributed data analytics framework designed to perform complex data analytics in real-time. Gathering DataIdentifying Data for Analysis Process for Identifying data Determine the information you want to collect (specific information/possible sources) Define a plan for collecting data (establish timeframe/how much is sufficient/dependencies/risks/mitigation plan) Determine your data collection methods depending on sources, types, timeframe and volume of data Data identifying has implication for quality, security, and privacy. None of these are one-time considerations but are relevant through the life cycle of the data analysis process. Data Quality: data needs to be free of errors, accurate, complete, relevant, and accessible. Data Governance: Security, Regulation and Compliances (relate to the usability, integrity, and availability of data) Data Privacy: confidentiality, license for use, and compliance to mandated regulations (Checks, validations, and an auditable trail needs to be planned.) Data Sources Data sources can be internal or external to the organization Primary data refers to information obtained directly from the source. Secondary data refers to information retrieved from existing sources, such as external databases, research articles, publications, training material and Internet searches, or financial records available as public data. Third party data is data you purchased from aggregators who collect data from various sources and combine it into comprehensive datasets purely for the purpose of selling the data. Sources for Gathering Data: Databases, Web, Social media sites and Interactive platforms, Sensor data, Data Exchange, Interviews and Observation studies How to Gather and Import Data Using queries to extract data from SQL databases Non-relational databases can be queried using SQL or SQL-like query tools. Application Programming Interfaces (or APIs) are also popularly used for extracting data from a variety of data sources. APIs are also used for data validation. Using Web Scraping to extract data from the web (RSS feeds are another source typically used for capturing updated data from online forums and news sites where data is refreshed on an ongoing basis.) Data streams are a popular source for aggregating constant streams of data flowing from sources such as instruments, IoT devices and applications, and GPS data from cars. Data Exchanges have a set of well-defined exchange standards, protocols, and formats relevant for exchanging data. Specific data repositories are optimized for certain types of data. Relational databases store structured data with a well-defined schema. Semi-structured can be stored in NoSQL clusters. XML and JSON are commonly used for storing and exchanging semi-structured data. JSON is also the preferred data type for web services. NoSQL databases and Data Lakes provide a good option to store and manipulate large volumes of unstructured data. Data lakes can accommodate all data types and schema. ETL tools and data pipelines provide automated functions that facilitate the process of importing data. Wrangling DataData Wrangling Data wrangling, also known as data munging, is an iterative process that involves data exploration, transformation, validation, and making it available for a credible and meaningful analysis. The Data Wrangling Process Discovery: Examine and understand data &amp; create a plan Transformation: Structuring, Normalizing and Denormalizing, Cleaning, Enriching Data Validation: Check the quality of the data post structuring, normalizing, cleaning and enriching of data. Publishing: Delivering the output of the wrangled data for downstream project needs. Documentation: It is vital that you document all considerations and actions. Tools for Data Wrangling Spreadsheets / Excel Power Query OpenRefine Google DataPrep Watson Studio Refinery Trifacta Wrangler Python: Jupyter Notebook, NumPy, pandas R: Dplyr, Data.Table, Jsonlite Data Cleaning Poor quality data weakens an organization’s competitive standing and undermines critical business objectives. Data Cleaning Workflow Inspection: Detect issues and errors, Validating against rules and constraints, Profiling data, visualizing data Cleaning: Imputate missing values, Remove duplicate data, Data type conversion, Standardize data, Rectify syntax errors, Examine outliers…… Verification: Reinspect data It is important to document Analyzing and Mining DataStatistical Analysis Statistics is a branch of mathematics dealing with the collection, analysis, interpretation, and presentation of numerical or quantitative data. Statistical Analysis is the application of statistical methods to a sample of data in order to develop an understanding of what that data represents. Descriptive Statistics enables you to present data in a meaningful way allowing simpler interpretation of the data. Central Tendency: Mean(average value), Medium(Middle’s value), Mode(Most popular value) Dispersion: Variance, Standard Deviation, Range Skewness: Measure of whether the distribution of values is symmetrical around a central value or skewed left or right. Inferential statistics takes data from a sample to make inferences about the larger population from which the sample was drawn. Hypothesis Testing—For example, for studying the effectiveness of a vaccine by comparing outcomes in a control group Confidence Intervals incorporate the uncertainty and sample error to create a range of values the actual population value is like to fall within. Regression Analysis incorporates hypothesis tests that help determine whether the relationships observed in the sample data actually exist in the population rather than just the sample. SAS, SPSS, StatsSoft Data Mining The process of extracting knowledge from data, is the heart of the data analysis process. An interdisciplinary field that involves the use of pattern recognition technologies, statistical analysis and mathematical techniques. Aims to identify correlations in data, find patterns and variations. understand trends and predict probabilities. Pattern recognition is the discovery of regularity’s or commonality’s in data. A trend is the general tendency of a set of data to change overtime. Data mining has applications across industries and disciplines. Data mining techniques Classification: Classifying attributes into target categories Clustering: Involves grouping data into clusters so they can be treated as groups Anomaly or Outlier Detection: Finding patterns in data that are not normal or unexpected Association Rule Mining: Establishing a relationship between two data events Sequential Patterns: Tracing a series of events that take place in a sequence Affinity Grouping: Discovering co-occurrence in relationships Decision trees: Building classification models in the form of a tree structure with multiple branches, where each branch represents a probable occurrence. Regression: Identifying the nature of the relationship between two variables, which could be causal or correlational. Tools for Data Mining Spreadsheets: Host data, create pivot table, add-ins(Data Mining Client, XLMiner) R-language: tm, twitteP, RStudio Python: pandas, NumPy, Jupyter Notebook IBM SPSS Statistics (Statistical Process for Social Sciences) IBM Watson Studio SAS Enterprise Miner: A comprehensive, graphical workbench for data mining. Communicating and Sharing Data Analysis Findings The data analysis process ends with communicating the findings in ways that impact decision making. Data projects involve A collaborative effort spread across business functions People with multi-disciplinary skills Findings incorporated into a larger business initiative. The success of your communication depends on how well others can understand and trust your insights to take further action. Understanding the information needs of your audience will help you decide what and how much information is essential to enable a better understanding of your findings. Structure your presentation Begin your presentation by demonstrating your understanding of the business problem to your audience. Speak in the language of the organization’s business domain. The next step in designing your communication is to structure and organize your presentation for maximum impact. The Role of Visuals A powerful visualization tells a story through the graphical depiction of facts and figures. (Graphs, Charts, Diagrams) Trust, Understanding, Relatability Introduction to Data Visualization Data visualization is the discipline of communicating information through the use of visual elements such as graphs, charts, and maps. Its goal is to make information easy to comprehend, interpret, and retain. Choosing appropriate visualizations Common types of graphs Bar Charts are great for comparing related data sets or parts of a whole. Column Charts compare values side-by-side. You can use them quite effectively to show change over time. Pie Charts show the breakdown of an entity into its sub-parts and the proportion of the sub-parts in relation to one another. Each portion of the pie represents a static value or category, and the sum of all categories is equal to hundred percent. Line Charts display trends. They’re great for showing how a data value is changing in relation to a continuous variable. Dashboards organize and display reports and visualizations coming from multiple data sources into a single graphical interface. Are easy to comprehend by an average user Make collaboration easy between teams Allow you to generate reports on the go Introduction to Visualization and Dashboarding Software Spreadsheets Jupyter Notebook and Python libraries (Matplotlib, Bokeh, Dash) R-Studio and R-Shiny IBM Cognos Analytics Tableau Microsoft Power BI Opportunities and Learning Paths Data analyst job openings exist across industry, government and academia. Banking and Finance, Insurance, Healthcare, Retail and Information Technology Roles and Responsibilities Data Analyst Specialist Roles Domain Specialist Roles Data Engineers &amp; Data Scientists 4 important soft skills Problem-Solving Project Management Communication Storytelling","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[]},{"title":"杭电 OJ 第 1000、1001 题思路解析","slug":"HODJ1000&1001","date":"2020-12-05T16:00:00.000Z","updated":"2022-05-23T09:47:52.902Z","comments":true,"path":"HODJ1000&1001/","link":"","permalink":"http://blog.zhuangzhihao.top/HODJ1000&1001/","excerpt":"在学完算法和数据结构，以及几门主流的编程语言后，本菜鸡从2021年1月起，正式加入刷题大军。对杭电OJ也慕名已久，所以成为我刷题的首选。","text":"在学完算法和数据结构，以及几门主流的编程语言后，本菜鸡从2021年1月起，正式加入刷题大军。对杭电OJ也慕名已久，所以成为我刷题的首选。 1000、A + B Problem解题思路系统默认要读取多组输入，所以要用while语句。 Java 提交时 class 类名应该为 Main。 C++版代码1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int num1, num2; while (cin &gt;&gt; num1 &gt;&gt; num2) &#123; cout &lt;&lt; num1 + num2 &lt;&lt; endl; &#125; return 0;&#125; Java版代码1234567891011import java.util.Scanner;public class hdoj1000 &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); while(sc.hasNextInt())&#123; int a = sc.nextInt(); int b = sc.nextInt(); System.out.println(a + b); &#125; &#125;&#125; 1001、Sum Problem解题思路32位编译直接用累加公式会溢出，只能用for循环。 注意格式：题目要求换行两次，否则会出现presentation error！。 C++版代码123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int num1; while(cin &gt;&gt; num1) &#123; int sum = 0; for(int i = 1; i &lt;= num1; i++) sum += i; cout &lt;&lt; sum &lt;&lt; endl &lt;&lt; endl; //For each case, output SUM(n) in one line, followed by a blank line. &#125; return 0;&#125; Java版代码1234567891011121314151617import java.util.*;import java.math.*;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); while(sc.hasNextInt()) &#123; int a=sc.nextInt(); int sum=0; for(int i=0; i&lt;=a;i++) &#123; sum=sum+i; &#125; System.out.println(sum); System.out.println( ); &#125; &#125;&#125;","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://blog.zhuangzhihao.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"C++ 基础知识总结","slug":"Cpp基础","date":"2020-11-08T16:00:00.000Z","updated":"2022-05-23T02:31:36.019Z","comments":true,"path":"Cpp基础/","link":"","permalink":"http://blog.zhuangzhihao.top/Cpp%E5%9F%BA%E7%A1%80/","excerpt":"Object Oriented Programming，面向对象的编程的思想是一种对现实世界理解和抽象的方法，其有的封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更灵活和易于维护，对软件开发相当重要。C++ 是一门面向对象的编程语言，本文包含对于C++语言中类、对象、运算符重载、继承、多态等面向对象的程序设计方法，以及模板、标准模板库STL等泛型程序设计的机制的描述，希望帮助读者能够更好的体会和领悟面向对象程序设计方法和泛型程序设计方法的优势。","text":"Object Oriented Programming，面向对象的编程的思想是一种对现实世界理解和抽象的方法，其有的封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更灵活和易于维护，对软件开发相当重要。C++ 是一门面向对象的编程语言，本文包含对于C++语言中类、对象、运算符重载、继承、多态等面向对象的程序设计方法，以及模板、标准模板库STL等泛型程序设计的机制的描述，希望帮助读者能够更好的体会和领悟面向对象程序设计方法和泛型程序设计方法的优势。 从C到C++C++程序 GCC 是所有编译器的总称，在C语言中使用 gcc 命令编译和链接 C 程序。g++ 命令用来编译 C++，gcj命令用来编译 Java，gccgo 命令用来编译 Go 语言 命名空间（Namespace）解决合作开发时的命名冲突问题 1namespace name&#123;//variables, functions, classes&#125; name 是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等 使用变量、函数时要指明它们所在的命名空间，::是域解析操作符，用来指明要使用的命名空间 可采用 using 关键字声明变量或整个命名空间，using Li::fp;，using namespace Li; C++头文件和std标准命名空间 123456789101112#include &lt;iostream&gt;// using namespace std;声明在全局范围中void func()&#123; using namespace std; cout&lt;&lt;&quot;Bezhuang&quot;&lt;&lt;endl;&#125;int main()&#123; using namespace std; //声明命名空间std cout&lt;&lt;&quot;C++学习者：&quot;&lt;&lt;endl; func(); return 0;&#125; 输入输出：需要包含头文件iostream，cin&gt;&gt;标准输入、cout&lt;&lt;标准输出、cerr标准错误，endl结束此行 new 动态分配内存（对应malloc()），delete 释放内存（对应free()） 12int *p = new int[10]; //分配10个int型的内存空间delete[] p; 内联函数 内联函数（Inline Function）：在函数调用处直接嵌入函数体的函数称为，类似于C语言中的宏展开 注意要在函数定义处添加 inline 关键字而不是在声明处（编译器会忽略） 12345678910111213inline void swap(int *a, int *b)&#123; //内联函数，交换两个数的值 int temp; temp = *a; *a = *b; *b = temp;&#125;int main()&#123; int m, n; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;m&lt;&lt;&quot;, &quot;&lt;&lt;n&lt;&lt;endl; swap(&amp;m, &amp;n); cout&lt;&lt;m&lt;&lt;&quot;, &quot;&lt;&lt;n&lt;&lt;endl; return 0; 重载和引用 通过使用默认参数，可以减少要定义的析构函数、方法以及方法重载的数量 实参和形参的传值是从左到右依次匹配的，默认参数只能放在形参列表的最后，一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值 1void func(int a, float b=d+2.9, char c=&#x27;@&#x27;, int e)&#123; &#125; 函数的重载（Function Overloading）允许多个函数拥有相同的名字，只要它们的参数列表（参数的类型、参数的个数和参数的顺序）不同就可以，但仅返回类型不同不能作为重载的依据 同指针一样，引用能够减少数据的拷贝，提高数据的传递效率 1类型名 &amp;引用变量名 = 被引用变量名; //type &amp;name = data; 引用在定义时需要添加 &amp;，在使用时不能添加 &amp;，使用时添加 &amp; 表示取地址 常引用：如果不希望通过引用来修改原始的数据，那么可以在定义时添加 const 限制 1const 类型名 &amp;引用变量名 = 被引用变量名; // comst type &amp;name = value; C++ 引用可以作为函数参数也可以作为函数返回值 12345678910int &amp;plus10(int &amp;r) &#123; r += 10; return r;&#125;int main() &#123; int num1 = 10; int num2 = plus10(num1); cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl; return 0;&#125; //运行结果20 20 C++字符串 使用 string 类需要包含头文件 #include &lt;string&gt; string s1; string s2 = &quot;c plus plus&quot;; string s3 = s2; string s4 (5, &#39;s&#39;); length() 函数求长度，c_str() 函数转为C风格字符串 string 类可以使用+或+=运算符来直接拼接字符串 insert() 函数可以在 string 字符串中指定的位置插入另一个字符串 123string&amp; insert (size_t pos, const string&amp; str);//pos 表示要插入的位置，也就是下标；str 表示要插入的字符串s1.insert(pos, str); erase(pos, len) 函数可以删除 string 中的一个子字符串 substr(pos, len) 函数用于从 string 字符串中提取子字符串 find(str, pos) 函数用于在 string 字符串中查找子字符串出现的位置 rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从 pos 参数开始往后查找，而 rfind() 函数则最多查找到 pos 处 find_first_of(str) 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置 类与对象编程类的定义 类是创建对象的模板，通过类名创建对象的过程叫做类的实例化，对象是类的一个实例（Instance） 类的成员变量称为类的属性（Property），类的成员函数称为类的方法（Method） 123456789class Student&#123; //类通常定义在函数外面public: //成员变量Property char *name; int age; float score; //成员函数Method void say()&#123;cout&lt;&lt;name&lt;&lt;&quot;年龄是&quot;&lt;&lt;age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;score&lt;&lt;endl;&#125;&#125;; 类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，只有在创建对象以后才会给成员变量分配内存，才可以赋值 123456int main()&#123; Student stu; //创建对象 stu.name = &quot;小明&quot;; stu.age = 15; stu.score = 92.5f; stu.say(); return 0;&#125; 使用 class 时，类中的成员默认都是 private 属性的，而使用 struct 时，结构体中的成员默认都是 public 属性的 使用 class 来定义类，使用 struct 来定义结构体，这样做语义更加明确 成员变量和成员函数 类的成员有成员变量和成员函数两种，成员函数之间可以互相调用，成员函数内部可以访问成员变量 在栈上创建对象指针，形式和定义普通变量类似，不能使用 delete 在栈上创建的对象 12Student stu; //对象stu在栈上分配内存，需要使用&amp;获取它的地址Student *pStu = &amp;stu; //pStu 是一个指针，它指向 Student 类型的数据 使用 new 在堆上创建出来的对象必须要用一个指针指向它来访问它的成员变量或成员函数 12345Student *pStu = new Student;pStu -&gt; name = &quot;小明&quot;; pStu -&gt; age = 15; pStu -&gt; score = 92.5f;pStu -&gt; say();delete pStu; //删除对象return 0; 可以用 对象名.成员名、引用名.成员名、对象指针-&gt;成员名 的方法访问对象的成员变量或调用成员函数 对象所占用的存储空间的大小等于各成员变量所占用的存储空间的大小之和（如果不考虑成员变量对齐问题的话） 当成员函数定义在类外时必须在函数名前面加上类名予以限定，域解析符（作用域运算符/限定符）:: 用来连接类名和函数名，指明当前函数属于哪个类 1234567class Student&#123;public: //成员函数 void say(); //成员函数必须先在类体中作原型声明，然后在类外定义&#125;;void Student::say()&#123; cout&lt;&lt;name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;score&lt;&lt;endl; 在类体外定义 inline 函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入，因此强烈建议将内联函数定义在类的内部 类的封装 成员访问限定符 public、protected、private 控制成员变量和成员函数的访问权限 C++ 中的类没有共有私有之分，public、private、protected 只能修饰类的成员，不能修饰类 封装是指尽量隐藏类的内部实现，只向用户提供有用的成员函数 实际项目开发中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都应声明为 private，只将允许通过对象调用的成员函数声明为 public 给成员变量赋值的函数通常称为 set 函数，读取成员变量的值的函数通常称为 get 函数 包含成员对象的类叫封闭类。任何能够生成封闭类对象的语句，都要说明对象中包含的成员对象是如何初始化的，如果不说明则编译器认为成员对象是用默认构造函数或参数全部可以省略的构造函数初始化 在封闭类的构造函数的初始化列表中可以说明成员对象如何初始化。封闭类对象生成时，先执行成员对象的构造函数，再执行自身的构造函数；封闭类对象消亡时，先执行自身的析构函数，再执行成员对象的析构函数 构造函数和析构函数 构造函数（Constructor）没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行 类名()&#123;&#125; 12345678//声明构造函数（Student类中）Student(char *name, int age, float score);//定义构造函数Student::Student(char *name, int age, float score)&#123; m_name = name; m_age = age; m_score = score;&#125;//创建对象时向构造函数传参（主函数中）Student *pstu = new Student(&quot;李华&quot;, 16, 96);pstu -&gt; show(); 构造函数必须是 public 属性的，否则创建对象时无法调用 构造函数没有返回值因此不管是声明还是定义，函数名前面都不能出现返回值类型，函数体中不能有 return 语句 构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用 创建对象时只有一个构造函数会被调用，如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配 一个类必须有构造函数，要么用户自己定义，要么编译器自动生成默认构造函数 类名()&#123;&#125; 定义类时，如果一个构造函数都不写，则编译器自动生成默认（无参）构造函数和复制构造函数，如果编写了构造函数，则编译器不自动生成默认构造函数 一个类不一定会有默认构造函数，但一定会有复制构造函数 构造函数的初始化列表 1234Student::Student(char *name, int age, float score): m_name(name)&#123; m_age = age; m_score = score;&#125; //只对 m_name 使用初始化列表，其他成员变量还是一一赋值 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，只与成员变量在类中声明的顺序有关 初始化 const 成员变量的唯一方法就是使用初始化列表 1234567891011class VLA&#123;private: const int m_len; int *m_arr;public: VLA(int len);&#125;;//必须使用初始化列表来初始化 m_lenVLA::VLA(int len): m_len(len)&#123; m_arr = new int[len];&#125; 对象在消亡时会调用析构函数 析构函数（Destructor）没有返回值，不需要程序员显式调用，在销毁对象时自动执行 ~类名()&#123;&#125; 构造函数和析构函数对于类来说是不可或缺的，new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数 静态成员和常成员 this 指针也是一个 const 指针，它指向当前对象，用-&gt;来访问当前对象的所有成员变量或成员函数，它的值是不能被修改的 this 只能用在类的内部，通过 this 可以访问类的所有成员，包括 private、protected、public 属性的 this 只能在成员函数内部使用，只有当对象被创建后 this 才有意义，因此也不能在 static 成员函数中使用 this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this 成员函数中出现的 this 指针，就是指向成员函数所作用的对象的指针，因此静态成员函数内部不能出现 this 指针 成员函数实际上的参数个数比表面上看到的多一个，多出来的参数就是 this 指针 静态成员变量是一种特殊的成员变量，它被关键字 static 修饰 1static int m_total; //静态成员变量 static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它 每个对象有各自的一份普通成员变量，但是静态成员变量只有一份，被所有对象所共享。 静态成员变量必须初始化，而且只能在类体外进行：int Student::m_total = 10; static 静态成员函数不具体作用于某个对象。即便对象不存在，也可以访问类的静态成员。 静态成员函数内部不能访问非静态成员变量，也不能调用非静态成员函数。 和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用 如果你不希望某些数据被修改，可以使用const关键字加以限定。const 可以用来修饰成员变量和常成员函数 const 成员和引用成员必须在构造函数的初始化列表中初始化，此后值不可修改 常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字 12345//声明常成员函数char *getname() const;//定义常成员函数char * Student::getname() const&#123; return m_name; 函数开头加 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如const char * getname() 函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如char * getname() const const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 const 成员了 常量对象上面不能执行非常量成员函数，只能执行常量成员函数 1234567//定义常对象的语法和定义常量的语法类似const class object(params); class const object(params);//当然你也可以定义 const 指针const class *p = new class(params); class const *p = new class(params);//class为类名，object为对象名，params为实参列表，p为指针名 友元函数和友元类 借助友元（friend）可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员 1friend void show(Student *pstu); //将show()声明为友元函数 友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。 1void show(Student *pstu)&#123;cout&lt;&lt;pstu-&gt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;pstu-&gt;m_age&lt;&lt;endl;&#125; 可以将非成员函数声明为友元函数，也可以将其他类的成员函数声明为友元函数 一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员 友元类中的所有成员函数都是另外一个类的友元函数 friend class Student; 友友元分为友元函数和友元类，友元关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类 友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类 引用 参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝，将一块内存上的数据复制到另一块内存上（内存拷贝） C/C++ 禁止在函数调用时直接传递数组的内容，而是强制传递数组指针，而对于结构体和对象没有这种限制，调用函数时既可以传递指针，也可以直接传递内容 引用（Reference）可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据 1type &amp;name = data; 引用必须在定义的同时初始化，并且不能再引用其它数据，类似于 const 常量 12345int main() &#123; int a = 99; int &amp;r = a; //引用 return 0;&#125; 常引用：如果不希望通过引用来修改原始的数据，那么可以在定义时添加 const 限制 12const type &amp;name = value;//或type const &amp;name = value; 引用作为函数参数 在定义或声明函数时，可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据 如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果 12345678910111213141516171819202122232425262728void swap1(int a, int b);void swap2(int *p1, int *p2);void swap3(int &amp;r1, int &amp;r2);int main() &#123; int num1, num2; swap1(num1, num2); swap2(&amp;num1, &amp;num2); swap3(num1, num2); return 0;&#125;//直接传递参数内容，不能达到交换两个数的值的目的void swap1(int a, int b) &#123; int temp = a; a = b; b = temp;&#125;//传递指针，调用函数时，分别将 num1、num2 的指针传递给 p1、p2，此后 p1、p2 指向 a、b 所代表的数据，在函数内部可以通过指针间接地修改 a、b 的值void swap2(int *p1, int *p2) &#123; int temp = *p1; *p1 = *p2; *p2 = temp;&#125;//按引用传参，调用函数时，分别将 r1、r2 绑定到 num1、num2 所指代的数据，此后 r1 和 num1、r2 和 num2 就都代表同一份数据了，通过 r1 修改数据后会影响 num1，通过 r2 修改数据后也会影响 num2void swap3(int &amp;r1, int &amp;r2) &#123; int temp = r1; r1 = r2; r2 = temp;&#125; 引用作为函数返回值 将引用作为函数返回值时，不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告 12345678910int &amp;plus10(int &amp;r) &#123; r += 10; return r;&#125;int main() &#123; int num1 = 10; int num2 = plus10(num1); cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl; return 0;&#125; 继承与派生三种继承方式 继承（Inheritance）/ 派生（Derive）是一个类从另一个类获取成员变量和成员函数的过程 被继承的类称为父类或基类，继承的类称为子类或派生类 123class 派生类名:［继承方式］ 基类名&#123; 派生类新增加的成员&#125;; 继承方式包括 public、private和 protected，此项是可选的，如果不写，那么默认为 private 类成员的访问权限由高到低依次为 public —&gt; protected —&gt; private protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用 基类成员在派生类中的访问权限不得高于继承方式中指定的权限，也就是说，继承方式中的 public、protected、private 是用来指明基类成员在派生类中的最高访问权限的 实际上基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了 在派生类中访问基类 private 成员的唯一方法就是借助基类的非 private 成员函数，如果基类没有非 private 成员函数，那么该成员在派生类中将无法访问 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//基类Peopleclass People&#123;public: void setname(char *name); void setage(int age); void sethobby(char *hobby); char *gethobby();protected: char *m_name; int m_age;private: char *m_hobby;&#125;;void People::setname(char *name)&#123; m_name = name; &#125;void People::setage(int age)&#123; m_age = age; &#125;void People::sethobby(char *hobby)&#123; m_hobby = hobby; &#125;char *People::gethobby()&#123; return m_hobby; &#125;//派生类Studentclass Student: public People&#123;public: void setscore(float score);protected: float m_score;&#125;;void Student::setscore(float score)&#123; m_score = score; &#125;//派生类Pupilclass Pupil: public Student&#123;public: void setranking(int ranking); void display();private: int m_ranking;&#125;;void Pupil::setranking(int ranking)&#123; m_ranking = ranking; &#125;void Pupil::display()&#123; cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;m_age&lt;&lt;&quot;，考试成绩为&quot;&lt;&lt;m_score&lt;&lt;&quot;分，班级排名第&quot;&lt;&lt;m_ranking&lt;&lt;&quot;，TA喜欢&quot;&lt;&lt;gethobby()&lt;&lt;&quot;。&quot;&lt;&lt;endl;&#125;int main()&#123; Pupil pup; pup.setname(&quot;小明&quot;); pup.setage(15); pup.setscore(92.5f); pup.setranking(4); pup.sethobby(&quot;乒乓球&quot;); pup.display(); return 0;&#125; 改变访问权限 使用 using 关键字可以改变基类成员在派生类中的访问权限 using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限，因为基类中 private 成员在派生类中是不可见的，根本不能使用，所以基类中的 private 成员在派生类中无论如何都不能访问 1234567//派生类Studentclass Student : public People &#123;public: void learning();public: using People::m_name; //将protected改为public using People::m_age; //将protected改为public 如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员 所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的 基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样 基类和派生类的构造函数和析构函数 类的构造函数不能被继承 解决方法：在派生类的构造函数中调用基类的构造函数 派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的 定义派生类构造函数时最好指明基类构造函数；如果不指明，就调用基类的默认构造函数（不带参数的构造函数）；如果没有默认构造函数，那么编译失败 123456789101112131415161718192021222324252627282930313233//基类Peopleclass People&#123;protected: char *m_name; int m_age;public: People(); //基类默认构造函数 People(char*, int);&#125;;People::People(): m_name(&quot;xxx&quot;), m_age(0)&#123; &#125;People::People(char *name, int age): m_name(name), m_age(age)&#123;&#125;//派生类Studentclass Student: public People&#123;private: float m_score;public: Student(); Student(char *name, int age, float score); void display();&#125;;//People(name, age)就是调用基类的构造函数Student::Student(): m_score(0.0)&#123; &#125; //派生类默认构造函数Student::Student(char *name, int age, float score): People(name, age), m_score(score)&#123; &#125;void Student::display()&#123; cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;m_score&lt;&lt;&quot;。&quot;&lt;&lt;endl;&#125;int main()&#123; Student stu1; stu1.display(); Student stu2(&quot;小明&quot;, 16, 90.5); stu2.display(); return 0;&#125; 和构造函数类似，析构函数也不能被继承 与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉 析构函数的执行顺序和构造函数的执行顺序也刚好相反： 创建派生类对象时，构造函数的执行顺序和继承顺序相同，即先执行基类构造函数，再执行派生类构造函数 而销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数 多重继承 多继承（Multiple Inheritance）：一个派生类可以有两个或多个基类 多继承容易让代码逻辑复杂、思路混乱，一直备受争议，中小型项目中较少使用，后来的 Java、C#、PHP 等干脆取消了多继承 123class D: public A, private B, protected C&#123; //类D新增加的成员&#125; D 是多继承形式的派生类，它以公有的方式继承 A 类，以私有的方式继承 B 类，以保护的方式继承 C 类 D 根据不同的继承方式获取 A、B、C 中的成员，确定它们在派生类中的访问权限 多继承形式下的构造函数和单继承形式基本相同，只是要在派生类的构造函数中调用多个基类的构造函数 基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同 123D(形参列表): A(实参列表), B(实参列表), C(实参列表)&#123; //其他操作&#125; 当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员 命名冲突的时候需要在成员名字前面加上类名和域解析符::，以显式地指明到底使用哪个类的成员，消除二义性 虚继承和虚基类 虚继承（Virtual Inheritance）：在继承方式前面加上 virtual 关键字，使得在派生类中只保留一份间接基类的成员 12345678910111213141516171819202122232425262728//间接基类Aclass A&#123;protected: int m_a;&#125;;//直接基类Bclass B: virtual public A&#123; //虚继承protected: int m_b;&#125;;//直接基类Cclass C: virtual public A&#123; //虚继承protected: int m_c;&#125;;//派生类Dclass D: public B, public C&#123;public: void seta(int a)&#123; m_a = a; &#125; //正确 void setb(int b)&#123; m_b = b; &#125; //正确 void setc(int c)&#123; m_c = c; &#125; //正确 void setd(int d)&#123; m_d = d; &#125; //正确private: int m_d;&#125;;int main()&#123; D d; return 0; 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类，这个被共享的基类就称为虚基类（Virtual Base Class） 必须在虚派生的真实需求出现前就已经完成虚派生的操作 虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身 C++ 标准库中的 iostream 类就是一个虚继承的实际应用案例 iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类 此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员 不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承 在虚继承中，虚基类是由最终的派生类初始化的，最终派生类的构造函数必须要调用虚基类的构造函数 对最终的派生类来说，虚基类是间接基类，而不是直接基类，这跟普通继承不同 在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的 向上转型 数据类型转换的前提是，编译器知道如何对数据进行取舍 类其实也是一种数据类型，也可以发生数据类型转换 不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这称为向上转型（Upcasting） 相应地，将基类赋值给派生类称为向下转型（Downcasting） 向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预 赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题 这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值 通过基类指针访问派生类的成员 编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据 编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数 多态与虚函数 多态（polymorphism）：同一名字的事物可以完成不同的功能 多态可以分为编译时的多态和运行时的多态 编译时的多态：主要是指函数的重载（包括运算符的重载）、对重载函数的调用，在编译时就能根据实参确定应该调用哪个函数 运行时的多态：通常所指的多态，和继承、虚函数等概念有关 通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数 为了消除这种尴尬，让基类指针能够访问派生类的成员函数，C++ 增加了虚函数（Virtual Function），只需要在函数声明前面增加 virtual 关键字即可 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员 因此，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，称为多态（Polymorphism） C++提供多态的目的：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行全方位的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量 借助引用也可以实现多态，不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力 为了方便，可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽关系的同名函数都将自动成为虚函数 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数 只有派生类的虚函数覆盖基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数） 例如基类虚函数的原型为virtual void func();，派生类虚函数的原型为virtual void func(int);，那么当基类指针 p 指向派生类对象时，语句p -&gt; func(100);将会出错，而语句p -&gt; func();将调用基类的函数 派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数 构成多态的条件 必须存在继承关系 继承关系中必须有同名的虚函数，并且它们是覆盖关系（函数原型相同） 存在基类的指针，通过该指针调用虚函数 1234567891011121314151617181920212223242526272829303132//基类Baseclass Base&#123;public: virtual void func(); virtual void func(int);&#125;;void Base::func()&#123; cout&lt;&lt;&quot;void Base::func()&quot;&lt;&lt;endl;&#125;void Base::func(int n)&#123; cout&lt;&lt;&quot;void Base::func(int)&quot;&lt;&lt;endl;&#125;//派生类Derivedclass Derived: public Base&#123;public: void func(); void func(char *);&#125;;void Derived::func()&#123; cout&lt;&lt;&quot;void Derived::func()&quot;&lt;&lt;endl;&#125;void Derived::func(char *str)&#123; cout&lt;&lt;&quot;void Derived::func(char *)&quot;&lt;&lt;endl;&#125;//在基类中将void func()声明为虚函数，这样派生类中的void func()就会自动成为虚函数int main()&#123; Base *p = new Derived(); p -&gt; func(); //调用的是派生类的虚函数，构成了多态，输出void Derived::func() p -&gt; func(10); //调用的是基类的虚函数，因为派生类中没有函数覆盖它，输出void Base::func(int) p -&gt; func(&quot;abcd&quot;); //compile error，因为通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员 return 0;&#125; 什么时候声明虚函数 首先看成员函数所在的类是否会作为基类，然后看成员函数在类的继承后有无可能被更改功能 如果希望更改其功能的，一般应该将它声明为虚函数 如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数 纯虚函数和抽象类 纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上 =0，表明此函数为纯虚函数 包含纯虚函数的类称为抽象类（Abstract Class），无法实例化，也就是无法创建对象，原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间 1virtual 返回值类型 函数名 (函数参数) = 0; 抽象基类除了约束派生类的功能，还可以实现多态 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数 1234567//顶层函数不能被声明为纯虚函数void fun() = 0; //compile errorclass base&#123;public : //普通成员函数不能被声明为纯虚函数 void display() = 0; //compile error&#125;; typeid 运算符 typeid 运算符用来获取一个表达式的类型信息 类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定 12typeid( dataType )typeid( expression ) //dataType 是数据类型，expression 是表达式 typeid 会把获取到的类型信息保存到一个 type_info 类型的对象里面，并返回该对象的常引用,当需要具体的类型信息时，可以通过成员函数来提取 type_info 类位于 typeinfo 头文件，它的构造函数是 private 属性的，所以不能在代码中直接实例化，只能由编译器在内部实例化（借助友元），而且还重载了 private 属性的 = 运算符，所以也不能赋值 运算符重载（operator） 运算符重载是通过函数实现的，它本质上是函数重载，运算符重载函数除了函数名有特定的格式，其它地方和普通函数并没有区别 123返回值类型 operator 运算符名称 (形参表列)&#123; //TODO:&#125; 重载后运算符的含义应该符合原有用法习惯，例如重载 + 运算符，完成的功能就应该类似于做加法 重载应尽量保留运算符原有的特性 运算符重载不改变运算符的优先级。 .、.*、::、? :、sizeof 不能被重载 重载运算符 ()、[]、-&gt; 或者赋值运算符 = 时，只能将它们重载为成员函数，不能重载为全局函数 运算符重载的实质是将运算符重载为一个函数，使用运算符的表达式就被解释为对重载函数的调用 运算符可以重载为全局函数，此时函数的参数个数就是运算符的操作数个数，运算符的操作数就成为函数的实参 运算符也可以重载为成员函数。此时函数的参数个数就是运算符的操作数个数减一，运算符的操作数有一个成为函数作用的对象，其余的成为函数的实参 必要时需要重载赋值运算符 =，以避免两个对象内部的指针指向同一片存储空间 运算符可以重载为全局函数，然后声明为类的友元 &lt;&lt; 和 &gt;&gt; 是在 iostream 中被重载，才成为所谓的“流插入运算符”和“流提取运算符”的 类型的名字可以作为强制类型转换运算符，也可以被重载为类的成员函数，它能使得对象被自动转换为某种类型 自增、自减运算符各有两种重载方式，用于区别前置用法和后置用法 运算符重载不改变运算符的优先级，重载运算符时，应该尽量保留运算符原本的特性 模板和泛型程序设计 泛型程序设计（generic programming）是一种算法在实现时不指定具体要操作的数据的类型的程序设计方法 所谓“泛型”，指的是算法只要实现一遍，就能适用于多种数据类型，泛型程序设计方法的优势在于能够减少重复代码的编写 泛型程序设计的概念最早出现于 1983 年的 Ada 语言，其最成功的应用就是 C++ 的标准模板库（STL） 在 C++ 中，模板分为函数模板和类模板两种，在编写函数时考虑能否将其写成函数模板，编写类时考虑能否将其写成类模板，以便实现重用 类型的参数化：数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型 函数模板（Function Template）：建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型 函数模板除了支持值的参数化，还支持类型的参数化 一但定义了函数模板（类模板），就可以将类型参数用于函数定义和函数声明了 函数模板也可以提前声明，不过声明时需要带上模板头，并且模板头和函数定义（声明）是一个不可分割的整体，它们可以换行，但中间不能有分号 123template &lt;typename 类型参数1 , typename 类型参数2 , ...&gt; 返回值类型 函数名(形参列表)&#123; //在函数体中可以使用类型参数&#125; 类模板和函数模板都是以 template 开头（当然也可以使用 class，目前来讲它们没有任何区别），后跟类型参数；类型参数不能为空，多个类型参数用逗号隔开 123template&lt;typename 类型参数1 , typename 类型参数2 , …&gt; class 类名&#123; //TODO:&#125;; 根据“在定义变量时是否需要显式地指明数据类型”可以分为强类型语言和弱类型语言 强类型语言在定义变量时需要显式地指明数据类型，并且一旦为变量指明了某种数据类型，该变量以后就不能赋予其他类型的数据了，除非经过强制类型转换或隐式类型转换（C/C++、Java、C#） 弱类型语言在定义变量时不需要显式地指明数据类型，编译器（解释器）会根据赋给变量的数据自动推导出类型，并且可以赋给变量不同类型的数据（JavaScript、Python、PHP、Ruby、Shell、Perl） 不管是强类型语言还是弱类型语言，在编译器（解释器）内部都有一个类型系统来维护变量的各种信息 异常处理 程序的错误大致可以分为三种，分别是语法错误、逻辑错误和运行时错误： 语法错误在编译和链接阶段就能发现，只有 100% 符合语法规则的代码才能生成可执行程序 编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决 运行时错误是指程序在运行期间发生的错误，例如除数为 0、内存分配失败、数组越界、文件不存在等 C++ 异常（Exception）机制就是为解决运行时错误而引入的 抛出异常:报告一个运行时错误，程序员可以根据错误信息来进一步处理 捕获异常 12345try&#123; // 可能抛出异常的语句&#125;catch(exceptionType variable)&#123; // 处理异常的语句&#125; 发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到 可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参（异常数据），但catch 和真正的函数调用相比，多了一个「在运行阶段将实参和形参匹配」的过程 多级 catch 1234567891011try&#123; //可能抛出异常的语句&#125;catch (exception_type_1 e)&#123; //处理异常的语句&#125;catch (exception_type_2 e)&#123; //处理异常的语句&#125;//其他的catchcatch (exception_type_n e)&#123; //处理异常的语句&#125; throw 用作异常规范 1double func (char param) throw (int, char, exception); 文件和流 打开文件 1void open(const char *filename, ios::openmode mode); 关闭文件 1void close(); 读取 &amp; 写入 123456789101112131415161718192021222324252627282930313233343536#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std; int main ()&#123; char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open(&quot;afile.dat&quot;); cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Enter your name: &quot;; cin.getline(data, 100); // 向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;Enter your age: &quot;; cin &gt;&gt; data; cin.ignore(); // 再次向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open(&quot;afile.dat&quot;); cout &lt;&lt; &quot;Reading from the file&quot; &lt;&lt; endl; infile &gt;&gt; data; // 在屏幕上写入数据 cout &lt;&lt; data &lt;&lt; endl; // 再次从文件读取数据，并显示它 infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 infile.close(); return 0;&#125; istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”） 12345678// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end );// 定位到 fileObject 的末尾fileObject.seekg( 0, ios::end ); 重用类代码 用类定义对象 通过组合定义新的类（组合类） 多级访问 类的聚合（指针形式传递） 通过继承定义新的类（继承类） 基类，派生类（基类成员与新增成员） 同名覆盖 派生类对基类成员的二次封装 obj.Circle::input() 保护权限与保护继承 继承与派生主要用于重用类代码和凝练类代码 多态性：相同程序元素不同的语法解释 运算符的多态与重载 对象的替换和多态 Liskov 替换准则：将派生类对象当做基类对象使用 类族：基类和派生类 对象的多态性 虚函数（virtual关键字） 抽象类 多继承（从多个类中继承，JAVA和C#中没有） 流类库和文件读写 输入/输出流 流类库：以ios为基类的类族 数据缓冲区和流缓冲区 标准I/O（&lt;iostream&gt;，cin/cout） 文件I/O（&lt;fstream&gt;，fin/fout） string类和字符串I/O（&lt;string&gt;，&lt;sstream&gt;，str） 基于Unicode编码的流类库（以wios为基类） C++标准库 系统函数和系统类库 模板技术：函数模板和类模板 使用typedef类型定义显示地实例化类模板 标准模板库STL（Standard Template Library） 异常处理机制：throw语句 / try-catch机制 / &lt;exception&gt; 数据集合及处理算法（CRUD） 链表 迭代器（Iterator） 查找算法、增删改算法和排序相关算法 容器类：&lt;vector&gt;、&lt;list&gt;、&lt;set&gt;、&lt;map&gt; 第三方开发的函数/类库 微软基础类库 Microsoft Foundation Classes（MFC）","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://blog.zhuangzhihao.top/categories/C-C/"}],"tags":[]},{"title":"必会新手 50 题之阶段一","slug":"必会新手50题阶段一","date":"2020-10-27T16:00:00.000Z","updated":"2022-05-23T09:48:08.791Z","comments":true,"path":"必会新手50题阶段一/","link":"","permalink":"http://blog.zhuangzhihao.top/%E5%BF%85%E4%BC%9A%E6%96%B0%E6%89%8B50%E9%A2%98%E9%98%B6%E6%AE%B5%E4%B8%80/","excerpt":"在线评测平台 LintCode 整合了当前各大IT企业技术求职的热门题库，拥有2000多道常见面试题，可有效提升算法与数据结构水平，助力通过知名IT企业面试，拿到满意的Offer。新手必刷编程50题为初到Lintcode所接触到的最基础的阶梯练习，必知必会。在新手50题阶段一中考验的是对基本数据类型的掌握。","text":"在线评测平台 LintCode 整合了当前各大IT企业技术求职的热门题库，拥有2000多道常见面试题，可有效提升算法与数据结构水平，助力通过知名IT企业面试，拿到满意的Offer。新手必刷编程50题为初到Lintcode所接触到的最基础的阶梯练习，必知必会。在新手50题阶段一中考验的是对基本数据类型的掌握。 37、反转一个3位整数描述反转一个只有3位数的整数。 问题分析获得个位数并将它变成百位数，获得十位数并将它变成十位数，获得百位数并将它变成个数位。 题解123456class Solution &#123;public: int reverseInteger(int number) &#123; return number % 10 * 100 + number / 10 % 10 * 10 + number / 100; &#125;&#125;; 1、A+B问题描述给出两个整数a和b，求他们的和并以整数（int）的形式返回。 问题分析不需要从标准输入流读入数据，只需要根据aplusb传入的两个参数a和b，计算他们的和并返回就行。 题解123456class Solution &#123;public: int aplusb(int a, int b) &#123; return a + b; &#125;&#125;; 1300、巴什博弈描述你正在和朋友玩一个游戏：桌子上有一堆石头，每一次你们都会从中拿出1到3个石头。拿走最后一个石头的人赢得游戏。 游戏开始时，你是先手。假设两个人都绝对理性，都会做出最优决策。给定石头的数量，判断你是否会赢得比赛。 举例：有四个石头，那么你永远不会赢得游戏。不管拿几个，最后一个石头一定会被你的朋友拿走。 问题分析巴什博弈：n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得胜。 如果物品数量 n 不能被 m+1 整除，则 n=k(m+1)+x（k为自然数，0&lt;x&lt;m+1），那么只要先手者第一次拿走 x 个物品，剩余物品数量变为 k(m+1)，接下来无论后手者怎么拿，先手者都可以让物品数量变 k(m+1) ，k逐渐变小直到最后变为 1，此时剩余物品为 m+1，接下来无论后手者拿多少都拿不完 ，并且会使剩余物品数量小于 m+1 ，而先手者则可以直接把剩下的拿完，先手者必胜。 如果物品数量为 k(m+1)，即 n 可被 (m+1) 整除，此时先手者就会面临上面的后手者的问题，先手者必输。 由题可知，m=3，所以物品数量不能被4整除，即n若是4的倍数则输出False，否则输出True。 题解12345678910class Solution &#123;public: bool canWinBash(int n) &#123; if(n%4 == 0) &#123; return false; &#125; else return true; &#125;&#125;; 764、计算圆周长和面积描述给定一个整数r代表一个圆的半径，返回一个数组，其中数组的第一个元素代表圆的周长，数组的第二个元素代表圆的面积。 问题分析PI = 3.14。 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container），是一个能够存放任意类型的动态数组。 #include&lt;vector&gt;; 题解123456789class Solution &#123;public: vector&lt;double&gt; calculate(int r) &#123; vector&lt;double&gt;ans; ans.push_back(2 * 3.14 * r); ans.push_back(3.14 * r * r); return ans; &#125;&#125;;","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://blog.zhuangzhihao.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"http://blog.zhuangzhihao.top/tags/LintCode/"}]},{"title":"Python 基础知识总结","slug":"Python基础","date":"2020-10-10T16:00:00.000Z","updated":"2022-05-05T12:41:45.406Z","comments":true,"path":"Python基础/","link":"","permalink":"http://blog.zhuangzhihao.top/Python%E5%9F%BA%E7%A1%80/","excerpt":"Python 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计的一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。","text":"Python 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计的一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。 计算机的使用方式 Interface 交互界面 TUI（文本交互界面）和 GUI（图形化交互界面） windows 的命令行 环境变量（environment variable） path 环境变量 进制 十进制（最常用的进制） 二进制（计算机底层使用的进制） bit 是计算机中的最小的单位 byte 是我们最小的可操作的单位 八进制（一般不用） 十六进制 我们在查看二进制数据时，一般会以十六进制的形式显示 文本文件和字符集 文本分成两种，一种叫做纯文本，还有一种叫做富文本 编码；解码；字符集 常见的字符集：ASCII；ISO-8859-1；GB2312；Unicode，最常用的就是 UTF-8 乱码 计算机语言 机器语言 符号语言（汇编） 高级语言 编译型语言和解释型语言 基本语法概念 表达式 语句 程序（program） 函数（function） 严格区分大小写 每一行语句不要过长（规范中建议每行不要超过 80 个字符） 多行编写时语句后边以\\结尾 注释要求简单明了，一般习惯上#后边会跟着一个空格 字面量、变量和标识符 在程序中可以直接使用字面量 变量（variable）变量可以用来保存字面量 数据类型 数据类型指的就是变量的值得类型，也就是可以为变量赋哪些值 数值：整数、浮点数、复数 整型：0b（二进制）0x（十六进制）0o（八进制） 字符串：\\t 缩进 \\n 换行 \\uxxxx表示 unicode 编码 格式化字符串：%s 任意字符 %f 浮点数占位符 %d 整数占位符 布尔值：True False 空值：None 类型检查：type() 对象（object） Python 是一门面向对象的语言 对象就是内存中专门用来存储指定数据的一块区域 数值、字符串、布尔值、None 都是对象 每个对象中都要保存三种数据 id（标识）：唯一性，id()函数，解析器生成，不能改变 type（类型）：type()函数，强类型—创建类型后便不能修改 value（值）：可变对象、不可变对象 变量和对象 对象并没有直接存储到变量中，在 Python 中变量更像是给对象起了一个别名 变量中存储的不是对象的值，而是对象的 id，当我们使用变量时，实际上就是在通过对象 id 在查找对象 变量中保存的对象，只有在为变量重新赋值时才会改变 变量和变量之间是相互独立的，修改一个变量不会影响另一个变量 类型转换 类型转换是将一个类型的对象转换为其他对象 int()、float()、str()、bool() 类型转换不是改变对象本身的类型，而是根据当前对象的值创建一个新对象 运算符(操作符) 运算符可以对一个值或多个值进行运算或各种操作 运算符的分类： 算术运算符：//整除、%余数 赋值运算符 比较运算符（关系运算符）：==等于、!=不等于、字符比较unicode 编码、is (is not)比较 id 逻辑运算符：not、and、or 条件运算符（三元运算符）：a if a&gt;b else b 流程控制语句 Python 代码在执行时是按照自上向下顺序执行的 通过流程控制语句，可以改变程序的执行顺序，也可以让指定的程序反复执行多次 流程控制语句分成两大类：条件判断语句，循环语句 条件判断语句（if 语句） if、elif、else try、except 循环语句（while、for 语句） while、else、for break、continue、pass（占位） 循环嵌套 外层循环控制图形的高度 内层循环控制图形的宽度 print(x, end=&quot; &quot;）不换行输出 序列（sequence） 序列是 Python 中最基本的一种数据结构 数据结构指计算机中数据存储的方式 序列用于保存一组有序的数据，所有的数据在序列当中都有一个唯一的位置（索引），并且序列中的数据会按照添加的顺序来分配索引 序列的分类： 可变序列（序列中的元素可以改变）： 列表（list） 不可变序列（序列中的元素不能改变）： 字符串（str） 元组（tuple） 列表（list） 列表是 Python 中的一个对象 对象（object）就是内存中专门用来存储数据的一块区域 之前我们学习的对象，像数值，它只能保存一个单一的数据 列表中可以保存多个有序的数据 列表是用来存储对象的对象 len()，所取长度 = 最后一位索引+1 列表[0:8:2]，起始：结束：间隔，包含开始不包含结束，间隔若为负数则从后往前取 min()，max()，in，not in xxx.index(&#39;n&#39;,0,8) 获取指定元素在列表中的位置，xxx.count()统计元素在列表中出现次数 xxx.append(x)插入元素到末尾，s.insert(&#39;x&#39;, 2)插入元素+插入索引位置，x.extend([x,y,z])插入列表 del [1:2] = x.remove(1)，xxx[0:2] = [&#39;x&#39;,&#39;y&#39;]替换元素，x.pop(2)删除索引位置的元素并返回此元素 x.reverse()反转，x.sort()排序，默认升序，x.sort(reverse=True)为降序 for x in xlist 遍历序列，range() 函数生成自然数列 元组（tuple） 元组是不可变的序列 tuple = (1, 2, 3, 4, 5) 当元组不是空元组时，括号可以省略 元组的解包 a, b, *c = tuple，c 为[3, 4, 5] 可变对象 每个对象中都保存了三个数据： id（标识） type（类型） value（值） 列表就是一个可变对象 一般只有在为变量赋值时才是修改变量，其余的都是修改对象 ==、!=比较对象的值，is、is not 比较对象的 id 字典（dict） 字典属于一种新的数据结构，称为映射（mapping） 字典的作用和列表类似，都是用来存储对象的容器 列表存储数据的性能很好，但是查询数据的性能的很差 在字典中每一个元素都有一个唯一的名字，通过这个唯一的名字可以快速的查找到指定的元素 在查询元素时，字典的效率是非常快的 在字典中可以保存多个对象，每个对象都会有一个唯一的名字 这个唯一的名字，我们称其为键（key），键可以是任意的不可变对象 通过 key 可以快速的查询 value 这个对象，我们称其为值（value），值可以是任意对象 所以字典，我们也称为叫做键值对（key-value）结构 每个字典中都可以有多个键值对，而每一个键值对我们称其为一项（item） &#123;key : value, key : value&#125;、d = dict(k1 = v1 , k2 = v2 , k3 = v3)、d = dict[ (k1 , v1) , (k2 , v2) , (k3 , v3) ] d[key]、d.get(key , 默认值) 如不存在 key 则返回默认值、d[key] = value in、not in 检查键 key、 .setdefault(key[ , default ])如果 key 存在，返回 key 的值，如果 key 不存在，添加并返回默认值 .update([other]) 将其他字典中的 key-value 添加到当前字典，若 key 重复则替换 .popiterm() 默认删除最后一个键值对，返回的是元组(key,value)，pop(key , 默认值)返回 value 或默认值 .clear()清空、.copy()用于对字典进行浅复制（复制后的对象和原对象相互独立）（不复制可变对象） .keys()会返回字典的所有 key，.values()返回字典的所有 value，.items()返回字典中所有项（双值子序列）、for k, v in d.items(): print(k , v) 集合（set） 集合和列表非常相似 不同点： 集合中只能存储不可变对象 集合中存储的对象是无序（不是按照元素的插入顺序保存） 集合中不能出现重复的元素 set()、&#123;&#125;、s = set(&#39;Hello&#39;) → &#123;&#39;H&#39; , &#39;e&#39; , &#39;l&#39; , &#39;o&#39;&#125; .add()向集合中添加元素、.update()将集合/元组/字典(key)中元素添加至集合中 .pop()随机删除并返回元素、.remove()删除指定元素、copy()浅复制 s &amp; s2 交集运算，s | s2 并集运算，s - s2差集运算，s ^ s2亦或运算 函数（function） 函数也是一个对象 对象是内存中专门用来存储数据的一块区域 函数可以用来保存一些可执行的代码，并且可以在需要时，对这些语句进行多次的调用 创建函数： def 函数名([形参 1,形参 2,...形参 n])：代码块 函数名必须要符号标识符的规范（可以包含字母、数字、下划线、但是不能以数字开头） 函数中保存的代码不会立即执行，需要调用函数代码才会执行 调用函数：函数对象() 定义函数一般都是要实现某种功能的 函数的参数 在定义函数时，可以在函数名后的()中定义数量不等的形参，多个形参之间使用,隔开 形参（形式参数），定义形参就相当于在函数内部声明了变量，但是并不赋值 定义形参时，可以指定默认值 实参（实际参数） 如果函数定义时指定了形参，那么在调用函数时也必须传递实参，实参将会赋值给对应的形参 有几个形参就得传几个实参 实参的传递方式 位置参数 关键字参数 混合使用时，必须把位置参数放前面 实参可以传递任意类型的对象 在函数中对形参进行重新赋值不会影响其他变量 如果形参执行的是一个对象，那么通过形参修改对象会影响到所有指向该对象的变量 定义函数形参前加 *，那么这个形参会获取到所有实参（将所有实参保留到元组），使用时遍历元组 可变参数不是必须写最后，但带*后的所有参数必须用关键字参数传递 **形参可以接收其他的关键字参数，并将它们保存在字典中 传递实参前加*可以将序列中元素依次传递（参数解包），**则对字典解包 return 返回值，可返回任意对象，return 一旦指向函数自动结束 作用域与命名空间 help() 文档字符串就是定义函数的说明，在函数第一行写一个字符串就是文档字符串 def() -&gt; str：表示返回值是字符串，同样为文档字符串 作用域（scope）指的是变量生效的区域 全局作用域与函数作用域 global a 声明在函数内部使用的 a 是全局变量，此时再修改 a 就是修改全局 a 命名空间（namespace）指的是变量存储的位置，实际是一个储存变量的字典 每一个 scope 都有对应的 namespace 全局命名空间用来保存全局变量，函数命名空间用来保存函数的变量 locals()用来获取当前作用域的命名空间 scope[&#39;c&#39;] = ...向字典中添加 key-value 等于在当前作用域中创建了一个变量 global()在任意位置获取全局命名空间 函数式编程 递归式函数（自己调用自己） 基线条件（可被分成的最小问题，满足即停止指向） 递归条件（将问题继续分解的条件） 在 Python 中，函数是一等对象 一等对象一般都会具有如下特点： 对象是在运行时创建的 能赋值给变量或作为数据结构中的元素 能作为参数传递 能作为返回值返回 高阶函数（接收函数作为参数或将函数作为返回值的函数） filter()从序列中过滤出符合条件的元素并保存到新的序列（可迭代结构） 匿名函数 lambda 函数表达式（lambda 参数列表: 返回值）(lambda a,b : a+b) 匿名函数也可以直接赋值给一个变量 map() 函数可以对可跌倒对象中的元素修改并添加到新变量并返回 匿名函数一般作为参数使用 sort() 对列表中的元素进行排列，也可以接收关键字参数（key=…）比较函数返回值 sorted()可对任意序列排序且不影响原来的对象，而是返回一个新对象 闭包是将函数作为返回值的函数，可以创建只有当前函数能访问的变量 装饰器 在不修改原有函数的情况下扩展函数的功能def funtion(*args ,**kwargs)result = old(*args ,**kwargs) @引用指定装饰器 一个函数指定多个装饰器时，函数安装从内向外引用装饰器 对象 对象是内存中专门用来存储数据的一块区域。 对象中可以存放各种数据（比如：数字、布尔值、代码） 对象由三部分组成： 对象的标识（id） 对象的类型（type） 对象的值（value） 面向对象（oop） Python 是一门面向对象的编程语言 所谓的面向对象的语言，简单理解就是语言中的所有操作都是通过对象来进行的 面向过程的编程的语言 面向过程指将我们的程序的逻辑分解为一个一个的步骤，通过对每个步骤的抽象，来完成程序 面向过程的编程思想将一个功能分解为一个一个小的步骤，我们通过完成一个一个的小的步骤来完成一个程序 这种编程方式，符合我们人类的思维，编写起来相对比较简单 但是这种方式编写代码的往往只适用于一个功能，如果要在实现别的功能，即使功能相差极小，也往往要重新编写代码，所以它可复用性比较低，并且难于维护 面向对象的编程语言 面向对象的编程语言，关注的是对象，而不关注过程 对于面向对象的语言来说，一切都是对象 面向对象的编程思想，将所有的功能统一保存到对应的对象中，要使用某个功能，直接找到对应的对象即可 这种方式编写的代码，比较容易阅读，并且比较易于维护，容易复用。 但是这种方式编写，不太符合常规的思维，编写起来稍微麻烦一点 简单归纳一下，面向对象的思想 找对象 搞对象 类(class) 我们目前所学习的对象都是 Python 内置的对象 但是内置对象并不能满足所有的需求，所以我们在开发中经常需要自定义一些对象 类，简单理解它就相当于一个图纸。在程序中我们需要根据类来创建对象 类就是对象的图纸 我们也称对象是类的实例（instance） 如果多个对象是通过一个类创建的，我们称这些对象是一类对象 像 int(), float(), bool(), str(), list(), dict() …. 这些都是类 a = int(10) # 创建一个 int 类的实例 等价于 a= 10 我们自定义的类都需要使用大写字母开头，使用大驼峰命名法（帕斯卡命名法）来对类命名 类也是一个对象 类就是一个用来创建对象的对象 类是 type 类型的对象，定义类实际上就是定义了一个 type 类型的对象 isinstance()用来检查一个对象是否是一个类的实例 使用类创建对象的流程 创建一个变量 在内存中创建一个新对象 将对象的 id 赋值给变量 向对象中添加变量，对象中的变量称为属性 语法：对象.属性名 = 属性值 类的定义 类和对象都是对现实生活中的事物或程序中的内容的抽象 实际上所有的事物都由两部分构成： 数据（属性） 行为（方法） 在类中定义的函数称为方法，方法可通过该类的所有实例来访问 在类的代码块中，我们可以定义变量和函数 变量会成为该类实例的公共属性，所有的该类实例都可以通过 对象.属性名 的形式访问 函数会成为该类实例的公共方法，所有该类实例都可以通过 对象.方法名() 的形式调用方法 注意：方法调用时，第一个参数由解析器自动传递，所以定义方法时，至少要定义一个形参 实例为什么能访问到类中的属性和方法 类中定义的属性和方法都是公共的，任何该类实例都可以访问 属性和方法查找的流程 当我们调用一个对象的属性时，解析器会先在当前对象中寻找是否含有该属性 如果有，则直接返回当前的对象的属性值，如果没有，则去当前对象的类对象中去寻找，如果有则返回类对象的属性值，如果类对象中依然没有，则报错 类对象和实例对象中都可以保存属性（方法） 如果这个属性（方法）是所有的实例共享的，则应该将其保存到类对象中 如果这个属性（方法）是某个实例独有，则应该保存到实例对象中 一般情况下，属性保存到实例对象中，而方法需要保存到类对象中 def method(self): 类的特殊方法 在类中可以定义一些特殊方法（魔术方法） 特殊方法都是以__开头，__结尾的方法，且不手动调用 def __init__(self): 创建对象的流程（ p1 = Person()的运行流程 ） 创建一个变量 在内存中创建一个新对象 __init__(self)方法执行 将对象的 id 赋值给变量 init会在对象创建以后立刻执行 init可以用来向新创建的对象中初始化属性（self.name） 直接通过 对象.属性 的方式可以来修改属性的值，但这样对象中的属性可以随意修改 类的基本结构 class 类名([父类]) :公共的属性…def __init__(self,...):(对象的初始化方法)…def method_1(self,...):(其他的方法)…def method_2(self,...):… 封装 封装是面向对象的三大特性之一 封装指的是隐藏对象中一些不希望被外部所访问到的属性或方法 getter 和 setter 方法使外部可以访问到属性 getter 获取对象中的指定属性（get_属性名）(return self.name） setter 用来设置对象中的指定属性（set_属性名） 如果希望属性只读，去除 setter 方法 如果不希望属性被外部访问，则去除 getter 方法 使用 setter 方法设置属性，可以增加数据的验证，确保数据的值是正确的 使用封装确实增加了类的定义的复杂程度，但是它也确保了数据的安全性 隐藏类中的属性 可以为对象的属性使用双下划线开头，__xxx 双下划线开头的属性，是对象的隐藏属性，隐藏属性只能在类的内部访问，无法通过对象访问 其实隐藏属性只是 Python 自动将属性名改名为_类名__属性名 一般我们会将私有属性（不希望被外部访问的属性）以_开头，没有特殊需要不要修改私有属性 property 装饰器 property 装饰器，用来将一个 get 方法，转换为对象的属性 添加为@property装饰器以后，我们就可以像调用属性一样使用 get方法 使用 property 装饰的方法，必须和属性名是一样的 setter 方法的装饰器：@属性名.setter 继承 继承是面向对象的三大特性之一 继承其他类中的属性和方法 在定义类时，可以在类名后的括号中指定当前类的父类（超类） 子类（衍生类）可以直接继承父类中的所有的属性和方法 我们经常需要通过继承来对一个类进行扩展 在创建类时，如果省略了父类，则默认父类为 object，object 是所有类的父类，即所有类都继承自 object issubclass() 检查一个类是否是另一个类的子类 isinstance() 检查一个对象是否是一个类的实例，如果这个类是这个对象的父类，也会返回 true，所有对象都是 object 的实例 方法的重写（override） 如果在子类中如果有和父类同名的方法，则通过子类实例去调用方法时，会调用子类的方法为不是父类的方法 当我们调用一个对象的方法时，会优先去当前对象中寻找是否具有该方法 如果有则直接调用，如果没有则去当前对象的父类中寻找 如果没有，则去父类的父类中寻找，以此类推到 object，如还没则报错 父类中所有方法（包括特殊方法）都会被子类继承，也可以重写特殊方法 super() 可以用来获取当前类的父类，并且通过 super()返回对象调用父类方法时，不需要传递 self 多重继承 在 Python 中是支持多重继承的，也就是我们可以为一个类同时指定多个父类 可以在类名的 ()中添加多个类，来实现多重继承 多重继承，会使子类同时拥有多个父类，并且会获取到所有父类中的方法 在开发中没有特殊的情况，应该尽量避免使用多重继承，因为多重继承会让我们的代码过于复杂 如果多个父类中有同名的方法，则从前往后查找，即前边父类的方法会覆盖后边父类的方法 类名，__bases__这个属性可以用来获取当前类的所有父类 print(C.__bases__) (&lt;class &#39;__main__.B&#39;&gt;,) print(B.__bases__)``(&lt;class &#39;object&#39;&gt;,) 多态 多态是面向对象的三大特征之一 一个对象可以以不同的形态去呈现，即多态 如函数违反多态，只适用于一种类型的对象，无法处理其他类型对象，则函数适应性会变差 多态的描述：鸭子类型 如果一个东西，走路像鸭子，叫声像鸭子，那么它就是鸭子 对象通过 len() 来获取长度，是因为对象中有__len__特殊方法 只要对象中具有__len__特殊方法，就可以通过 len()来获取长度 面向对象的三大特征的总结 封装 确保对象中的数据安全 继承 保证了对象的可扩展性 多态 保证了程序的灵活性 类中的属性和方法 类属性 类属性，直接在类中定义的属性是类属性 类属性可以通过类或类的实例访问到 类属性只能通过类对象来修改，无法通过实例对象修改 实例属性和方法 通过实例对象添加到属性属于实例属性 在类中定义，以 self为第一个参数的方法是实例方法 实例方法在调用时，Python 会调用对象作为 self传入 实例方法可以通过实例和类去调用 当通过实例调用时，会自动将当前调用对象作为 self 传入 但通过类调用时，不会自动传递 self，此时我们必须手动传递 self 类方法 在类内部使用 @classmethod 来修饰的方法属于类方法 类方法的第一个参数是 cls ，也会被自动传递，cls 就是当前的类对象 实例方法 实例方法的第一个参数是 self，类方法的第一个参数是 cls 类方法可以通过类去调用，也可以通过实例调用，没有区别 静态方法 在类中实用 @staticmethod 来修饰的方法属于静态方法 静态方法不需要指定任何的默认参数，静态方法可以通过类和实例去调用 静态方法基本是一个和当前类无关的方法，只是一个保存到当前类中的函数 静态方法一般都是一些工具方法，和当前的需要无关 垃圾回收 就像我们生活中会产生垃圾一样，程序在运行过程当中也会产生垃圾 程序运行过程中产生的垃圾会影响到程序的运行的运行性能，所以这些垃圾必须被及时清理 在程序中没有被引用的对象就是垃圾，这种垃圾对象过多以后会影响到程序的运行的性能，所以我们必须进行及时的垃圾回收 所谓的垃圾回收就是将垃圾对象从内存中删除 在 Python 中有自动的垃圾回收机制，它会自动将这些没有被引用的对象删除，所以我们不用手动处理垃圾回收 特殊方法 特殊方法，也称为魔术方法 特殊方法都是使用__开头和结尾的 特殊方法一般不需要我们手动调用，需要在一些特殊情况下自动执行 __str__()这个特殊方法会在尝试将对象转换为字符串的时候调用，它的作用可以用来指定对象转换为字符串的结果 （print 函数） __repr__()这个特殊方法会在对当前对象使用 repr()函数时调用，它的作用是指定对象在 “交互模式” 中直接输出的效果 object.__add__(self, other) object.__sub__(self, other) object.__mul__(self, other) object.__matmul__(self, other) object.__truediv__(self, other) object.__floordiv__(self, other) object.__mod__(self, other) object.__divmod__(self, other) object.__pow__(self, other[, modulo]) object.__lshift__(self, other) object.__rshift__(self, other) object.__and__(self, other) object.__xor__(self, other) object.__or__(self, other) object.__lt__(self, other) 小于 &lt; object.__le__(self, other)小于等于 &lt;= object.__eq__(self, other) 等于 == object.__ne__(self, other) 不等于 != object.__gt__(self, other) 大于 &gt; object.__ge__(self, other) 大于等于 &gt;= __len__()获取对象的长度 object.__bool__(self)可以通过 bool 来指定对象转换为布尔值的情况 __gt__会在对象做大于比较的时候调用，该方法的返回值将会作为比较的结果 他需要两个参数，一个 self 表示当前对象，other 表示和当前对象比较的对象：self &gt; other 模块（module） 模块化，模块化指将一个完整的程序分解为一个一个小的模块，通过将模块组合，来搭建出一个完整的程序 不采用模块化，统一将所有的代码编写到一个文件中 采用模块化，将程序分别编写到多个文件中 模块化的优点： 方便开发 方便维护 模块可以复用 在 Python 中一个 .py 文件就是一个模块，要想创建模块，实际上就是创建一个 python 文件 注意：模块名要符号标识符的规范 在一个模块中引入外部模块 import 模块名 （模块名，就是 python 文件的名字，注意不要 py） import 模块名 as 模块别名 可以引入同一个模块多次，但是模块的实例只会创建一个 import 可以在程序的任意位置调用，但是一般情况下，import 语句都会统一写在程序的开头 在每一个模块内部都有一个__name__属性，通过这个属性可以获取到模块的名字 __name__属性值为__main__的模块是主模块，一个程序中只会有一个主模块 主模块就是我们直接通过 python 执行的模块 访问模块中的变量：模块名.变量名 只引入模块中的部分内容：from 模块名 import 变量, 变量... from m import * 引入到模块中所有内容，一般不会使用 为引入的变量使用别名：from 模块名 import 变量 as 别名 包（Package） 包也是一个模块，当我们模块中代码过多时，或者一个模块需要被分解为多个模块时，这时就需要使用到包 普通的模块就是一个 .py 文件，而包是一个文件夹 包中必须要一个一个__init__.py这个文件，这个文件中可以包含有包中的主要内容 __pycache__是模块的缓存文件 .py 代码在执行前，需要被解析器先转换为机器码，然后再执行,所以我们在使用模块（包）时，也需要将模块的代码先转换为机器码然后再交由计算机执行 为了提高程序运行的性能，python 会在编译过一次以后，将代码保存到一个缓存文件中,这样在下次加载这个模块（包）时，就可以不再重新编译而是直接加载缓存中编译好的代码即可 Python 标准库 为了实现开箱即用的思想，Python 中为我们提供了一个模块的标准库 在这个标准库中，有很多很强大的模块我们可以直接使用，并且标准库会随 Python 的安装一同安装 sys 模块，它里面提供了一些变量和函数，使我们可以获取到 Python 解析器的信息，或者通过函数来操作 Python 解析器 pprint 模块它给我们提供了一个方法 pprint() 该方法可以用来对打印的数据做简单的格式化 sys.argv 获取执行代码时，命令行中所包含的参数，该属性是一个列表，列表中保存了当前命令的所有参数 sys.modules 获取当前程序中引入的所有模块 modules 是一个字典，字典的 key 是模块的名字，字典的 value 是模块对象 sys.path 是一个列表，列表中保存的是模块的搜索路径 sys.platform 表示当前 Python 运行的平台 sys.exit() 函数用来退出程序 os 模块让我们可以对操作系统进行访问 os.environ. 通过这个属性可以获取到系统的环境变量 os.system() 可以用来执行操作系统的名字os.system(&#39;dir&#39;) os.system(&#39;notepad&#39;) 异常 程序在运行过程当中，不可避免的会出现一些错误，比如：使用了没有赋值过的变量，使用了不存在的索引，除 0 等 这些错误在程序中，我们称其为异常 程序运行过程中，一旦出现异常将会导致程序立即终止，异常以后的代码全部都不会执行 处理异常 程序运行时出现异常，目的并不是让我们的程序直接终止 Python 是希望在出现异常时，我们可以编写代码来对异常进行处理 try 语句 12345678try:代码块（可能出现错误的语句）except 异常类型 as 异常名:代码块（出现错误以后的处理方式）else：代码块（没出错时要执行的语句） finally:代码块（该代码块总会执行） try 是必须的；else 语句有没有都行；except 和 finally 至少有一个 可以将可能出错的代码放入到 try 语句，这样如果代码没有错误，则会正常执行 如果出现错误，则会执行 expect 子句中的代码，这样我们就可以通过代码来处理异常，避免因为一个异常导致整个程序的终止 异常的传播（抛出异常） 当在函数中出现异常时，如果在函数中对异常进行了处理，则异常不会再继续传播 如果函数中没有对异常进行处理，则异常会继续向函数调用处传播, 如果函数调用处处理了异常，则不再传播，如果没有处理则继续向调用处传播 直到传递到全局作用域（主模块）如果依然没有处理，则程序终止，并且显示异常信息 当程序运行过程中出现异常以后，所有的异常信息会被保存一个专门的异常对象中，而异常传播时，实际上就是异常对象抛给了调用处 ZeroDivisionError 类的对象专门用来表示除 0 的异常，NameError 类的对象专门用来处理变量错误的异常 在 Python 为我们提供了多个异常对象 如果 except 后不跟任何的内容，则此时它会捕获到所有的异常 如果在 except 后跟着一个异常的类型，那么此时它只会捕获该类型的异常 Exception 是所有异常类的父类，所以如果 except 后跟的是 Exception，他也会捕获到所有的异常 可以在异常类后边跟着一个 as xx 此时 xx 就是异常对象 也可以自定义异常类，只需要创建一个类继承 Exception 即可 可以使用 raise 语句来抛出异常，raise 语句后需要跟一个异常类 或 异常的实例 raise Exception 抛出异常的目的，告诉调用者这里调用时出现问题，希望你自己处理一下 文件（File） 通过 Python 程序来对计算机中的各种文件进行增删改查的操作 I/O(Input / Output) 操作文件的步骤： 打开文件 对文件进行各种操作（读、写），然后保存 关闭文件 打开关闭文件 使用 open 函数 来打开一个文件 参数： file 要打开的文件的名字（路径） 返回值：返回一个对象，这个对象就代表了当前打开的文件 创建一个变量，来保存文件的名字， 如果目标文件和当前文件在同一级目录下，则直接使用文件名即可 在 windows 系统使用路径时，可以使用/来代替 \\ ；或者可以使用 \\ 来代替 \\ ；或者也可以使用原始字符串 表示路径，可以使用..来返回一级目录 如果目标文件距离当前文件比较远，此时可以使用绝对路径 绝对路径应该从磁盘的根目录开始书写 file_obj = open(file_name)打开 file_name 对应的文件 调用 close() 方法来关闭文件 open() 打开文件时，默认是以文本文件的形式打开的，但是 open() 默认的编码为 None 所以处理文本文件时，必须要指定文件的编码 文件的读取 当我们获取了文件对象以后，所有的对文件的操作都应该通过对象来进行 read() 方法，用来读取文件中的内容，它会将内容全部保存为一个字符串返回 with open() as file_obj:在 with 语句中可以直接使用 file_obj 来做文件操作 此时这个文件只能在 with 中使用，一旦 with 结束则文件会自动close() 如果要读取的文件较大的话，会一次性将文件的内容加载到内存中，容易导致内存泄漏，所以对于较大的文件，不要直接调用 read() help(file_obj.read) read() 可以接收一个 size 作为参数，该参数用来指定要读取的字符的数量，默认值为-1，它会读取文件中的所有字符 可以为 size 指定一个值，这样read()会读取指定数量的字符， 每一次读取都是从上次读取到位置开始读取的，如果字符的数量小于 size，则会读取剩余所有的，如果已经读取到了文件的最后了，则会返回’ ‘空串 readline()方法可以用来读取一行内容 readlines() 方法用于一行一行的读取内容，它会一次性将读取到的内容封装到一个列表中返回 文件的写入 使用 open() 打开文件时必须要指定打开文件所要做的操作（读、写、追加） 如果不指定操作类型，则默认是 读取文件 ， 而读取文件时是不能向文件中写入的 r 表示只读的 w 表示是可写的，使用 w 来写入文件时，如果文件不存在会创建文件，如果文件存在则会截断文件，截断文件指删除原来文件中的所有内容 a 表示追加内容，如果文件不存在会创建文件，如果文件存在则会向文件中追加内容 x 用来新建文件，如果文件不存在则创建，存在则报错 - 为操作符增加功能 r+ 即可读又可写，文件不存在会报错 w+ a+ 例如：with open(file_name , &#39;w&#39; , encoding=&#39;utf-8&#39;) as file_obj: write()来向文件中写入内容，如果操作的是一个文本文件的话，则 write() 需要传递一个字符串作为参数 write() 方法会可以分多次向文件中写入内容，写入完成以后，该方法会返回写入的字符的个数 文件的其他操作 t 读取文本文件（默认值） b 读取二进制文件 with open(file_name , &#39;rb&#39;) as file_obj: 读取文本文件时，size 是以字符为单位的 读取二进制文件时，size 是以字节为单位 将读取到的内容写出来 定义一个新的文件 seek() 可以修改当前读取的位置 seek() 需要两个参数，第一个 是要切换到的位置，第二个 计算位置方式 seek 计算位置可选值：0 从头计算（默认值）；1 从当前位置计算；2 从最后位置开始计算 tell() 方法用来查看当前读取的位置 os.listdir() 获取指定目录的目录结构，需要一个路径作为参数，会获取到该路径下的目录结构，默认路径为 . 当前目录 该方法会返回一个列表，目录中的每一个文件（夹）的名字都是列表中的一个元素 r = os.listdir() os.getcwd() 获取当前所在的目录 r = os.getcwd() os.chdir() 切换当前所在的目录 作用相当于 cd os.chdir(&#39;c:/&#39;) r = os.getcwd() 创建目录，os.mkdir(&quot;aaa&quot;) 在当前目录下创建一个名字为 aaa 的目录 删除目录， os.rmdir(&#39;abc&#39;) open(&#39;aa.txt&#39;,&#39;w&#39;) 删除文件， os.remove(&#39;aa.txt&#39;) os.rename(&#39;旧名字&#39;,&#39;新名字&#39;) 可以对一个文件进行重命名，也可以用来移动一个文件， os.rename(&#39;aa.txt&#39;,&#39;bb.txt&#39;)","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.zhuangzhihao.top/categories/Python/"}],"tags":[]},{"title":"JavaScript 基础知识总结","slug":"JavaScript基础","date":"2020-10-04T16:00:00.000Z","updated":"2022-06-21T07:13:21.695Z","comments":true,"path":"JavaScript基础/","link":"","permalink":"http://blog.zhuangzhihao.top/JavaScript%E5%9F%BA%E7%A1%80/","excerpt":"JavaScript 是一门跨平台、面向对象的脚本语言，它能使网页可交互，可以让你在网页上添加更多功能，另外还有高级的服务端 JavaScript 版本，在 web 浏览器中，JavaScript 能够通过其所连接的环境提供的编程接口进行控制。在之前我已经简单总结了HTML5/CSS3的必会知识点，为 Javascript 学习打下基础。","text":"JavaScript 是一门跨平台、面向对象的脚本语言，它能使网页可交互，可以让你在网页上添加更多功能，另外还有高级的服务端 JavaScript 版本，在 web 浏览器中，JavaScript 能够通过其所连接的环境提供的编程接口进行控制。在之前我已经简单总结了HTML5/CSS3的必会知识点，为 Javascript 学习打下基础。 一、JavaScript 简介JavaScript 是一门跨平台、面向对象的脚本语言，不需要编译成字节码，由浏览器直接解析并执行。JavaScript 是用来控制网页行为的，它能使网页可交互，如改变页面内容、修改指定元素的属性值、对表单进行校验等。 JavaScript（简称：JS） 在 1995 年由 Brendan Eich 发明，并于 1997 年成为一部 ECMA 标准。ECMA 规定了一套标准 就叫 ECMAScript ，所有的客户端校验语言必须遵守这个标准，当然 JavaScript 也遵守了这个标准。ECMAScript 6 (简称ES6) 是最新的 JavaScript 版本（发布于 2015 年)。 二、JavaScript 引入方式JavaScript 引入方式就是 HTML 和 JavaScript 的结合方式。JavaScript引入方式有两种：内部脚本（将 JS 代码定义在 HTML 页面中）和外部脚本（将 JS 代码定义在外部 JS 文件中，然后引入到 HTML 页面中）。 内部脚本在 HTML 中，JavaScript 代码必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间，在 HTML 文档中可以在任意地方，放置任意数量的 &lt;script&gt; 标签。 alert(数据) 是 JavaScript 的一个方法，作用是将参数数据以浏览器弹框的形式输出出来。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; alert(&quot;hello js1&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一般把脚本置于 &lt;body&gt; 元素的底部，可改善显示速度，因为浏览器在加载页面的时候会从上往下进行加载并解析。 我们应该让用户看到页面内容，然后再展示动态的效果。 外部脚本定义外部 js 文件（demo.js），外部脚本不能包含 &lt;script&gt; 标签，在 js 文件中直接写 js 代码即可，不要在 js文件 中写 script 标签。 1alert(&quot;hello js&quot;); 在 HTML 页面使用 script 标签中使用 src 属性指定 js 文件的 URL 路径，引入外部的 js 文件。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;../js/demo.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; &lt;script&gt; 标签不能自闭合：在页面中引入外部 js 文件时，不能写成 &lt;script src=&quot;../js/demo.js&quot; /&gt;。 三、JavaScript 基础语法书写语法区分大小写：变量名、函数名以及其他一切东西都是区分大小写的。 每行结尾的分号可有可无，如果一行上写多个语句时，必须加分号用来区分多个语句。 注释 单行注释：// 注释内容 多行注释：/* 注释内容 */ JavaScript 没有文档注释 大括号表示代码块 123if (count == 3) &#123; alert(count); &#125; 输出语句js 可以通过以下方式进行内容的输出，只不过不同的语句输出到的位置不同。 使用 window.alert() 写入警告框。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.alert(&quot;hello js&quot;);//写入警告框&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用 document.write() 写入 HTML 输出。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; document.write(&quot;hello js 2~&quot;);//写入html页面&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用 console.log() 写入浏览器控制台。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; console.log(&quot;hello js 3&quot;);//写入浏览器的控制台&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 变量JavaScript 中用 var 关键字（variable 的缩写）来声明变量。格式： var 变量名 = 数据值; JavaScript 提供八种不同的数据类型，它们是 undefined（未定义）、null（空）、boolean（布尔型）、string（字符串）、symbol、number（数字）、bigint（可以表示任意大的整数）和 object（对象）。 JavaScript 是一门弱类型语言，变量可以存放不同类型的值，如在定义变量时赋值为数字数据，还可以将变量的值改为字符串类型的数。 12var test = 20;test = &quot;张三&quot;; js 中的变量名命名规则和 Java 语言基本都相同：组成字符可以是任何字母、数字、下划线（_）或美元符号（$），数字不能开头，使用驼峰命名。 JavaScript 中 var 关键字有点特殊，有以下地方和其他语言不一样： 作用域：全局变量。 1234&#123; var age = 20;&#125;alert(age); // 在代码块中定义的age 变量，在代码块外边还可以使用 变量可以重复定义。 12345&#123; var age = 20; var age = 30;//JavaScript 会用 30 将之前 age 变量的 20 替换掉&#125;alert(age); //打印的结果是 30 ECMAScript 6 新增了 let关键字来定义变量。它的用法类似于 var，但是所声明的变量，只在 let 关键字所在的代码块内有效，且不允许重复声明。 1234&#123; let age = 20;&#125;alert(age); ECMAScript 6 新增了 const 关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变。 全局作用域和函数在 JavaScript 中，作用域涉及到变量的作用范围。 在函数外定义的变量具有 全局 作用域。 这意味着，具有全局作用域的变量可以在代码的任何地方被调用。 未使用 let 或 const 关键字声明的变量会在 global 范围内自动创建。 当在代码其他地方无意间定义了一个变量，刚好变量名与全局变量相同，这时会产生意想不到的后果。 你应该总是用 let 或 const 声明你的变量。 重载：一个程序中有可能具有相同名称的局部变量 和全局变量。 在这种情况下，局部变量将会优先于全局变量。 12345// myGlobal、oopsGlobal 变量均为全局变量let myGlobal = 10;function fun1() &#123; oopsGlobal = 5;&#125; 数据类型JavaScript 中提供了两类数据类型：原始类型 和 引用类型。使用 typeof 运算符可以获取数据类型。 原始数据类型： number：数字（整数、小数、NaN），NaN 是一个特殊的 number 类型的值（Not a number）。 12345var age = 20;var price = 99.8;alert(typeof age); // 结果是 ： numberalert(typeof price);// 结果是 ： number string：字符、字符串，单双引皆可。在 js 中 双引号和单引号都表示字符串类型的数据。 123456var ch = &#x27;a&#x27;;var name = &#x27;张三&#x27;; var addr = &quot;北京&quot;;alert(typeof ch); //结果是 stringalert(typeof name); //结果是 stringalert(typeof addr); //结果是 string boolean：布尔。true，false。 12345var flag = true;var flag2 = false;alert(typeof flag); //结果是 booleanalert(typeof flag2); //结果是 boolean null：对象为空。 123var obj = null;alert(typeof obj);//结果是 object undefined：当声明的变量未初始化时，该变量的默认值是 undefined。 12var a ;alert(typeof a); //结果是 undefined 运算符JavaScript 提供了如下的运算符。大部分和 Java语言 都是一样的，不同的是 JS 关系运算符中的 == 和 ===。 一元运算符：++，-- 算术运算符：+，-，*，/，% 赋值运算符：=，+=，-=… 关系运算符：&gt;，&lt;，&gt;=，&lt;=，!=，==，===… 逻辑运算符：&amp;&amp;，||，! 三元运算符：条件表达式 ? true_value : false_value == 和 === 区别： ==：判断类型是否一样，如果不一样，则进行类型转换，再去比较其值。 ===：js 中的全等于，判断类型是否一样，如果不一样，直接返回 false，再去比较其值。 12345var age1 = 20;var age2 = &quot;20&quot;;alert(age1 == age2);// truealert(age1 === age2);// false 类型转换string 转换为 number 类型：按照字符串的字面值，转为数字。如果字面值不是数字，则转为 NaN。 使用 + 正号运算符： 12var str = +&quot;20&quot;;alert(str + 1) //21 使用 parseInt() 函数(方法)： 12var str = &quot;20&quot;;alert(parseInt(str) + 1); //建议使用 `parseInt()` 函数进行转换 boolean 转换为 number 类型：true 转为1，false 转为0。 12var flag = +false;alert(flag); // 0 number 类型转换为 boolean 类型：0 和 NaN 转为false，其他的数字转为true。 string 类型转换为 boolean 类型：空字符串转为false，其他的字符串转为true。 null类型转换为 boolean 类型是 false。 undefined 转换为 boolean 类型是 false。 123456789// var flag = 3;// var flag = &quot;&quot;;var flag = undefined;if(flag)&#123; alert(&quot;转为true&quot;);&#125;else &#123; alert(&quot;转为false&quot;);&#125; 在 Java 中使用字符串前，一般都会先判断字符串不是null，并且不是空字符才会做其他的一些操作，JavaScript也有类型的操作。 1234567var str = &quot;abc&quot;;//健壮性判断if(str != null &amp;&amp; str.length &gt; 0)&#123; alert(&quot;转为true&quot;);&#125;else &#123; alert(&quot;转为false&quot;);&#125; 但是由于 JavaScript 会自动进行类型转换，所以上述的判断可以进行简化。 1234567var str = &quot;abc&quot;;//健壮性判断if(str)&#123; alert(&quot;转为true&quot;);&#125;else &#123; alert(&quot;转为false&quot;);&#125; 流程控制语句if 语句 1234var count = 3;if (count == 3) &#123; alert(count);&#125; switch 语句 123456789101112131415161718192021222324252627var num = 3;switch (num) &#123; case 1: alert(&quot;星期一&quot;); break; case 2: alert(&quot;星期二&quot;); break; case 3: alert(&quot;星期三&quot;); break; case 4: alert(&quot;星期四&quot;); break; case 5: alert(&quot;星期五&quot;); break; case 6: alert(&quot;星期六&quot;); break; case 7: alert(&quot;星期日&quot;); break; default: alert(&quot;输入的星期有误&quot;); break;&#125; for 循环语句 12345var sum = 0;for (let i = 1; i &lt;= 100; i++) &#123; //建议for循环小括号中定义的变量使用let sum += i;&#125;alert(sum); while 循环语句 1234567var sum = 0;var i = 1;while (i &lt;= 100) &#123; sum += i; i++;&#125;alert(sum); dowhile 循环语句 12345678var sum = 0;var i = 1;do &#123; sum += i; i++;&#125;while (i &lt;= 100);alert(sum); 函数函数（就是Java中的方法）是被设计为执行特定任务的代码块；JavaScript 函数通过 function 关键词进行定义。 定义格式 1234567function 函数名(参数1,参数2..)&#123; 要执行的代码&#125;var 函数名 = function (参数列表)&#123; 要执行的代码&#125; 形式参数不需要类型，因为JavaScript是弱类型语言。 123function add(a, b)&#123; return a + b;&#125; 上述函数的参数 a 和 b 不需要定义数据类型，因为在每个参数前加上 var 也没有任何意义。返回值也不需要定义类型，可以在函数内部直接使用 return 返回即可。 函数调用：函数名称(实际参数列表); 1let result = add(10,20); JS 中，函数调用可以传递任意个数参数，例如 let result = add(1,2,3); ，它是将数据 1 传递给了变量 a，将数据 2 传递给了变量 b，而数据 3 没有变量接收。 三、JavaScript 常用对象JavaScript 提供了很多对象供使用者来使用。这些对象总共分类三类： 基本对象 BOM 对象 DOM对象 Array 对象JavaScript Array对象用于定义数组。 12345var 变量名 = new Array(元素列表); var arr = new Array(1,2,3); //1,2,3 是存储在数组中的数据（元素）var 变量名 = [元素列表];var arr = [1,2,3]; //1,2,3 是存储在数组中的数据（元素） Java 中的数组静态初始化使用的是 &#123;&#125; 定义，而 JavaScript 中使用的是 [] 定义。 元素访问：arr[索引] = 值; 123456789101112131415 // 方式一var arr = new Array(1,2,3);// alert(arr);// 方式二var arr2 = [1,2,3];//alert(arr2);//方式三var arr3 = [[&quot;Str1&quot;, 1], [&quot;Str2&quot;, 2], [&quot;Str3&quot;, 3]];// 访问arr2[0] = 10;arr3[2][1] = &quot;3&quot;;alert(arr2) JavaScript 中的数组相当于 Java 中集合。数组的长度是可以变化的，而 JavaScript 是弱类型，所以可以存储任意的类型的数据。 12345// 变长var arr3 = [1,2,3];arr3[10] = 10;alert(arr3[10]); // 10alert(arr3[9]); //undefined 在 JavaScript 中没有赋值的话，默认就是 undefined。如果给 arr3 数组添加字符串的数据，也是可以添加成功的。 12arr3[5] = &quot;hello&quot;;alert(arr3[5]); // hello 属性：Array 对象提供了很多属性。例如length 属性：该数组可以动态的获取数组的长度。而有这个属性，我们就可以遍历数组了。 1234var arr = [1,2,3];for (let i = 0; i &lt; arr.length; i++) &#123; alert(arr[i]);&#125; 方法：Array 对象同样也提供了很多方法。 push 函数：给数组添加元素，也就是在数组的末尾添加元素，参数表示要添加的元素。 1234// push:添加方法var arr5 = [1,2,3];arr5.push(10);alert(arr5); //数组的元素是 &#123;1,2,3,10&#125; splice 函数：删除元素。 参数1：索引。表示从哪个索引位置删除。 参数2：个数。表示删除几个元素。 1234// splice:删除元素var arr5 = [1,2,3];arr5.splice(0,1); //从 0 索引位置开始删除，删除一个元素 alert(arr5); // &#123;2,3&#125; pop() 函数：用来移出数组中最后一个元素。 .shift() 函数用来移出数组中第一个元素： 12const ourArray = [&quot;Stimpson&quot;, &quot;J&quot;, [&quot;cat&quot;]];const removedFromOurArray = ourArray.shift(); //ourArray.pop() .unshift() 函数：类似 .push() 函数，但不是在数组的末尾添加元素，unshift() 在数组的头部添加元素： 123const ourArray = [&quot;Stimpson&quot;, &quot;J&quot;, &quot;cat&quot;];ourArray.shift(); // [&quot;J&quot;, &quot;cat&quot;]ourArray.unshift(&quot;Happy&quot;); // [&quot;Happy&quot;, &quot;J&quot;, &quot;cat&quot;] String 对象String对象的创建方式有两种： 123var 变量名 = new String(s); var 变量名 = &quot;数组&quot;; 属性：String 对象提供了很多属性，属性 length ，是用于动态的获取字符串的长度。 函数：String 对象提供了很多函数（方法）。 函数 trim() ，该方法是用来去掉字符串两端的空格。 123var str4 = &#x27; abc &#x27;;alert(1 + str4 + 1);alert(1 + str4.trim() + 1); trim() 函数在开发中还是比较常用的，例如在登陆界面 ，用户在输入用户名和密码时，可能会习惯的输入一些空格，这样在我们后端程序中判断用户名和密码是否正确，结果肯定是失败。所以我们一般都会对用户输入的字符串数据进行去除前后空格的操作。 自定义对象在 JavaScript 中自定义对象特别简单： 1234567var 对象名称 = &#123; 属性名称1:属性值1, 属性名称2:属性值2, ..., 函数名称:function (形参列表)&#123;&#125;, ...&#125;; 调用属性的格式：对象名.属性名；调用函数的格式：对象名.函数名()： 12345678910111213var person = &#123; name : &quot;zhangsan&quot;, age : 23, eat: function functionName()&#123; alert(&quot;干饭~&quot;); &#125; &#125;;alert(person.name); //zhangsanperson.eat(); //干饭~delete person.name; //删除对象元素person.familyName = &quot;zhang&quot; //添加对象元素 有时检查一个对象属性是否存在是非常有用的。 我们可以用对象的 .hasOwnProperty(propname) 方法来检查对象是否有指定的属性： 1234567function checkObj(obj, checkProp) &#123; if (obj.hasOwnProperty(checkProp)) &#123; return obj[checkProp]; &#125; else &#123; return &quot;Not Found&quot;; &#125;&#125; 其他方法对象在 JavaScript 中，可以用 Math.random() 生成一个在0（包括 0）到 1（不包括 1）之间的随机小数。用 Math.floor() 向下取整，获得它最近的整数： 12// 生成并返回 0 和 9 之间的随机整数return Math.floor(Math.random() * 10); parseInt() 函数解析一个字符串返回一个整数，它还可以传入第二个参数，指定了字符串中数字的基数。： 12const a = parseInt(&quot;007&quot;); //7const a = parseInt(&quot;11&quot;, 2); //指示 11 在二进制系统中，输出：3 四、BOMBOM：Browser Object Model 浏览器对象模型。也就是 JavaScript 将浏览器的各个组成部分封装为对象。 我们要操作浏览器的各个组成部分就可以通过操作 BOM 中的对象来实现。比如：我现在想将浏览器地址栏的地址改为 https://www.itheima.com 就可以通过使用 BOM 中定义的 Location 对象的 href 属性，代码： location.href = &quot;https://itheima.com&quot;; 。 BOM 中包含了如下对象 Window：浏览器窗口对象 Navigator：浏览器对象 Screen：屏幕对象 History：历史记录对象 Location：地址栏对象 Window 对象window 对象是 JavaScript 对浏览器的窗口进行封装的对象。 该对象不需要创建直接使用 window，其中 window. 可以省略。比如我们之前使用的 alert() 函数，其实就是 window 对象的函数，在调用是可以写成如下两种： 1234//显式使用 window 对象调用window.alert(&quot;abc&quot;); //隐式调用alert(&quot;abc&quot;) window 对象提供了用于获取其他 BOM 组成对象的属性。也就是说，我们想使用 Location 对象的话，就可以使用 window 对象获取；写成 window.location，而 window. 可以省略，简化写成 location 来获取 Location 对象。 window 对象函数：window 对象提供了很多函数供我们使用，而很多都不常用。 setTimeout(function,毫秒值) : 在一定的时间间隔后执行一个function，只执行一次。 setInterval(function,毫秒值) :在一定的时间间隔后执行一个function，循环执行。 1234// confirm()，点击确定按钮，返回true，点击取消按钮，返回falsevar flag = confirm(&quot;确认删除？&quot;);alert(flag); 1234// 定时器，打开浏览器，3秒后才会弹框输出 hehe，并且只会弹出一次setTimeout(function ()&#123; alert(&quot;hehe&quot;);&#125;,3000); 1234// 定时器，打开浏览器，每隔2秒都会弹框输出 hehesetInterval(function ()&#123; alert(&quot;hehe&quot;);&#125;,2000); History 对象History 对象是 JavaScript 对历史记录进行封装的对象。 History 对象的获取：使用 window.history 获取，其中 window. 可以省略。 History 对象的函数：当我们点击向左的箭头，就跳转到前一个访问的页面，这就是 back() 函数的作用；当我们点击向右的箭头，就跳转到下一个访问的页面，这就是 forward() 函数的作用。 Location对象Location 对象是 JavaScript 对地址栏封装的对象。可以通过操作该对象，跳转到任意页面。 获取 Location 对象：使用 window.location 获取，其中 window. 可以省略。 12window.location.方法();location.方法(); Location 对象属性：Location 对象提供了很对属性。常用的只有一个属性 href。 1234document.write(&quot;3秒跳转到首页...&quot;); setTimeout(function ()&#123; location.href = &quot;https://www.baidu.com&quot;&#125;,3000); 五、DOMDOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。JavaScript 通过 DOM， 就能够对 HTML进行操作了，例如改变 HTML 元素的内容，改变 HTML 元素的样式（CSS），对 HTML DOM 事件作出反应，添加和删除 HTML 元素。 DOM 是 W3C（万维网联盟）定义了访问 HTML 和 XML 文档的标准。该标准被分为 3 个不同的部分： 核心 DOM：针对任何结构化文档的标准模型。 XML 和 HTML 通用的标准。 Document：整个文档对象。 Element：元素对象。 Attribute：属性对象。 Text：文本对象。 Comment：注释对象。 XML DOM： 针对 XML 文档的标准模型。 HTML DOM： 针对 HTML 文档的标准模型。该标准是在核心 DOM 基础上，对 HTML 中的每个标签都封装成了不同的对象。 例如：&lt;img&gt; 标签在浏览器加载到内存中时会被封装成 Image 对象，同时该对象也是 Element 对象。 例如：&lt;input type=&#39;button&#39;&gt; 标签在浏览器加载到内存中时会被封装成 Button 对象，同时该对象也是 Element 对象。 获取 Element 对象HTML 中的 Element 对象可以通过 Document 对象获取，而 Document 对象是通过 window 对象获取。 Document 对象中提供了以下获取 Element 元素对象的函数： getElementById()：根据 id 属性值获取，返回单个 Element 对象。 getElementsByTagName()：根据标签名称获取，返回 Element 对象数组。 getElementsByName()：根据 name 属性值获取，返回 Element 对象数组。 getElementsByClassName()：根据 class 属性值获取，返回 Element 对象数组。 HTML Element 对象使用HTML 中的 Element 元素对象有很多，不可能全部记住，以后是根据具体的需求查阅文档使用。 1234567891011121314151617181920//getElementById：根据 id 属性值获取上面的 img 元素对象，返回单个对象var img = document.getElementById(&quot;light&quot;);alert(img); //getElementsByTagName：根据标签名称获取所有的 `div` 元素对象var divs = document.getElementsByTagName(&quot;div&quot;);// 返回一个数组，数组中存储的是 div 元素对象// alert(divs.length); //输出 数组的长度//遍历数组for (let i = 0; i &lt; divs.length; i++) &#123; alert(divs[i]);&#125; //getElementsByName：根据name属性值获取，返回Element对象数组var hobbys = document.getElementsByName(&quot;hobby&quot;);for (let i = 0; i &lt; hobbys.length; i++) &#123; alert(hobbys[i]);&#125;//getElementsByClassName：根据class属性值获取，返回Element对象数组var clss = document.getElementsByClassName(&quot;cls&quot;);for (let i = 0; i &lt; clss.length; i++) &#123; alert(clss[i]);&#125; 六、事件监听HTML 事件是发生在 HTML 元素上的“事情”。比如：页面上的 按钮被点击、鼠标移动到元素之上、按下键盘按键 等都是事件.事件监听是JavaScript 可以在事件被侦测到时执行一段逻辑代码. 事件绑定JavaScript 提供了两种事件绑定方式： 通过 HTML标签中的事件属性进行绑定，如下面代码，有一个按钮元素，我们是在该标签上定义 事件属性，在事件属性中绑定函数。onclick 就是 单击事件 的事件属性。onclick=&#39;on（）&#39; 表示该点击事件绑定了一个名为 on() 的函数。 12&lt;input type=&quot;button&quot; onclick=&#x27;on()’&gt;&lt;script&gt;&lt;/ 下面是点击事件绑定的 on() 函数。 123function on()&#123; alert(&quot;我被点了&quot;);&#125; 通过 DOM 元素属性绑定，如下面代码是按钮标签，在该标签上我们并没有使用 事件属性，绑定事件的操作需要在 js 代码中实现。 1&lt;input type=&quot;button&quot; id=&quot;btn&quot;&gt; 下面 js 代码是获取了 id=&#39;btn&#39; 的元素对象，然后将 onclick 作为该对象的属性，并且绑定匿名函数。该函数是在事件触发后自动执行。 123document.getElementById(&quot;btn&quot;).onclick = function ()&#123; alert(&quot;我被点了&quot;);&#125; 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--方式1：在下面input标签上添加 onclick 属性，并绑定 on() 函数--&gt; &lt;input type=&quot;button&quot; value=&quot;点我&quot; onclick=&quot;on()&quot;&gt; &lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;再点我&quot; id=&quot;btn&quot;&gt; &lt;script&gt; function on()&#123; alert(&quot;我被点了&quot;); &#125; //方式2：获取 id=&quot;btn&quot; 元素对象，通过调用 onclick 属性 绑定点击事件 document.getElementById(&quot;btn&quot;).onclick = function ()&#123; alert(&quot;我被点了&quot;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 常见事件 事件属性名 说明 onclick 鼠标单击事件 onblur 元素失去焦点 onfocus 元素获得焦点 onload 某个页面或图像被完成加载 onsubmit 当表单提交时触发该事件 onmouseover 鼠标被移到某元素之上 onmouseout 鼠标从某元素移开 如下是带有表单的页面 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;register&quot; action=&quot;#&quot; &gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;script&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如上代码的表单，当我们点击 提交 按钮后，表单就会提交，此处默认使用的是 GET 提交方式，会将提交的数据拼接到 URL 后。现需要通过 js 代码实现阻止表单提交的功能，js 代码实现如下： 获取 form 表单元素对象。 给 form 表单元素对象绑定 onsubmit 事件，并绑定匿名函数。 该匿名函数如果返回的是true，提交表单；如果返回的是false，阻止表单提交。 1234document.getElementById(&quot;register&quot;).onsubmit = function ()&#123; //onsubmit 返回true，则表单会被提交，返回false，则表单不提交 return true;&#125; 七、表单验证案例需求有如下注册页面，对表单进行校验，如果输入的用户名、密码、手机号符合规则，则允许提交；如果不符合规则，则不允许提交。 完成以下需求： 当输入框失去焦点时，验证输入内容是否符合要求。 当点击注册按钮时，判断所有输入框的内容是否都符合要求，如果不合符则阻止表单提交。 环境准备 下面是初始页面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;欢迎注册&lt;/title&gt; &lt;link href=&quot;../css/register.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;form-div&quot;&gt; &lt;div class=&quot;reg-content&quot;&gt; &lt;h1&gt;欢迎注册&lt;/h1&gt; &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;reg-form&quot; action=&quot;#&quot; method=&quot;get&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br&gt; &lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;用户名不太受欢迎&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;span id=&quot;password_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;密码格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt;&lt;input name=&quot;tel&quot; type=&quot;text&quot; id=&quot;tel&quot;&gt; &lt;br&gt; &lt;span id=&quot;tel_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;手机号格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;input value=&quot;注 册&quot; type=&quot;submit&quot; id=&quot;reg_btn&quot;&gt; &lt;/div&gt; &lt;br class=&quot;clear&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 验证输入框校验用户名。当用户名输入框失去焦点时，判断输入的内容是否符合 长度是 6-12 位 规则，不符合使 id=&#39;username_err&#39; 的span标签显示出来，给出用户提示。 校验密码。当密码输入框失去焦点时，判断输入的内容是否符合 长度是 6-12 位 规则，不符合使 id=&#39;password_err&#39; 的span标签显示出来，给出用户提示。 校验手机号。当手机号输入框失去焦点时，判断输入的内容是否符合 长度是 11 位 规则，不符合使 id=&#39;tel_err&#39; 的span标签显示出来，给出用户提示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//1. 验证用户名是否符合规则//1.1 获取用户名的输入框var usernameInput = document.getElementById(&quot;username&quot;);//1.2 绑定onblur事件 失去焦点usernameInput.onblur = function () &#123; //1.3 获取用户输入的用户名 var username = usernameInput.value.trim(); //1.4 判断用户名是否符合规则：长度 6~12 if (username.length &gt;= 6 &amp;&amp; username.length &lt;= 12) &#123; //符合规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;&#x27;; &#125;&#125;//1. 验证密码是否符合规则//1.1 获取密码的输入框var passwordInput = document.getElementById(&quot;password&quot;);//1.2 绑定onblur事件 失去焦点passwordInput.onblur = function() &#123; //1.3 获取用户输入的密码 var password = passwordInput.value.trim(); //1.4 判断密码是否符合规则：长度 6~12 if (password.length &gt;= 6 &amp;&amp; password.length &lt;= 12) &#123; //符合规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;&#x27;; &#125;&#125;//1. 验证手机号是否符合规则//1.1 获取手机号的输入框var telInput = document.getElementById(&quot;tel&quot;);//1.2 绑定onblur事件 失去焦点telInput.onblur = function() &#123; //1.3 获取用户输入的手机号 var tel = telInput.value.trim(); //1.4 判断手机号是否符合规则：长度 11 if (tel.length == 11) &#123; //符合规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;&#x27;; &#125;&#125; 验证表单当用户点击 注册 按钮时，需要同时对输入的 用户名、密码、手机号 ，如果都符合规则，则提交表单；如果有一个不符合规则，则不允许提交表单。实现该功能需要获取表单元素对象，并绑定 onsubmit 事件。 1234567//1. 获取表单对象var regForm = document.getElementById(&quot;reg-form&quot;);//2. 绑定onsubmit 事件regForm.onsubmit = function () &#123; &#125; onsubmit 事件绑定的函数需要对输入的 用户名、密码、手机号 进行校验，这些校验我们之前都已经实现过了，这里我们还需要再校验一次吗？不需要，只需要对之前校验的代码进行改造，把每个校验的代码专门抽象到有名字的函数中，方便调用；并且每个函数都要返回结果来去决定是提交表单还是阻止表单提交。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//1. 验证用户名是否符合规则//1.1 获取用户名的输入框var usernameInput = document.getElementById(&quot;username&quot;);//1.2 绑定onblur事件 失去焦点usernameInput.onblur = checkUsername;function checkUsername() &#123; //1.3 获取用户输入的用户名 var username = usernameInput.value.trim(); //1.4 判断用户名是否符合规则：长度 6~12 var flag = username.length &gt;= 6 &amp;&amp; username.length &lt;= 12; if (flag) &#123; //符合规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;&#x27;; &#125; return flag;&#125;//1. 验证密码是否符合规则//1.1 获取密码的输入框var passwordInput = document.getElementById(&quot;password&quot;);//1.2 绑定onblur事件 失去焦点passwordInput.onblur = checkPassword;function checkPassword() &#123; //1.3 获取用户输入的密码 var password = passwordInput.value.trim(); //1.4 判断密码是否符合规则：长度 6~12 var flag = password.length &gt;= 6 &amp;&amp; password.length &lt;= 12; if (flag) &#123; //符合规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;&#x27;; &#125; return flag;&#125;//1. 验证手机号是否符合规则//1.1 获取手机号的输入框var telInput = document.getElementById(&quot;tel&quot;);//1.2 绑定onblur事件 失去焦点telInput.onblur = checkTel;function checkTel() &#123; //1.3 获取用户输入的手机号 var tel = telInput.value.trim(); //1.4 判断手机号是否符合规则：长度 11 var flag = tel.length == 11; if (flag) &#123; //符合规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;&#x27;; &#125; return flag;&#125; 而 onsubmit 绑定的函数需要调用 checkUsername() 函数、checkPassword() 函数、checkTel() 函数。 1234567891011//1. 获取表单对象var regForm = document.getElementById(&quot;reg-form&quot;);//2. 绑定onsubmit 事件regForm.onsubmit = function () &#123; //挨个判断每一个表单项是否都符合要求，如果有一个不合符，则返回false var flag = checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkTel(); return flag;&#125; 八、RegExp对象RegExp 是正则对象。正则对象是判断指定字符串是否符合规则。在 js 中对正则表达式封装的对象就是正则对象。 正则对象使用 直接量方式：注意不要加引号 1var reg = /正则表达式/; 创建 RegExp 对象 1var reg = new RegExp(&quot;正则表达式&quot;); 函数：test(str) ：判断指定字符串是否符合规则，返回 true 或 false。 正则表达式正则表达式定义了字符串组成的规则。也就是判断指定的字符串是否符合指定的规则，如果符合返回 true，如果不符合返回 false。 正则表达式是和语言无关的。很多语言都支持正则表达式，Java 语言也支持，只不过正则表达式在不同的语言中的使用方式不同，js 中需要使用正则对象来使用正则表达式。 正则表达式常用的规则如下： ^：表示开始 $：表示结束 [ ]：代表某个范围内的单个字符，比如： [0-9] 单个数字字符 .：代表任意单个字符，除了换行和行结束符 \\w：代表单词字符：字母、数字、下划线(_)，相当于 [A-Za-z0-9_] \\d：代表数字字符： 相当于 [0-9] 量词： +：至少一个 *：零个或多个 ？：零个或一个 &#123;x&#125;：x个 &#123;m,&#125;：至少m个 &#123;m,n&#125;：至少m个，最多n个 12345678// 规则：单词字符，6~12//1,创建正则对象，对正则表达式进行封装var reg = /^\\w&#123;6,12&#125;$/;var str = &quot;abcccc&quot;;//2,判断 str 字符串是否符合 reg 封装的正则表达式的规则var flag = reg.test(str);alert(flag); 改进表单校验案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;欢迎注册&lt;/title&gt; &lt;link href=&quot;../css/register.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;form-div&quot;&gt; &lt;div class=&quot;reg-content&quot;&gt; &lt;h1&gt;欢迎注册&lt;/h1&gt; &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;form id=&quot;reg-form&quot; action=&quot;#&quot; method=&quot;get&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br&gt; &lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;用户名不太受欢迎&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;span id=&quot;password_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;密码格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号&lt;/td&gt; &lt;td class=&quot;inputs&quot;&gt;&lt;input name=&quot;tel&quot; type=&quot;text&quot; id=&quot;tel&quot;&gt; &lt;br&gt; &lt;span id=&quot;tel_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;手机号格式有误&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;input value=&quot;注 册&quot; type=&quot;submit&quot; id=&quot;reg_btn&quot;&gt; &lt;/div&gt; &lt;br class=&quot;clear&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt; //1. 验证用户名是否符合规则 //1.1 获取用户名的输入框 var usernameInput = document.getElementById(&quot;username&quot;); //1.2 绑定onblur事件 失去焦点 usernameInput.onblur = checkUsername; function checkUsername() &#123; //1.3 获取用户输入的用户名 var username = usernameInput.value.trim(); //1.4 判断用户名是否符合规则：长度 6~12,单词字符组成 var reg = /^\\w&#123;6,12&#125;$/; var flag = reg.test(username); //var flag = username.length &gt;= 6 &amp;&amp; username.length &lt;= 12; if (flag) &#123; //符合规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;username_err&quot;).style.display = &#x27;&#x27;; &#125; return flag; &#125; //1. 验证密码是否符合规则 //1.1 获取密码的输入框 var passwordInput = document.getElementById(&quot;password&quot;); //1.2 绑定onblur事件 失去焦点 passwordInput.onblur = checkPassword; function checkPassword() &#123; //1.3 获取用户输入的密码 var password = passwordInput.value.trim(); //1.4 判断密码是否符合规则：长度 6~12 var reg = /^\\w&#123;6,12&#125;$/; var flag = reg.test(password); //var flag = password.length &gt;= 6 &amp;&amp; password.length &lt;= 12; if (flag) &#123; //符合规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;password_err&quot;).style.display = &#x27;&#x27;; &#125; return flag; &#125; //1. 验证手机号是否符合规则 //1.1 获取手机号的输入框 var telInput = document.getElementById(&quot;tel&quot;); //1.2 绑定onblur事件 失去焦点 telInput.onblur = checkTel; function checkTel() &#123; //1.3 获取用户输入的手机号 var tel = telInput.value.trim(); //1.4 判断手机号是否符合规则：长度 11，数字组成，第一位是1 //var flag = tel.length == 11; var reg = /^[1]\\d&#123;10&#125;$/; var flag = reg.test(tel); if (flag) &#123; //符合规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;none&#x27;; &#125; else &#123; //不合符规则 document.getElementById(&quot;tel_err&quot;).style.display = &#x27;&#x27;; return flag; &#125; //1. 获取表单对象 var regForm = document.getElementById(&quot;reg-form&quot;); //2. 绑定onsubmit 事件 regForm.onsubmit = function () &#123; //挨个判断每一个表单项是否都符合要求，如果有一个不合符，则返回false var flag = checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkTel(); return flag; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.zhuangzhihao.top/tags/JavaScript/"}]},{"title":"HTML 和 CSS 基础知识总结","slug":"HTML和CSS基础","date":"2020-09-09T16:00:00.000Z","updated":"2022-05-23T10:38:00.709Z","comments":true,"path":"HTML和CSS基础/","link":"","permalink":"http://blog.zhuangzhihao.top/HTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80/","excerpt":"对于前端开发来说，最基本的知识肯定是HTML, CSS, JavaScript三剑客了。前端技术更新快，因此对于文档的阅读和实际操练十分重要，基础阶段一定要打好，才能向更高峰攀登。本篇笔记是对一些我认为的 HTML5 和 CSS3 相关常用知识的总结。至于想看最全和最权威文档的朋友还是移步 MDN web docs 吧。","text":"对于前端开发来说，最基本的知识肯定是HTML, CSS, JavaScript三剑客了。前端技术更新快，因此对于文档的阅读和实际操练十分重要，基础阶段一定要打好，才能向更高峰攀登。本篇笔记是对一些我认为的 HTML5 和 CSS3 相关常用知识的总结。至于想看最全和最权威文档的朋友还是移步 MDN web docs 吧。 一、HTMLHTML(HyperText Markup Language)：超文本标记语言。 超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容。 标记语言：由标签构成的语言。 XML就是标记语言，由一个一个的标签组成，HTML 也是由标签组成。HTML中的标签都是预定义好的，运行在浏览器上并由浏览器解析，然后展示出对应的效果。例如我们想在浏览器上展示出图片就需要使用预定义的 img 标签；想展示可以点击的链接的效果就可以使用预定义的 a 标签等。 W3C标准：W3C是万维网联盟，这个组成是用来定义标准的。他们规定了一个网页是由三部分组成，分别是： 结构：对应的是 HTML 语言 表现：对应的是 CSS 语言 行为：对应的是 JavaScript 语言 HTML定义页面的整体结构；CSS是用来美化页面，让页面看起来更加美观；JavaScript可以使网页动起来，比如轮播图也就是多张图片自动的进行切换等效果。 HTML 快速入门新建文本文件，后缀名改为 .html，编写 HTML 结构标签。 HTML 是由一个一个的标签组成的，但是它也用于表示结构的标签： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; html 标签是根标签，下面有 head 标签和 body 标签这两个子标签。而 head 标签的 title 子标签是用来定义页面标题名。 body 标签的内容会被展示在内容区中： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;html 快速入门&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 乾坤未定，你我皆是黑马~ &lt;/body&gt;&lt;/html&gt; 可以使用 font 标签更改字体颜色：该标签有一个 color 属性可以设置字体颜色，如：&lt;font color=&#39;red&#39;&gt;&lt;/font&gt; 就是将文字设置成了红颜色。那么我们只需要将需要变成红色的文字放在标签体部分就可以了。12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;html 快速入门&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;font color=&#x27;red&#x27;&gt;乾坤未定，你我皆是黑马~&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; HTML 语法松散：不区分大小写，HTML 标签属性值单双引皆可。 基础标签标题标签：创建页面文件，在 body 标签中书写标签。 书写标题标签：标题标签中 h1最大，h6最小。 123456&lt;h1&gt;我是标题 h1&lt;/h1&gt;&lt;h2&gt;我是标题 h2&lt;/h2&gt;&lt;h3&gt;我是标题 h3&lt;/h3&gt;&lt;h4&gt;我是标题 h4&lt;/h4&gt;&lt;h5&gt;我是标题 h5&lt;/h5&gt;&lt;h6&gt;我是标题 h6&lt;/h6&gt; hr标签：hr 标签在浏览器中呈现出 横线 的效果。 1&lt;hr&gt; font：字体标签（已不建议使用了，可以用 CSS 进行设置）。 face 属性：用来设置字体。如 “楷体”、”宋体”等。 color 属性：设置文字颜色。颜色有三种表示方式： 英文单词：red,pink,blue… rgb(值1,值2,值3)：值的取值范围：0~255 #值1值2值3：值的范围：00~FF size 属性：设置文字大小。 1&lt;font face=&quot;楷体&quot; size=&quot;5&quot; color=&quot;#ff0000&quot;&gt;传智教育&lt;/font&gt; 换行标签：&lt;br&gt; 标签。 段落标签： 123456&lt;p&gt;刚察草原绿草如茵，沙柳河水流淌入湖。藏族牧民索南才让家中，茶几上摆着馓子、麻花和水果，炉子上刚煮开的奶茶香气四溢……&lt;/p&gt;&lt;p&gt;6月8日下午，习近平总书记来到青海省海北藏族自治州刚察县沙柳河镇果洛藏贡麻村，走进牧民索南才让家中，看望慰问藏族群众。&lt;/p&gt; 加粗、斜体、下划线标签： b：加粗标签。 i：斜体标签。 u：下划线标签，在文字的下方有一条横线。 123&lt;b&gt;沙柳河水流淌&lt;/b&gt;&lt;br&gt;&lt;i&gt;沙柳河水流淌&lt;/i&gt;&lt;br&gt;&lt;u&gt;沙柳河水流淌&lt;/u&gt;&lt;br&gt; 居中标签 &lt;center&gt; ：文本居中。 1234&lt;hr&gt;&lt;center&gt; &lt;b&gt;沙柳河水流淌&lt;/b&gt;&lt;/center&gt; 图片、音频、视频标签&lt;img&gt;：定义图片 src：规定显示图像的 URL（统一资源定位符）。 height：定义图像的高度。 width：定义图像的宽度。 audio：定义音频。支持的音频格式：MP3、WAV、OGG 。 src：规定音频的 URL。 controls：显示播放控件。 &lt;video&gt;：定义视频。支持的音频格式：MP4, WebM、OGG。 src：规定视频的 URL。 controls：显示播放控件。 尺寸单位：height 属性和 width 属性有两种设置方式。 像素：单位是px。 百分比。占父标签的百分比。例如宽度设置为 50%，意思就是占它的父标签宽度的一般（50%）。 资源路径：图片，音频，视频标签都有 src 属性，而 src 是用来指定对应的图片，音频，视频文件的路径。 绝对路径：协议://ip地址:端口号/资源名称。 相对路径：相对位置关系。 123&lt;img src=&quot;../img/a.jpg&quot; width=&quot;300&quot; height=&quot;400&quot;&gt;&lt;audio src=&quot;b.mp3&quot; controls&gt;&lt;/audio&gt;&lt;video src=&quot;c.mp4&quot; controls width=&quot;500&quot; height=&quot;300&quot;&gt;&lt;/video&gt; 超链接标签在网页中可以看到很多超链接标签，超链接使用的是 a 标签。 href：指定访问资源的URL 。 target：指定打开资源的方式。 _self：默认值，在当前页面打开。 _blank：在空白页面打开。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;https://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我有惊喜&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 列表标签有序列表：&lt;ol&gt;。有序列表中的 type 属性用来指定标记的标号的类型（数字、字母、罗马数字等）。 无序列表：&lt;ul&gt;。无序列表中的 type 属性用来指定标记的形状。 列表项：&lt;li&gt;。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ol type=&quot;A&quot;&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;茶&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;/ol&gt; &lt;ul type=&quot;circle&quot;&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;茶&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 表格标签table ：定义表格。 border：规定表格边框的宽度。 width ：规定表格的宽度。 cellspacing：规定单元格之间的空白。 tr ：定义行。 align：定义表格行的内容对齐方式。 td ：定义单元格。 rowspan：规定单元格可横跨的行数。 colspan：规定单元格可横跨的列数。 th：定义表头单元格。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500&quot;&gt; &lt;tr&gt; &lt;th cospan=&quot;2&quot;&gt;品牌logo&lt;/th&gt; &lt;!--合并单元格--&gt; &lt;th&gt;品牌名称&lt;/th&gt; &lt;th&gt;企业名称&lt;/th&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;010&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;../img/三只松鼠.png&quot; width=&quot;60&quot; height=&quot;50&quot;&gt;&lt;/td&gt; &lt;td&gt;三只松鼠&lt;/td&gt; &lt;td&gt;三只松鼠&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;009&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;../img/优衣库.png&quot; width=&quot;60&quot; height=&quot;50&quot;&gt;&lt;/td&gt; &lt;td&gt;优衣库&lt;/td&gt; &lt;td&gt;优衣库&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;008&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;../img/小米.png&quot; width=&quot;60&quot; height=&quot;50&quot;&gt;&lt;/td&gt; &lt;td&gt;小米&lt;/td&gt; &lt;td&gt;小米科技有限公司&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 布局标签&lt;div&gt;：定义 HTML 文档中的一个区域部分，经常与 CSS 一起使用，用来布局网页。 &lt;span&gt;：用于组合行内元素。 div标签 在浏览器上会有换行的效果，而 span 标签在浏览器上没有换行效果。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;span&gt;我是span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 表单标签表单就是用来采集用户输入的数据，然后将数据发送到服务端，服务端会对数据库进行操作，比如注册就是将数据保存到数据库中，而登陆就是根据用户名和密码进行数据库的查询操作。 表单：在网页中主要负责数据采集功能，使用 &lt;form&gt; 标签定义表单。form 是表单标签，它在页面上没有任何展示的效果。需要借助于表单项标签来展示不同的效果。 表单项（元素）：不同类型的 input 元素、下拉列表、文本域等。 &lt;form&gt;：定义表单 &lt;input&gt;：定义表单项，通过 type属性控制输入形式 &lt;label&gt;：为表单项定义标注 &lt;select&gt;：定义下拉列表 &lt;option&gt;：定义下拉列表的列表项 &lt;textarea&gt;：定义文本域 form 标签属性action：规定当提交表单时向何处发送表单数据，该属性值就是 URL。action 会将数据提交到服务端，该属性需要书写服务端的 URL。可以书写 # ，表示提交到当前页面。 method ：规定用于发送表单数据的方式 get：默认值。如果不设置 method 属性则默认就是该值。请求参数会拼接在 URL 后边。url的长度有限制 4KB。 post：浏览器会将数据放到 http 请求消息体中。请求参数无限制的。 要想提交数据，input 输入框必须设置 name 属性。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 表单项标签&lt;input&gt;：表单项，通过type属性控制输入形式。 input 标签有个 type 属性。 type 属性的取值不同，展示的效果也不一样 text：默认值。定义单行的输入字段 password：定义密码字段 radio：定义单选按钮 checkbox：定义复选框 file：定义文件上传按钮 hidden：定义隐藏的输入字段 submit：定义提交按钮，提交按钮会把表单数据发送到服务器 reset：定义重置按钮，重置按钮会清除表单中的所有数据 button：定义可点击按钮 &lt;select&gt;：定义下拉列表，&lt;option&gt; 定义列表项。 &lt;textarea&gt;：文本域，它可以输入多行文本，而 input 数据框只能输入一行文本。 以上标签项的内容要想提交，必须得定义 name 属性。 每一个标签都有 id 属性，id 属性值是唯一的标识。 单选框、复选框、下拉列表需要使用 value 属性指定提交的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;123&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;br&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot;&gt;&lt;br&gt; 性别： &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; id=&quot;male&quot;&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;2&quot; id=&quot;female&quot;&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;br&gt; 爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt; 旅游 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt; 电影 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot;&gt; 游戏 &lt;br&gt; 头像： &lt;input type=&quot;file&quot;&gt;&lt;br&gt; 城市: &lt;select name=&quot;city&quot;&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;br&gt; 个人描述： &lt;textarea cols=&quot;20&quot; rows=&quot;5&quot; name=&quot;desc&quot;&gt;&lt;/textarea&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;一个按钮&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 二、CSSCSS 是一门语言，用于控制网页表现。CSS也有一个专业的名字：Cascading Style Sheet（层叠样式表）。 style 标签中定义的就是css代码。以下代码描述了将 div 标签的内容的字体颜色设置为 红色。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Hello CSS~&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css 导入方式css 导入方式其实就是 css 代码和 html 代码的结合方式。CSS 导入 HTML有三种方式： 内联样式：在标签内部使用style属性，属性值是css属性键值对。 1&lt;div style=&quot;color: red&quot;&gt;Hello CSS~&lt;/div&gt; 内部样式：定义 &lt;style&gt; 标签，在标签内部定义css样式。 12345&lt;style type=&quot;text/css&quot;&gt; div&#123; color: red; &#125;&lt;/style&gt; 外部样式：定义link标签，引入外部的css文件（编写一个css文件。名为：demo.css）。 123div&#123; color: red;&#125; 在html中引入 css 文件：&lt;link rel=&quot;stylesheet&quot; href=&quot;demo.css&quot;&gt;。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; span&#123; color: red; &#125; &lt;/style&gt; &lt;link href=&quot;../css/demo.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=&quot;color: red&quot;&gt;hello css&lt;/div&gt; &lt;span&gt;hello css &lt;/span&gt; &lt;p&gt;hello css&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; css 选择器css 选择器就是选取需设置样式的元素（标签）。 123div &#123; color:red;&#125; 元素选择器：元素名称&#123;color: red;&#125; 1div &#123;color:red&#125; /*该代码表示将页面中所有的div标签的内容的颜色设置为红色*/ id 选择器：#id属性值&#123;color: red;&#125; 1&lt;div id=&quot;name&quot;&gt;hello css2&lt;/div&gt; 1#name&#123;color: red;&#125; /*该代码表示将页面中所有的id属性值是 name 的标签的内容的颜色设置为红色*/ 类选择器：.class属性值&#123;color: red;&#125; 1&lt;div class=&quot;cls&quot;&gt;hello css3&lt;/div&gt; 1.cls&#123;color: red;&#125; /*该代码表示将页面中所有的class属性值是 cls 的标签的内容的颜色设置为红色*/ 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div&#123; color: red; &#125; #name&#123; color: blue; &#125; .cls&#123; color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div1&lt;/div&gt; &lt;div id=&quot;name&quot;&gt;div2&lt;/div&gt; &lt;div class=&quot;cls&quot;&gt;div3&lt;/div&gt; &lt;span class=&quot;cls&quot;&gt;span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; CSS 基本样式属性 属性 描述 background 简写属性，作用是将背景属性设置在一个声明中。 background-attachment 背景图像是否固定或者随着页面的其余部分滚动。 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 background-position 设置背景图像的起始位置。 background-repeat 设置背景图像是否及如何重复。 color 设置文本颜色 direction 设置文本方向。 line-height 设置行高。 letter-spacing 设置字符间距。 text-align 对齐元素中的文本。 text-decoration 向文本添加修饰。 text-indent 缩进元素中文本的首行。 text-shadow 设置文本阴影。CSS2 包含该属性，但是 CSS2.1 没有保留该属性。 text-transform 控制元素中的字母。 unicode-bidi 设置文本方向。 white-space 设置元素中空白的处理方式。 word-spacing 设置字间距。 font 简写属性。作用是把所有针对字体的属性设置在一个声明中。 font-family 设置字体系列。 font-size 设置字体的尺寸。 font-size-adjust 当首选字体不可用时，对替换字体进行智能缩放。（CSS2.1 已删除该属性。） font-style 设置字体风格。 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 设置字体的粗细。 list-style 简写属性。用于把所有用于列表的属性设置于一个声明中。 list-style-image 将图象设置为列表项标志。 list-style-position 设置列表中列表项标志的位置。 list-style-type 设置列表项标志的类型。 marker-offset border-collapse 设置是否把表格边框合并为单一的边框。 border-spacing 设置分隔单元格边框的距离。 caption-side 设置表格标题的位置。 empty-cells 设置是否显示表格中的空单元格。 table-layout 设置显示单元、行和列的算法。 outline 在一个声明中设置所有的轮廓属性。 outline-color 设置轮廓的颜色。 outline-style 设置轮廓的样式。 outline-width 设置轮廓的宽度。 CSS链接的四种状态： a:link &#123;&#125;- 普通的、未被访问的链接。 a:visited &#123;&#125;- 用户已访问的链接。 a:hover &#123;&#125;- 鼠标指针位于链接的上方。 a:active &#123;&#125;- 链接被点击的时刻。 CSS框模型：element : 元素，padding : 内边距，border : 边框，margin : 外边距。 CSS定位（position属性）： static：元素框正常生成。 relative：元素框偏移某个距离。 absolute：元素框从文档流完全删除，并相对于其包含块定位。 fixed：元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://blog.zhuangzhihao.top/tags/HTML/"}]},{"title":"MySQL 的安装和使用","slug":"MySQL安装使用","date":"2020-08-31T16:00:00.000Z","updated":"2022-05-23T10:34:28.068Z","comments":true,"path":"MySQL安装使用/","link":"","permalink":"http://blog.zhuangzhihao.top/MySQL%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"MySQL 是目前应用最广泛的开源关系数据库，在学习完 SQL 语言基础后，需要使用 MySQL 进行学习、开发、测试，部署，本篇笔记是对 MySQL 的安装和使用的记录，可供参考。 下载 https://downloads.mysql.com/archives/community/ 添加环境变量 在系统变量中新建 MYSQL_HOME 在系统变量中找到并双击 Path 新建 %MYSQL_HOME%\\bin 选择命令提示符(管理员)，敲入mysql，回车,如果提示 Can&#39;t connect to MySQL server on &#39;localhost&#39; 则证明添加成功 新建配置文件 新建一个文本文件，内容如下： 1234567[mysql]default-character-set=utf8[mysqld]character-set-server=utf8default-storage-engine=INNODBsql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 把上面的文本文件另存为 my.ini，存放的路径为 MySQL 的根目录 上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。 初始化1mysqld --initialize-insecure 如果出现没有出现报错信息，则证明 data 目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。 注册 MySQL 服务1mysqld -install 现在你的计算机上已经安装好了MySQL服务了 启动 MySQL 服务123net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 默认账户密码1mysqladmin -u root password 1234 这里的 1234 就是指默认管理员（root 账户）的密码 登录 MySQL1mysql -uroot -p1234 下角为mysql&gt;，则登录成功 退出 MySQL12exitquit 登陆参数1mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306) 卸载 MySQL123net stop mysqlmysqld -remove mysql 删除MySQL目录及相关的环境变量。","categories":[{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.zhuangzhihao.top/tags/MySQL/"}]},{"title":"C 语言基础知识总结","slug":"C语言基础","date":"2020-08-19T16:00:00.000Z","updated":"2022-05-23T02:30:41.963Z","comments":true,"path":"C语言基础/","link":"","permalink":"http://blog.zhuangzhihao.top/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","excerpt":"1972 年，为了移植与开发 UNIX 操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了 C 语言。C 语言是一种通用的、面向过程式的计算机程序设计语言，它与 Java 编程语言一样普及，二者在现代软件程序员之间都得到广泛使用。强烈推荐郝斌老师的C语言自学教程，在入门 C 语言时给了我很大的启发和帮助。","text":"1972 年，为了移植与开发 UNIX 操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了 C 语言。C 语言是一种通用的、面向过程式的计算机程序设计语言，它与 Java 编程语言一样普及，二者在现代软件程序员之间都得到广泛使用。强烈推荐郝斌老师的C语言自学教程，在入门 C 语言时给了我很大的启发和帮助。 C编程预备整数： int，short int，long int。 浮点数（实数）：float，double。 字符 ：char。 变量：本质就是内存中一段存储空间，变量必须的初始化。 定义变量： 数据类型变量名 = 要赋的值;。 常量的表示： 整数：十进制传统写法，十六进制前面加 Ox 或 0X，八进制前面加 0。 浮点数：float x = 3.2 or float x = 123.45e-2;。 字符：单个字符用单引号括起来，字符串用双引号括起来。 整数是以补码的形式转化为二进制代码存储在计算机中的。实数是以 IEEE754 标准转化为二进制代码存储在计算机中的。 字符的存储本质上与整数的存储方式相同。字符的本质实际也是与整数的存储方式相同。 字节就是存储数据的单位，并且是硬件所能访问的最小单位，1字节 = 8位。 不同类型数据之间相互赋值：(数据类型)(表达式)。 变量不能被重复定义。 输入和输出函数输入函数：printf(&quot;输出控制符&quot;, 输出参数);。 逻辑运算符：!= == &amp;&amp;。 输出控制符：%d, %ld, %c, %lf, %x, %o, %s。 输出函数：scanf(&quot;输入控制符&quot;, 输入参数);。 处理非法输入： 123char ch;while ( (ch=getchar0) != ’\\n’）continue; 流程控制流程控制：程序代码执行的顺序。流程控制的分类：顺序、选择、定义。 if 语句：if...else... C语言对真假的处理：非零是真，真用1表示，假用零表示。 else后不跟判断句。 switch：电梯程序。 循环：某些代码会被重复执行 for语句； 三目运算符 (A? B: C)； while语句：for 和 while 可以相互转换，但 for 的逻辑性更强，更不容易出错。 do...while：do…while…并不等价于 for，当然也不等价于 while，主要用于人机交互。 break 用来终止循环。 continue 用于跳过本次循环佘下的语句。 数组数组：为了解决大量同类型数据的存储和使用间题，为了模拟现实世界。 一维数组：为n个变量连续分配存储空间，所有的变量数据类型必须相同，所有变量所占的字节大小必须相等，int a[5];。一维数组名不代表数组中所有的元素，一维数组名代表数组第一个元素的地址。 二维数组，int a[3][4];总共是12个元素， 可以当做3行4列看待。a[i][j] 表示第 i+1 行第 j+1 列的元素。 int a[m][n];： 该二维数组右下角位置的元素只能是 a[m-l][n-l]。 C 语言中不存在多维数组，因为内存是线性一维的，n 维数组可以当做每个元素是 n-1 维数组的一维数组。 函数函数：避免了重复性操作，有利于程序的模块化。逻辑上：函数是能够完成特定功能的独立的代码块。物理上：函数能够接收数据，能够对接受的数据进行处理能够将数据处理的结果返回。函数返回值的类型也称为函数的类型。 定义函数：函数定义的本质是详细描述函数之所以能够实现某个特定功能。 return 表达式：终止被调函数， 向主调函数返回表达式的值。break 是用来终止循环和 switch 的， return 是用来终止函数的。 函数的分类： 有参函数和无参函数； 有返回值函数和无返回值函数； 库函数和用户自定函数； 值传递函数和地址传递函数； 普通函数和主函数（main 函数）。 一个程序必须有且只能有一个主函数。主函数可以调用普通函数普通函数不能调用主函数。普通函数可以相互调用。 主函数是程序的入口，也是程序的出口。 函数调用和函数定义的顺序如果函数调用写在了函数定义的前面， 则必须加函数前置声明。 函数是 C 语言的基本单位，类是 Java, C#, C++ 的基本单位。 常用的系统函数： double sqrt(double x);：求的 x 的平方根。 int abs(int x) or double fabs(double x)：求 x 的绝对值。 递归和栈。 变量的作用域和存储方式全局变量：在所有函数外部定义的变量叫全局变量。全局变量使用范围：从定义位置开始到整个程序结束。 局部变量：在一个函数内部定义的变量或者函数的形参都统称为局部变量。局部变量使用范围： 只能在本函数内部使用。 在一个函数内部如果定义的局部变量的名字和全局变量名一样时， 局部变量会屏蔽掉全局变量。 静态变量；自动变量；寄存器变量。 指针指针：表示一些复杂的数据结构，快速的传递数据，减少内存的耗用，使函数返回一个以上的值，能直接访问硬件，能够方便的处理字符串，是理解面向对象语言中引用的基础，是C语言的灵魂。 1typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型 地址：内存单元的编号，从零开始的非负整数，范围: 4G [0—4G-1]。指针就是地址， 地址就是指针。 指针变量就是存放内存单元编号的变量，或者说指针变量就是存放地址的变量。 指针和指针变量是两个不同的概念。指针的本质就是一个操作受限的非负整数。 基本类型指针：int * p;。 指针运算符：放在已经定义好的指针变量的前面。如果 P 是一个已经定义好的指针变量，则 *p 表示以 p 的内容为地址的变量。 如何通过被调函数修改主调函数普通变量的值： 实参必须为该普通变量的地址 形参必须为指针变量 在被调函数中通过 *形参名 = 的方式就可以修改主调函数相关变量的值。 指针和一维数组： 一维数组名 a[0] 是个指针常量，存放的是一维数组第一个元素的地址。 下标和指针的关系：如果 P 是个指针变量， 则 p[i] 永远等价于 *(P+i)。 确定一个一维数组需要两个参数：数组第一个元素的地址和数组的长度。 指针变量不能相加不能相乘也不能相除。如果两个指针变量指向的是同一块连续空间中的不同存储单元，则这两个指针变量才可以相减。 sizeof(数据类型)：返回值就是该数据类型所占的字节数。指针变量，无论它指向的变量占几个字节，该指针变量本身只占四个字节。 一个变量的地址是用该变量首字节的地址来表示。 指针和二维数组： 指针和函数； 指针和结构体； 多级指针。 动态内存分配传统数组也叫静态数组。 传统数组的缺点：数组长度必须事先制定，且只能是常整数，不能是变量，一旦定义， 其长度就不能在更改。传统数组的内存程序员无法手动释放，在一个函数运行期间，系统为该函数中数组所分配的空间会一直存在，直到该函数运行完毕时，数组的空间才会被系统释放。传统方式定义的数组不能跨函数使用。 int 类动态数组：int *p = (int *)malloc(int len);。本语句分配了两块内存， 一块内存是动态分配的，总共 len 个字节， 另一块是静态分配的，并且这块静态内存是P变量本身所占的内存， 总共 4 个字节。malloc 只有一个 int 型的形参，表示要求系统分配的字节数。 malloc 函数的功能是请求系统 len 个字节的内存空间， 如果请求分配成功，则返回第一个字节的地址， 如果分配不成功， 则返回 NULL。 malloc 函数能且只能返回第一个字节的地址， 所以我们需要把这个无任何实际意义的第一个字节的地址（俗称干地址）转化为一个有实际意义的地址，因此 malloc 前面必须加（数据类型 *)， 表示把这个无实际意义的第一个字节的地址转化为相应类型的地址。 int *p = (int *)malloc(50); 表示将系统分配好的 50 个字节的第一个字节的地址转化为 int * 型的地址。更准确的说是把第一个字节的地址转化为四个字节的地址，这样 P 就指向了第一个的四个字节，P+1 就指向了第2个的四个字节，p+i 就指向了第 i+1 个的4个字节。p[0] 就是第一个元素，p[i] 就是第 i+1 个元素。 free(p)表示把P所指向的内存给释放掉。 静态内存是由系统自动分配，由系统自动释放，静态内存是在栈分配的。动态内存是由程序员手动分配，手动释放，动态内存是在堆分配的。静态内存不可以跨函数使用。 函数 描述 void *calloc(int num, int size); 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。 void free(void *address); 释放 address 所指向的内存块,释放的是动态分配的内存空间。 void *malloc(int num); 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 void *realloc(void *address, int newsize); 重新分配内存，把内存扩展到 newsize。 结构体结构体：为了表示一些复杂的事物，而普通的基本类型无法满足实际要求，把一些基本类型数据组合在一起形成的一个新的复合数据类型，这个叫做结构体。 123456struct tag &#123; member-list member-list member-list ...&#125; variable-list ; 定义结构体：结构体变量定义的同时可以整体赋初值，如果定义完之后， 则只能单个的赋初值。 取出结构体变量中的每一个成员： 结构体变量名.成员名； 指针变量名-&gt;成员名。 使用结构体指针变量作为函数参数来传递。结构体变量不能相加减乘除，但结构体变量可以相互赋值。 共用体： 1234567union [union tag]&#123; member definition; member definition; ... member definition;&#125; [one or more union variables]; 位域声明： 1234struct&#123; type [member_name] : width ;&#125;; typedef： 1typedef unsigned char byte; 枚举和补码枚举：把一个事物所有可能的取值一一列举出来。 1enum 枚举名 &#123;枚举元素1,枚举元素2,……&#125;; 原码：也叫符号-绝对值码，最髙位 0 表示正，1表示负，其余二进制位是该数字的绝对值的二进制位。原码简单易懂，加减运算复杂，存在加减乘除四种运算，增加了CPU的复杂度，零的表示不唯一。 反码：反码运算不便，没有在计算机中应用。 移码：移码表示数值平移 n 位，n 称为移码量。移码主要用于浮点数的阶码的存储。 补码： 求正整数的二进制：除 2 取余，直至商为零，余数倒叙排序。 求负整数的二进制：先求与该负数相对应的正整数的二进制代码，然后将所有位取反，末尾加1，不够位数时， 左边补1。 零的二进制全是零。 如果首位是 0，表明是正整数， 按普通方法来求。 如果首位是 1， 则表明是负整数，将所有位取反，末尾加1，所得数字就是该负数的绝对值。 int 类型变量所能存储的最大正数用十六进制表示是：7FFFFFFF。 int 类型变量所能存储的绝对值最大的负整数用十六进制表示是：80000000。 链表算法：对存储数据的操作，对不同的存储结构，要完成某一个功能所执行的操作是不一样的。算法是依附于存储结构的，不同的存储结构， 所执行的算法是不一样的。广义的算法也叫泛型，无论数据是如何存储的，对该数据的操作都是一样的。 数组查找快，增删慢；链表查找慢，增删快，占位小。 首节点是存放第一个有效数据的节点。尾节点是存放最后一个有效数据的节点。头结点是首节点前面的那个节点。头结点的数据类型和首节点的类型是一摸一样的。头结点并不存放有效数据设置头结点的目的是为了方便对链表的操作。 确定一个链表需要一个参数：头指针，头指针是存放头结点地址的指针变量。 二进制全部为零的含义 —0000000000000 的含义： 数值零； 字符串结束标记符 \\0； 空指针 NULL。NULL 本质也是零，但这个零不代表数字零，而表示的是内存单元的编号零。以零为编号的存储单元的内容不可读，不可写。 位运算符： 按位与 &amp; ； 按位或 | ； 按位取反 ~ ； 按位异或 ^ ； 按位左移 &lt;&lt; ； 按位右移 &gt;&gt; 。 C 输入输出 标准文件 文件指针 设备 标准输入 stdin 键盘 标准输出 stdout 屏幕 标准错误 stderr 您的屏幕 getchar() &amp; putchar() 函数； gets() &amp; puts() 函数； scanf() 和 printf() 函数。 文件文件指针fp：fopen(文件名, 使用方式);、fclose(文件名, 使用方式);。 文件读取： fgets(str,n,fp)、fputs(str,fp)； fprintf(文件指针,格式字符串,输出表列)、fscanf(文件指针,格式字符串,输入表列)； fread(buffer,size,count,fp)、fwrite(buffer,size,count,fp)； ferror(fp);、clearerr(fp)。 fopen()函数原型： 1FILE *fopen( const char * filename, const char * mode ); C 预处理器（C Preprocessor）C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤，它们会指示编译器在实际编译之前完成所需的预处理。 所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。 指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else #if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器中 C 错误处理C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。 在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。 C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。 C 命令行参数执行程序时，可以从命令行传值给 C 程序，这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。 对命令行参数解析：12345678910111213141516171819202122232425262728293031323334353637int main(int argc, char *argv[])&#123; char *optstr = &quot;p:n:m:c:&quot;; struct option opts[] = &#123; &#123;&quot;path&quot;, 1, NULL, &#x27;p&#x27;&#125;, &#123;&quot;name&quot;, 1, NULL, &#x27;n&#x27;&#125;, &#123;&quot;mtime&quot;, 1, NULL, &#x27;m&#x27;&#125;, &#123;&quot;ctime&quot;, 1, NULL, &#x27;c&#x27;&#125;, &#123;0, 0, 0, 0&#125;, &#125;; int opt; while((opt = getopt_long(argc, argv, optstr, opts, NULL)) != -1)&#123; switch(opt) &#123; case &#x27;p&#x27;: strcpy(path, optarg); break; case &#x27;n&#x27;: strcpy(targetname, optarg); break; case &#x27;m&#x27;: modifiedtime = atoi(optarg); break; case &#x27;c&#x27;: changetime = atoi(optarg); break; case &#x27;?&#x27;: if(strchr(optstr, optopt) == NULL)&#123; fprintf(stderr, &quot;unknown option &#x27;-%c&#x27;\\n&quot;, optopt); &#125;else&#123; fprintf(stderr, &quot;option requires an argument &#x27;-%c&#x27;\\n&quot;, optopt); &#125; return 1; &#125; &#125; findInDir(path); return 0;&#125; C 库函数C 标准库是一组 C 内置函数、常量和头文件，比如 &lt;stdio.h&gt;、&lt;stdlib.h&gt;、&lt;math.h&gt;，等等。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://blog.zhuangzhihao.top/categories/C-C/"}],"tags":[]},{"title":"SQL 语法总结","slug":"SQL基础","date":"2020-07-25T16:00:00.000Z","updated":"2022-05-23T10:36:50.679Z","comments":true,"path":"SQL基础/","link":"","permalink":"http://blog.zhuangzhihao.top/SQL%E5%9F%BA%E7%A1%80/","excerpt":"现代程序离不开关系数据库，要使用关系数据库就必须掌握 SQL 语言。SQL 是用于访问和处理数据库的标准的计算机语言。常见的关系型数据库包括：MySQL、SQL Server、Access、Oracle、Sybase、DB2 等等，MySQL 是目前使用最多的 SQL 数据库，本文也是以 MySQL 的操作为例阐释 SQL 语法。","text":"现代程序离不开关系数据库，要使用关系数据库就必须掌握 SQL 语言。SQL 是用于访问和处理数据库的标准的计算机语言。常见的关系型数据库包括：MySQL、SQL Server、Access、Oracle、Sybase、DB2 等等，MySQL 是目前使用最多的 SQL 数据库，本文也是以 MySQL 的操作为例阐释 SQL 语法。 基本概念数据库术语数据库（database）：保存有组织的数据的容器（通常是一个文件或一组文件） 数据表（table）：某种特定类型数据的结构化清单 模式（schema）：关于数据库和表的布局及特性的信息 模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息 数据库和表都有模式 列（column）：表中的一个字段，所有表都是由一个或多个列组成的 行（row）：表中的一个记录 主键（primary key）：一列（或一组列），其值能够唯一标识表中每一行 SQL 语法SQL（Structured Query Language)：标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL SQL 让您可以访问和处理数据库，包括数据插入、查询、更新和删除 各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等 SQL 语法结构子句：是语句和查询的组成成分（在某些情况下，这些都是可选的） 表达式：可以产生任何标量值，或由列和行的数据库表 谓词：给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程 查询：基于特定条件检索数据，这是 SQL 的一个重要组成部分 语句：可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断 SQL 语法要点SQL 语句不区分大小写，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置 多条 SQL 语句必须以分号（;）分隔 处理 SQL 语句时，所有空格都被忽略，SQL 语句可以写成一行，也可以分写为多行 一行 SQL 语句： 1UPDATE user SET username=&#x27;robot&#x27;, password=&#x27;robot&#x27; WHERE username = &#x27;root&#x27;; 多行 SQL 语句 123UPDATE userSET username=&#x27;robot&#x27;, password=&#x27;robot&#x27;WHERE username = &#x27;root&#x27;; SQL 支持三种注释： 123##注释1-- 注释2/* 注释3 */ SQL 分类 数据定义语言（DDL） 数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言 DDL 的主要功能是定义数据库对象 DDL 的核心指令是 CREATE、ALTER、DROP 数据操纵语言（DML） 数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句 DML 的主要功能是 访问数据，因此其语法都是以读写数据库为主 DML 的核心指令是 INSERT、UPDATE、DELETE、SELECT，这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查 事务控制语言（TCL） 事务控制语言 (Transaction Control Language, TCL) 用于管理数据库中的事务 这些事务用于管理由 DML 语句所做的更改，它还允许将语句分组为逻辑事务 TCL 的核心指令是 COMMIT、ROLLBACK 数据控制语言（DCL） 数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权 DCL 的核心指令是 GRANT、REVOKE DCL 以控制用户的访问权限为主，因此其指令作法并不复杂 可利用 DCL 控制的权限有：CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES 根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同 增删改查 增删改查，又称为 CRUD，数据库基本操作中的基本操作插入数据 INSERT INTO 语句用于向表中插入新记录 插入完整的行 12INSERT INTO userVALUES (10, &#x27;root&#x27;, &#x27;root&#x27;, &#x27;xxxx@163.com&#x27;); 插入行的一部分 12INSERT INTO user(username, password, email)VALUES (&#x27;admin&#x27;, &#x27;admin&#x27;, &#x27;xxxx@163.com&#x27;); 插入查询出来的数据 123INSERT INTO user(username)SELECT nameFROM account; 更新数据 UPDATE 语句用于更新表中的记录 123UPDATE userSET username=&#x27;robot&#x27;, password=&#x27;robot&#x27;WHERE username = &#x27;root&#x27;; 删除数据 DELETE 语句用于删除表中的记录 1TRUNCATE TABLE ##可以清空表，也就是删除所有行 删除表中的指定数据 12DELETE FROM userWHERE username = &#x27;robot&#x27;; 清空表中的数据 1TRUNCATE TABLE user; 查询数据 SELECT 语句用于从数据库中查询数据 DISTINCT 用于返回唯一不同的值，它作用于所有列，也就是说所有列的值都相同才算相同 LIMIT 限制返回的行数，有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数 ASC ：升序（默认） DESC ：降序 查询单列 12SELECT prod_nameFROM products; 查询多列 12SELECT prod_id, prod_name, prod_priceFROM products; 查询所有列 12ELECT *FROM products; 查询不同的值 12SELECT DISTINCTvend_id FROM products; 限制查询结果 12345-- 返回前 5 行SELECT * FROM mytable LIMIT 5;SELECT * FROM mytable LIMIT 0, 5;-- 返回第 3 ~ 5 行SELECT * FROM mytable LIMIT 2, 3; 子查询 子查询是嵌套在较大查询中的 SQL 查询 子查询也称为内部查询或内部选择，而包含子查询的语句也称为外部查询或外部选择 子查询可以嵌套在 SELECT，INSERT，UPDATE 或 DELETE 语句内或另一个子查询中 子查询通常会在另一个 SELECT 语句的 WHERE 子句中添加 您可以使用比较运算符，如 &gt;，&lt;，或 =，比较运算符也可以是多行运算符，如 IN，ANY 或 ALL 子查询必须被 () 括起来 内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询 子查询的子查询 1234567SELECT cust_name, cust_contactFROM customersWHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &#x27;RGAN01&#x27;)); WHERE WHERE 子句用于过滤记录，即缩小访问数据的范围 WHERE 后跟一个返回 true 或 false 的条件 WHERE 可以与 SELECT，UPDATE 和 DELETE 一起使用 WHERE 子句中使用的操作符 | 运算符 | 描述 || ————- | ———————————————————————————— || = | 等于 || &lt;&gt; | 不等于，注释：在 SQL 的一些版本中，该操作符可被写成 != || &gt; | 大于 || &lt; | 小于 || &gt;= | 大于等于 || &lt;= | 小于等于 || BETWEEN | 在某个范围内 || LIKE | 搜索某种模式 || IN | 指定针对某个列的多个可能值 | SELECT 语句中的 WHERE 子句 12SELECT * FROM CustomersWHERE cust_name = &#x27;Kids Place&#x27;; UPDATE 语句中的 WHERE 子句 123UPDATE CustomersSET cust_name = &#x27;Jack Jones&#x27;WHERE cust_name = &#x27;Kids Place&#x27;; DELETE 语句中的 WHERE 子句 12DELETE FROM CustomersWHERE cust_name = &#x27;Kids Place&#x27;; IN 和 BETWEEN IN 操作符在 WHERE 子句中使用，作用是在指定的几个特定值中任选一个值 123SELECT *FROM productsWHERE vend_id IN (&#x27;DLL01&#x27;, &#x27;BRS01&#x27;); BETWEEN 操作符在 WHERE 子句中使用，作用是选取介于某个范围内的值 123SELECT *FROM productsWHERE prod_price BETWEEN 3 AND 5; AND、OR、NOT AND、OR、NOT 是用于对过滤条件的逻辑处理指令 AND 优先级高于 OR，为了明确处理顺序，可以使用 () AND 操作符表示左右条件都要满足 123SELECT prod_id, prod_name, prod_priceFROM productsWHERE vend_id = &#x27;DLL01&#x27; AND prod_price &lt;= 4; OR 操作符表示左右条件满足任意一个即可 123SELECT prod_id, prod_name, prod_priceFROM productsWHERE vend_id = &#x27;DLL01&#x27; OR vend_id = &#x27;BRS01&#x27;; NOT 操作符用于否定一个条件 123SELECT *FROM productsWHERE prod_price NOT BETWEEN 3 AND 5; LIKE LIKE 操作符在 WHERE 子句中使用，作用是确定字符串是否匹配模式 只有字段是文本值时才使用 LIKE LIKE 支持两个通配符匹配选项：% 和 _ 不要滥用通配符，通配符位于开头处匹配会非常慢 % 表示任何字符出现任意次数 123SELECT prod_id, prod_name, prod_priceFROM productsWHERE prod_name LIKE &#x27;%bean bag%&#x27;; _ 表示任何字符出现一次 123SELECT prod_id, prod_name, prod_priceFROM productsWHERE prod_name LIKE &#x27;__ inch teddy bear&#x27;; 连接和组合连接（JOIN） 如果一个 JOIN 至少有一个公共字段并且它们之间存在关系，则该 JOIN 可以在两个或多个表上工作 连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE JOIN 保持基表（结构和数据）不变 JOIN 有两种连接类型：内连接和外连接 内连接又称等值连接，使用 INNER JOIN 关键字，在没有条件语句的情况下返回笛卡尔积 123SELECT vend_name, prod_name, prod_priceFROM vendors INNER JOIN productsON vendors.vend_id = products.vend_id; 自连接可以看成内连接的一种，只是连接的表是自身而已 123SELECT c1.cust_id, c1.cust_name, c1.cust_contactFROM customers c1, customers c2WHERE c1.cust_name = c2.cust_nameAND c2.cust_contact = &#x27;Jim Jones&#x27;; 自然连接（NATURAL JOIN）是把同名列通过 = 测试连接起来的，同名列可以有多个 123SELECT *FROM ProductsNATURAL JOIN Customers; 左外连接（LEFT JOIN）就是保留左表没有关联的行 123SELECT customers.cust_id, orders.order_numFROM customers LEFT JOIN ordersON customers.cust_id = orders.cust_id; 右外连接（RIGHT JOIN）就是保留右表没有关联的行 123SELECT customers.cust_id, orders.order_numFROM customers RIGHT JOIN ordersON customers.cust_id = orders.cust_id; 内连接 vs 自然连接 内连接提供连接的列，而自然连接自动连接所有同名列 外连接返回一个表中的所有行，并且仅返回来自次表中满足连接条件的那些行，即两个表中的列是相等的 外连接分为左外连接、右外连接、全外连接（Mysql 不支持） 连接 vs 子查询：连接可以替换子查询，并且比子查询的效率一般会更快 组合（UNION） UNION 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 UNION 中参与查询的提取行 UNION 基本规则 所有查询的列数和列顺序必须相同 每个查询中涉及表的列的数据类型必须相同或兼容 通常返回的列名取自第一个查询 默认会去除相同行，如果需要保留相同行，使用 UNION ALL 只能包含一个 ORDER BY 子句，并且必须位于语句的最后 UNION 应用场景 在一个查询中从不同的表返回结构数据 对一个表执行多个查询，按一个查询返回数据 组合查询 1234567SELECT cust_name, cust_contact, cust_emailFROM customersWHERE cust_state IN (&#x27;IL&#x27;, &#x27;IN&#x27;, &#x27;MI&#x27;)UNIONSELECT cust_name, cust_contact, cust_emailFROM customersWHERE cust_name = &#x27;Fun4All&#x27;; JOIN vs UNION JOIN 中连接表的列可能不同，但在 UNION 中，所有查询的列数和列顺序必须相同 UNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积 函数文本处理 函数 说明 LEFT()、RIGHT() 左边或者右边的字符 LOWER()、UPPER() 转换为小写或者大写 LTRIM()、RTIM() 去除左边或者右边的空格 LENGTH() 长度 SOUNDEX() 转换为语音值 SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式 123SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX(&#x27;apple&#x27;) 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS | 函 数 | 说 明 || ———————- | ——————————————— || AddDate() | 增加一个日期（天、周等） || AddTime() | 增加一个时间（时、分等） || CurDate() | 返回当前日期 || CurTime() | 返回当前时间 || Date() | 返回日期时间的日期部分 || DateDiff() | 计算两个日期之差 || Date_Add() | 高度灵活的日期运算函数 || Date_Format() | 返回一个格式化的日期或时间串 || Day() | 返回一个日期的天数部分 || DayOfWeek() | 对于一个日期，返回对应的星期几 || Hour() | 返回一个时间的小时部分 || Minute() | 返回一个时间的分钟部分 || Month() | 返回一个日期的月份部分 || Now() | 返回当前日期和时间 || Second() | 返回一个时间的秒部分 || Time() | 返回一个日期时间的时间部分 || Year() | 返回一个日期的年份部分 | 12mysql&gt; SELECT NOW();2020-11-14 20:11:11 数值处理 | 函数 | 说明 || ———— | ——— || SIN() | 正弦 || COS() | 余弦 || TAN() | 正切 || ABS() | 绝对值 || SQRT() | 平方根 || MOD() | 余数 || EXP() | 指数 || PI() | 圆周率 || RAND() | 随机数 | 汇总 | 函 数 | 说 明 || ————- | ———————— || AVG() | 返回某列的平均值 || COUNT() | 返回某列的行数 || MAX() | 返回某列的最大值 || MIN() | 返回某列的最小值 || SUM() | 返回某列值之和 || AVG() | 会忽略 NULL 行 | 使用 DISTINCT 可以让汇总函数值汇总不同的值 12SELECT AVG(DISTINCT col1) AS avg_colFROM mytable 排序和分组ORDER BY ORDER BY 用于对结果集进行排序 ASC ：升序（默认） DESC ：降序 ORDER BY 可以按多个列进行排序，并且为每个列指定不同的排序方式 ORDER BY 指定多个列的排序方向 12SELECT * FROM productsORDER BY prod_price DESC, prod_name ASC; GROUP BY GROUP BY 子句将记录分组到汇总行中 GROUP BY 为每个组返回一个记录 GROUP BY 通常还涉及聚合：COUNT，MAX，SUM，AVG 等 GROUP BY 可以按一列或多列进行分组 GROUP BY 按分组字段进行排序后，ORDER BY 可以以汇总字段来进行排序 分组 12SELECT cust_name, COUNT(cust_address) AS addr_numFROM Customers GROUP BY cust_name; 分组后排序 123SELECT cust_name, COUNT(cust_address) AS addr_numFROM Customers GROUP BY cust_nameORDER BY cust_name DESC; HAVING HAVING 用于对汇总的 GROUP BY 结果进行过滤 HAVING 要求存在一个 GROUP BY 子句 WHERE 和 HAVING 可以在相同的查询中 HAVING vs WHERE WHERE 和 HAVING 都是用于过滤 HAVING 适用于汇总的组记录；而 WHERE 适用于单个记录 使用 WHERE 和 HAVING 过滤数据 12345SELECT cust_name, COUNT(*) AS numFROM CustomersWHERE cust_email IS NOT NULLGROUP BY cust_nameHAVING COUNT(*) &gt;= 1; 数据定义（ DDL 语句用法） DDL 的主要功能是定义数据库对象，如数据库、数据表、视图、索引等 数据库（DATABASE） 创建数据库 1CREATE DATABASE test; 删除数据库 1DROP DATABASE test; 选择数据库 1USE test; 数据表（TABLE） 创建数据表 普通创建 123456CREATE TABLE user ( id int(10) unsigned NOT NULL COMMENT &#x27;Id&#x27;, username varchar(64) NOT NULL DEFAULT &#x27;default&#x27; COMMENT &#x27;用户名&#x27;, password varchar(64) NOT NULL DEFAULT &#x27;default&#x27; COMMENT &#x27;密码&#x27;, email varchar(64) NOT NULL DEFAULT &#x27;default&#x27; COMMENT &#x27;邮箱&#x27;) COMMENT=&#x27;用户表&#x27;; 根据已有的表创建新表 12CREATE TABLE vip_user ASSELECT * FROM user; 删除数据表 1DROP TABLE user; 修改数据表 添加列 12ALTER TABLE userADD age int(3); 删除列 12ALTER TABLE userDROP COLUMN age; 修改列 12ALTER TABLE `user`MODIFY COLUMN age tinyint; 添加主键 12ALTER TABLE userADD PRIMARY KEY (id); 删除主键 12ALTER TABLE userDROP PRIMARY KEY; 视图（VIEW） 视图是基于 SQL 语句的结果集的可视化的表 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作 对视图的操作和对普通表的操作一样 视图的作用：简化复杂的 SQL 操作，比如复杂的联结；只使用实际表的一部分数据；通过只给用户访问视图的权限，保证数据的安全性；更改数据格式和表示 创建视图 1234CREATE VIEW top_10_user_view ASSELECT id, usernameFROM userWHERE id &lt; 10; 删除视图 1DROP VIEW top_10_user_view; 索引（INDEX） 通过索引可以更加快速高效地查询数据 用户无法看到索引，它们只能被用来加速查询 注意：更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新，因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引 唯一索引表明此索引的每一个索引值只对应唯一的数据记录 创建索引 12CREATE INDEX user_indexON user (id); 创建唯一索引 12CREATE UNIQUE INDEX user_indexON user (id); 删除索引 12ALTER TABLE userDROP INDEX user_index; 约束 SQL 约束用于规定表中的数据规则 如果存在违反约束的数据行为，行为会被约束终止 约束可以在创建表时规定（通过 CREATE TABLE 语句）或者在表创建之后规定（通过 ALTER TABLE 语句） 约束类型 NOT NULL：指示某列不能存储 NULL 值 UNIQUE：保证某列的每行必须有唯一的值 PRIMARY KEY：NOT NULL 和 UNIQUE 的结合 确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录 FOREIGN KEY：保证一个表中的数据匹配另一个表中的值的参照完整性 CHECK：保证列中的值符合指定的条件 DEFAULT：规定没有给列赋值时的默认值 创建表时使用约束条件： 12345678CREATE TABLE Users ( Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#x27;自增Id&#x27;, Username VARCHAR(64) NOT NULL UNIQUE DEFAULT &#x27;default&#x27; COMMENT &#x27;用户名&#x27;, Password VARCHAR(64) NOT NULL DEFAULT &#x27;default&#x27; COMMENT &#x27;密码&#x27;, Email VARCHAR(64) NOT NULL DEFAULT &#x27;default&#x27; COMMENT &#x27;邮箱地址&#x27;, Enabled TINYINT(4) DEFAULT NULL COMMENT &#x27;是否有效&#x27;, PRIMARY KEY (Id)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;; 事务处理（ TCL 语句用法） 不能回退 SELECT 语句，也不能回退 CREATE 和 DROP 语句 MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交，当出现 START TRANSACTION 语句时，会关闭隐式提交 当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交 通过 set autocommit=0 可以取消自动提交，直到 set autocommit=1 才会提交 autocommit 标记是针对每个连接而不是针对服务器的 START TRANSACTION 指令用于标记事务的起始点，开始事务 1START TRANSACTION; AINSERT INTO user 插入操作 1VALUES (1, &#x27;root1&#x27;, &#x27;root1&#x27;, &#x27;xxxx@163.com&#x27;); SAVEPOINT 指令用于创建保留点 updateA 1SAVEPOINT updateA; 插入操作 B 12INSERT INTO `user`VALUES (2, &#x27;root2&#x27;, &#x27;root2&#x27;, &#x27;xxxx@163.com&#x27;); ROLLBACK TO 指令用于回滚到指定的保留点 updateA；如果没有设置保留点，则回退到 START TRANSACTION 语句处 1ROLLBACK TO updateA; 提交事务，只有操作 A 生效 1COMMIT; 权限控制 GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL 整个数据库，使用 ON database.* 特定的表，使用 ON database.table 特定的列 特定的存储过程 新创建的账户没有任何权限 账户用 username@host 的形式定义，username@% 使用的是默认主机名 MySQL 的账户信息保存在 mysql 这个数据库中 12USE mysql;SELECT user FROM user; 复制代码 创建账户 1CREATE USER myuser IDENTIFIED BY &#x27;mypassword&#x27;; 修改账户名 12UPDATE user SET user=&#x27;newuser&#x27; WHERE user=&#x27;myuser&#x27;;FLUSH PRIVILEGES; 删除账户 1DROP USER myuser; 查看权限 1SHOW GRANTS FOR myuser; 授予权限 1GRANT SELECT, INSERT ON *.* TO myuser; 删除权限 1REVOKE SELECT, INSERT ON *.* FROM myuser; 更改密码 1SET PASSWORD FOR myuser = &#x27;mypass&#x27;; 存储过程 存储过程可以看成是对一系列 SQL 操作的批处理 使用存储过程的好处：代码封装，保证了一定的安全性；代码复用；由于是预先编译，因此具有很高的性能 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误 给变量赋值都需要用 select into 语句 每次只能给一个变量赋值，不支持集合的操作 创建存储过程，包含 in、out 和 inout 三种参数 12345678910111213DROP PROCEDURE IF EXISTS `proc_adder`;DELIMITER ;;CREATE DEFINER=`root`@`localhost` PROCEDURE `proc_adder`(IN a int, IN b int, OUT sum int)BEGIN DECLARE c int; if a is null then set a = 0; end if;if b is null then set b = 0;end if;set sum = a + b;END;;DELIMITER ; 使用存储过程 123set @b=5;call proc_adder(2,@b,@s);select @s as sum; 游标 游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集 在存储过程中使用游标可以对一个结果集进行移动遍历 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据 打开游标 取出数据 关闭游标 1234567891011121314151617181920212223242526DELIMITER $CREATE PROCEDURE getTotal()BEGIN DECLARE total INT; -- 创建接收游标数据的变量 DECLARE sid INT; DECLARE sname VARCHAR(10); -- 创建总数变量 DECLARE sage INT; -- 创建结束标志变量 DECLARE done INT DEFAULT false; -- 创建游标 DECLARE cur CURSOR FOR SELECT id,name,age from cursor_table where age&gt;30; -- 指定游标循环结束时的返回值 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true; SET total = 0; OPEN cur; FETCH cur INTO sid, sname, sage; WHILE(NOT done) DO SET total = total + 1; FETCH cur INTO sid, sname, sage; END WHILE; CLOSE cur; SELECT total;END $DELIMITER ; 调用存储过程 1call getTotal(); 触发器 触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行 可以使用触发器来进行审计跟踪，把修改记录到另外一张表中 MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程 BEGIN 和 END 当触发器的触发条件满足时，将会执行 BEGIN 和 END 之间的触发器执行动作 注意：在 MySQL 中，分号 ; 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了，因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END 这时就会用到 DELIMITER 命令（DELIMITER 是分隔符的意思），不需要语句结束标识 DELIMITER new_delemiter new_delemiter 可以设为 1 个或多个长度的符号，默认的是 ; 我们可以把;修改为其他符号，如 - DELIMITER 在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 $，才认为是语句结束 注意，使用完之后，我们还应该记得把它给修改回来 NEW 和 OLD MySQL 中定义了 NEW 和 OLD 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据 在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据 在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据 在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据 使用方法： NEW.columnName （columnName 为相应数据表某一列名） CREATE TRIGGER 指令用于创建触发器 12345678CREATE TRIGGER trigger_nametrigger_timetrigger_eventON table_nameFOR EACH ROWBEGIN trigger_statementsEND; trigger_name：触发器名 trigger_time: 触发器的触发时机，取值为 BEFORE 或 AFTER trigger_event: 触发器的监听事件，取值为 INSERT、UPDATE 或 DELETE table_name: 触发器的监听目标，指定在哪张表上建立触发器 FOR EACH ROW: 行级监视，Mysql 固定写法，与其他 DBMS 不同 trigger_statements: 触发器执行动作，是一条或多条 SQL 语句的列表，列表内的每条语句都必须用 ; 来结尾 12345678910111213DELIMITER $CREATE TRIGGER `trigger_insert_user`AFTER INSERT ON `user`FOR EACH ROWBEGIN INSERT INTO `user_history`(user_id, operate_type, operate_time) VALUES (NEW.id, &#x27;add a user&#x27;, now());END $DELIMITER ;查看触发器SHOW TRIGGERS;删除触发器DROP TRIGGER IF EXISTS trigger_insert_user;","categories":[{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.zhuangzhihao.top/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.zhuangzhihao.top/tags/MySQL/"}]},{"title":"Creative Thinking：Techniques and Tools for Success","slug":"Creative-Thinking-for-Success","date":"2020-07-09T16:00:00.000Z","updated":"2022-05-23T09:44:48.186Z","comments":true,"path":"Creative-Thinking-for-Success/","link":"","permalink":"http://blog.zhuangzhihao.top/Creative-Thinking-for-Success/","excerpt":"The greatest innovators aren’t necessarily the people who have the most original idea. Often, they are people- or teams- that have harnessed their creativity to develop a new perspective or more effective way of communicating an idea. You can train your imagination to seize opportunities, break away from routine and habit, and tap into your natural creativity. This course provided by IMPERIAL COLLEGE LONDON equips us with a tool-box, introducing us to a selection of behaviors and techniques that augments our innate creativity.","text":"The greatest innovators aren’t necessarily the people who have the most original idea. Often, they are people- or teams- that have harnessed their creativity to develop a new perspective or more effective way of communicating an idea. You can train your imagination to seize opportunities, break away from routine and habit, and tap into your natural creativity. This course provided by IMPERIAL COLLEGE LONDON equips us with a tool-box, introducing us to a selection of behaviors and techniques that augments our innate creativity. 1. Principle of CreativityNecessity is the mother of invention. Opportunity is the father of invention. Creativity is imagination with responsibility. Creativity is the ability to imagine or invent something new of value. Levels of Creativity: Big C vs Little C, Eminent vs Everyday. The value of patronage: The Renaissance → Industrial Revolution → Neuroscience → Data and AI Creative Environments: Create a low stress environment with reassurance and high trust. Relaxation aids production and realization of ideas are also important. 2. Creativity ToolsCreativity Tools to Enhance: Fluency, Flexibility, Originality. Various Types of Brainstorming Techniques: Flipchart, Post-its, Brainwriting, Alphabet, Grid, Circle brainstorming. Morphological Analysis: A creative tool that helps generate ideas that would not normally spring to mind. Generic morphological analysis chart. Subsystems and Means. Explore the design space systematically or experimentally. Sketching synthesises the subsystems. Small variation in selection = Substantial difference in outcome. The sub-functions and potential means of fulfilling each of these sub-functions can be arranged in a grid. Morphological Analysis applied to Plot Line. Six Thinking Hats: The Value of Diversity. The six thinking hat technique aids and augments creativity. White Hat (facts, figures, information) Red Hat (intuition, gut reaction, emotion) Black Hat (critically, cautiously, defensively) Yellow Hat (optimistic viewpoint) Green Hat (creativity) Blue Hat (control and organization) TRIZ: Theory of intensive problem solving Invented by Genrich Altshuller Specific Problem —Abstraction-&gt; General Problem -&gt; General Solutions —Analogy-&gt; Solution to Specific Problem 39 Parameters 40 principles The concept of contradiction Scamper Substitute Combine Adapt Magnify/ Minify/ Modify Put to other uses Eliminate Reverse/ Rearrange Using the Tools in Combination The Double Diamond Model Circle Brainstorming","categories":[{"name":"慕课MOOC","slug":"慕课MOOC","permalink":"http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"}],"tags":[]},{"title":"Marketing Analytics","slug":"Marketing-Analytics","date":"2020-06-21T16:00:00.000Z","updated":"2022-05-05T09:10:17.923Z","comments":true,"path":"Marketing-Analytics/","link":"","permalink":"http://blog.zhuangzhihao.top/Marketing-Analytics/","excerpt":"Marketing analytics enables marketers to measure, manage and analyze marketing performance to maximize its effectiveness and optimize return on investment (ROI). Beyond the obvious sales and lead generation applications, offers profound insights into customer preferences and trends, which can be further utilized for future marketing and business decisions. The Marketing Analytics course is provided by UNIVERSITY OF VIRGINIA.","text":"Marketing analytics enables marketers to measure, manage and analyze marketing performance to maximize its effectiveness and optimize return on investment (ROI). Beyond the obvious sales and lead generation applications, offers profound insights into customer preferences and trends, which can be further utilized for future marketing and business decisions. The Marketing Analytics course is provided by UNIVERSITY OF VIRGINIA. 1. Marketing AnalyticsDescriptive analytics Predictive analytics Prescriptive analytics 2. Marketing ProcessObjectives: Customer, Company, Competitor, Collaborators, Context Strategy: Segmentation, Targeting, Positioning Tactics: Product, Price, Place, Promotion Financials: Margin, ROI, CLV 3. Marketing Strategy with DataMental models Text analytics 4. Brand ArchitectureBrand value Brand personality: Sincerity / Excitement / Competence / Sophistication / Ruggedness Brand Architecture Brand core / Essence Brand personality Emotional benefits Product benefits Product attributes 5. Calculating Brand ValueInterbrand brand valuation model Financial analysis -&gt; Residual earnings -&gt; Brand earnings Marketing analysis -&gt; Role of branding -&gt; Brand earnings Brand analysis -&gt; Brand strength score -&gt; Risk rate Y &amp;R brand asset valuator Brand strength (Strength / Vatality) -&gt; Differentiation &amp; Relevance Brand stature (Emotional capital) -&gt; Esteem &amp; Knowledge Brand equity: long term estimate Revenue Premium Equity = Annual revenue premium * (1 + discount rate) / (1 + discount rate - stability factor) Annual revenue premium = Revenue premium - Additional variable cost 6. Customer Lifetime Value (CLV)Both backward looking and forward looking Net present value (NPV) CLV = (Gross margin - Detention spending) * (1 + discount rate) / (1+discount rate - retention rate) Cohort and incubators 7. Experimental DesignCorrelation and causation / Causality Marketing return on investment Test group &amp; Control group / Randomization Experiments assess cause and effect 8. Calculating Break Even and LiftFull factorial design Projrcting lift Pitfalls of marketing experiments Maximizing effectiveness Experiments provide forecasts of expected ROI 9. Regression BasicsRegression analysis Regression outputs (about intuition) R-squared (sales/promotion) P-value (lower than 10% is trustable) Multivariable regressions Omitted variable bias: price -&gt; Units sold + feature / display 10. Price ElasticityPED = (Change in Sales / Change in Price) * (Price / Sales) Coefficient * Average price/ Average sales Measures the impact of a change in price on sales Enhances your ability to utilize regressions Allows you to track marketing efforts over time 11. Log-Log ModelsLOG = Percentage Change 12. Marketing Mix ModelStatistical significance &amp; Economic significance Product line Place Price Promotion","categories":[{"name":"慕课MOOC","slug":"慕课MOOC","permalink":"http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"}],"tags":[]},{"title":"Managing Machine Learning Projects with Google Cloud","slug":"Managing-Machine-Learning-Projects","date":"2020-06-07T16:00:00.000Z","updated":"2022-05-05T12:32:01.758Z","comments":true,"path":"Managing-Machine-Learning-Projects/","link":"","permalink":"http://blog.zhuangzhihao.top/Managing-Machine-Learning-Projects/","excerpt":"This course provided by GOOGLE CLOUD is intended to be an introduction to machine learning for business professionals. It teaches me how to translate business problems into machine learning use cases and vet them for feasibility and impact.","text":"This course provided by GOOGLE CLOUD is intended to be an introduction to machine learning for business professionals. It teaches me how to translate business problems into machine learning use cases and vet them for feasibility and impact. 1. What is Machine Learning ?ML is a way to use standard algorithms to derive predictive insights from data and make repeated decisions. Phases of ML Collecting data. Labeling data. Training using chosen metrics and objectives. Evaluate a model. Deploy a model. 2. Good data characteristic Has coverage. Is clean. Is complete. 3. ML vs AIML is a type of Artificial intelligence. Logic vs Machine Learning. Neural networks &amp; Deep learning. Use AI responsibly —- responsible AI = successful AI. 4. Why ML now ? Increasing availability of data. Increasing maturity and sophistication of ML algorithms. Increasing power and availability of computing hardware and software. 5. Labeling dataLabel is the true answer for a given input. Regression vs Classification. Every example needs to have features and a label. Ways to label your data: Use a proxy label. Build a labeling system. Use a labeling service. 6. Modeling TrainingContinuous training keeps models fresh. https://github.com/tensorflow. Formulating the ML problem Choosing input features. Get labels. Choose an objective. 7. Modeling EvaluationTest data (20%) Confusion matrices measure performance relative to expectations for classification. 8. ML Best Practices ML involves experimentation. start simple. Don’t use your test data during experimentation. Do pilot projects with end-users. 9. Human Bias in MLDecisions made as you do ML have real world impact for you and your customers. Unconscious biases exist in data. Fairness in ML. 10. Discovering ML Use CasesSimplifying rule-based systems. Streaming business processes. Understanding unstructured data. Personalizing experiences: Adds significant value to users. Recommender systems. ML in Series. 11. Data StrategyML is about repeated decisions: Design a system so that you will have more data next year. Break down data silos. Transition from data lakes to data warehouses. Learn about your data. Integrate pilots into your tools. Run ML models on real-time data to extract the most value. Collect more data. 12. Data GovernanceData access must be balanced against security. Three goals for ML and Privacy: Identify sensitive data. Protect sensitive data by removing, masking or coarsening. Create public governance documentation. Types of sensitive data: Specific columns in structured datasets. Patterned text, e.g., credit card numbers. Unstructured data, like audio, video and images. Combination of fields. Common principles for establishing a policy framework: Establish a secure location for documentation. Exclude sensitive information from documentation. Document all sources and processes. Establish a process to review and enforce policies. Build your ML team: Data engineers. ML engineers. Data analysts. 13. Create a Culture of InnovationStarts with a dedicated mindset. Focus on the user. 10X thinking. Launch and iterate. Change is inevitable.","categories":[{"name":"慕课MOOC","slug":"慕课MOOC","permalink":"http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"}],"tags":[]},{"title":"使用 Python 程序画画","slug":"Python画画","date":"2020-05-31T16:00:00.000Z","updated":"2022-05-05T13:06:21.722Z","comments":true,"path":"Python画画/","link":"","permalink":"http://blog.zhuangzhihao.top/Python%E7%94%BB%E7%94%BB/","excerpt":"turtle 库是 Python 的标准库之一，属于入门级的图形绘制函数库，其原理是让一只海龟在画布上游走，走过的轨迹形成了绘制的图形，海龟由程序控制，可以自由改变颜色、方向宽度等。我们也可以依赖这个库完成一些简单的画画，以下为一些经典图像的代码实现笔记，可供参考。","text":"turtle 库是 Python 的标准库之一，属于入门级的图形绘制函数库，其原理是让一只海龟在画布上游走，走过的轨迹形成了绘制的图形，海龟由程序控制，可以自由改变颜色、方向宽度等。我们也可以依赖这个库完成一些简单的画画，以下为一些经典图像的代码实现笔记，可供参考。 turtle 简介123456789101112131415161718192021222324import turtle# 设置窗体大小turtle.setup(width,height,startx,starty) #后两个参数非必选参数#turtle的移动turtle.goto(x,y)#画圆turtle.circle(r,angle)#当前距离后退turtle.bk(d)#当前距离前进turtle.fd(d) #turtle.forward(d)#改变海龟行进方向，angle为绝对角度turtle.seth(angle) #只改变呢方向不行进#向左右前进turtle.right(angle)turtle.left(angle)#抬起画笔turtle.pu() #turtle.penup()#画笔落下turtle.pd() #turtle.pendown()#画笔宽度turtle.width(width) #turtle.pensize(width)#画笔颜色turtle.pencolor(color):color 画笑脸123456789101112131415161718192021222324252627282930313233343536import turtle as fucksisudef eye(col, rad): fucksisu.down() fucksisu.fillcolor(col) fucksisu.begin_fill() fucksisu.circle(rad) fucksisu.end_fill() fucksisu.up()fucksisu.fillcolor(&#x27;yellow&#x27;)fucksisu.begin_fill()fucksisu.circle(100)fucksisu.end_fill()fucksisu.up()fucksisu.goto(-40, 120)eye(&#x27;white&#x27;, 15)fucksisu.goto(-37, 125)eye(&#x27;black&#x27;, 5)fucksisu.goto(40, 120)eye(&#x27;white&#x27;, 15)fucksisu.goto(40, 125)eye(&#x27;black&#x27;, 5)fucksisu.goto(0, 75)eye(&#x27;black&#x27;, 8)fucksisu.goto(-40, 85)fucksisu.down()fucksisu.right(90)fucksisu.circle(40, 180)fucksisu.up()fucksisu.goto(-10, 45)fucksisu.down()fucksisu.right(180)fucksisu.fillcolor(&#x27;red&#x27;)fucksisu.begin_fill()fucksisu.circle(10, 180)fucksisu.end_fill()fucksisu.hideturtle() 画柱状图1234567891011121314151617181920212223242526272829303132333435import turtleturtle.title(&quot;柱状图名称&quot;)heights = [834, 620,460,260,105]def main(): t = turtle.Turtle() t.hideturtle() for i in range(5): drawFilledRectangle(t,-200+(76*i),0,76,heights[i]/4,&quot;black&quot;,&quot;light blue&quot;) displayText(t)def drawFilledRectangle(t,x,y,w,h,colorP=&quot;black&quot;,colorF=&quot;white&quot;): t.pencolor(colorP) t.fillcolor(colorF) t.up() t.goto(x,y) t.down() t.begin_fill() t.goto(x+w,y) t.goto(x+w,y+h) t.goto(x,y+h) t.goto(x,y) t.end_fill()def displayText(t): languages = [&quot;柱状图1&quot;, &quot;柱状图2&quot;, &quot;柱状图3&quot;, &quot;柱状图4&quot;, &quot;柱状图5&quot;] t.pencolor(&quot;blue&quot;) t.up() for i in range(5): t.goto((-162+76*i),heights[i] / 4) t.write(str(heights[i]),align=&quot;center&quot;,font=(&quot;Arial&quot;,10,&quot;normal&quot;)) t.goto((-162+76*i),10) t.write(languages[i],align=&quot;center&quot;,font=(&quot;Arial&quot;,10,&quot;normal&quot;)) t.goto(-200,-25) t.write(&quot;柱状图1名称&quot;,font=(&quot;Arial&quot;,10,&quot;normal&quot;)) t.goto(-200,-45) t.write(&#x27;(柱状图1注解)&#x27;,font=(&quot;Arial&quot;,10,&quot;normal&quot;))main() 画皮卡丘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454import turtledef sisuisrubbishl(x, y): turtle.setx(x) turtle.sety(y) print(x, y)class Cartoon: def __init__(self): self.t = turtle.Turtle() t = self.t t.pensize(3) t.speed(9) t.ondrag(sisuisrubbishl) def meme(self, x, y): self.t.penup() self.t.goto(x, y) self.t.pendown() def ihatesisu1(self, x, y): self.meme(x, y) t = self.t t.seth(0) t.fillcolor(&#x27;#333333&#x27;) t.begin_fill() t.circle(22) t.end_fill() self.meme(x, y + 10) t.fillcolor(&#x27;#000000&#x27;) t.begin_fill() t.circle(10) t.end_fill() self.meme(x + 6, y + 22) t.fillcolor(&#x27;#ffffff&#x27;) t.begin_fill() t.circle(10) t.end_fill() def ihatesisu2(self, x, y): self.meme(x, y) t = self.t t.seth(0) t.fillcolor(&#x27;#333333&#x27;) t.begin_fill() t.circle(22) t.end_fill() self.meme(x, y + 10) t.fillcolor(&#x27;#000000&#x27;) t.begin_fill() t.circle(10) t.end_fill() self.meme(x - 6, y + 22) t.fillcolor(&#x27;#ffffff&#x27;) t.begin_fill() t.circle(10) t.end_fill() def fucksisu(self, x, y): self.meme(x, y) t = self.t t.fillcolor(&#x27;#88141D&#x27;) t.begin_fill() l1 = [] l2 = [] t.seth(190) a = 0.7 for i in range(28): a += 0.1 t.right(3) t.fd(a) l1.append(t.position()) self.meme(x, y) t.seth(10) a = 0.7 for i in range(28): a += 0.1 t.left(3) t.fd(a) l2.append(t.position()) t.seth(10) t.circle(50, 15) t.left(180) t.circle(-50, 15) t.circle(-50, 40) t.seth(233) t.circle(-50, 55) t.left(180) t.circle(50, 12.1) t.end_fill() self.meme(17, 54) t.fillcolor(&#x27;#DD716F&#x27;) t.begin_fill() t.seth(145) t.circle(40, 86) t.penup() for pos in reversed(l1[:20]): t.goto(pos[0], pos[1] + 1.5) for pos in l2[:20]: t.goto(pos[0], pos[1] + 1.5) t.pendown() t.end_fill() self.meme(-17, 94) t.seth(8) t.fd(4) t.back(8) def fucksisu4(self, x, y): turtle.tracer(False) t = self.t self.meme(x, y) t.seth(300) t.fillcolor(&#x27;#DD4D28&#x27;) t.begin_fill() a = 2.3 for i in range(120): if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90: a -= 0.05 t.lt(3) t.fd(a) else: a += 0.05 t.lt(3) t.fd(a) t.end_fill() turtle.tracer(True) def fucksisu5(self, x, y): t = self.t turtle.tracer(False) self.meme(x, y) t.seth(60) t.fillcolor(&#x27;#DD4D28&#x27;) t.begin_fill() a = 2.3 for i in range(120): if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90: a -= 0.05 t.lt(3) t.fd(a) else: a += 0.05 t.lt(3) t.fd(a) t.end_fill() turtle.tracer(True) def fucksisu6(self, x, y): t = self.t self.meme(x, y) t.fillcolor(&#x27;#000000&#x27;) t.begin_fill() t.seth(330) t.circle(100, 35) t.seth(219) t.circle(-300, 19) t.seth(110) t.circle(-30, 50) t.circle(-300, 10) t.end_fill() def fucksisu7(self, x, y): t = self.t self.meme(x, y) t.fillcolor(&#x27;#000000&#x27;) t.begin_fill() t.seth(300) t.circle(-100, 30) t.seth(35) t.circle(300, 15) t.circle(30, 50) t.seth(190) t.circle(300, 17) t.end_fill() def fucksisu8(self): t = self.t t.fillcolor(&#x27;#F6D02F&#x27;) t.begin_fill() t.penup() t.circle(130, 40) t.pendown() t.circle(100, 105) t.left(180) t.circle(-100, 5) t.seth(20) t.circle(300, 30) t.circle(30, 50) t.seth(190) t.circle(300, 36) t.seth(150) t.circle(150, 70) t.seth(200) t.circle(300, 40) t.circle(30, 50) t.seth(20) t.circle(300, 35) t.seth(240) t.circle(105, 95) t.left(180) t.circle(-105, 5) t.seth(210) t.circle(500, 18) t.seth(200) t.fd(10) t.seth(280) t.fd(7) t.seth(210) t.fd(10) t.seth(300) t.circle(10, 80) t.seth(220) t.fd(10) t.seth(300) t.circle(10, 80) t.seth(240) t.fd(12) t.seth(0) t.fd(13) t.seth(240) t.circle(10, 70) t.seth(10) t.circle(10, 70) t.seth(10) t.circle(300, 18) t.seth(75) t.circle(500, 8) t.left(180) t.circle(-500, 15) t.seth(250) t.circle(100, 65) t.seth(320) t.circle(100, 5) t.left(180) t.circle(-100, 5) t.seth(220) t.circle(200, 20) t.circle(20, 70) t.seth(60) t.circle(-100, 20) t.left(180) t.circle(100, 20) t.seth(300) t.circle(10, 70) t.seth(60) t.circle(-100, 20) t.left(180) t.circle(100, 20) t.seth(10) t.circle(100, 60) t.seth(180) t.circle(-100, 10) t.left(180) t.circle(100, 10) t.seth(5) t.circle(100, 10) t.circle(-100, 40) t.circle(100, 35) t.left(180) t.circle(-100, 10) t.seth(290) t.circle(100, 55) t.circle(10, 50) t.seth(120) t.circle(100, 20) t.left(180) t.circle(-100, 20) t.seth(0) t.circle(10, 50) t.seth(110) t.circle(100, 20) t.left(180) t.circle(-100, 20) t.seth(30) t.circle(20, 50) t.seth(100) t.circle(100, 40) t.seth(200) t.circle(-100, 5) t.left(180) t.circle(100, 5) t.left(30) t.circle(100, 75) t.right(15) t.circle(-300, 21) t.left(180) t.circle(300, 3) t.seth(43) t.circle(200, 60) t.right(10) t.fd(10) t.circle(5, 160) t.seth(90) t.circle(5, 160) t.seth(90) t.fd(10) t.seth(90) t.circle(5, 180) t.fd(10) t.left(180) t.left(20) t.fd(10) t.circle(5, 170) t.fd(10) t.seth(240) t.circle(50, 30) t.end_fill() self.meme(130, 125) t.seth(-20) t.fd(5) t.circle(-5, 160) t.fd(5) self.meme(166, 130) t.seth(-90) t.fd(3) t.circle(-4, 180) t.fd(3) t.seth(-90) t.fd(3) t.circle(-4, 180) t.fd(3) self.meme(168, 134) t.fillcolor(&#x27;#F6D02F&#x27;) t.begin_fill() t.seth(40) t.fd(200) t.seth(-80) t.fd(150) t.seth(210) t.fd(150) t.left(90) t.fd(100) t.right(95) t.fd(100) t.left(110) t.fd(70) t.right(110) t.fd(80) t.left(110) t.fd(30) t.right(110) t.fd(32) t.right(106) t.circle(100, 25) t.right(15) t.circle(-300, 2) ############## t.seth(30) t.fd(40) t.left(100) t.fd(70) t.right(100) t.fd(80) t.left(100) t.fd(46) t.seth(66) t.circle(200, 38) t.right(10) t.fd(10) t.end_fill() t.fillcolor(&#x27;#923E24&#x27;) self.meme(126.82, -156.84) t.begin_fill() t.seth(30) t.fd(40) t.left(100) t.fd(40) t.pencolor(&#x27;#923e24&#x27;) t.seth(-30) t.fd(30) t.left(140) t.fd(20) t.right(150) t.fd(20) t.left(150) t.fd(20) t.right(150) t.fd(20) t.left(130) t.fd(18) t.pencolor(&#x27;#000000&#x27;) t.seth(-45) t.fd(67) t.right(110) t.fd(80) t.left(110) t.fd(30) t.right(110) t.fd(32) t.right(106) t.circle(100, 25) t.right(15) t.circle(-300, 2) t.end_fill() self.fucksisu9(-134.07, 147.81) self.fucksisu(-5, 25) self.fucksisu4(-126, 32) self.fucksisu5(107, 63) self.fucksisu6(-250, 100) self.fucksisu7(140, 270) self.ihatesisu1(-85, 90) self.ihatesisu2(50, 110) t.hideturtle() def fucksisu9(self, x, y): self.meme(x, y) t = self.t t.fillcolor(&#x27;#CD0000&#x27;) t.begin_fill() t.seth(200) t.circle(400, 7) t.left(180) t.circle(-400, 30) t.circle(30, 60) t.fd(50) t.circle(30, 45) t.fd(60) t.left(5) t.circle(30, 70) t.right(20) t.circle(200, 70) t.circle(30, 60) t.fd(70) t.right(35) t.fd(50) t.circle(8, 100) t.end_fill() self.meme(-168.47, 185.52) t.seth(36) t.circle(-270, 54) t.left(180) t.circle(270, 27) t.circle(-80, 98) t.fillcolor(&#x27;#444444&#x27;) t.begin_fill() t.left(180) t.circle(80, 197) t.left(58) t.circle(200, 45) t.end_fill() self.meme(-58, 270) t.pencolor(&#x27;#228B22&#x27;) t.dot(35) self.meme(-30, 280) t.fillcolor(&#x27;#228B22&#x27;) t.begin_fill() t.seth(100) t.circle(30, 180) t.seth(190) t.fd(15) t.seth(100) t.circle(-45, 180) t.right(90) t.fd(15) t.end_fill() t.pencolor(&#x27;#000000&#x27;) def start(self): self.fucksisu8()def main(): turtle.screensize(800, 600) turtle.title(&#x27;皮卡丘&#x27;) cartoon = Cartoon() cartoon.start() turtle.mainloop()if __name__ == &#x27;__main__&#x27;: main() 画哆啦A梦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247import turtlefrom turtle import *turtle.title(&quot;哆啦A梦&quot;)def fucksisu1(x, y): penup() goto(x, y) pendown()def fucksisu2(): fillcolor(&quot;#ffffff&quot;) begin_fill() tracer(False) a = 2.5 for i in range(120): if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90: a -= 0.05 lt(3) fd(a) else: a += 0.05 lt(3) fd(a) tracer(True) end_fill()def fucksisu3(): fucksisu1(-32, 135) seth(165) fd(60) fucksisu1(-32, 125) seth(180) fd(60) fucksisu1(-32, 115) seth(193) fd(60) fucksisu1(37, 135) seth(15) fd(60) fucksisu1(37, 125) seth(0) fd(60) fucksisu1(37, 115) seth(-13) fd(60)def fucksisu4(): fucksisu1(5, 148) seth(270) fd(100) seth(0) circle(120, 50) seth(230) circle(-120, 100)def fucksisu5(): fillcolor(&#x27;#e70010&#x27;) begin_fill() seth(0) fd(200) circle(-5, 90) fd(10) circle(-5, 90) fd(207) circle(-5, 90) fd(10) circle(-5, 90) end_fill()def fucksisu6(): fucksisu1(-10, 158) seth(315) fillcolor(&#x27;#e70010&#x27;) begin_fill() circle(20) end_fill()def black_fucksisu2(): seth(0) fucksisu1(-20, 195) fillcolor(&#x27;#000000&#x27;) begin_fill() circle(13) end_fill() pensize(6) fucksisu1(20, 205) seth(75) circle(-10, 150) pensize(3) fucksisu1(-17, 200) seth(0) fillcolor(&#x27;#ffffff&#x27;) begin_fill() circle(5) end_fill() fucksisu1(0, 0)def face(): fd(183) lt(45) fillcolor(&#x27;#ffffff&#x27;) begin_fill() circle(120, 100) seth(180) fd(121) pendown() seth(215) circle(120, 100) end_fill() fucksisu1(63.56, 218.24) seth(90) fucksisu2() seth(180) penup() fd(60) pendown() seth(90) fucksisu2() penup() seth(180) fd(64)def fucksisu7(): penup() circle(150, 40) pendown() fillcolor(&#x27;#00a0de&#x27;) begin_fill() circle(150, 280) end_fill()def fucksisu8(): fucksisu7() fucksisu5() face() fucksisu6() fucksisu4() fucksisu3() fucksisu1(0, 0) seth(0) penup() circle(150, 50) pendown() seth(30) fd(40) seth(70) circle(-30, 270) fillcolor(&#x27;#00a0de&#x27;) begin_fill() seth(230) fd(80) seth(90) circle(1000, 1) seth(-89) circle(-1000, 10) seth(180) fd(70) seth(90) circle(30, 180) seth(180) fd(70) seth(100) circle(-1000, 9) seth(-86) circle(1000, 2) seth(230) fd(40) circle(-30, 230) seth(45) fd(81) seth(0) fd(203) circle(5, 90) fd(10) circle(5, 90) fd(7) seth(40) circle(150, 10) seth(30) fd(40) end_fill() seth(70) fillcolor(&#x27;#ffffff&#x27;) begin_fill() circle(-30) end_fill() fucksisu1(103.74, -182.59) seth(0) fillcolor(&#x27;#ffffff&#x27;) begin_fill() fd(15) circle(-15, 180) fd(90) circle(-15, 180) fd(10) end_fill() fucksisu1(-96.26, -182.59) seth(180) fillcolor(&#x27;#ffffff&#x27;) begin_fill() fd(15) circle(15, 180) fd(90) circle(15, 180) fd(10) end_fill() fucksisu1(-133.97, -91.81) seth(50) fillcolor(&#x27;#ffffff&#x27;) begin_fill() circle(30) end_fill() fucksisu1(-103.42, 15.09) seth(0) fd(38) seth(230) begin_fill() circle(90, 260) end_fill() fucksisu1(5, -40) seth(0) fd(70) seth(-90) circle(-70, 180) seth(0) fd(70) fucksisu1(-103.42, 15.09) fd(90) seth(70) fillcolor(&#x27;#ffd200&#x27;) begin_fill() circle(-20) end_fill() seth(170) fillcolor(&#x27;#ffd200&#x27;) begin_fill() circle(-2, 180) seth(10) circle(-100, 22) circle(-2, 180) seth(180 - 10) circle(100, 22) end_fill() goto(-13.42, 15.09) seth(250) circle(20, 110) seth(90) fd(15) dot(10) fucksisu1(0, -150) black_fucksisu2()if __name__ == &#x27;__main__&#x27;: screensize(800, 600, &quot;#f0f0f0&quot;) pensize(3) speed(9) fucksisu8() mainloop() 钢铁侠123456789101112131415161718192021222324252627282930313233343536373839import turtlefucksisu1 = [[(-40, 120), (-70, 260), (-130, 230), (-170, 200), (-170, 100), (-160, 40), (-170, 10), (-150, -10), (-140, 10), (-40, -20), (0, -20)], [(0, -20), (40, -20), (140, 10), (150, -10), (170, 10), (160, 40), (170, 100), (170, 200), (130, 230), (70, 260), (40, 120), (0, 120)]]fucksisu2 = [[(-40, -30), (-50, -40), (-100, -46), (-130, -40), (-176, 0), (-186, -30), (-186, -40), (-120, -170), (-110, -210), (-80, -230), (-64, -210), (0, -210)], [(0, -210), (64, -210), (80, -230), (110, -210), (120, -170), (186, -40), (186, -30), (176, 0), (130, -40), (100, -46), (50, -40), (40, -30), (0, -30)]]fucksisu3 = [[(-60, -220), (-80, -240), (-110, -220), (-120, -250), (-90, -280), (-60, -260), (-30, -260), (-20, -250), (0, -250)], [(0, -250), (20, -250), (30, -260), (60, -260), (90, -280), (120, -250), (110, -220), (80, -240), (60, -220), (0, -220)]]turtle.hideturtle()turtle.bgcolor(&#x27;#ba161e&#x27;) # Dark Redturtle.setup(500, 600)turtle.title(&quot;钢铁侠&quot;)fucksisu1Goto = (0, 120)fucksisu2Goto = (0, -30)fucksisu3Goto = (0, -220)turtle.speed(2)def logo(a, b): turtle.penup() turtle.goto(b) turtle.pendown() turtle.color(&#x27;#fab104&#x27;) # Light Yellow turtle.begin_fill() for i in range(len(a[0])): x, y = a[0][i] turtle.goto(x, y) for i in range(len(a[1])): x, y = a[1][i] turtle.goto(x, y) turtle.end_fill()logo(fucksisu1, fucksisu1Goto)logo(fucksisu2, fucksisu2Goto)logo(fucksisu3, fucksisu3Goto)turtle.hideturtle()turtle.done() 蝙蝠侠123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import turtleimport mathturtle.title(&quot;蝙蝠侠&quot;)fucksisu1 = turtle.Turtle()fucksisu1.speed(500)window = turtle.Screen()window.bgcolor(&quot;#000000&quot;)fucksisu1.color(&quot;yellow&quot;)fucksisu2 = 20fucksisu1.left(90)fucksisu1.penup()fucksisu1.goto(-7 * fucksisu2, 0)fucksisu1.pendown()for a in range(-7 * fucksisu2, -3 * fucksisu2, 1): x = a / fucksisu2 rel = math.fabs(x) y = 1.5 * math.sqrt((-math.fabs(rel - 1)) * math.fabs(3 - rel) / ((rel - 1) * (3 - rel))) * ( 1 + math.fabs(rel - 3) / (rel - 3)) * math.sqrt(1 - (x / 7) ** 2) + ( 4.5 + 0.75 * (math.fabs(x - 0.5) + math.fabs(x + 0.5)) - 2.75 * ( math.fabs(x - 0.75) + math.fabs(x + 0.75))) * (1 + math.fabs(1 - rel) / (1 - rel)) fucksisu1.goto(a, y * fucksisu2)for a in range(-3 * fucksisu2, -1 * fucksisu2 - 1, 1): x = a / fucksisu2 rel = math.fabs(x) y = (2.71052 + 1.5 - 0.5 * rel - 1.35526 * math.sqrt(4 - (rel - 1) ** 2)) * math.sqrt( math.fabs(rel - 1) / (rel - 1)) fucksisu1.goto(a, y * fucksisu2)fucksisu1.goto(-1 * fucksisu2, 3 * fucksisu2)fucksisu1.goto(int(-0.5 * fucksisu2), int(2.2 * fucksisu2))fucksisu1.goto(int(0.5 * fucksisu2), int(2.2 * fucksisu2))fucksisu1.goto(1 * fucksisu2, 3 * fucksisu2)for a in range(1 * fucksisu2 + 1, 3 * fucksisu2 + 1, 1): x = a / fucksisu2 rel = math.fabs(x) y = (2.71052 + 1.5 - 0.5 * rel - 1.35526 * math.sqrt(4 - (rel - 1) ** 2)) * math.sqrt( math.fabs(rel - 1) / (rel - 1)) fucksisu1.goto(a, y * fucksisu2)for a in range(3 * fucksisu2 + 1, 7 * fucksisu2 + 1, 1): x = a / fucksisu2 rel = math.fabs(x) y = 1.5 * math.sqrt((-math.fabs(rel - 1)) * math.fabs(3 - rel) / ((rel - 1) * (3 - rel))) * ( 1 + math.fabs(rel - 3) / (rel - 3)) * math.sqrt(1 - (x / 7) ** 2) + ( 4.5 + 0.75 * (math.fabs(x - 0.5) + math.fabs(x + 0.5)) - 2.75 * ( math.fabs(x - 0.75) + math.fabs(x + 0.75))) * (1 + math.fabs(1 - rel) / (1 - rel)) fucksisu1.goto(a, y * fucksisu2)for a in range(7 * fucksisu2, 4 * fucksisu2, -1): x = a / fucksisu2 rel = math.fabs(x) y = (-3) * math.sqrt(1 - (x / 7) ** 2) * math.sqrt(math.fabs(rel - 4) / (rel - 4)) fucksisu1.goto(a, y * fucksisu2)for a in range(4 * fucksisu2, -4 * fucksisu2, -1): x = a / fucksisu2 rel = math.fabs(x) y = math.fabs(x / 2) - 0.0913722 * x ** 2 - 3 + math.sqrt(1 - (math.fabs(rel - 2) - 1) ** 2) fucksisu1.goto(a, y * fucksisu2)for a in range(-4 * fucksisu2 - 1, -7 * fucksisu2 - 1, -1): x = a / fucksisu2 rel = math.fabs(x) y = (-3) * math.sqrt(1 - (x / 7) ** 2) * math.sqrt(math.fabs(rel - 4) / (rel - 4)) fucksisu1.goto(a, y * fucksisu2)fucksisu1.penup()fucksisu1.goto(300, 300)turtle.done()","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.zhuangzhihao.top/categories/Python/"}],"tags":[]},{"title":"Data Science Math Skills","slug":"Data-Science-Math-Skills","date":"2020-05-24T16:00:00.000Z","updated":"2022-05-05T12:45:29.974Z","comments":true,"path":"Data-Science-Math-Skills/","link":"","permalink":"http://blog.zhuangzhihao.top/Data-Science-Math-Skills/","excerpt":"Data Science Math Skills course provided by DUKE UNIVERSITY is designed to teach the vocabulary, notation, concepts, and algebra rules that all data scientists must know before moving on to more advanced material. The following are the notes I took during this course.","text":"Data Science Math Skills course provided by DUKE UNIVERSITY is designed to teach the vocabulary, notation, concepts, and algebra rules that all data scientists must know before moving on to more advanced material. The following are the notes I took during this course. SetsWhat is a set? A set is made up of elements. Cardinality The cardinality (size) of a set is the number of elements in it. $|A| = 4$ (there are 4 elements in A, so the cardinality is 4) Intersections The intersection is defined as elements that are in both sets. Symbol $∩$: “intersects” (and) $A ∩ B = {x : x ∈ A and x ∈ B}$ If there are no elements in common, the answer is the empty set ∅. The cardinality of the empty set $|∅| = 0$ Unions The union is defined as elements that are in either set. Symbol ∪: “union” (or) $A ∪ B = {x ∈ A or x ∈ B}$ Visualizing sets Venn diagrams Inclusion-exclusion formula Inclusion-exclusion formula: $|A ∪ B| = |A| + |B| − |A ∩ B|$ NumbersIntegers and rational numbers Some real numbers terminate, and some do not. The number π = 3.14159… is irrational, it does not repeat after the decimal point. Absolute value The absolute value of a number x, |x|, is the distance from x to 0. Intervals and Interval Notation Closed intervals $[2, 3.1]$ Open intervals $(5, 8)$ Half-open intervals $(2, 3], [20, 20.3)$ Sigma NotationSigma notation (Σ) distributive property: $a(b + c) = ab + ac$ commutative property: $a + b = b + a$ Cartesian PlaneAxes and quadrants X−axis Y−axis first quadrant second quadrant third quadrant fourth quadrant Pythagorean theoremDerivation using point-slope formSlope-intercept form If L has slope m, and hits the y-axis at (0, b), then y = mx + b is an equation for L, where m is the slope and b is the y-intercept. Point-Slope Formula for Lines $y-y{0}=m\\left( x-x{0}\\right)$ Point-slope form $y=mx+b$ Slope-intercept form Functions f : A → B Tangent LinesThe Slope of a Graph at a Point The slope of the tangent line gives the instantaneous rate of change. This is also called the derivative of the function at that point, or f(a). The Derivative Function Derivative formula: $\\lim _{n\\rightarrow 0}\\dfrac{f\\left( a+h\\right) -f\\left( a\\right) }{h}$ Fast Growth, Slow GrowthInteger Exponents Multiplication rule: $x^{n}x^{m}=x^{m+n}$ Power to a power: $x^{n^{m}}=x^{nm}$ Product to a power: $\\left( x\\cdot y\\right) ^{n}=x^{n}\\cdot y^{n}$ Fraction to a power: $\\left( \\dfrac{x}{y}\\right) ^{n}=\\dfrac{x^{n}}{y^{n}}$ Division and negative powers How Logarithms and Exponents Are Related $b^{x}=N$ “exponential form” $x=\\log _{b}N$ “logarithmic form” Product rule: $\\log(xy) = \\log(x) + \\log(y)$ Quotient rule: $\\log ( \\dfrac{x}{y}) = \\log(x) − \\log(y)$ Power and root rule: $\\log \\left( x^{n}\\right) =nlog\\left( x\\right)$ Basic Probability Definitions probability—the degree of belief in the truth or falsity of a statement Range of uncertainty from 0 to 1 P(x) probability of x ∼x negation of statement x joint probability—probability that two separate events with separate probability distributions are both true. P(A and B) is written P(A, B), and read “the joint probability of A and B” or “the probability that A is true and B is true.” Problem Solving MethodsPermutations and Combinations permutation—order matters, $\\dfrac{n!}{\\left( n-m\\right) !}$ combination—order does not matter, n! / (m! * (n-m)!) Using Factorial and “M Choose N” (m n) = m! / ((m − n)! · n!) The Sum Rule, Conditional Probability, and the Product Rule P(A) = P(A, B1) + P(A, B2) + … + P(A, Bn) P(A | B) = (relevant outcomes) / (total outcomes remaining in universe, when B is true) P(A | B) = P(A, B) / P(B) Bayes’ Theorem P(A | B) = P(B | A) * P(A) / P(B) Technical vocabulary of Bayesian inverse probability: posterior probability = likelihood * prior probability / marginal probability posterior probability—probability after new data is observed prior probability—probability before any data is observed or before new data is observed likelihood—standard forward probability of data given parameters marginal probability—probability of the data The Binomial Theorem and Bayes’ Theorem Binomial theorem used when there are two possible outcomes—a success or a non-success, for example, flipping a coin—heads are a success, binary outcome. Not limited to fair coins, where the probability of success is 0.5. Probability can be any value &gt; 0 and &lt; 1. Probability of s successes in n trials, when probability of 1 success is p: (n s) p^s (1 − p)^(n−s) where n is the number of independent trials (with replacement), s is the number of successes,and p is the probability of one success","categories":[{"name":"慕课MOOC","slug":"慕课MOOC","permalink":"http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"}],"tags":[]},{"title":"Python for everybody","slug":"Python-for-Everybody","date":"2020-05-13T16:00:00.000Z","updated":"2022-05-23T10:34:03.145Z","comments":true,"path":"Python-for-Everybody/","link":"","permalink":"http://blog.zhuangzhihao.top/Python-for-Everybody/","excerpt":"The Python for Everybody Specialization provided by UNIVERSITY OF MICHIGAN introduces fundamental programming concepts including data structures, networked application program interfaces, and databases, using the Python programming language. Python for Everybody is a completely open-source course, you can find all the notes and textbooks on its official website, so this note will only contain my solution to all post-lesson exercises in this course.","text":"The Python for Everybody Specialization provided by UNIVERSITY OF MICHIGAN introduces fundamental programming concepts including data structures, networked application program interfaces, and databases, using the Python programming language. Python for Everybody is a completely open-source course, you can find all the notes and textbooks on its official website, so this note will only contain my solution to all post-lesson exercises in this course. Chapter 1Question 1Write a program that uses a print statement to say ‘hello world’ as shown in ‘Desired Output’.Desired Output 1hello world Solution 1print(&quot;hello world&quot;) Chapter 2Question 1Write a program to prompt the user for hours and rate per hour using input to compute gross pay. Use 35 hours and a rate of 2.75 per hour to test the program (the pay should be 96.25). You should use input to read a string and float() to convert the string to a number. Do not worry about error checking or bad user data.Desired Output 1Pay: 96.25 Solution 1234hrs = input(&quot;Enter Hours: &quot;)rat = input(&quot;Enter Rates: &quot;)pay = float(hrs) * float(rat)print(&quot;Pay: &quot; + str(pay)) Chapter 3Question 1Write a program to prompt the user for hours and rate per hour using input to compute gross pay. Pay the hourly rate for the hours up to 40 and 1.5 times the hourly rate for all hours worked above 40 hours. Use 45 hours and a rate of 10.50 per hour to test the program (the pay should be 498.75). You should use input to read a string and float() to convert the string to a number. Do not worry about error checking the user input - assume the user types numbers properly.Desired Output 1498.75 Solution 123456789hrs = input(&quot;Enter Hours:&quot;)h = float(hrs)rat = input(&quot;Enter Rates:&quot;)r = float(rat)if h &lt;=40: pay = h * relse: pay = 40 * r + (h - 40) * r * 1.5print(str(pay)) Question 2Write a program to prompt for a score between 0.0 and 1.0. If the score is out of range, print an error. If the score is between 0.0 and 1.0, print a grade using the following table:Score Grade>= 0.9 A>= 0.8 B>= 0.7 C>= 0.6 D&lt; 0.6 FIf the user enters a value out of range, print a suitable error message and exit. For the test, enter a score of 0.85.Desired Output 1B Solution 12345678910111213141516score = input(&quot;Enter Score: &quot;)sco = float(score)if 0.0 &lt;= sco &lt;= 1.0: if sco &gt;= 0.9: grade = &quot;A&quot; elif sco &gt;= 0.8: grade = &quot;B&quot; elif sco &gt;= 0.7: grade = &quot;C&quot; elif sco &gt;= 0.6: grade = &quot;D&quot; else: grade = &quot;F&quot; print(grade)else: print(&quot;error&quot;) Chapter 4Question 1Write a program to prompt the user for hours and rate per hour using input to compute gross pay. Pay should be the normal rate for hours up to 40 and time-and-a-half for the hourly rate for all hours worked above 40 hours. Put the logic to do the computation of pay in a function called computepay() and use the function to do the computation. The function should return a value. Use 45 hours and a rate of 10.50 per hour to test the program (the pay should be 498.75). You should use input to read a string and float() to convert the string to a number. Do not worry about error checking the user input unless you want to - you can assume the user types numbers properly. Do not name your variable sum or use the sum() function.Desired Output 1Pay 498.75 Solution 123456789101112def computepay(h,r): if h &lt;= 40: p = h * r else: p = 40 * r + (h - 40) * 1.5 * r return phrs = input(&quot;Enter Hours:&quot;)ho = float(hrs)rat = input(&quot;Enter Rates:&quot;)ro = float(rat)p = computepay(ho,ro)print(&quot;Pay&quot;,p) Chapter 5Question 1Write a program that repeatedly prompts a user for integer numbers until the user enters ‘done’. Once ‘done’ is entered, print out the largest and smallest of the numbers. If the user enters anything other than a valid number catch it with a try/except and put out an appropriate message and ignore the number. Enter 7, 2, bob, 10, and 4 and match the output below.Desired Output 123Invalid inputMaximum is 10Minimum is 2 Solution 1234567891011121314151617largest = Nonesmallest = Noneshuzi = []while True: num = input(&quot;Enter a number: &quot;) if num == &quot;done&quot; : break else: try: numm = int(num) shuzi.append(numm) except: print(&quot;Invalid input&quot;) continuelargest = max(shuzi)smallest = min(shuzi)print(&quot;Maximum is&quot;, largest)print(&quot;Minimum is&quot;, smallest) Chapter 6Question 1Write code using find() and string slicing (see section 6.10) to extract the number at the end of the line below. Convert the extracted value to a floating point number and print it out.Desired Output 10.8475 Solution 1234text = &quot;X-DSPAM-Confidence: 0.8475&quot;;shuziqian = text.find(&#x27;:&#x27;)number = float(text[shuziqian+1:])print(number) Chapter 7Question 1Write a program that prompts for a file name, then opens that file and reads through the file, looking for lines of the form: 1X-DSPAM-Confidence: 0.8475 Count these lines and extract the floating point values from each of the lines and compute the average of those values and produce an output as shown below. Do not use the sum() function or a variable named sum in your solution.You can download the sample data at http://www.py4e.com/code3/mbox-short.txt when you are testing below enter mbox-short.txt as the file name.Desired Output 1Average spam confidence: 0.750718518519 Solution 123456789101112# Use the file name mbox-short.txt as the file namefname = input(&quot;Enter file name: &quot;)fh = open(fname)value = 0count = 0for line in fh: if not line.startswith(&quot;X-DSPAM-Confidence:&quot;) : continue shuziqian = line.find(&#x27;:&#x27;)+1 value = float(line[shuziqian:]) + value count = count + 1print(&quot;Average spam confidence:&quot;,value / count) Chapter 8Question 1Open the file romeo.txt and read it line by line. For each line, split the line into a list of words using the split() method. The program should build a list of words. For each word on each line check to see if the word is already in the list and if not append it to the list. When the program completes, sort and print the resulting words in alphabetical order.You can download the sample data at http://www.py4e.com/code3/romeo.txtDesired Output 1[&#x27;Arise&#x27;, &#x27;But&#x27;, &#x27;It&#x27;, &#x27;Juliet&#x27;, &#x27;Who&#x27;, &#x27;already&#x27;, &#x27;and&#x27;, &#x27;breaks&#x27;, &#x27;east&#x27;, &#x27;envious&#x27;, &#x27;fair&#x27;, &#x27;grief&#x27;, &#x27;is&#x27;, &#x27;kill&#x27;, &#x27;light&#x27;, &#x27;moon&#x27;, &#x27;pale&#x27;, &#x27;sick&#x27;, &#x27;soft&#x27;, &#x27;sun&#x27;, &#x27;the&#x27;, &#x27;through&#x27;, &#x27;what&#x27;, &#x27;window&#x27;, &#x27;with&#x27;, &#x27;yonder&#x27;] Solution 12345678910fname = input(&quot;Enter file name: &quot;)fh = open(fname)lst = list()for line in fh: line = line.strip() words = line.split() for word in words: if word not in lst: lst.append(word)print(sorted(lst)) Question 2Open the file mbox-short.txt and read it line by line. When you find a line that starts with ‘From ‘ like the following line: 1From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008 You will parse the From line using split() and print out the second word in the line (i.e. the entire address of the person who sent the message). Then print out a count at the end.Hint: make sure not to include the lines that start with ‘From:’.You can download the sample data at http://www.py4e.com/code3/mbox-short.txtDesired Output 12345678910111213141516171819202122232425262728stephen.marquard@uct.ac.zalouis@media.berkeley.eduzqian@umich.edurjlowe@iupui.eduzqian@umich.edurjlowe@iupui.educwen@iupui.educwen@iupui.edugsilver@umich.edugsilver@umich.eduzqian@umich.edugsilver@umich.eduwagnermr@iupui.eduzqian@umich.eduantranig@caret.cam.ac.ukgopal.ramasammycook@gmail.comdavid.horwitz@uct.ac.zadavid.horwitz@uct.ac.zadavid.horwitz@uct.ac.zadavid.horwitz@uct.ac.zastephen.marquard@uct.ac.zalouis@media.berkeley.edulouis@media.berkeley.eduray@media.berkeley.educwen@iupui.educwen@iupui.educwen@iupui.eduThere were 27 lines in the file with From as the first word Solution 123456789101112fname = input(&quot;Enter file name: &quot;)if len(fname) &lt; 1 : fname = &quot;mbox-short.txt&quot;fh = open(fname)count = 0for line in fh: line = line.strip() if not line.startswith(&quot;From &quot;): continue words = line.split() print(words[1]) count = count + 1print(&quot;There were&quot;, count, &quot;lines in the file with From as the first word&quot;) Chapter 9Question 1Write a program to read through the mbox-short.txt and figure out who has sent the greatest number of mail messages. The program looks for ‘From ‘ lines and takes the second word of those lines as the person who sent the mail. The program creates a Python dictionary that maps the sender’s mail address to a count of the number of times they appear in the file. After the dictionary is produced, the program reads through the dictionary using a maximum loop to find the most prolific committer.Desired Output 1cwen@iupui.edu 5 Solution 1234567891011121314fname = input(&quot;Enter file name: &quot;)if len(fname) &lt; 1 : fname = &quot;mbox-short.txt&quot;fh = open(fname)count_dict = dict()for line in fh: line = line.strip() if not line.startswith(&#x27;From &#x27;): continue words = line.split() count_dict[words[1]] = 1 + count_dict.get(words[1],0)sort_list = sorted([(v,k) for k,v in count_dict.items()],reverse=True)print(sort_list[0][1],sort_list[0][0]) Chapter 10Question 1Write a program to read through the mbox-short.txt and figure out the distribution by hour of the day for each of the messages. You can pull the hour out from the ‘From ‘ line by finding the time and then splitting the string a second time using a colon. 1From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008 Once you have accumulated the counts for each hour, print out the counts, sorted by hour as shown below.Desired Output 12345678910111204 306 107 109 210 311 614 115 216 417 218 119 1 Solution 123456789101112131415fname = input(&quot;Enter file name: &quot;)if len(fname) &lt; 1 : fname = &quot;mbox-short.txt&quot;fh = open(fname)count_dict = dict()for line in fh: line = line.strip() if not line.startswith(&#x27;From &#x27;): continue words = line.split() times = words[5].split(&#x27;:&#x27;) hours = times[0] count_dict[hours] = 1 + count_dict.get(hours,0)count_list = sorted([(k,v) for k,v in count_dict.items()])for k,v in count_list: print(k,v) Chapter 11Question 1Handling The DataThe basic outline of this problem is to read the file, look for integers using the re.findall(), looking for a regular expression of ‘[0-9]+’ and then converting the extracted strings to integers and summing up the integers.Solution 12345678import refile = open(&#x27;C:/Users/dell/Desktop/regex_sum_501451.txt&#x27;, &#x27;r&#x27;)file_data = file.read()numbers_str = re.findall(&#x27;[0-9]+&#x27;, file_data)total = 0for number_str in numbers_str: total = total + int(number_str)print(total) Chapter 12Question 1Exploring the HyperText Transport ProtocolYou are to retrieve the following document using the HTTP protocol in a way that you can examine the HTTP Response headers. http://data.pr4e.org/intro-short.txtThere are three ways that you might retrieve this web page and look at the response headers: Preferred: Modify the socket1.py program to retrieve the above URL and print out the headers and data. Make sure to change the code to retrieve the above URL - the values are different for each URL. Open the URL in a web browser with a developer console or FireBug and manually examine the headers that are returned. Use the telnet program as shown in lecture to retrieve the headers and content.Desired Output 123456789101112HTTP/1.1 200 OKDate: Sun, 01 Oct 2017 05:25:59 GMTServer: Apache/2.4.7 (Ubuntu)Last-Modified: Sat, 13 May 2017 11:22:22 GMTETag: “1d3-54f6609240717”Accept-Ranges: bytesContent-Length: 467Cache-Control: max-age=0, no-cache, no-store, must-revalidatePragma: no-cacheExpires: Wed, 11 Jan 1984 05:00:00 GMTConnection: closeContent-Type: text/plain Solution 123456789101112import socketmysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)mysock.connect((&#x27;data.pr4e.org&#x27;, 80))cmd = &#x27;GET http://data.pr4e.org/intro-short.txt HTTP/1.0\\r\\n\\r\\n&#x27;.encode()mysock.send(cmd)while True: data = mysock.recv(512) if (len(data) &lt; 1): break print(data.decode())mysock.close() Question 2Scraping Numbers from HTML using BeautifulSoup In this assignment you will write a Python program similar to http://www.py4e.com/code3/urllink2.py. The program will use urllib to read the HTML from the data files below, and parse the data, extracting numbers and compute the sum of the numbers in the file.We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment. Sample data: http://py4e-data.dr-chuck.net/comments_42.html (Sum=2553) Actual data: http://py4e-data.dr-chuck.net/comments_501453.html (Sum ends with 35)You do not need to save these files to your folder since your program will read the data directly from the URL. Note: Each student will have a distinct data url for the assignment - so only use your own data url for analysis.Solution 1234567891011121314151617181920from urllib.request import urlopenfrom bs4 import BeautifulSoupimport ssl# Ignore SSL certificate errorsctx = ssl.create_default_context()ctx.check_hostname = Falsectx.verify_mode = ssl.CERT_NONEurl = input(&#x27;Enter - &#x27;)html = urlopen(url, context=ctx).read()# html.parser is the HTML parser included in the standard Python 3 library.# information on other HTML parsers is here:# http://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-a-parsersoup = BeautifulSoup(html, &quot;html.parser&quot;)# Retrieve all of the anchor tagstags = soup(&#x27;span&#x27;)total = 0for tag in tags: # Look at the parts of a tag total = total + int(tag.contents[0])print(total) Question 3Following Links in PythonIn this assignment you will write a Python program that expands on http://www.py4e.com/code3/urllinks.py. The program will use urllib to read the HTML from the data files below, extract the href= vaues from the anchor tags, scan for a tag that is in a particular position relative to the first name in the list, follow that link and repeat the process a number of times and report the last name you find.We provide two files for this assignment. One is a sample file where we give you the name for your testing and the other is the actual data you need to process for the assignment Sample problem: Start at http://py4e-data.dr-chuck.net/known_by_Fikret.htmlFind the link at position 3 (the first name is 1). Follow that link. Repeat this process 4 times. The answer is the last name that you retrieve.Sequence of names: Fikret Montgomery Mhairade Butchi AnayahLast name in sequence: Anayah Actual problem: Start at: http://py4e-data.dr-chuck.net/known_by_Malaeka.htmlFind the link at position 18 (the first name is 1). Follow that link. Repeat this process 7 times. The answer is the last name that you retrieve.Hint: The first character of the name of the last page that you will load is: KSolution 12345678910111213141516171819202122232425262728 import urllib.requestimport urllib.parseimport urllib.errorfrom bs4 import BeautifulSoupimport ssldef findUrl(url, position): html = urllib.request.urlopen(url, context=ctx).read() soup = BeautifulSoup(html, &#x27;html.parser&#x27;) # Retrieve all of the anchor tags tags = soup(&#x27;a&#x27;) return tags[position].get(&#x27;href&#x27;, None)# Ignore SSL certificate errorsctx = ssl.create_default_context()ctx.check_hostname = Falsectx.verify_mode = ssl.CERT_NONEcount_str = input(&#x27;Enter count - &#x27;)count = int(count_str)position_str = input(&#x27;Enter position - &#x27;)position = int(position_str)-1for i in range(count): if i == 0: url_now = input(&#x27;Enter - &#x27;) print(url_now) url_now = findUrl(url_now, position) print(url_now) else: url_now = findUrl(url_now, position) print(url_now) Chapter 13Question 1Extracting Data from XMLIn this assignment you will write a Python program somewhat similar to http://www.py4e.com/code3/geoxml.py. The program will prompt for a URL, read the XML data from that URL using urllib and then parse and extract the comment counts from the XML data, compute the sum of the numbers in the file.We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment. Sample data: http://py4e-data.dr-chuck.net/comments_42.xml (Sum=2553) Actual data: http://py4e-data.dr-chuck.net/comments_501455.xml (Sum ends with 78)You do not need to save these files to your folder since your program will read the data directly from the URL. Note: Each student will have a distinct data url for the assignment - so only use your own data url for analysis.Solution 12345678910111213141516import urllib.requestimport urllib.parseimport urllib.errorimport xml.etree.ElementTree as ETurl = &#x27;http://py4e-data.dr-chuck.net/comments_501455.xml&#x27;print(&#x27;Retrieving&#x27;, url)uh = urllib.request.urlopen(url)data = uh.read()print(&#x27;Retrieved&#x27;, len(data), &#x27;characters&#x27;)tree = ET.fromstring(data)comments_node = tree.findall(&#x27;comments&#x27;)comment_node = comments_node[0].findall(&#x27;comment&#x27;)total = 0for node in comment_node: total = total + int(node.find(&#x27;count&#x27;).text)print(total) Question 2Extracting Data from JSONIn this assignment you will write a Python program somewhat similar to http://www.py4e.com/code3/json2.py. The program will prompt for a URL, read the JSON data from that URL using urllib and then parse and extract the comment counts from the JSON data, compute the sum of the numbers in the file and enter the sum below:We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment. Sample data: http://py4e-data.dr-chuck.net/comments_42.json (Sum=2553) Actual data: http://py4e-data.dr-chuck.net/comments_501456.json (Sum ends with 42)You do not need to save these files to your folder since your program will read the data directly from the URL. Note: Each student will have a distinct data url for the assignment - so only use your own data url for analysis.Solution 123456789101112131415import urllib.requestimport urllib.parseimport urllib.errorimport jsonurl = &#x27;http://py4e-data.dr-chuck.net/comments_501456.json&#x27;print(&#x27;Retrieving&#x27;, url)uh = urllib.request.urlopen(url)data = uh.read()info = json.loads(data.decode())print(&#x27;User count:&#x27;, len(info))comments_dic = info[&#x27;comments&#x27;]total = 0for item in comments_dic: total = total + int(item[&#x27;count&#x27;])print(total) Question 3Calling a JSON APIIn this assignment you will write a Python program somewhat similar to http://www.py4e.com/code3/geojson.py. The program will prompt for a location, contact a web service and retrieve JSON for the web service and parse that data, and retrieve the first place_id from the JSON. A place ID is a textual identifier that uniquely identifies a place as within Google Maps.API End PointsTo complete this assignment, you should use this API endpoint that has a static subset of the Google Data: 1http://py4e-data.dr-chuck.net/json? This API uses the same parameter (address) as the Google API. This API also has no rate limit so you can test as often as you like. If you visit the URL with no parameters, you get “No address…” response.To call the API, you need to include a key= parameter and provide the address that you are requesting as the address= parameter that is properly URL encoded using the urllib.parse.urlencode() function as shown in http://www.py4e.com/code3/geojson.pyMake sure to check that your code is using the API endpoint is as shown above. You will get different results from the geojson and json endpoints so make sure you are using the same end point as this autograder is using.Solution 123456789101112131415161718192021222324252627282930313233343536373839404142434445import urllib.requestimport urllib.parseimport urllib.errorimport jsonimport sslapi_key = False# If you have a Google Places API key, enter it here# api_key = &#x27;AIzaSy___IDByT70&#x27;# https://developers.google.com/maps/documentation/geocoding/introif api_key is False: api_key = 42 serviceurl = &#x27;http://py4e-data.dr-chuck.net/json?&#x27;else: serviceurl = &#x27;https://maps.googleapis.com/maps/api/geocode/json?&#x27;# Ignore SSL certificate errorsctx = ssl.create_default_context()ctx.check_hostname = Falsectx.verify_mode = ssl.CERT_NONEwhile True: address = input(&#x27;Enter location: &#x27;) if len(address) &lt; 1: break parms = dict() parms[&#x27;address&#x27;] = address if api_key is not False: parms[&#x27;key&#x27;] = api_key url = serviceurl + urllib.parse.urlencode(parms) print(&#x27;Retrieving&#x27;, url) uh = urllib.request.urlopen(url, context=ctx) data = uh.read().decode() print(&#x27;Retrieved&#x27;, len(data), &#x27;characters&#x27;) try: js = json.loads(data) except: js = None if not js or &#x27;status&#x27; not in js or js[&#x27;status&#x27;] != &#x27;OK&#x27;: print(&#x27;==== Failure To Retrieve ====&#x27;) print(data) continue print(json.dumps(js, indent=4)) lat = js[&#x27;results&#x27;][0][&#x27;geometry&#x27;][&#x27;location&#x27;][&#x27;lat&#x27;] lng = js[&#x27;results&#x27;][0][&#x27;geometry&#x27;][&#x27;location&#x27;][&#x27;lng&#x27;] print(&#x27;lat&#x27;, lat, &#x27;lng&#x27;, lng) location = js[&#x27;results&#x27;][0][&#x27;formatted_address&#x27;] print(location) Chapter 15Question 1create a SQLITE database or use an existing database and create a table in the database called “Ages”: 1234CREATE TABLE Ages ( name VARCHAR(128), age INTEGER) Then make sure the table is empty by deleting any rows that you previously inserted, and insert these rows and only these rows with the following commands: 12345DELETE FROM Ages;INSERT INTO Ages (name, age) VALUES (&#x27;Muqadaas&#x27;, 29);INSERT INTO Ages (name, age) VALUES (&#x27;Sabine&#x27;, 13);INSERT INTO Ages (name, age) VALUES (&#x27;Brydon&#x27;, 35);INSERT INTO Ages (name, age) VALUES (&#x27;Jayla&#x27;, 39); Once the inserts are done, run the following SQL command: 1SELECT hex(name || age) AS X FROM Ages ORDER BY X Question 2Counting OrganizationsThis application will read the mailbox data (mbox.txt) and count the number of email messages per organization (i.e. domain name of the email address) using a database with the following schema to maintain the counts. 1CREATE TABLE Counts (org TEXT, count INTEGER) When you have run the program on mbox.txt upload the resulting database file above for grading.If you run the program multiple times in testing or with dfferent files, make sure to empty out the data before each run.You can use this code as a starting point for your application: http://www.py4e.com/code3/emaildb.py.The data file for this application is the same as in previous assignments: http://www.py4e.com/code3/mbox.txt.Solution 123456789101112131415161718192021222324252627282930import sqlite3conn = sqlite3.connect(&#x27;emaildb2.sqlite&#x27;)cur = conn.cursor()cur.execute(&#x27;&#x27;&#x27;DROP TABLE IF EXISTS Counts&#x27;&#x27;&#x27;)cur.execute(&#x27;&#x27;&#x27;CREATE TABLE Counts (org TEXT, count INTEGER)&#x27;&#x27;&#x27;)fh = open(&#x27;C:/Users/dell/Desktop/mbox.txt&#x27;, &#x27;r&#x27;)list_1 = []for line in fh: if not line.startswith(&#x27;From: &#x27;): continue pieces = line.split() email = pieces[1] dom = email.find(&#x27;@&#x27;) org = email[dom+1:len(email)] cur.execute(&#x27;SELECT count FROM Counts WHERE org = ? &#x27;, (org,)) row = cur.fetchone() if row is None: cur.execute(&#x27;&#x27;&#x27;INSERT INTO Counts (org, count) VALUES (?, 1)&#x27;&#x27;&#x27;, (org,)) else: cur.execute(&#x27;UPDATE Counts SET count = count + 1 WHERE org = ?&#x27;, (org,))conn.commit()# https://www.sqlite.org/lang_select.htmlsqlstr = &#x27;SELECT org, count FROM Counts ORDER BY count DESC LIMIT 10&#x27;for row in cur.execute(sqlstr): print(str(row[0]), row[1])cur.close() Question 3Musical Track DatabaseThis application will read an iTunes export file in XML and produce a properly normalized database with this structure: 123456789101112131415161718192021CREATE TABLE Artist ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, name TEXT UNIQUE);CREATE TABLE Genre ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, name TEXT UNIQUE);CREATE TABLE Album ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, artist_id INTEGER, title TEXT UNIQUE);CREATE TABLE Track ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, title TEXT UNIQUE, album_id INTEGER, genre_id INTEGER, len INTEGER, rating INTEGER, count INTEGER); If you run the program multiple times in testing or with different files, make sure to empty out the data before each run.You can use this code as a starting point for your application: http://www.py4e.com/code3/tracks.zip. The ZIP file contains the Library.xml file to be used for this assignment. You can export your own tracks from iTunes and create a database, but for the database that you turn in for this assignment, only use the Library.xml data that is provided.To grade this assignment, the program will run a query like this on your uploaded database and look for the data it expects to see: 12345SELECT Track.title, Artist.name, Album.title, Genre.name FROM Track JOIN Genre JOIN Album JOIN Artist ON Track.genre_id = Genre.ID and Track.album_id = Album.id AND Album.artist_id = Artist.id ORDER BY Artist.name LIMIT 3 The expected result of the modified query on your database is: (shown here as a simple HTML table with titles)Solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import xml.etree.ElementTree as ETimport sqlite3conn = sqlite3.connect(&#x27;trackdb.sqlite&#x27;)cur = conn.cursor()# Make some fresh tables using executescript()cur.executescript(&#x27;&#x27;&#x27;DROP TABLE IF EXISTS Artist;DROP TABLE IF EXISTS Album;DROP TABLE IF EXISTS Genre;DROP TABLE IF EXISTS Track;CREATE TABLE Artist ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, name TEXT UNIQUE);CREATE TABLE Album ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, artist_id INTEGER, title TEXT UNIQUE);CREATE TABLE Genre ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, name TEXT UNIQUE);CREATE TABLE Track ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, title TEXT UNIQUE, album_id INTEGER, genre_id INTEGER, len INTEGER, rating INTEGER, count INTEGER);&#x27;&#x27;&#x27;)fname = input(&#x27;Enter file name: &#x27;)if (len(fname) &lt; 1): fname = &#x27;Library.xml&#x27;# &lt;key&gt;Track ID&lt;/key&gt;&lt;integer&gt;369&lt;/integer&gt;# &lt;key&gt;Name&lt;/key&gt;&lt;string&gt;Another One Bites The Dust&lt;/string&gt;# &lt;key&gt;Artist&lt;/key&gt;&lt;string&gt;Queen&lt;/string&gt;def lookup(d, key): found = False for child in d: if found: return child.text if child.tag == &#x27;key&#x27; and child.text == key: found = True return Nonestuff = ET.parse(fname)all = stuff.findall(&#x27;dict/dict/dict&#x27;)print(&#x27;Dict count:&#x27;, len(all))for entry in all: if (lookup(entry, &#x27;Track ID&#x27;) is None): continue name = lookup(entry, &#x27;Name&#x27;) artist = lookup(entry, &#x27;Artist&#x27;) album = lookup(entry, &#x27;Album&#x27;) genre = lookup(entry, &#x27;Genre&#x27;) count = lookup(entry, &#x27;Play Count&#x27;) rating = lookup(entry, &#x27;Rating&#x27;) length = lookup(entry, &#x27;Total Time&#x27;) if name is None or artist is None or album is None: continue print(name, artist, album, genre, count, rating, length) cur.execute(&#x27;&#x27;&#x27;INSERT OR IGNORE INTO Artist (name) VALUES ( ? )&#x27;&#x27;&#x27;, (artist, )) cur.execute(&#x27;SELECT id FROM Artist WHERE name = ? &#x27;, (artist, )) artist_id = cur.fetchone()[0] cur.execute(&#x27;&#x27;&#x27;INSERT OR IGNORE INTO Album (title, artist_id) VALUES ( ?, ? )&#x27;&#x27;&#x27;, (album, artist_id)) cur.execute(&#x27;SELECT id FROM Album WHERE title = ? &#x27;, (album, )) album_id = cur.fetchone()[0] cur.execute(&#x27;&#x27;&#x27;INSERT OR IGNORE INTO Genre (name) VALUES ( ? )&#x27;&#x27;&#x27;, (genre, )) cur.execute(&#x27;SELECT id FROM Genre WHERE name = ? &#x27;, (genre, )) genre_id = cur.fetchone()[0] cur.execute(&#x27;&#x27;&#x27;INSERT OR REPLACE INTO Track (title, album_id, genre_id, len, rating, count) VALUES ( ?, ?, ?, ?, ?, ?)&#x27;&#x27;&#x27;, (name, album_id, genre_id, length, rating, count)) conn.commit() Question 4This application will read roster data in JSON format, parse the file, and then produce an SQLite database that contains a User, Course, and Member table and populate the tables from the data file.You can base your solution on this code: http://www.py4e.com/code3/roster/roster.py - this code is incomplete as you need to modify the program to store the role column in the Member table to complete the assignment.Each student gets their own file for the assignment. Download this file and save it as roster_data.json. Move the downloaded file into the same folder as your roster.py program.Once you have made the necessary changes to the program and it has been run successfully reading the above JSON data, run the following SQL command: 1234SELECT hex(User.name || Course.title || Member.role ) AS X FROM User JOIN Member JOIN Course ON User.id = Member.user_id AND Member.course_id = Course.id ORDER BY X Find the first row in the resulting record set and enter the long string that looks like 53656C696E613333.Solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import jsonimport sqlite3# PART 1: Creating the databasedbname = &quot;roster.sqlite&quot;conn = sqlite3.connect(dbname)cur = conn.cursor()cur.executescript(&#x27;&#x27;&#x27; DROP TABLE IF EXISTS User; DROP TABLE IF EXISTS Course; DROP TABLE IF EXISTS Member; CREATE TABLE User ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, name TEXT UNIQUE ); CREATE TABLE Course ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, title TEXT UNIQUE ); CREATE TABLE Member ( user_id INTEGER, course_id INTEGER, role INTEGER, PRIMARY KEY(user_id, course_id) )&#x27;&#x27;&#x27;)# Note: if we don&#x27;t add UNIQUE after &quot;User.name&quot; and &quot;Course.title&quot;,# the IGNORE statement won&#x27;t work and therefore we&#x27;ll have duplicates# PART 2: DESERIALIZING THE data# The JSON data we&#x27;re going to process is stored in an array form, with each# item being also an array of three elements: one corresponding to the username# one corresponding to the course name, and one indicating if the user is instructor# None of them has any field title.filename = &quot;roster_data.json&quot;jsondata = open(&#x27;C:/Users/dell/Desktop/roster_data.json&#x27;)data = json.load(jsondata)# PART 3: INSERTING DATAfor entry in data: user = entry[0] course = entry[1] instructor = entry[2] # Inserting user user_statement = &quot;&quot;&quot;INSERT OR IGNORE INTO User(name) VALUES( ? )&quot;&quot;&quot; SQLparams = (user, ) cur.execute(user_statement, SQLparams) # Inserting course course_statement = &quot;&quot;&quot;INSERT OR IGNORE INTO Course(title) VALUES( ? )&quot;&quot;&quot; SQLparams = (course, ) cur.execute(course_statement, SQLparams) # Getting user and course id courseID_statement = &quot;&quot;&quot;SELECT id FROM Course WHERE title = ?&quot;&quot;&quot; SQLparams = (course, ) cur.execute(courseID_statement, SQLparams) courseID = cur.fetchone()[0] userID_statement = &quot;&quot;&quot;SELECT id FROM User WHERE name = ?&quot;&quot;&quot; SQLparams = (user, ) cur.execute(userID_statement, SQLparams) userID = cur.fetchone()[0] # Inserting the entry member_statement = &quot;&quot;&quot;INSERT INTO Member(user_id, course_id, role) VALUES(?, ?, ?)&quot;&quot;&quot; SQLparams = (userID, courseID, instructor) cur.execute(member_statement, SQLparams)# Saving the changesconn.commit()# PART 4: Testing and obtaining the resultstest_statement = &quot;&quot;&quot;SELECT hex(User.name || Course.title || Member.role ) AS X FROM User JOIN Member JOIN Course ON User.id = Member.user_id AND Member.course_id = Course.id ORDER BY X&quot;&quot;&quot;cur.execute(test_statement)result = cur.fetchone()print(&quot;RESULT: &quot; + str(result))# Closing the connectioncur.close()conn.close()","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.zhuangzhihao.top/categories/Python/"}],"tags":[]},{"title":"Sport-Related Concussion Training","slug":"Sport-Related-Concussion-Training","date":"2020-04-19T16:00:00.000Z","updated":"2022-05-05T13:06:32.063Z","comments":true,"path":"Sport-Related-Concussion-Training/","link":"","permalink":"http://blog.zhuangzhihao.top/Sport-Related-Concussion-Training/","excerpt":"Some common sports injuries can occur when engaging in confrontational sports like basketball, therefore it’s important to have some knowledge of avoiding and dealing with them. The Michigan Sport-Related Concussion Training Certification satisfies the state-mandated requirement for concussion training in the state of Michigan and can be helpful under certain circumstances. The following are the notes I took during this course.","text":"Some common sports injuries can occur when engaging in confrontational sports like basketball, therefore it’s important to have some knowledge of avoiding and dealing with them. The Michigan Sport-Related Concussion Training Certification satisfies the state-mandated requirement for concussion training in the state of Michigan and can be helpful under certain circumstances. The following are the notes I took during this course. Identifying a Concussion A concussion, sometimes called a mild traumatic brain injury, can occur from a sudden fall, a blow from another person or a hit from the piece of equipment that causes the brain to move quickly within the skull. This motion changes the way the brain communicates which can lead to changes in how someone thinks or behaves. On-field Signs Dazed or stunned Displaying the motions that are uncharacteristic of the athlete Slowly responding to play calls Holding their head Difficulty recalling events Concussion symptoms Physical Cognitive Emotional Sleep-related Emergency “Red Flags” Severe or increasing headache Intense neck pain particularly down the middle with weakness or burning into both arms or legs Athlete reporting double vision Seizing or convulsing body movements Loss of consciousness for greater than one minute A deteriorating mental state such as going in and out of consciousness Repetitive vomiting Increasingly combative Michigan’s Youth Concussion Law Every athlete and their parent or guardian must provide written informed consent of concussion education materials Each coach, employee or volunteer is required to complete a concussion awareness training program once every three years Any athlete who is suspected of having concussion must be immediately removed from participation Any athlete removed from participation because of a possible concussion cannot return to full sport participation until an appropriate health professional has provided written clearance for the athlete to return to full sport participation Remove from Play Do not attempt to diagnose a concussion yourself. Goal of Removal The goal is not to diagnose a concussion on the sideline, but to remove the athlete from risk, risk of another concussion, or risk of a more serious brain injury. For Athletes It’s important to know that you don’t need to be able to diagnose concussion. What we want you to be able to do is recognize signs and symptoms of concussion, so that when a suspected concussion occurs, you’ll be able to manage it, and feel calm, and safe during that situation. Responsibilities of Coaches and Parents Make sure they’re not participating anymore You need to get him to a medical professional You need to keep them quiet The law in Michigan requires immediate removal of student-athlete whenever there is concern for concussion Before return to full participation, a written authorization from a healthcare provider must be obtained Forms must be kept on file at the school for seven years following the students graduation Rest and RehabilitationThe first few Days If red flags symptoms should develop, medical care should be sought immediately Activities that makes symptoms worse should be avoided Activities that put one at an increased risk for concussion should be avoided Reintroduction of Physical School and Work Activities Getting restful sleep Adequate hydration of 60-80 ounces A healthy diet Use of electronic devices during recovery from concussion can be undertaken as long as it doesn’t markedly worsen symptoms Return to Learn and ActivityReturn to Learn Daily activities School activities Return to school Part-time Return to school Full-time Return to Athletic Activity Stages Symptom-limited activity Light aerobic exercise Sport-specific exercise Non-contact training drills Full contact practice Return to sport Long-Term Effects It’s important to remember that most people have a normal recovery within 30 days of injury When prolonged recovery occurs, it’s very important to identify the factors that cause the symptoms and to initiate treatment immediately Care at a healthcare facility with expertise in concussion can aid in this process Management of prolonged recovery should be individualized, and best takes place by those with expertise in concussion care Studies do not suggest that there’s an increased risk of dementia, depression, or suicide later in life","categories":[{"name":"慕课MOOC","slug":"慕课MOOC","permalink":"http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"}],"tags":[]},{"title":"Git 操作指令总结","slug":"Git知识点","date":"2020-04-12T16:00:00.000Z","updated":"2022-06-07T13:46:50.421Z","comments":true,"path":"Git知识点/","link":"","permalink":"http://blog.zhuangzhihao.top/Git%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件，是目前世界上最先进的分布式版本控制系统。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。Git 指令操作简单易上手。","text":"Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件，是目前世界上最先进的分布式版本控制系统。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。Git 指令操作简单易上手。 一、Git 基本概念Git 操作指令 集中式（SVN） VS 分布式（Git） SVN 和 Git 主要的区别在于历史版本维护的位置; Git 本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而 SVN 的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行; 这样的好处在于：自己可以在脱机环境查看开发的版本历史。并且多人开发时如果充当中央仓库的 Git 仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。 创建版本库git init初始化一个 Git 仓库。 git add ‘&lt;name&gt;’or git add . 暂存文件。 git commit -m ‘&lt;name&gt;’ 提交到Git仓库。 文件状态git status 随时掌握工作区的状态。 git diff 比较工作区与缓存区，查看修改内容。 git diff -- cached 比较缓存区与本地库最近一次commit内容。 git diff HEAD比较工作区与本地最近一次commit内容。 配置命令git config --list 列出当前配置。 git config --local --list 列出Repository配置。 git config --global --list 列出全局配置。 git config --system --list 列出系统配置。 git config --global user.name &quot;your name&quot; 配置用户名。 git config --global user.email &quot;youremail@github.com&quot; 配置用户邮箱。 配置 Git 的时候，加上--global 是针对当前用户起作用的；如果不加，那只针对当前的仓库起作用。 每个仓库的 Git 配置文件都放在.git/config 文件中。 版本回退HEAD指向的版本就是当前版本。 git log 可以查看提交历史，以便确定要回退到哪个版本。 git reflog 查看命令历史，以便确定要回到未来的哪个版本。 git reset --hard commit_id 在版本的历史之间穿梭。 工作区和暂存区（Working Directory and Repository）。 管理修改git add 实际上是把文件添加到暂存区。 git commit 实际上是把暂存区的所有内容提交到当前分支。 每次修改，如果不用git add到暂存区，那就不会加入到commit中。 撤销修改当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file 。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，用命令git reset HEAD &#39;&lt;name&gt;&#39; 回到上一步。 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考’’版本回退’’，不过前提是没有推送到远程库。 git rm 删除一个文件。 二、远程仓库添加远程库git remote add origin git@server-name:path/repo-name.git 关联一个远程库。 git push -u origin main 第一次推送 main 分支的所有内容。 git push origin main 推送最新修改。 从远程库克隆git clone 命令克隆克隆一个仓库。 Git 支持多种协议，包括 https，但 ssh 协议速度最快。 远程库操作git push origin -d &lt;branch-name&gt; 删除远程分支。 git branch -m &lt;oldbranch-name&gt; &lt;newbranch-name&gt; 重命名分支。 git checkout -b 本地分支名x origin/远程分支名x 拉取远程分支并创建本地分支。 git fetch origin &lt;branch-name&gt;:&lt;local-branch-name&gt; 将远程仓库内容更新到本地。 三、分支管理创建与合并分支git branch 查看分支。 git branch &lt;name&gt; 创建分支。 git checkout &lt;name&gt; 或者git switch &lt;name&gt; 切换分支。 git branch -r 查看远程分支或者 git branch -a 查看本地和远程分支。 git checkout -b &lt;name&gt; 或者git switch -c &lt;name&gt; 创建+切换分支。 git merge &lt;name&gt; 合并某分支到当前分支。 git branch --merged 查看哪些分支已经合并到当前分支。 git branch --no-merged 查看哪些分支没有合并到当前分支。 git branch -v 查看各个分支最后一个提交对象的信息。 git branch -d &lt;name&gt; 删除分支。 解决冲突当 Git 无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成。 解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。 git log --graph 查看分支合并图。 合并分支时，加上 --no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，fast forward 合并就看不出来曾经做过合并。 修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除。 当手头工作没有完成时，先把工作现场git stash 一下（文件暂存），然后去修复 bug。 git stash save -a “message” 添加改动到stash。 git stash drop &lt;stash@&#123;ID&#125;&gt; 删除暂存，git stash clear 删除全部缓存。 git stash list 查看stash列表。 修复后，再git stash pop，回到工作现场。 在 main 分支上修复的 bug，想要合并到当前 dev 分支，可以用git cherry-pick &lt;commit&gt; 命令，把 bug 提交的修改“复制”到当前分支，避免重复劳动。 开发一个新 feature，最好新建一个分支。 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 多人协作git remote -v 查看远程库信息。 本地新建的分支如果不推送到远程，对其他人就是不可见的。 git pull 抓取远程的分支，如果有冲突，要先处理冲突。 git push origin branch-name 从本地推送分支。 git checkout -b branch-name origin/branch-name 在本地创建和远程分支对应的分支。 git branch --set-upstream branch-name origin/branch-name 建立本地分支和远程分支的关联。 Rebaserebase 操作可以把本地未 push 的分叉提交历史整理成直线。 rebase 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 四、标签管理创建标签git tag &lt;tagname&gt; 用于新建一个标签，默认为 HEAD，也可以指定一个 commit id 。 git tag -a &lt;tagname&gt; -m &quot; &quot;可以指定标签信息。 git tag 查看所有标签。 操作标签git push origin &lt;tagname&gt; 可以推送一个本地标签。 git push origin --tags 可以推送全部未推送过的本地标签。 git tag -d &lt;tagname&gt; 可以删除一个本地标签。 git push origin :refs/tags/&lt;tagname&gt; 可以删除一个远程标签。 五、自定义 Gitgitgonore 忽略特殊文件忽略某些文件时，需要编写.gitignore。 .gitignore 文件本身要放到版本库里，并且可以对.gitignore 做版本管理。 搭建 Git 服务器要方便管理公钥，用 Gitosis。 要像 SVN 那样变态地控制权限，用 Gitolite。","categories":[{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.zhuangzhihao.top/tags/Git/"}]},{"title":"计算机科学速成课","slug":"计算机科学速成课","date":"2020-03-11T16:00:00.000Z","updated":"2022-05-23T09:46:55.013Z","comments":true,"path":"计算机科学速成课/","link":"","permalink":"http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/","excerpt":"计算机科学速成课程的授课老师是英国树莓派基金会教育部长Carrie Anne，她以入门级大学教材和 AP 计算机科学原理指南为基础，在短短40节课中概述了计算机的历史、设计决策、编程和软件的基本要素、硬件的基本组件及其作用，对新手小白可以说是非常友好了。","text":"计算机科学速成课程的授课老师是英国树莓派基金会教育部长Carrie Anne，她以入门级大学教材和 AP 计算机科学原理指南为基础，在短短40节课中概述了计算机的历史、设计决策、编程和软件的基本要素、硬件的基本组件及其作用，对新手小白可以说是非常友好了。 一、计算机的早期历史和电子计算机最早的计算设备是算盘，其次是步进计算器，差分机，分析机，打孔卡片制表机。步进计算器是第一个可以做加减乘除的机器，Charles Babbage 提出了“差分机”，在构造差分机期间，想出了分析机, 分析机是通用计算机。 Ada Lovelace 给分析机写了假想程序，因此成为了第一位程序员，后来 Herman Hollerith 的打孔卡片制表机又大大提升了人口普查效率。 电子计算机组成核心最初由继电器组成。继电器一秒最多 50 次开关，bug 原指继电器上的虫子。 IBM 于 1944 年制造哈佛 Mark I。1904 年，热电子管出现成为第一个真空管。改进后和继电器的功能一样，”巨人 1 号” 计算机在英国布莱切利园首次大规模使用真空管，但编程麻烦，还要配置。1946 年，宾夕法尼亚大学的 ENIAC 是第一个通用可编程计算机。1947 年，贝尔实验室做出了晶体管，晶体管有诸多好处，IBM 很快全面转向晶体管。 当时，很多晶体管和半导体的开发都是硅谷做的。而生产半导体最常见的材料是硅，著名的有肖克利半导体、仙童半导体和英特尔。 二、布尔逻辑、逻辑门和二进制George Boole 提出布尔逻辑（真假），也称 Boolean Algebra。基本操作有：NOT，AND，OR，以及异或 XOR。 存储单位有 MB（Megabyte），GB（Gigabyte），TB（Terabyte），树型单位有正数、负数、整数、浮点数。 美国信息交换标准代码 ASCII：用来表示字符。1992 年诞生 UNICODE，16 位，是字符编码标准，解决 ASCII 不够表达所有语言的问题。 三、算数逻辑单元（ALU）ALU（Arithmetic and Logic Unit）有 2 个单元，1 个算术单元和 1 个逻辑单元。 算术单元分为半加器 （处理 1 个 bit，2 个输入）和全加器（处理 1 个 bit，3 个输入），8 bit 加法就包括（1 个半加器，7 个全加器），溢出为 Overflow。 逻辑单元是检测数字是否为 0 的电路（一堆 OR 门最后加个 NOT 门）。 8 位 ALU 抽象成一个 V 符号。 Flag 标志判断是否相等，是否小于，是否溢出等。 最早的处理器为英特尔 74181。 四、寄存器和内存Memory 有存储、内存两种含义：Gated Latch（锁存器）存 1 位字节，Register（寄存器）存 8 位，16x16 的矩阵存 256 位，Opcode 操作码。 数据选择器/多路复用器 （Multiplexer）用来解码 8 位地址（4 位代表行，4 位代表列），定位到单个锁存器，组合 256 位内存 + 多路复用器 Multiplexer。 可寻址的 256 字节内存：8 个模块，每个模块有 32 个小方块，每个小方块有 4 个小块，每个小块是 128 位 x 64 位。 一条 1980 年代的内存有 1M 大小。 五、中央处理器（CPU）以及指令和程序Instruction Register、Instruction Address Register。 RAM + 寄存器 + ALU = CPU。 取指令 → 解释 → 执行循环。 时钟 clock：时钟速度和赫兹，超频提升性能, 降频省电。 ”指令集”，LOAD_A，LOAD_B，SUB，JUMP，ADD，HALT 等指令，带条件跳转：JUMP NEGATIVE 是负数才跳转，还有其他类型的 JUMP。 真正现代 CPU 用更多指令集。位数更长，1971 年的英特尔 4004 处理器，有 46 个指令，如今英特尔酷睿 i7, 有上千条指令。CPU 发展早期是加快晶体管切换速度，来提升 CPU 速度，现在给 CPU 专门的除法电路 + 其他电路来做复杂操作，比如游戏，视频解码，或是给 CPU 加缓存，提高数据存取速度，更快喂给 CPU。 专有名词：脏位（Dirty bit）、流水线设计（pipeline）、并行处理（parallelize）、乱序执行（out-of-order execution）、推测执行（speculative execution）、分支预测（branch prediction）。 多个 ALU 组成多核放大为多个独立 CPU 放大为超级计算机（中国的神威太湖之光）。 六、编程语言发展史早期的编程发展从纺织业开始，给机器编程的需求远在计算机出现前就有了，于是有了打孔纸卡（Punched card）和插线板（Plugboard）。 冯诺依曼架构（Von Neumann Architecture）是编程的鼻祖，在这之上演变出面板编程（Panel programming）。第一款取得商业成功的家用计算机是 Altair 8800。 二进制写程序，先纸上写伪代码，手工转二进制，很快就烦了，于是用助记符（mnemonic）写代码（LOAD_A 14），为了把助记符转二进制，汇编器（Assembler）诞生。 Grace Hopper 设计了编程语言 A-0，并在 1952 年做了第一个编译器（Compiler），实现 A-0。IBM 在 1957 年开发出 FORTRAN，随后 COBOL（Common Business-Oriented Language）诞生。 1960 年代：ALGOL，LISP，BASIC。 1970 年代：Pascal，C，Smalltalk。 1980 年代：C++，Objective-C，Perl。 1990 年代：Python，Ruby，Java。 New millennium：Swift，C#，Go。 七、函数、算法和数据结构最经典的是 Grace Hopper 拍虫子游戏。 专有名词：变量、赋值语句、if 判断、while 循环、for 循环、函数。 最简单的算法有：选择排序（Selection sort O(n^2)）、归并排序（Merge sort O(n log n)）、Dijkstra 算法（（graph search algorithms） O(n log n +1)）。 大 O 表示法（Big O notation）用来表示算法复杂度。 数据结构要点：数组（Array）、下标（Index）、字符串（String）、矩阵（Matrix）、结构体（Struct）、指针（Pointer）、节点（Node）、链表（Linked List）。 队列（Queue）(First in first out)，栈（Stack）(Last in first out) push、pop。 不同数据结构适用不同场景：树（Tree）root/ leaf nodes，二叉树（Binary Tree），图（Graph），红黑树和堆。 八、阿兰·图灵阿兰·图灵生于 1912，是计算机之父，他首先提出可判定性问题（Entscheidungs problem）和停机问题，阿隆佐·丘奇研究 Lambda 算子。图灵机是计算机的蓝本而 Bombe 则破解了德军英格玛加密机。 图灵测试和图灵奖。 九、软件工程对象（Object）以及面向对象编程（Object Oriented Programming）。 API（Application Programming Interface）和集成开发环境 IDE（Integrated Development Environments）。 其他专有名词：调试（debugging），文档和注释（readme, comment）版本控制（Version control）质量控制（Quality Assurance testing，QA）。 十、集成电路与摩尔定律晶圆的制作：光刻（Photolithography）、晶圆（Wafer）、光刻胶（Photoresist）、光掩膜（Photomask）、掺杂（Doping）、分立元件（Discrete components）。 数字暴政（Tyranny of Numbers）是 1960 年代工程师碰到的问题（如果想加强电脑性能，就要更多部件，这导致更多线路，更复杂。所以很难做）。 摩尔定律 Moore’s Law。晶体管数量大幅度增长, 1980 年三万个，1990 年一百万个，2000 年三千万个，2010 年十亿个，进一步小型化会碰到 2 个问题：1、光的波长不足以制作更精细的设计，2、量子隧穿效应。 十一、操作系统操作系统（Operating systems）：计算机变便宜变多，有不同配置，写程序处理不同硬件细节很痛苦，因此操作系统负责抽象硬件。 专有名词：批处理（Batch processing）、外部设备（Peripherals）、设备驱动程序（Device drivers）、多任务处理（Multitasking）、虚拟内存（Virtual Memory）、动态内存分配（Dynamic memory allocation）、内存保护（Memory Protection）。 1970 年代，计算机足够便宜，大学买了让学生用，多个学生用多个 “终端” 连接到主机。 多用户分时操作系统，Multics、Unix、MS-DOS。 十二、内存和文件存储技术的发展，首先是纸卡（Paper punch cards），随后发展为延迟线存储器（Delay Line Memory）、磁芯（Magnetic Core Memory）、磁带（Magnetic Tape）、磁鼓（Magnetic Drum Memory）。 硬盘（Hard Disk Drives）有内存层次结构（Memory Hierarchy）。 软盘（Floppy Disk）、光盘（Compact Disk）、固态硬盘（Solid State Drives）。 文件格式：可以随便存文件数据，但按格式存会更方便。 TXT 文本文件：ASCII。 WAV 音频文件：每秒上千次的音频采样数字。 BMP 图片文件：像素的红绿蓝 RGB 值。 文件系统：很早期时空间小，整个存储器就像一整个文件。后来随容量增长，多文件非常必要。 目录文件：用来解决多文件问题，存其他文件的信息，比如开头，结尾，创建时间等。 平面文件系统（Flat File System）：文件都在同一个层次，早期空间小，只有十几个文件，平面系统够用，如果文件紧密的一个个前后排序会造成问题，所以文件系统会： 1. 把空间划分成一块块 2. 文件拆分存在多个块里，文件的增删改查会不可避免的造成文件散落在各个块里，如果是磁带这样的存储介质就会造成问题，所以做碎片整理。 分层文件系统（Hierarchical File System）：有不同文件夹，文件夹可以层层嵌套。 压缩的好处是能存更多文件，传输也更快。 无损压缩（Lossless compression）：游程编码（Run-Length Encoding）和字典编码（Dictionary coders）。 霍夫曼树 Huffman Tree、消除冗余和用更紧凑的表示方法，这些方法通常会组合使用。 感知编码（Perceptual coding）、有损压缩，如 jpeg 格式、时间冗余（Temporal redundancy）、MPEG-4 视频编码。 十三、命令行界面与 图形用户界面（GUI）最早计算机程序从运行开始直到结束，中间没有人类进行操作，原因是计算机很贵，不能等人类慢慢输入，执行完结果打印到纸上，到 1950 年代，计算机足够便宜+快，人类和计算机交互式操作变得可行，为了让人类输入到计算机，改造之前就有的打字机，变成电传打字机，到 1970 年代末，屏幕成本足够低，屏幕代替电传打字机，屏幕成为标配。 人机交互（Human-Computer Interaction）：早期输出数据是打印到纸上，而输入是用纸卡/纸带一次性把程序和数据都给进去。 克里斯托弗·莱瑟姆·肖尔斯于 1868 年发明 QWERTY 打字机，随后诞生电传打字机（Teletype machine），输入指令打印在纸上，电脑会将返回指令打印在纸上完成交互。 命令行界面（Command line interface）：ls 命令、cd 命令、早期文字游戏 Zork（1977 年）。 图形界面先驱：道格拉斯·恩格尔巴特（Douglas Engelbart），施乐公司则在 1970 年成立 帕洛阿尔托研究中心（Palo Alto Research Center），1973 年完成 Xerox Alto 计算机。 1981 年的 Xerox Star system，史蒂夫·乔布斯去施乐参观，所见即所得 WYSIWYG，1983 年推出 Apple Lisa，1984 年推出 Macintosh。 微软则在 1985 年推出 Windows 1.0，之后出到 3.1，1995 年推出 Windows 95 提供图形界面，1995 年微软失败的 Microsoft Bob。 十四、冷战、消费主义和个人计算机发展范内瓦·布什预见了计算机的潜力，提出假想机器 Memex，帮助建立国家科学基金会，给科学研究提供资金。 1950 年代消费者开始买晶体管设备，收音机大卖，日本取得晶体管授权后，索尼做了晶体管收音机，为日本半导体行业崛起埋下种子。 苏联 1961 年把宇航员加加林送上太空，导致美国提出登月，NASA 预算大大增加，用集成电路来制作登月计算机，集成电路的发展实际上是由军事应用大大推进的，阿波罗登月毕竟只有 17 次，美国造超级计算机进一步推进集成电路。 美国半导体行业一开始靠政府高利润合同活着，忽略消费者市场，1970 年代冷战渐消，行业开始衰败，很多公司倒闭，英特尔转型处理器，政府和消费者推动了计算机的发展，早期靠政府资金，让技术发展到足够商用，然后消费者购买商用产品继续推动产品发展。 1970 年代初成本下降，个人计算机变得可行，Altair 8800 大卖。比尔·盖茨和保罗·艾伦写了 BASIC 解释器，乔布斯提议卖组装好的计算机，Apple-I 诞生。1977 年出现 3 款开箱即用计算机：Apple-II、TRS-80 Model I、Commodore PET 2001。 IBM 意识到个人计算机市场，IBM PC 发布，采用开放架构，兼容的机器都叫 IBM Compatible（IBM 兼容），生态系统产生雪球效应：因为用户多，软硬件开发人员更愿意花精力在这个平台，因为软硬件多，用户也更乐意买 “IBM 兼容” 的计算机。苹果选封闭架构，一切都自己来，只有苹果在非 “IBM 兼容” 下保持了足够市场份额。 十五、2D 图形和3D 图形显示屏幕对于临时值的表现比纸张打印好太多，所以人们把键盘和显示器分开，屏幕显示临时值。（PDP-1 计算机）。 阴极射线管（Cathode Ray Tube(CRT)），有两种绘图方式：1、矢量扫描（Vector Scanning），2、光栅扫描（Raster Scanning）。 其他显示有关：液晶显示器（Liquid Crystal Displays (LCD)）、像素（Pixel））、字符生成器（Character generator）、屏幕缓冲区（Screen buffer）、矢量命令画图、Sketchpad、光笔（Light pen）、函数画线、矩形。 3D 投影包括：线框渲染（Wireframe Rendering）、正交投影（Orthographic Projection）、透视投射（Perspective Projection）。 相对于网格（Mesh），三角形更常用因为能定义唯一的平面，扫描线渲染（Scanline Rendering）。 为了处理遮挡（Occlusion），使用画家算法（Painter’s Algorithm）、深度缓冲 Z Buffering、Z Fighting 错误出现穿模。 其他处理：背面剔除（Back Face Culling）、表面法线（Surface Normal）、平面着色（Flat Shading）、高洛德着色（Gouraud shading）, 冯氏着色（Phong Shading）、纹理映射（Texture Mapping）。 图形处理单元 GPU（Graphics Processing Unit）。 十六、计算机网络和互联网局域网 LAN（Local Area Networks），最著名的是 1970 年代的以太网，需要每个电脑（网卡）有独立的媒体访问控制地址 MAC（Media Access Control address），载波侦听多路访问 CSMA（Carrier Sense Multiple Access）是多电脑共享的传输媒介，传输速度用带宽（bandwidth）表示。 多线路的冲突使用指数退避（Exponential Backoff），同时分组、引入交换机减少冲突域（Collision Domain）的范围。 电路交换（Circuit Switching）、报文交换（Message Switching）、分组交换（Packet Switching）、阻塞控制、ICMP、BGP。 IP 互联网协议（Internet Protocol），负责把数据包送到正确的计算机。UDP 用户数据报协议（User Datagram Protocol）在数据包中跟在 IP 之后，负责把数据包送到正确的程序。UDP 头部包含校验数（Checksum）。 但是要保证所有数据必须到达，则要使用 TCP 传输控制协议（Transmission Control Protocol），含有序号，发送确认码，调整传输率。 IP 地址复杂难记，DNS 域名系统（Domain Name System），分为 TLD、二级域名、子域名。 OSI 开放式系统互联通信参考模型（Open System Interconnection）从下至上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用程序层。 超链接（Hyperlinks）形成巨大的网络：万维网。 URL 统一资源定位器（Uniform Resource Locator）、HTTP 超文本传输协议（HyperText Transfer Protocol）定位服务器中的内容。 HTML 超文本标记语言（HyperText Markup Language）。 第一个浏览器和服务器是 Tim Berners-Lee 花了 2 个月在 CERN 写的，1991 年正式发布，万维网就此诞生。 Jerry 和 David 的万维网指南 后来改名成 Yahoo，其他搜索引擎：JumpStation、Google。 网络中立性：平等对待所有数据包。 十七、计算机安全与黑客攻击计算机安全三大要素：保密性, 完整性, 可用性（Secrecy, Integrity, Availability）。 使用威胁模型（Threat Model）模拟黑客攻击。 身份验证（Authentication）的三种方式：What you know、What you have、What you are。 访问控制（Access Control）：公开、机密/只读、可写、完全控制，例如美国国防部的 Bell LaPadula model 不能向上读取，不能向下写入。 安全内核、隔离（Isolation）：沙盒（Sandbox）建立在虚拟机上。 社会工程学（Social Engineering）：钓鱼（Phishing）、假托（Pretexting）、木马（Trojan Horses）。 NAND 镜像（NAND Mirroring）：物理连接复制内存，覆盖错误。 漏洞利用（Exploit）在远程端：利用缓冲区溢出（Buffer Overflow），通过边界检查（Bounds Checking）可以避免。 代码注入（Code Injection）植入 bug。 零日漏洞（Zero Day Vulnerability）是发现后立即被恶意利用的安全漏洞。 计算机蠕虫（Worms）、僵尸网络（Botnet）、拒绝服务攻击（DDoS）。 十八、加密多层防御（Defence in depth）：加密（Encryption）、解密（Decryption）。 替换加密（Substitution cipher）、移位加密（Permutation cipher）：如凯撒加密（Caesar cipher）：字母向前移位 3 位。 列移位加密（Columnar transposition cipher）：读取方向和列表大小。 德国 Enigma 加密机，利用转子替换加密。 IBM 和 NSA1977 年制定数据加密标准（Data Encryption Standard (DES)）。 2001 年出现高级加密标准（Advanced Encryption Standard (AES)）。 密钥交换（Key exchange）：单向函数和密钥加密、迪菲-赫尔曼密钥交换（Diffie-Hellman Key Exchange）属于对称加密。 非对称加密（Asymmetric encryption）只能加密不能解密或只能解密不能加密、非对称加密算法（RSA）。 十九、机器学习与人工智能分类（Classification）：使用分类器（Classifier）辨别特征（Feature），再标记数据（Labeled data）记录。 数据分析会出现决策边界（Decision boundaries）、混淆矩阵（Confusion matrix）、未标签数据（Unlabeled data）。 决策树（Decision tree）是机器学习算法的一种。还有支持向量机（Support Vector Machines）都源于统计学。 人工神经网络（Artificial Neural Network）和深度学习（Deep learning）。 弱 AI/窄 AI（Weak AI/Narrow AI）复杂但只能做一件事，强 AI（Strong AI）接近人类智能。强化学习（Reinforcement Learning）：和人类学习方式类似。 二十、计算机视觉计算机视觉算法：检验颜色/垂直边缘。 核/过滤器（kernel or filter）包含做像素乘法的数字、卷积（convolution）。 Prewitt 算子（Prewitt Operators）、维奥拉·琼斯人脸检测（Viola-Jones Face Detection）、卷积神经网络（Convolutional Neural Networks）。 情感识别算法在识别出脸之后，可以进一步用其他算法定位面部标志，如眼睛和眉毛具体位置，从而判断心情等信息，也可用其他算法跟踪全身的标记点，如肩部，手臂等。 二十一、自然语言处理（NLP） 把句子分块，区分出词性（Parts of speech）、短语结构规则（Phrase structure rules）。 分析树（Parse tree）、知识图谱。 语音识别（Speech recognition）：谱图（Spectrogram）、快速傅立叶变换（Fast Fourier Transform）。 音素（Phonemes）识别、语音合成（Speech Synthesis）。 二十二、机器人和计算机心理学机器人早期雏形：法国吃饭鸭（Digesting Duck, Canard Digerateur）、土耳其行棋傀儡下国际象棋。 第一台计算机控制的机器出现在 1940 年代晚期，叫数控机器（Computer Numerical Control(CNC)）。 1960 年 Unimate 是第一个商业贩卖的可编程工业机器人。 简单控制回路（simple control loop）、负反馈回路（negative feedback loop）。 比例-积分-微分控制器（Proportional–Integral–Derivative controller）即 PID 控制器。 机器人三定律（Three Laws of Robotics）。 我们需要了解人类心理学，做出更好的计算机。 易用度（Usability）：颜色强度排序比颜色排序好，分组更好记，电话号码 317-555-3897 比 3175553897 好记。 直观功能（Affordances）：认出 vs 回想（Recognition vs Recall）、Facebook 研究正面情绪影响。 用软件修正注视位置，让视频通话时看起来像盯着对方，而不是盯着下方。 让机器有一定情商，把机器人做的像人，恐怖谷理论。 计算机心理学有很多开放式的问题，心理学帮助我们明白不同选择可能带来的影响。 二十三、教育科技和计算机的未来大型开放式在线课程（Massive Open Online Courses (MOOC)）。 智能辅导系统（Intelligent Tutoring Systems）：判断规则（Production rule）、域模型（Domain Model）、贝叶斯知识追踪（Bayesian knowledge tracing）：学生已经学会的概率、瞎猜的概率、失误的概率、做题过程中学会的概率、教育数据挖掘（Educational Data Mining）。 普适计算（Ubiquitous Computing）的愿景。 奇点（Singularity）：冯诺依曼提出，计算机发展爆炸性增长。 把工作分为 4 个象限，讨论自动化带来的影响。 机器人的存在时间可能长过人类，可以长时间探索宇宙。","categories":[{"name":"计算机科学与技术","slug":"计算机科学与技术","permalink":"http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"经济学原理","slug":"经济学原理","date":"2020-01-31T16:00:00.000Z","updated":"2022-05-05T13:07:52.522Z","comments":true,"path":"经济学原理/","link":"","permalink":"http://blog.zhuangzhihao.top/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/","excerpt":"经济学原理是经管类学生的一门基础核心课程，基本理论通常分为微观经济学与宏观经济学两大部分，主要介绍经济学的基本概念、基本理论和基本分析方法。经济学通才保罗·萨缪尔森说过：“在当今社会，谁不学习经济学，谁就不懂得怎样生活”。学习经济学原理知识有助于培养对现实生活中经济行为与经济现象的观察能力，了解现实世界的运作，训练经济学直觉。","text":"经济学原理是经管类学生的一门基础核心课程，基本理论通常分为微观经济学与宏观经济学两大部分，主要介绍经济学的基本概念、基本理论和基本分析方法。经济学通才保罗·萨缪尔森说过：“在当今社会，谁不学习经济学，谁就不懂得怎样生活”。学习经济学原理知识有助于培养对现实生活中经济行为与经济现象的观察能力，了解现实世界的运作，训练经济学直觉。 微观经济学经济名词概念 稀缺性：社会拥有的资源是有限的，因此不能生产人们希望拥有的所有物品与劳务。 经济学：研究社会如何管理自己的稀缺资源。 经济学家研究：人们如何作出决策、人们如何相互交易、影响整体经济的力量和趋势。 效率：社会能从其稀缺资源中得到最大利益的特性。 平等：经济成果在社会成员中平均分配的特性。 效率：经济蛋糕的大小，而平等则是指如何分割这块蛋糕。 机会成本：为了得到某种东西所必须放弃的东西。 理性人：系统而有目的地尽最大努力实现其目标的人。 边际变动 对行动计划的微小增量调整。 理性人通常通过比较边际利益与边际成本来做出决策。当且仅当一种行为的 边际利益 ＞ 边际成本 时，一个理性决策者才会采取这种行动。 激励：引起一个人做出某种行为的某种东西。激励在经济学中起着中心作用。 市场经济：当许多企业和家庭在物品与劳务市场上相互交易时，通过它们的分散决策配置资源的经济。 价格：“看不见的手”，用来指引经济活动的工具。 产权：个人拥有并控制稀缺资源的能力。产权包括所有权，使用权，处置权，收益权。 市场失灵 市场本身不能有效配置资源的情况 市场失灵的原因：垄断、信息不对称、外部性、市场势力。 外部性：一个人的行为对旁观者福利的影响。 市场势力：单个或一小群经济活动者对市场价格有显著影响的能力。 生产率：每一单位劳动投入所生产的物品与劳务数量。生产率取决于设备，劳动者的技能以及可用的技术。 通货膨胀：经济中物价总水平的上升。 经济周期：就业和生产等经济活动的波动。 经济学十大原理 人们面临权衡取舍 某种东西的成本是为了得到它所放弃的东西 理性人考虑边际量 人们会对激励做出反应 贸易可以使每个人的状况都变得更好 市场通常是组织经济活动的一种好办法 政府有时可以改善市场结果 一国的生活水平取决于它生产物品与劳务的能力 当政府发行了过多货币时，物价上升 社会面临通货膨胀与失业之间的短期权衡取舍 像经济学家一样思考 循环流向图：说明货币如何通过市场在家庭与企业之间流动的直观经济模型。 生产可能性边界 表示在可得到的生产要素与生产技术既定时，一个经济所能生产的产品数量的各种组合的图形。 生产可能性边界表明在某一特定时期内生产不同物品之间的权衡取舍，但随着时间的推移，这种权衡取舍可以改变。 微观经济学：研究家庭和企业如何做出决策，以及它们如何在市场上相互交易。 宏观经济学：研究整体经济现象，包括通货膨胀、失业和经济增长。 实证表述：试图描述世界是什么样子的观点。（描述性的） 规范表述：试图描述世界应该是什么样子的观点。（规范性的） 相互依存性与贸易的好处 绝对优势：用比另一个生产者更少的投入生产某种物品的能力。 机会成本：为了得到某样东西而必须放弃的东西。 比较优势：一个生产者以低于另一个生产者的机会成本生产一种物品的行为。 学会运用比较优势原理分析交易的机会成本：当每个人专门生产自己有比较优势的物品时，经济的总产量就增加了。贸易可以使社会上每个人都获益，因为它使人们可以专门从事他们具有比较优势的活动。 进口品：在国外生产而在国内销售的物品。 出口品：在国内生产而在国外销售的物品。 供给与需求的市场力量 市场：由某种物品或劳务的买者与卖者组成的一个群体。 竞争市场：有许多买者与卖者，以至于每个人对市场价格的影响都微乎其微的市场。 完全竞争市场必须具备两个特征： 可供销售的物品时完全相同的 买者和卖者人数众多，以至于没有任何一个买者或卖者可以影响市场价格 需求量：买者愿意并且能够购买的一种物品的数量。 需求定理：认为在其他条件不变时，一种物品的价格上升，对该物品的需求量减少的观点。 需求表：表示一种物品的价格与需求量之间关系的表格。 需求曲线：表示一种物品的价格与需求量之间关系的图形。 正常物品：在其他条件相同时，收入增加引起需求量增加的物品。 低档物品：在其他条件相同时，收入增加引起需求量减少的物品。 替代品：一种物品价格上升引起另一种物品需求量增加的两种物品。 互补品：一种物品价格上升引起另一种物品需求量减少的两种物品。 影响买者的变量：价格、收入、相关物品的价格、嗜好、预期、买者的数量。 商品本身的价格是影响需求量的因素，价格变动表现为沿着需求曲线的变动。其它都是影响需求的因素，其变动使需求曲线移动。 供给量：卖者愿意并且能够出售的一种物品的数量。 供给定理：认为在其他条件不变时，一种物品价格上升，该物品供给量增加的观点。 供给表：表示一种物品的价格与供给量之间关系的表格。 供给曲线：表示一种物品的价格与供给量之间关系的图形。 影响卖者的变量： 价格、投入品价格、技术、预期、卖者的数量 商品本身的价格，变动表现为沿着供给曲线的变动 其他变量的变动将使供给曲线移动 均衡：市场价格达到使供给量与需求量相等的水平时的状态。 均衡价格：使供给与需求平衡的价格。 均衡数量：均衡价格下的供给量与需求量。 过剩：供给量＞需求量的状态。 短缺：需求量＞供给量的状态。 供求定理：任何一种物品价格的调整都会使该物品的供给与需求达到平衡。 分析均衡变动的三个步骤： 确定该事件是使供给曲线移动还是使需求曲线移动（还是使两者都移动） 确定曲线移动的方向 用供求图说明这种移动如何改变均衡价格和均衡数量 当供给或需求变动时，价格和数量会发生什么变动 | | 供给未变 | 供给增加 | 供给减少 | | ———— | ————————- | —————————- | —————————- | | 需求未变 | 价格相同 数量相同 | 价格下降 数量增加 | 价格上升 数量减少 | | 需求增加 | 价格上升 数量增加 | 价格不确定 数量增加 | 价格上升 数量不确定 | | 需求减少 | 价格下降 数量减少 | 价格下降 数量不确定 | 价格不确定 数量减少 | 弹性及其应用 弹性：衡量需求量或供给量对其某种决定因素的反应程度的指标。 需求价格弹性：衡量一种物品需求量对其价格变动反应程度的指标。 需求价格弹性 = 需求量变动百分比 ÷ 价格变动百分比 决定需求价格弹性的因素：相近替代品的可获得性、必需品与奢侈品、市场的定义、时间框架。 需求收入弹性：衡量一种物品需求量对消费者收入变动反应程度的指标。 需求收入弹性 = 需求量变动百分比 ÷ 收入变动百分比 需求的交叉价格弹性：衡量一种物品需求量对另一种物品价格变动的反应程度的指标。 需求的交叉价格弹性 = 物品 1 的需求量变动百分比 ÷ 物品 2 的价格变动百分比 供给价格弹性：衡量一种物品供给量对其价格变动反应程度的指标。 供给价格弹性 = 供给量变动百分比 ÷ 价格变动百分比 总收益：一种物品的买者支付从而卖者得到的量。 总收益 = 该物品的价格 × 销售量 （P×Q） 利用弹性的定义计算价格或需求量的变动 需求价格弹性的中点法 理解需求曲线形状与弹性的关系，以及弹性与总收入之间的关系 Ep &gt; 1 富有弹性 曲线平坦 降价销售可以增加销售收入 Ep &lt; 1 缺乏弹性 曲线陡峭 提价销售才能增加销售收入 但是，由于同一条直线上弹性值不同，这就决定了在陡峭的曲线的上部，降价也能增加销售收入，反之，在平坦曲线的下部，降价则要减少销售收入。 Ep = 1 单位弹性 价格变动，总收益不动 Ep = 0 完全无弹性，一条垂线 Ep = ∞ 完全富有弹性，一条水平线 “谷贱伤农”的含义：当粮食供给增加，导致价格下降时，也导致了销售量的增加。但因为粮食的需求缺乏弹性，所以价格下降的幅度大于销售量增加的幅度，所以总收益下降。 供给、需求与政府政策 价格上限：出售一种物品的法定最高价格。 价格下限：出售一种物品的法定最低价格。 价格上限与下限对市场结果的影响：当政府对竞争市场实行限制性价格上限时，就产生了物品的短缺，而且，卖者必须在大量潜在买者中配给稀缺物品。 价格下限引起了过剩。 税收归宿：税收负担在市场参与者之间进行分配的方式。 学会利用供求模型分析税收对买方价格和卖方价格的影响 税收抑制了市场活动。当对一种物品征税时，该物品在新均衡时的销售量减少了。 买者与卖者分摊了税收负担。在新均衡时，买者为该物品支付的更多了，而卖者得到的更少了。 对买者征税和对卖者征税是相同的。唯一区别是谁把钱交给政府。 理解供求曲线的弹性与税收负担之间的关系 税收归宿取决于供给和需求的弹性，税收负担更多得落在缺乏弹性的市场一方身上。 因为，在本质上，弹性衡量当条件变得不利时，买者或卖者离开市场的意愿。 需求弹性小意味着买者对消这某种物品没有适当的替代品。供给弹性小意味着卖者对生产这某种物品没有适当的替代品。 当对这种物品征税时，市场中其他好的选择少的一方不能轻而易举地离开市场，从而必须承担更多的税收负担。 消费者、生产者与市场效率 福利经济学：研究资源配置如何影响经济福利的一门学问。 掌握支付意愿、消费者剩余、生产者剩余以及总剩余等概念 支付意愿：买者愿意为某种物品支付的最高量。 消费者剩余：买者愿意为一种物品支付的量减去其为此实际支付的量。（=买者的支付意愿—市场价格） 需求曲线以下和价格以上的面积衡量一个市场上的消费者剩余。反映了经济福利。 成本：卖者为了生产一种物品而必须放弃的每种东西的价值。 生产者剩余：卖者出售一种物品得到的量减去其生产成本。（=市场价格—卖者成本） 价格之下和供给曲线以上的面积衡量一个市场上的生产者剩余。 总剩余：两者消费者剩余和生产者剩余的总和（=买者的支付意愿—卖者成本）是供给曲线和需求曲线到均衡数量之间的面积。 理解经济效率的含义 效率：资源配置使社会所有成员得到的总剩余最大化的性质。 平等：在社会成员中平均地分配经济成果的特性。 关于市场结果的观点： 自由市场把物品的供给分配給对这些物品评价最高的买者，这种评价用买者的支付意愿来衡量 自由市场把物品的需求分配給可以以最低成本生产这些物品的卖者 自由市场生产使消费者和生产者剩余总和最大化的产量，均衡结果是资源的有效配置。 学会利用供求曲线衡量消费者剩余与生产者剩余及其变动 市场均衡时的消费者剩余与生产者剩余 赋税的代价 无谓损失：市场扭曲（例如税收）引起的总剩余减少。 税收引起无谓损失是因为它使买者和卖者不能实现某些贸易的好处。 贸易的好处——买者评价与卖者成本之间的差额——小于税收。一旦征税，这些贸易就无法进行。无谓损失就是由于税收阻止了这些互利的贸易而引起的剩余损失。 税收引起无谓损失是因为它使买者和卖者不能实现某些贸易的好处。由于供给和需曲弹性衡量市场参与者对市场状况的反应程度，所以供给和需求的弹性越大，税收的无谓损失也就越大。 随着税收规模提高，无谓损失的增加越来越快，且快于税收规模。税收收入起初随着税收规模扩大而增加，但最终由于高税收减少了市场规模，也就减少了税收收入。 国际贸易 世界价格：一种物品在世界市场上所通行的价格。 学会应用供求曲线分析自由贸易与关税对国内生产者剩余和消费者剩余的影响 自由贸易对出口国的影响：当一国允许贸易并成为一种物品的出口者时，国内该物品的生产者状况变好，而国内该物品的消费者状况变坏；从赢家收益超过了输家损失的意义上说，贸易使一国的经济福利增加了。 自由贸易对进口国的影响：当一国贸允许贸易并成为一种物品的进口者时，国内该物品消费者的状况变好，而国内该物品生产者的状况变坏；从赢家收益超过了输家损失的意义上说，贸易使一国的经济福利增加了。 关税：对国外生产而在国内销售的物品征收的税。 关税的影响： 关税减少了进口量，并使国内市场向没有贸易时的均衡移动。 关税会引起无谓损失，仅仅是因为它是一种税。它扭曲了激励，并使稀缺资源配置背离了最适水平 一部分是国内企业以高成本生产造成的无谓损失，一部分是消费不足的无谓损失。 国际贸易的其他利益：增加了物品的多样性，通过规模经济降低了成本，增加了竞争，加强了思想交流。 外部性 理解正外部性、负外部性的含义及其对资源配置的影响 外部性：一个人的行为对旁观者福利的无补偿的影响。 外部性有负，也有正，前者增加别人的福利，后者减少别人的福利。 负外部性：社会成本大于私人成本，社会最适量小于私人市场决定的数量，征税 正外部性：社会价值大于私人价值，社会最适量大于私人市场决定的数量，补贴 外部性的内在化：改变激励，以使人们考虑到自己行为的外部效应。 负外部性使市场生产的数量大于社会合意的数量，正外部性使市场生产的数量小于社会合意的数量。为了解决这个问题，政府可以通过对有负外部性的物品征税并给予有正外部性的物品补贴来使外部性内在化。 矫正税（庇古税）：旨在引导私人决策者考虑负外部性引起的社会成本的税收。 科斯定理：认为如果私人各方可以无成本地就资源配置进行协商，那么，他们就可以自己解决外部性问题的一个命题。 科斯定理说明，私人经济主体可以解决他们之间的外部性问题。无论最初的权利如何分配，有关各方总可以达成一种协议，在这种协议中，每个人的状况都可以变好，而且，结果是有效率的。 交易成本：各方在达成协议与遵守协议过程中所发生的成本。 公共物品和公共资源 理解公共品的经济含义（非竞争性与非排他性）以及由此引发的免费搭车问题 排他性：一种物品具有的可以阻止一个人使用该物品的特性。 消费中的竞争性：一个人使用一种物品将减少其他人对该物品的使用的特性。 根据这两个特点，把物品分成了四种类型： 私人物品：既有排他性又有竞争性的物品。 公共物品：既无排他性又无竞争性的物品。 如国防、灯塔、知识、基础研究和反贫困。 公共资源：有竞争性但无排他性的物品。 如清洁的空气和水、畅通的交通和野生动物。 自然垄断：有排他性但无竞争性的物品。 搭便车者：得到一种物品的利益但避开为此付费的人。 由于公共物品没有排他性，搭便车者问题的存在就使私人市场无法提供公共物品。但是，政府可以潜在地解决这个问题。如果政府确信一种公共物品的总利益大于成本，他就可以提供该公共物品，并用税收收入对其进行支付，从而可以使每个人的状况变好。 成本——收益分析：比较提供一种公共物品的社会成本与社会收益的研究。 公地悲剧：一个寓言，说明从整个社会的角度看，为什么公共资源的使用大于合意的水平。 税制的设计 预算赤字：政府支出大于政府收入。 预算盈余：政府收入大于政府支出。 平均税率：支付的总税收除以总收入。 边际税率：增加 1 美元收入所支付的额外税收。 定额税：对每个人等量征收的税收。 受益原则：认为人们应该根据他们从政府服务中得到的利益来纳税的思想。 支付能力原则：认为应该根据一个人可以承受的负担来对这个人征税的思想。 纵向平等：主张支付能力更强的纳税人应该缴纳更多税收的思想。 横向平等：主张有相似支付能力的纳税人应该缴纳等量税收的思想。 比例税：高收入纳税人和低收入纳税人缴纳收入中相同比例的税收。 累退税：高收入纳税人缴纳的税收在收入中的比例低于低收入纳税人的税收。 累进税：高收入纳税人缴纳的税收在收入中的比例高于低收入纳税人的税收。 生产成本 总收益：企业出售其产品所得到的货币量。 总成本：企业用于生产的投入品的市场价值。 利润：=总收益—总成本。 显性成本：需要企业支出货币的投入成本。 隐性成本：不需要企业支出货币的投入成本。 经济利润：总收益减总成本，包括显性成本与隐性成本。 会计利润：总收益减总显性成本。 生产函数：用于生产一种物品的投入量与该物品产量之间的关系。 边际产量：增加一单位投入所引起的产量增加。 边际产量递减：一种投入的边际产量随着投入量增加而减少的特征。例如：因为超过了劳动力与设备的最佳配比点，工人越多，每个新增工人的产量就越小。 成本的各种衡量指标 固定成本（FC）：不随着产量变动而变动的成本。 主要有厂房设备和管理人员的工资。 可变成本（VC）：随着产量变动而变动的成本。 主要指原材料、能源和工人的工资等。 平均总成本（ATC）：总成本除以产量。 平均固定成本（AFC）：固定成本除以产量。 平均可变成本（AVC）：可变成本除以产量。 边际成本（MC）：额外一单位产量所引起的总成本的增加。(=总成本变动量/产量变动量) 平均成本告诉我们，如果总成本在所生产的所有单位中平均分摊，普通一单位产量的成本。 边际成本告诉我们，多生产一单位产量引起的总成本变动。 有效规模：使平均总成本最小的产量。只要边际成本小于平均总成本，平均总成本就下降；只要边际成本大于平均总成本，平均总成本就上升。 边际成本曲线与平均总成本曲线相交于有效规模点。 一个典型企业的成本曲线的重要特征： 随着产量增加，边际成本最终要上升。 平均总成本曲线是 U 形的。 边际成本曲线与平均总成本曲线在平均总成本曲线的最低点相交。（有效规模） 短期成本是指至少有一个要素不变时期中的成本。 长期成本是指在所有投入要素都发生变化时期中发生的成本。长期中没有固定成本。 规模经济：长期平均总成本随产量增加而减少的特性。 规模不经济：长期平均总成本随产量增加而增加的特性。 规模收益不变：长期平均总成本在产量变动时保持不变的特性。 名称 定义 数学表述 显性成本 要求企业支出货币的成本 隐性成本 不要求企业支出货币的成本 固定成本 不随产量变动而变动的成本 FC 可变成本 随产量变动而变动的成本 VC 总成本 企业在生产中使用的所有投入的市场价值 TC=FC+VC 平均固定成本 固定成本除以产量 AFC=FC/Q 平均可变成本 可变成本除以产量 AVC=VC/Q 平均总成本 总成本除以产量 ATC=TC/Q 边际成本 多生产一单位产品所引起的总成本增加量 MC=△TC/△Q 竞争市场上的企业 竞争市场：有许多交易相同产品的买者与卖者，以至于每一个买者和卖者都是价格接受者的市场。 竞争市场的特点： 市场上有许多买者和许多卖者。 各个卖者提供的物品大体上是相同的。 企业可以自由地进入或退出市场。 平均收益：总收益除以销售量。 边际收益：增加一单位销售量引起的总收益变动。 竞争企业的短期供给曲线是边际成本曲线在平均可变成本曲线以上的那一部分。 竞争企业的长期供给曲线是边际成本曲线位于平均总成本曲线之上的那一部分。 沉没成本：已经发生而且无法收回的成本。 垄断 垄断企业：一种没有相近替代品的产品的唯一卖者的企业。 垄断产生的基本原因是进入壁垒，进入壁垒有三个主要形成条件： 垄断资源：生产所需要的关键资源由单个企业所拥有； 政府管制：政府给予单个企业排他性地生产某种物品或劳务的权利； 生产流程：某个企业能以低于大量生产者的成本生产产品。 自然垄断：由于一个企业能以低于两个或更多企业的成本向整个市场供给一种物品或劳务而产生的垄断。当相关产量范围存在规模经济时，自然垄断就产生了。 垄断者利润最大化产量是由边际收益曲线与边际成本曲线的交点决定的。 供给曲线告诉我们，企业在任何一种既定价格时选择的供给量。当我们分析作为价格接受者的竞争企业时，这个概念是有意义的。但垄断企业是价格制定者，而不是价格接受者。企业在选择供给量的同时确定价格。 实际上，垄断者关于供给多少的决策不可能与它所面临的需求曲线分开。需求曲线的形状决定边际收益曲线的形状，边际收益曲线的形状又决定了垄断者的利润最大化产量。在竞争市场上，可以在不了解需求曲线的情况下分析供给决策，但在垄断市场上，这是不正确的。因此，我们从不谈论垄断者的供给曲线。 竞争与垄断 竞争 垄断 相似之处 企业目标 利润最大化 最大化原则 MR=MC 短期中能赚到经济利润吗？ 能 不同之处 企业数量 许多 一家 边际收益 MR=P MR&lt;P 价格 P=MC P&gt;MC 有生产者福利最大化的产量水平吗? 有 没有 长期中能进入吗？ 能 不能 长期中能赚到经济利润吗？ 不能 能 有价格歧视的可能吗？ 没有 有 价格歧视：以不同价格向不同顾客出售同一种物品的经营做法。 价格歧视能增加垄断者的利润，可能减少无谓损失。通过使一些本来不想购买的消费者得到物品而增加经济福利。 垄断竞争 寡头：只有几个提供相似或相同产品的卖者的市场结构。 垄断竞争：存在许多出售相似但不相同产品的企业的市场结构。 垄断竞争描述了具有以下特征的市场： 许多卖者：有许多企业争夺相同的顾客群体 产品差别：每个企业生产的一种产品至少与其他企业生产的这种产品略有不同。因此每个企业不是价格接受者，而是面临一条向右下方倾斜的需求曲线 自由进入和退出：企业可以无限制地进入或退出一个市场。因此，市场上企业的数量要一直调整到经济利润为零时为止 垄断竞争：在完全竞争与垄断之间 市场结构 完全竞争 垄断竞争 垄断 所有这三种结构的特征 企业目标 利润最大化 最大化规则 MR=MC 短期中能赚到经济利润吗？ 能 垄断和垄断竞争共同的特征 是价格接受者吗？ 是 不是 不是 价格 P=MC P&gt;MC P&gt;MC 能生产福利最大化的产量水平吗？ 能 不能 不能 完全竞争与垄断竞争共同的特征 企业数量 许多 许多 一家 长期中能进入吗？ 能 能 不能 长期中能赚到经济利润吗？ 不能 不能 能 市场结构的四种类型 垄断 寡头 垄断竞争 完全竞争 ·自来水 ·有线电视 ·网球 ·烟草 ·小说 ·电影 ·小麦 ·牛奶 寡头 寡头：只有少数几个卖者提供相似或相同产品的市场结构。 博弈论：研究在策略状况下人们如何行为。 勾结：一个市场上的企业之间就生产的产量或收取的价格达成的协议。 卡特尔：联合起来行事的企业集团。 纳什均衡：相互作用的经济主体在假定所有其他主体所选策略为既定的情况下选择自己最优策略的状态。 当寡头企业单独地选择利润最大化的产量时，它们生产的产量大于垄断但小于竞争的产量水平。寡头价格低于垄断价格，但高于竞争价格（竞争价格等于边际成本） 随着寡头市场上卖者数量增加，寡头市场就越来越像竞争市场，其价格接近于边际成本，生产量接近于对社会有效率的水平。 囚徒困境：两个被捕的囚徒之间的一种特殊“博弈”，说明为什么甚至在合作对双方都有利时，保持合作也是困难的。 占优策略：无论其他参与者选择什么策略，对一个参与者都为最优的策略。 宏观经济学GDP 和 CPI 掌握消费物价指数（CPI）与生产物价指数（PPI）的计算方法； 通货膨胀：指经济中物价总水平的上升 消费物价指数（CPI）：普通消费者购买的物品与劳务总费用的衡量指标。每年一篮子物品与劳务的价格要除以基年一篮子物品与劳务的价格，然后把这个比率乘以 100，所得出的数字就是消费物价指数。 通货膨胀率：从前一个时期以来物价总水平变动的百分比 第二年通胀率 = （第二年 CPI - 第一年 CPI）/ 第一年 CPI 生产物价指数（PPI）：企业购买的一篮子物品与劳务的费用的衡量指标。由于企业最终要把它们的费用以更高消费价格的形式转移给消费者，所以生产物价指数变动将领先于消费物价指数，因此可以预测消费物价指数的变动。 理解 CPI 是高估还是低估生活费用？为什么？ 替代倾向。一篮子的数量权重不变，但实际上便宜物品一直在替代昂贵物品，CPI 高估了从某一年到下一年生活费用的增加。 新产品的引进。新产品的出现并不能在一篮子物品中反映出来，所以物价指数不能反映公众享受到的福利。 无法衡量的质量变动。物品质量变动不能在货币价值中反映出来，物价指数不能反映生活质量的变动。 因此，CPI 高估了真实的通货膨胀。 了解 CPI 与 GDP 平减指数的差异 消费物价指数与 GDP 平减指数的变动并不完全一致，因为前者只指消费者的支出，后者指所有的商品和劳务，进口影响消费物价指数而不影响 GDP 平减指数；且两者的权重不同，GDP 平减指数一直随 GDP 构成的变动而自动地改变物品与劳务的组合，而消费物价指数用固定的一篮子物品。 指数化：当一美元购买力根据法律或合约自动按照通货膨胀校正时被称为通货膨胀的指数化。 掌握生产率的含义以及决定生产率的各种要素 生产率：一个工人每小时工作时间所生产的物品与劳务的数量。 生产率的决定因素：物质资本、人力资本、自然资源和技术知识 物质资本：用于生产物品与劳务的设备与建筑物存量 人力资本：工人通过教育、培训和经验而获得的知识与技能 自然资源：由自然界提供的用于生产物品与劳务的投入，如土地、河流和矿藏。 技术知识：社会对生产物品与劳务的最好方法的了解。 理解“一个国家的生活水平取决于生产物品和劳务的能力”的原理 一个经济的国内生产总值（GDP）同时衡量经济中所有人赚到的总收入和经济中物品与劳务产量的总支出。一个经济的收入是该经济的产出。一个国家只有生产出大量物品与劳务，它才能享有更高的生活水平。 金融体系和金融工具 了解金融市场的类型与主要参与者 金融体系：经济中促使一个人的储蓄与另一个人的投资相匹配的一组机构 金融机构分为两种类型——金融市场和金融中介机构 金融市场：储蓄者可以通过它直接向借款人提供资金的金融机构。两种最重要的金融市场是债券市场和股票市场。 债券市场：专门交易企业债券和政府债券的市场 债券：一种债务证明书，规定借款人对债券持有人负有债务责任的证明。 债券的三个特点： 期限——债券到期之前的时间长度。债券的利率部分取决于它的期限，长期债券风险高、利率高。 信用风险——借款人不能支付某些利息或本金的可能性，这种不能支付成为拖欠。 税收待遇——税法对待债券所赚到的利息的方式 股票市场：专门买卖股票的市场 股票：代表企业的所有权，也代表对企业所获得利润的索取权。与债券相比，股票既提供高风险，又提供潜在的高收益。股票市场上股票交易的价格是由其供求状况决定的。由于股票代表公司所有权，所以，股票的需求（以及其价格）反映了人们对公司未来盈利性的预期。 股票指数：计算一组股票价格的平均数，可用于监视整个股票价格水平。 企业筹资出售股票为股本筹资；出售债券为债务筹资。 金融中介机构：储蓄者可以间接地向借款者提供资金的金融机构，它们是借贷双方的中介和桥梁。两种最重要的金融中介机构——银行和共同基金。 银行：吸收储蓄者的存款贷放给借款人，赚取存贷款利差。银行可以给存款人提供支票，作为交换媒介进行交易。 共同基金：是一个向公众出售股份，并用收入来购买各种股票、债券、或者它们的某种组合的机构。共同基金持有人接受这种资产组合相关的所有风险与收益。如果资产组合价值上升，持股人受益；反之则损失。 共同基金的优点：可以使钱不多的人也能进行多元化投资，降低风险；可以使普通人享有专业资金管理者的服务。 理解国民收入帐户恒等式以及储蓄和投资的含义（它适用于每个家庭和企业吗？）； 重要的恒等式 Y=C+I+G+NX 封闭经济（不与其他经济交易的经济）的净出口等于零，所以 Y=C+I+G 对此等式移项，得 Y-C-G=I 等式左端是在消费和政府购买之后留下的总收入，称为国民储蓄（简称储蓄）， 所以该式又可以表达为 S=I 储蓄等于投资 也可以是 S=Y-C-G 或者 S=（Y-T-C）+（T-G）储蓄因此等于私人储蓄与公共储蓄之和 私人储蓄（Y-T-C）是家庭在支付了税收和消费之后剩下的收入量 公共储蓄（T-G）是政府在支付其花费后剩下来的税收收入量，政府税收大于支出为预算盈余，反之则为预算赤字。 该等式表明通过金融市场可以在整体上实现社会的储蓄等于投资。 储蓄等于投资的机制：个人存款银行或买股票的储蓄未必等于另一个人购买厂房设备的投资，但是，投资者可以通过金融机构借到不足的资金，这就能在总量上实现投资等于储蓄。 理解可贷资金市场的供给（储蓄）和需求（投资）及其均衡； 可贷资金市场：假定存在这样一个市场，所有的储蓄都进入这个市场，所有的投资都借自这个市场。这个市场的利率既是储蓄的收益，又是借款的成本。 可贷资金：人们选择储蓄并贷出不用于自己消费的所有收入。 可贷资金市场的供给与需求：供给来自那些有额外收入，并想储蓄和贷出的人。其方式可以是直接的买债券，也可以是间接的存款。需求来自希望借款进行投资的家庭和企业，包括抵押贷款购置住房或购买设备建立工厂。 可贷资金的供求取决于实际利率。· 挤出：由于政府借款所引起的投资减少 能够利用供求曲线分析各类政策（譬如，存款利息政策）对可贷资金市场均衡的影响 掌握用现值来衡量货币的时间价值，掌握风险的概念并区分特有风险、总风险 金融学：研究在一定时期内，如何配置资源和应对风险，作出决策的学科。 现值：用现行利率带来一定量未来货币所需要的现在货币量。 现值的概念说明：接受现在一定量货币比接受未来等量货币更为可取；不同时点上的货币价值的比较要转换成现值进行。如果一个项目的现值超过成本，企业就应该投资这个项目。 货币的时间价值是按照复利计算的，其公式为 FV=PV（1+r）t 如果将未来的货币转换成现在的货币，其公式为 PV=FV/（1+r）t 风险厌恶：对坏事的厌恶大于对可比的好事的喜欢，边际效用递减 多元化：通过用大量不相关的小风险代替一种风险来减少风险。 特有风险：只影响一个经济主体的风险 总风险：同时影响所有经济主体的风险 股票有价证券的风险随股票数量的增加而大大降低，但完全消除风险是不可能的。多元化可以消除特有风险——与某公司相关的不确定性，但是不能消除总风险——与影响所有公司的整个经济相关的不确定性。 投入股票越多，风险和收益就越大。 失业 理解政府是如何统计劳动力与失业指标的； 劳动力（成年人）= 就业人数 + 失业人数 失业率=失业人数 /（就业人数 + 失业人数） 劳动力参工率=劳动力 / 成年人口 失业指标并没有反映所有的失业者，特别是那些没有工作，找不到工作失去信心的工人，没有反映在失业统计中。失业大多是短期的，而在任何一个时间所观察到的大多数失业是长期的。经济中大部分失业问题是由少数长期没有工作的工人造成的。 注意区分自然失业、周期性失业以及摩擦性失业、结构性失业等概念； 正常失业率就是自然失业，它为劳动力市场的不完善所造成，可以分成摩擦性失业、求职性失业、结构性失业、技术性失业、季节性失业和古典性失业。 周期性失业：与自然失业率背离的失业，它为总需求不足所造成。 摩擦性失业：由于工人找到最适于自己嗜好和技能的工作需要时间而引起的失业。解释较短的失业持续时间。摩擦性失业不可避免，因为经济在发展，产业结构在调整，劳动力也要随之在不同产业之间转移，这个转移的过程就是摩擦性失业。 失业保障：当工人失业时为他们提供部分收入保护的政府计划。这在一定程度上提高了摩擦性失业，因为工人缺乏足够的就业刺激。 结构性失业：由于某些劳动市场上可得到的工作岗位数量不足以为每个想工作的人提供工作而引起的失业。解释较长的失业持续时间。当工资由于某些原因高于使供求均衡的水平时，就产生了这种失业。高于均衡工资的三个可能原因：最低工资法、工会和效率工资。 工会：与雇主就工资和工作条件进行谈判的工人协会。工会通过集体谈判和罢工，将工资提高得超过均衡水平，从而使就业的局内人得到好处，没有就业的局外人承受损失。工会的存在既有提高工资，造成资源配置低效率的一面；也有保护工人利益，形成乐观有效的工人队伍的一面。 了解最低工资法是如何造成古典性失业的； 了解效率工资理论。 效率工资：企业为了提高工人生产率而支付的高于均衡水平的工资。效率工资高于均衡水平，它在增加企业成本的同时，也提高了效率；而且高效率的收益大于工资成本的上升。效率工资有利于工人的健康，降低工人的流动性，提高工人的努力程度，可以选择高素质的工人。 货币制度 理解货币的含义和货币的三项职能； 货币：经济中人们经常用于向其他人购买物品与劳务的一组资产。 货币的三种职能：交换媒介、计价单位和价值储藏。 交换媒介：当买者在购买物品与劳务时给予卖者的东西 计价单位：人们用来表示价格和记录债务的标准 价值储藏：人们可以用来把现在的购买力转变为未来的购买力的东西 流动性：一种资产可以兑换为经济中交换媒介的容易程度。货币是最具流动性的资产。 商品货币：以有内在价值的商品为形式的货币。（黄金、香烟） 法定货币：没有内在价值、由政府法令而作为通货使用的货币。（纸币美元） 美国经济中的货币主要有现金和支票。信用卡不包括在货币量的所有衡量中，结算卡上的账户余额包括在货币量的衡量中。 现金：公众手中持有的纸币钞票和铸币 活期存款：储户可以随时开支票的银行账户余额 理解货币的创造过程与乘数效应，并能计算货币乘数与货币供给量； 准备金：银行得到但没有贷出去的存款。 准备率：银行作为准备金持有的存款比例。美联储规定银行持有的准备金量的最低水平，称为法定准备金率。银行可以持有高于法定最低量的准备金，称为超额准备金。 货币乘数：银行体系用 1 美元准备金所产生的货币量。是准备率的倒数 M = 1/R，所以银行创造多少货币量取决于准备率。 了解美联储管理货币供给的三个主要工具：公开市场活动、准备金率、贴现率 。 中央银行：为了监督银行体系和调节经济中货币量而设计的机构。 公开市场活动：美联储买卖美国政府债券。是最常用的货币政策工具。中央银行高价买进国债，收益率下降，货币供给量增加，利率下降；反之中央银行低价卖出国债，利率上升，货币供给量减少。 法定准备金：关于银行必须根据其存款持有的最低准备金量的规定。在繁荣时期，提高准备金率，货币乘数缩小，货币供给减少，可以防止经济的过热；在萧条时期，降低准备率，货币乘数扩大，货币供给增加，可以促使经济回暖。其长处是作用速度快，影响所有有关金融机构，有明确的告示效应。其短处则是作用效果太强烈，无法经常灵活地逆向调控。 贴现率：美联储向银行发放贷款的利率。中央银行提高贴现率，减少基础货币供给，提高利率，抽紧银根；反之，增加基础货币供给，降低利率，放松银根。所以，再贴现也有明显的告示效应，公众可以从再贴率的变化判断中央银行政策意图倾向，但有被误导的可能。 货币增长与通货膨胀 掌握货币流通速度、货币数量论、货币中性、费雪效应、通货膨胀税、皮鞋成本、菜单成本等概念； 名义变量：按货币单位衡量的变量（物价水平、美元工资、名义 GDP） 实际变量：按实物单位衡量的变量（生产、就业、实际工资、实际利率、实际 GDP） 古典二分法：名义和实际变量的理论区分 货币中性：认为货币供给变动并不影响实际变量的观点。（适用于长期经济。在短期中，货币变动对实际变量有重要影响。） 货币流通速度：货币易手的速度，指货币在一定时期内完成交易的次数 V =（P × Y）/M 货币数量论：一种理论，认为可得到的货币量决定物价水平，可得到的货币量增长率决定通货膨胀率。 货币数量方程式：货币数量（M）乘货币流通速度（V）等于产品价格（P）（GDP 平减指数）乘产量（Y）（实际 GFP）M × V = P × Y 货币数量论的本质： 货币流通速度比较稳定； 由于货币流通速度稳定，货币数量变动引起名义产值（P×Y）同比例变动； 货币是中性的，货币不影响实际产量（Y）； 货币变动将反映在价格水平（P）上； 货币供给过多将引起通货膨胀。 通货膨胀税：政府多印货币造成通货膨胀，实际上是以减少货币价值的方式增加政府收入，也就是向所有的货币持有人征收额外的税。 注意名义利率和实际利率的区别； 因为 实际利率 = 名义利率 - 通货膨胀率 所以 名义利率 = 实际利率 + 通货膨胀率 货币在长期中为中性的，货币增长的变动不会影响实际利率，这就决定了通货膨胀将导致名义利率上升，这就是费雪效应。费雪效应的分析具有长期正确性。而在通货膨胀不可预料的短期中，费雪效应是不成立的。确切地说，费雪效应表明名义利率根据预期的通货膨胀调整。长期中预期通货膨胀随实际通货膨胀而变动，但短期中不一定。 理解古典通货膨胀理论和数量方程式； 古典通货膨胀理论：物价水平与货币价值反方向变动，物价越高就是货币价值越低。在长期中，物价水平要调节到货币供给与货币需求相等的均衡位置，如果物价高于（货币价值低于）均衡水平，人们将减少商品购买，他们期望持有的货币大于央行发行的货币，物价将会回落；如果物价低于（货币价值高于）均衡水平，人们将增加商品购买，他们期望持有的货币将小于央行发行的货币，物价相应回升。 理解通货膨胀的代价 造成工人的损失：通货膨胀未必降低实际购买力，因为在货币购买力下降的同时，人们的工资也增加了。但如果工资的调整滞后于通货膨胀，它还是会造成工人的损失。 皮鞋成本：当通货膨胀鼓励人们减少货币持有量时所浪费的资源。 菜单成本：改变价格的成本 价格扭曲误导资源配置：通胀造成商品的价格不完全反映商品的效用，而为产品对通胀的灵敏度为转移。从而使得资源从效用高，但对通胀灵敏度低的产业进入效用低，但对通胀灵敏度高的产业，造成资源配置实现的社会满足低于没有通胀时的同等情况。 税收扭曲提高税负：政府按照名义收入征税，而不管通胀造成实际收入减少，这就加重按实际收入计算的税赋。高税收降低利息受益，遏制储蓄。指数化是解决问题的方法，却未必总是有效。 造成价值尺度的紊乱：货币是价值尺度，尺度不准将导致对经济活动评价的紊乱。通货膨胀造成不同时期的货币具有不同的价值，所以难比较企业不同时期的真实收益、成本和利润。 没有预期到的通胀扭曲财富再分配：没有预期到的通胀有利于借款人，不利于贷款人；有利于债务人，不利于债权人；有利于老板，不利于员工；有利于政府，不利于公众。 轻微的通胀可以推动经济增长，严重的通胀则会扭曲价格信号，甚至使货币失去应有的功能。 开放经济学 掌握资本净流出、净出口、名义汇率和实际汇率、购买力平价等基本概念 封闭经济：不与世界其他经济进行交易的经济。 开放经济：自由地与世界其他经济进行交易的经济。 净出口：一国的出口值减进口值，又称贸易余额。 贸易盈余：出口大于进口；贸易赤字：进口大于出口；平衡的贸易：出口等于进口。 影响进出口的因素：消费者的嗜好，国内外产品的比价、汇率的高低及其变动，消费者的收入，产品的运送成本，政府的政策等。 资本净流出：本国居民购买到的外国资产（股票债券）减外国人购买的国内资产。 影响资本净流出的因素：国内外资产得到的实际利率的差别，持有国外资产的经济与政治风险，影响外国拥有本国资产的政府政策。 理解资本净流出与净出口之间的恒等关系； 净出口衡量一国出口与其进口之间的不平衡；资本净流出衡量本国居民购买的外国资产量与外国人购买的国内资产量之间的不平衡。对整个经济而言，这两种不平衡必然相互抵消，资本净流出（NCO）总等于净出口（NX）：NCO = NX 因为一国出口增加，收入外汇，只有买入外国资产，才能实现一国经济的均衡。这就表明净出口增加并非就是净资本流出，而是实现经济均衡要求净资本流出增加。 净出口形成对本国货币的需求，因为外国需要本国货币购买本国出口商品；资本净流出形成本币供给，因为本币需要换成外币，购买外国资产。此二者相等为本币在国际市场的均衡，如果不等，则通过汇率变动，实现这两者的相等。 当 NCO &lt; NX 资本净流出小于商品净出口表明本国货币的外流小于外国对本国货币的需求，本币汇率上升，遏制商品净出口，刺激资本外流，使得这两者相等。 Y = C + I + G + NX → Y - C - G = I + NX → S = I + NX 因为净出口 NX 等于国外净投资，所以 S = I + NCO 储蓄 = 国内投资 + 资本净流出 在封闭经济中，没有资本净流出，储蓄就等于国内投资。 | 贸易赤字 | 贸易平衡 | 贸易盈余 || :——————- | ——————— | ——————— || 出口 &lt; 进口 | 出口 = 进口 | 出口 &gt; 进口 || 净出口 &lt; 0 | 净出口 = 0 | 净出口 &gt; 0 || Y &lt; C + I + G | Y = C + I + G | Y &gt; C + I + G || 储蓄 &lt; 投资 | 储蓄 = 投资 | 储蓄 &gt; 投资 || 资本净流出 &lt; 0 | 资本净流出 = 0 | 资本净流出 &gt; 0 | 运用名义汇率和实际汇率的联系分析货币供给、价格变动对汇率的影响。 名义汇率：两种货币的交换比率 升值：该国货币可以买到更多的外国货币；反之则是贬值。 实际汇率：两国货币在两个国家可以购买到的商品和劳务的比例。 实际汇率 =（名义汇率 × 国内价格）÷ 国外价格 用美国国一篮子物品和劳务的物价指数（P）,国外一篮子物品和劳务物价指数（P-）以及美元和外国通货之间的名义汇率（e），可以得出美国与其他国家之间的总体实际汇率：实际汇率=（ e × P ）/ P- 这个实际汇率衡量国内得到的一篮子物品与劳务相对于国外得到的一篮子物品与劳务的价格。一国的实际汇率是其物品与劳务净出口的关键决定因素。实际汇率贬值（下降）意味着相对于外国物品而言，美国物品变得便宜了，因此，净出口增加。 购买力平价：认为任何一单位通货应该能在所有国家买到等量物品，即有相同的实际价值。根据单一价格规律得出。 单一价格规律：一种物品在所有地方都应该按同样的价格出售，否则就有未被利用的利润机会。 假设 P 是美国一篮子物品的价格，用美元计价，P + 是日本一篮子物品的价格，用日元衡量，而 e 是名义汇率，1 美元可以购买日元的数量。考虑 1 美元可以在国内与国外购买的物品数量。在国内，物价水平是 P，因此 1 美元的国内购买力为 1 / P。在国外，1 美元可以换到 e 单位外国货币，外国货币的购买力为 e / P + 。由于两国 1 美元的购买力相同，所以情况应该是 1 / P= e / + → 1= eP / P + （右边是实际汇率） 如果美元购买力在国内外相同，那么实际汇率——国内外物品的相对价格——就保持不变。 名义汇率 e = P +/ P 等于外国物价水平与国内物价水平的比率，根据购买力平价理论，两国通货之间的名义汇率必然反映两国物价水平的差别。这就是说，如果一国增发货币导致通货膨胀，它对全世界货币的购买力也相对下降了。 可贷资金市场 S = I + NCO 储蓄 = 国内投资 + 资本净流出 供给来自国民储蓄，需求来自国内投资和资本净流出。可贷资金的供给量和需求量取决于实际利率。在均衡利率时，人们储蓄的量正好与合意的国内投资与资本净流出量平衡。实际利率还决定资本净流出。 外汇市场 NCO = N x 资本净流出 = 净出口 供给来自资本净流出，需求来自净出口。使外汇市场供求平衡的价格是实际汇率。实际汇率是国内与国外物品的相对价格，是净出口的关键决定因素。当美元实际汇率升值，美国净出口减少，减少了外汇市场上美元的需求量。 在均衡的实际汇率时，外国人由美国物品与劳务净出口所引起的美元需求正好与美国人由美国资本净流出所引起的美元供给相平衡。 总供给和总需求 理解造成总需求曲线向下倾斜的三个效应：财富效应、利率效应和汇率效应； 衰退：实际收入下降和失业增加的时期。 萧条：严重的衰退。 古典理论描述长期世界，并不描述短期世界。 长期：根据古典二分法和货币中性，货币供给的变动影响物价和其他名义变量，但并不影响实际 GDP、失业以及其他实际变量。 短期：实际与名义变量高度相关，货币供给的变动可以暂时地使产量背离其长期趋势。 总需求曲线向右下方倾斜的原因：Y = C + I + G + NX 财富效应：物价水平下降使货币更值钱，消费者更富裕，这又鼓励他们更多地支出。消费支出增加意味着物品与劳务需求量更大。 利率效应：物价水平下降，需要持有的货币量减少，家庭努力把自己的一些货币换为有利息的资产，所以利率下降，鼓励了更多地支出于投资物品，从而增加了物品与劳务的需求量。 汇率效应：当美国物价水平下降引起美国利率下降时，实际汇率贬值；这种贬值刺激了美国的净出口，从而增加了物品与劳务的需求量。 理解短期总供给曲线向上倾斜的三种理论：粘性工资、粘性价格、错觉理论。 供给曲线：长期中是垂线；短期中向右上方倾斜。 在长期中，一个经济的物品与劳务供给取决于它的资本、劳动和自然资源的供给，以及生产技术。由于物价水平不影响这些实际 GDP 的长期决定因素，所以长期供给曲线是一条垂线。意味着产量（实际变量）不取决于物价水平（名义变量）。它所决定的产量水平称为自然产量率，因为它表明当失业为其自然率或正常率时经济的产量。自然产量率是长期中经济所趋向的生产水平。 短期总供给曲线向右上方倾斜的原因： 粘性工资理论：如果物价水平 P 降到低于预期的水平而名义工资仍然滞留在 W 上，那么，实际工资 W/P 就会上升到企业计划支付的水平之上，企业的实际成本增加了，则企业减少物品与劳务的供给量。 粘性价格理论：由于并不是所有价格都根据变动的状况而迅速调整，未预料到的物价水平下降使一些企业的价格高于合意水平，而这些高于合意水平的价格压低了销售，并引起企业减少他们生产的物品与劳务的量。 错觉理论：低物价水平引起相对价格下降的错觉，而且这种错觉引起供给者对较低物价水平的反应是减少物品与劳务的供给量。 所有这三个理论都表明，当物价水平背离了人们预期的物价水平时，供给量就背离了其长期水平或“自然”水平。当物价水平高于预期水平时，产量就高于其自然率；当物价水平低于其预期水平时，产量就低于其自然率。 产量的供给量 = 自然产量率 + a (实际物价水平 - 预期的物价水平) a 是决定产量对物价水平未预期到的变动作出多大反应的数字。 货币政策和财政政策对总需求的影响 运用流动偏好理论分析短期内价格上升对利率的影响 流动偏好理论：凯恩斯的理论，认为利率的调整使货币供给与货币需求平衡。 货币供给：美联储通过公开市场买卖国债，变动准备金率和再贴现率影响货币供给，但是，这种变动不受利率影响，所以货币供给曲线是条垂线。 货币需求：货币需求曲线向右下方倾斜，表明利率下降，持币的机会成本也下降，所以货币需求增加。 货币市场均衡：货币供给大于货币需求，公众买入国债，国债价格上升，利率下降；货币供给小于货币需求，公众卖出国债，国债价格下跌，利率上升。在货币供给等于货币需求时，利率实现均衡。 运用流动偏好理论理解美联储运用三个主要工具时对货币供给和市场利率的影响； 当美联储增加了货币供给时，它降低了利率，增加了物价水平为既定时的物品与劳务需求量，使总需求曲线向右移动。流动偏好理论说明：既可以根据货币供给，也可以根据利率来描述货币政策。 理解政府购买增加引起的乘数效应与边际消费倾向（MPC）的关联性； 理解财政政策和货币政策对总需求的影响，例如，扩张性的财政政策引起总需求趋向如何移动？ 财政政策：指政府对政府购买或税收总水平的选择。在长期中影响储蓄、投资和增长；在长期中，影响物品与劳务的总需求。 乘数效应：当扩张性财政政策增加了收入，从而增加了消费支出时引起的总需求的额外移动。 边际消费倾向（MPC）：家庭额外收入中用于消费而不用于储蓄的比例。 乘数 = 1/（1 - MPC）表示每 1 美元政府购买所引起的物品与劳务的需求。 乘数普遍存在所有的政府购买、消费、投资和进出口收支中，也就是支出增加，国民收入乘数增加，支出减少，国民收入乘数减少。 挤出效应：当扩张性财政政策引起利率上升，从而减少了投资支出时所引起的总需求减少。挤出效应部分抵消了政府购买对总需求的影响。根据乘数效应与挤出效应的大小，总需求曲线的移动可以大于或小于引起它的政府购买的变动。 掌握乘数效应、挤出效应、自动稳定器、转移支付等概念； 自动稳定器：当经济进入衰退时，决策者不用采取任何有意的行动也会刺激总需求的财政政策变动。主要是累进所得税和转移支付，它表现为在经济繁荣的时候，自动增加财政税收，减少支出，遏制社会总需求；反之，在经济萧条的时候，自动减少税收，增加支出，刺激社会总需求，从而使过热的经济降温，过冷的经济升温，国民经济因此而处于相对稳定的状态，这就是财政收支的“自动稳定器”。但是,“自动稳定器”的作用是有限的，所以政府还是要实行积极的财政政策。 通货膨胀与失业之间的短期权衡取舍 掌握菲利普斯曲线、理性预期等概念 菲利普斯曲线：一条表示通货膨胀与失业之间短期交替关系的曲线。 长期的菲利普斯曲线是条垂线，因为长期中总供给曲线为实际经济变量所决定，产出不能增加，就业也就增加不了，总需求的增加只能表现在价格的上升上。 预期的通货膨胀：衡量人们预期物价总水平的变动幅度。是决定短期总供给曲线位置的一个因素。 失业和通货膨胀的关系： 凯恩斯学派认为，失业与通货膨胀之间存在着替代关系，菲里普斯曲线向右下方倾斜，因为货币供给增加，利率下降，企业的边际成本下降，企业家扩大生产规模，就业增加，所以政府可以以增加货币供给的方式降低失业率。 货币主义者认为，公众只有在短期中存在“货币幻觉”，长期中，他们会意识到自己的实际收入随物价的上涨而下跌，所以要求增加工资，企业家就会缩小生产规模，实际失业还要回到“自然失业率” 水平上，菲里普斯曲线在短期中是条斜线，而在长期中则是条垂线，货币供给增加只会造成物价的上涨。 失业率 = 自然失业率 - a（实际通胀率 - 预期通胀率） 自然率假说：弗里德曼认为无论通胀如何，失业率都要回到自然率水平上。也就是说，在长期中，失业和通胀之间没有替代关系。 理解预期变化、供给冲击和紧缩性货币政策影响菲利普斯曲线移动的机理； 理解短期菲利普斯曲线与长期菲利普斯曲线的关系； 理解理性预期理论下的菲利普斯曲线变化。 供给冲击：直接改变企业的成本和价格，使经济的总供给曲线移动，进而使菲利普斯曲线移动的事件。例如，石油涨价等造成生产成本上升，总供给曲线向左移动，菲利普斯曲线相应向向右移动，表明在同样通胀的水平上，失业增加了，或者在同样失业水平上，通胀严重了。 牺牲率：在通货膨胀减少 1%的过程中每年产量损失的百分比。 如果一个经济要降低通货膨胀，它就必然忍受一个高失业和低产量的时期。 理性预期：当人们预期未来时，可以最好地利用他们拥有的所有信息，包括有关政府政策的信息。 预期通货膨胀是解释为什么短期中存在通货膨胀与失业之间的权衡取舍而长期中不存在的一个重要变量。短期权衡取舍消失的速度取决于预期调整的速度。如果政府做出来降低通货膨胀政策的可信承诺，人们的理性就足以立即降低通货膨胀预期。短期菲利普斯曲线向下移动，而且经济将很快达到低通货膨胀，并没有暂时高失业和低产量的代价。 宏观经济政策的五个争论问题 熟悉宏观经济有关五个争论问题的支持与反对观点的主要内容。 决策目标是否应该稳定经济 主张稳定经济的认为失业和通胀都会造成资源浪费，各类经济指标下降，增加人们的苦难，所以政府应该努力稳定经济；反对者认为政策的实施有时滞，从而可能使正确的政策在错误的时间发生作用，不是稳定经济，而是加剧经济的波动。 应该实行规则还是权变的货币政策 主张实行权变货币政策认为经济运行时不稳定的，所以政策的实施影响及形势。 反对者认为要约束政策的制定者，以免受政治周期的干扰；政策的宣布与执行的时间的不一致性，提高通胀预期，加剧物价的不稳。所以不管经济如何，货币供给量都应是经济增长率和物价上涨率之和。 央行是否应该以零通胀为目标 主张央行以零通胀为目标的认为在温和通胀的时期，通胀的成本比较低；只要采取取信于公众的零通胀政策，人们的通胀预期也会下降，降低通胀的所增加的失业也会减少；零通胀可以提供比任何其他数字更为合理，且不会因为操作困难而上升的基点。 反对者认为，零通胀的代价太大，越接近零，失业的增长越快，所以应选择温和的通胀。 财政是否应该平衡预算 主张财政应减少债务的人认为，债务最终会增加后代的负担；负储蓄会提高利率，对经济产生不良影响。只有在战争和衰退时期，才可以有较多的赤字。 反对者认为，相对人一生的收入，上代人的债务毕竟是有限的；债务要与支出结合起来考虑，有足够回报的债务不会有负面影响，不敢承担有足够回报的债务反而有负面影响。 是否应该为鼓励储蓄而修改税法 主张为鼓励储蓄而修改税法的人认为降低税率可以提高储蓄，从而不利于投资和未来的繁荣。 反对者认为，降低税率会加剧社会的贫富不均，因为储蓄缺乏利率弹性，降低资本收入税可能使富人更富。减税增加政府赤字的负面影响还可能大于增加储蓄的正面影响。 五大争论小结： 经济具有不稳定性，需要政府进行干预，但是管理层对未来预期的能力是有限的，所以干预的结果可能造成经济更大的波动。 规则的货币政策可以避免相机抉择带来的判断失误、滥用权力等问题，但是，它也使调控失去灵活性。 零通胀可以免除通胀的成本，但是它的成本也很高。且温和的通胀的成本是有限的，还能推动经济增长。 平衡预算可以实现代际间的公平，避免下一代承受过高的税负。但是，却不能享有财政赤字对经济的积极作用。 修改税法，刺激储蓄可以推动经济发展，但是却可能有利于富人，且对私人储蓄的影响不如直接增加公共储蓄。","categories":[{"name":"慕课MOOC","slug":"慕课MOOC","permalink":"http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"}],"tags":[]}],"categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://blog.zhuangzhihao.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C/C++","slug":"C-C","permalink":"http://blog.zhuangzhihao.top/categories/C-C/"},{"name":"观点与感想","slug":"观点与感想","permalink":"http://blog.zhuangzhihao.top/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"},{"name":"Java","slug":"Java","permalink":"http://blog.zhuangzhihao.top/categories/Java/"},{"name":"机器学习","slug":"机器学习","permalink":"http://blog.zhuangzhihao.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"其他开发","slug":"其他开发","permalink":"http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"},{"name":"计算机科学与技术","slug":"计算机科学与技术","permalink":"http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"},{"name":"慕课MOOC","slug":"慕课MOOC","permalink":"http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"},{"name":"Python","slug":"Python","permalink":"http://blog.zhuangzhihao.top/categories/Python/"},{"name":"数据科学","slug":"数据科学","permalink":"http://blog.zhuangzhihao.top/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.zhuangzhihao.top/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://blog.zhuangzhihao.top/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://blog.zhuangzhihao.top/tags/HTML/"},{"name":"JSP","slug":"JSP","permalink":"http://blog.zhuangzhihao.top/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://blog.zhuangzhihao.top/tags/Servlet/"},{"name":"HTTP","slug":"HTTP","permalink":"http://blog.zhuangzhihao.top/tags/HTTP/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://blog.zhuangzhihao.top/tags/MyBatis/"},{"name":"Maven","slug":"Maven","permalink":"http://blog.zhuangzhihao.top/tags/Maven/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://blog.zhuangzhihao.top/tags/PyTorch/"},{"name":"pandas","slug":"pandas","permalink":"http://blog.zhuangzhihao.top/tags/pandas/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.zhuangzhihao.top/tags/MySQL/"},{"name":"JDBC","slug":"JDBC","permalink":"http://blog.zhuangzhihao.top/tags/JDBC/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.zhuangzhihao.top/tags/Linux/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.zhuangzhihao.top/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.zhuangzhihao.top/tags/Spring-Boot/"},{"name":"Gradle","slug":"Gradle","permalink":"http://blog.zhuangzhihao.top/tags/Gradle/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://blog.zhuangzhihao.top/tags/Jenkins/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://blog.zhuangzhihao.top/tags/OpenCV/"},{"name":"IDEA","slug":"IDEA","permalink":"http://blog.zhuangzhihao.top/tags/IDEA/"},{"name":"R Language","slug":"R-Language","permalink":"http://blog.zhuangzhihao.top/tags/R-Language/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://blog.zhuangzhihao.top/tags/Jupyter/"},{"name":"SQL","slug":"SQL","permalink":"http://blog.zhuangzhihao.top/tags/SQL/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://blog.zhuangzhihao.top/tags/Spring-Cloud/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.zhuangzhihao.top/tags/MongoDB/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.zhuangzhihao.top/tags/Redis/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://blog.zhuangzhihao.top/tags/Tomcat/"},{"name":"LintCode","slug":"LintCode","permalink":"http://blog.zhuangzhihao.top/tags/LintCode/"},{"name":"Git","slug":"Git","permalink":"http://blog.zhuangzhihao.top/tags/Git/"}]}