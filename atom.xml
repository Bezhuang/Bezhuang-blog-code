<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bezhuang&#39;s Blog</title>
  
  
  <link href="http://blog.zhuangzhihao.top/atom.xml" rel="self"/>
  
  <link href="http://blog.zhuangzhihao.top/"/>
  <updated>2022-03-06T07:49:41.561Z</updated>
  <id>http://blog.zhuangzhihao.top/</id>
  
  <author>
    <name>Bezhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>macOS + Ubuntu 实现远程开发配置</title>
    <link href="http://blog.zhuangzhihao.top/Ubuntu%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.zhuangzhihao.top/Ubuntu%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-03-06T07:49:41.561Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>刚刚续费了一年的阿里云轻量应用服务器，打算把大多数的开发环境放到服务器上，实现远程开发。我使用的是 macOS Monterey 和基于 Ubuntu 18.04 的 LNMP 镜像系统，IDE 选取 Visual Studio Code 和 IntelliJ IDEA 进行开发学习，以下为搭建环境过程中所记笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="服务器镜像信息"><a href="#服务器镜像信息" class="headerlink" title="服务器镜像信息"></a>服务器镜像信息</h3><ul><li><p>我使用的是阿里云轻量应用服务器提供的 LNMP 7.4 镜像，该镜像为LNMP（Ubuntu18.04 64位+Nginx+MySQL5.7+PHP5.3～8.0切换）架构，jemalloc优化内存管理，脚本菜单式添加Nginx虚拟主机绑定，并支持内网OSS备份功能，是常见的搭建Web应用所需的环境，支持高并发性能。</p></li><li><p>应用程序安装信息</p><ul><li><p>Nginx 1.18：<code>/usr/local/nginx</code></p></li><li><p>PHP 7.4：<code>/usr/local/php</code></p></li><li><p>MySQL 5.7：<code>/usr/local/mysql</code></p></li></ul></li><li><p>数据库地址：127.0.0.1:3306 </p></li><li><p>网站根目录：<code>/data/wwwroot</code></p></li><li><p>查询数据库和 FTP 密码</p><pre><code class="bash">sudo cat /root/ReadMe</code></pre></li></ul><h3 id="Ubuntu-系统配置"><a href="#Ubuntu-系统配置" class="headerlink" title="Ubuntu 系统配置"></a>Ubuntu 系统配置</h3><ul><li><p>依赖源设置</p><pre><code class="bash">mv /etc/apt/sources.list&#123;,bak&#125; #备份sources.listcat &gt; /etc/apt/sources.list &lt;&lt; EOFdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverseEOFapt update</code></pre></li><li><p>在防火墙添加规则放行 21、20000/30000 端口，允许通过 FTP 连接</p></li></ul><h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><ul><li><p>C/C++ 开发环境</p><pre><code class="bash">sudo apt-get install build-essential</code></pre></li><li><p>Python3 开发环境</p><pre><code class="bash">python3 --version  sudo apt-get install python3-pip</code></pre></li><li><p>Java 开发环境</p><pre><code class="bash">sudo apt install openjdk-11-jdk</code></pre></li><li><p>Go 开发环境</p><pre><code class="bash">sudo wget -c https://dl.google.com/go/go1.15.6.linux-amd64.tar.gz -O - | sudo tar -xz -C /usr/localvim /etc/profile</code></pre><ul><li><p>添加以下内容</p><pre><code class="bash">export GOROOT=/usr/local/goexport GOPATH=/tufei/code/goexport GOBIN=$GOPATH/binexport PATH=$GOPATH:$GOBIN:$GOROOT/bin:$PATH</code></pre></li><li><p>保存</p><pre><code class="bash">source  /etc/profilego version</code></pre></li></ul></li><li><p>Git 安装配置</p><pre><code class="bash">sudo apt-get install gitgit config --global user.name &quot;Zhuang Zhihao&quot;git config --global user.email &quot;bezhuang@outlook.com&quot;ssh-keygen -t rsa -C &quot;bezhuang@outlook.com&quot;cat /root/.ssh/id_rsa.pub</code></pre><ul><li>提交公钥到 Github 或其他 Git 仓库</li></ul></li></ul><h3 id="本地开发环境"><a href="#本地开发环境" class="headerlink" title="本地开发环境"></a>本地开发环境</h3><ul><li>使用 Visual Studio Code 中的 Remote -SSH 插件连接</li><li>使用 Termius 进行 SSH 和 SFTP 连接</li><li>博客现仍使用 Hexo，Typora 软件用于编写博客文章，uPic 软件用于上传图床</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;刚刚续费了一年的阿里云轻量应用服务器，打算把大多数的开发环境放到服务器上，实现远程开发。我使用的是 macOS Monterey 和基于 Ubuntu 18.04 的 LNMP 镜像系统，IDE 选取 Visual Studio Code 和 IntelliJ IDEA 进行开发学习，以下为搭建环境过程中所记笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="云计算与应用开发" scheme="http://blog.zhuangzhihao.top/categories/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="云服务器" scheme="http://blog.zhuangzhihao.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="MacOS" scheme="http://blog.zhuangzhihao.top/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础知识总结</title>
    <link href="http://blog.zhuangzhihao.top/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/"/>
    <id>http://blog.zhuangzhihao.top/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/</id>
    <published>2022-02-12T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.840Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Go 语言是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，它用批判吸收的眼光，融合 C 语言、Java 等众家之长，将简洁、高效演绎得淋漓尽致。Golang非常适合用来做网络并发方面的服务，比如消息推送、监控、容器等。初次学习我选择的是 <a href="https://go-zh.org/">Go 编程语言</a>指南，指南涵盖了该语言的大部分重要特性，放在以下为所记笔记，另附有随堂代码放在 <a href="https://github.com/Bezhuang/Learn-CS/tree/main/Learn%20Programming/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85">Github 仓库</a>中，可供参考。</p></blockquote><a id="more"></a><h3 id="包、变量和函数"><a href="#包、变量和函数" class="headerlink" title="包、变量和函数"></a>包、变量和函数</h3><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><ul><li><p>每个 Go 程序都是由包构成的</p></li><li><p>程序从 <code>main</code> 包开始运行</p><pre><code class="go">package main</code></pre></li></ul><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><ul><li><p>此代码用圆括号组合了导入，这是“分组”形式的导入语句</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;math&quot;)</code></pre></li><li><p>当然也可以编写多个导入语句，不过使用分组导入语句是更好的形式</p></li></ul><h4 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h4><ul><li><p>在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，<code>Pizza</code> 就是个已导出名，<code>Pi</code> 也同样，它导出自 <code>math</code> 包</p><pre><code class="go">func main() &#123;    fmt.Println(math.Pi)&#125;</code></pre></li><li><p>在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问</p></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li><p>函数可以没有参数或接受多个参数</p><pre><code class="go">// add 接受两个 int 类型的参数func add(x int, y int) int &#123;    return x + y&#125;</code></pre></li><li><p>注意类型在变量名 <strong>之后</strong></p></li><li><p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略</p><pre><code class="go">func add(x, y int) int &#123;    return x + y&#125;</code></pre></li></ul><h4 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h4><ul><li><p>函数可以返回任意数量的返回值</p></li><li><p><code>swap</code> 函数返回了两个字符串</p><pre><code class="go">func swap(x, y string) (string, string) &#123;    return y, x&#125;</code></pre></li></ul><h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><ul><li><p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量</p></li><li><p>返回值的名称应当具有一定的意义，它可以作为文档使用</p></li><li><p>没有参数的 <code>return</code> 语句返回已命名的返回值。也就是 <code>直接</code> 返回</p></li><li><p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性</p><pre><code class="go">func split(sum int) (x, y int) &#123;    x = sum * 4 / 9    y = sum - x    return&#125;</code></pre></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</p></li><li><p><code>var</code> 语句可以出现在包或函数级别</p><pre><code class="go">var c, python, java boolfunc main() &#123;    var i int    fmt.Println(i, c, python, java)&#125;</code></pre></li></ul><h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><ul><li><p>变量声明可以包含初始值，每个变量对应一个</p></li><li><p>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型</p><pre><code class="go">var i, j int = 1, 2func main() &#123;    var c, python, java = true, false, &quot;no!&quot;    fmt.Println(i, j, c, python, java)&#125;</code></pre></li></ul><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><ul><li><p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明</p></li><li><p>函数外的每个语句都必须以关键字开始（<code>var</code>, <code>func</code> 等等），因此 <code>:=</code> 结构不能在函数外使用</p><pre><code class="go">func main() &#123;    var i, j int = 1, 2    k := 3    c, python, java := true, false, &quot;no!&quot;    fmt.Println(i, j, k, c, python, java)&#125;</code></pre></li></ul><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul><li><p>Go 的基本类型有</p><pre><code>boolstringint  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名，表示一个 Unicode 码点float32 float64complex64 complex128</code></pre></li><li><p>同导入语句一样，变量声明也可以“分组”成一个语法块</p><pre><code class="go">var (    ToBe   bool       = false    MaxInt uint64     = 1&lt;&lt;64 - 1    z      complex128 = cmplx.Sqrt(-5 + 12i))</code></pre></li><li><p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽</p></li><li><p>当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型</p></li></ul><h4 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h4><ul><li>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong><ul><li>数值类型零值为 <code>0</code></li><li>布尔类型零值为 <code>false</code></li><li>字符串零值为 <code>&quot;&quot;</code>（空字符串）</li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li><p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p><pre><code class="go">i := 42f := float64(i)u := uint(f)</code></pre></li><li><p>与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换</p><pre><code class="go">var i int = 42var f float64 = float64(i)var u uint = uint(f)</code></pre></li></ul><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><ul><li><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法）</p></li><li><p>变量的类型由右值推导得出</p></li><li><p>当右值声明了类型时，新变量的类型与其相同：</p><pre><code class="go">var i intj := i // j 也是一个 int</code></pre></li><li><p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p><pre><code class="go">i := 42           // intf := 3.142        // float64g := 0.867 + 0.5i // complex128</code></pre></li></ul><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul><li><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字</p></li><li><p>常量可以是字符、字符串、布尔值或数值</p></li><li><p>常量不能用 <code>:=</code> 语法声明</p><pre><code class="go">const Pi = 3.14</code></pre></li></ul><h4 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h4><ul><li><p>数值常量是高精度的 <strong>值</strong></p></li><li><p>一个未指定类型的常量由上下文来决定其类型</p></li><li><p><code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少</p><pre><code class="go">const (    // 将 1 左移 100 位来创建一个非常大的数字    // 即这个数的二进制是 1 后面跟着 100 个 0    Big = 1 &lt;&lt; 100    // 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2    Small = Big &gt;&gt; 99)func needInt(x int) int &#123; return x*10 + 1 &#125;func needFloat(x float64) float64 &#123;    return x * 0.1&#125;</code></pre></li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ul><li><p>Go 只有一种循环结构：<code>for</code> 循环</p></li><li><p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开</p><ul><li>初始化语句：在第一次迭代前执行</li><li>条件表达式：在每次迭代前求值</li><li>后置语句：在每次迭代的结尾执行</li></ul><pre><code class="go">for i := 0; i &lt; 10; i++ &#123;        sum += i&#125;</code></pre></li><li><p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见</p></li><li><p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止</p></li><li><p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的</p></li></ul><h4 id="for-是-Go-中的-“while”"><a href="#for-是-Go-中的-“while”" class="headerlink" title="for 是 Go 中的 “while”"></a>for 是 Go 中的 “while”</h4><ul><li><p>初始化语句和后置语句是可选的</p></li><li><p>此时你可以去掉分号，因为 C 的 <code>while</code> 在 Go 中叫做 <code>for</code></p><pre><code class="go">sum := 1for sum &lt; 1000 &#123;    sum += sum&#125;</code></pre></li><li><p>如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑</p><pre><code class="go">func main() &#123;    for &#123;    &#125;&#125;</code></pre></li></ul><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><ul><li><p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的</p><pre><code class="go">func sqrt(x float64) string &#123;    if x &lt; 0 &#123;        return sqrt(-x) + &quot;i&quot;    &#125;    return fmt.Sprint(math.Sqrt(x))&#125;</code></pre></li><li><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 <code>if</code> 之内</p><pre><code class="go">func pow(x, n, lim float64) float64 &#123;    if v := math.Pow(x, n); v &lt; lim &#123;        return v    &#125;    return lim&#125;</code></pre></li></ul><h4 id="if-和-else"><a href="#if-和-else" class="headerlink" title="if  和 else"></a>if  和 else</h4><ul><li><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用</p><pre><code class="go">func pow(x, n, lim float64) float64 &#123;    if v := math.Pow(x, n); v &lt; lim &#123;        return v    &#125; else &#123;        fmt.Printf(&quot;%g &gt;= %g\n&quot;, v, lim)    &#125;    // 这里开始就不能使用 v 了    return lim&#125;</code></pre></li></ul><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><ul><li><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法，它运行第一个值等于条件表达式的 case 语句</p></li><li><p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case</p></li><li><p>实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句</p></li><li><p>除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止</p></li><li><p>Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数</p><pre><code class="go">switch os := runtime.GOOS; os &#123;    case &quot;darwin&quot;:        fmt.Println(&quot;OS X.&quot;)    case &quot;linux&quot;:        fmt.Println(&quot;Linux.&quot;)    default:        fmt.Println(&quot;%s. \n&quot;, os)</code></pre></li><li><p>switch 的求值顺序：case 语句从上到下顺次执行，直到匹配成功时停止</p><pre><code class="go">switch i &#123;case 0:case f():  // 在 i==0 时 f 不会被调用&#125;</code></pre></li><li><p>没有条件的 switch 同 <code>switch true</code> 一样。这种形式能将一长串 <code>if-then-else</code> 写得更加清晰</p><pre><code class="go">switch &#123;    case t.Hour() &lt; 12:        fmt.Println(&quot;Good morning!&quot;)    case t.Hour() &lt; 17:        fmt.Println(&quot;Good afternoon.&quot;)    default:        fmt.Println(&quot;Good evening.&quot;)</code></pre></li></ul><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><ul><li><p>defer 语句会将函数推迟到外层函数返回之后执行</p></li><li><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</p><pre><code class="go">func main() &#123;    defer fmt.Println(&quot;world&quot;)    fmt.Println(&quot;hello&quot;)&#125; // 输出：hello world</code></pre></li></ul><h4 id="defer-栈"><a href="#defer-栈" class="headerlink" title="defer 栈"></a>defer 栈</h4><ul><li><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用</p><pre><code class="go">func main() &#123;    fmt.Println(&quot;counting&quot;)    defer fmt.Println(&quot;done&quot;)    for i := 0; i &lt; 10; i++ &#123;        defer fmt.Println(i)    &#125;&#125; // 输出：counting 9 8 7 6 5 4 3 2 1 0 done</code></pre></li></ul><h3 id="结构体、数组、切片和映射"><a href="#结构体、数组、切片和映射" class="headerlink" title="结构体、数组、切片和映射"></a>结构体、数组、切片和映射</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul><li><p>Go 拥有指针。指针保存了值的内存地址</p></li><li><p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code></p><pre><code class="go">var p *int</code></pre></li><li><p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p><pre><code class="go">i := 42p = &amp;i</code></pre></li><li><p><code>*</code> 操作符表示指针指向的底层值</p><pre><code class="go">fmt.Println(*p) // 通过指针 p 读取 i*p = 21         // 通过指针 p 设置 i</code></pre></li><li><p>这也就是通常所说的“间接引用”或“重定向”</p></li><li><p>与 C 不同，Go 没有指针运算</p></li></ul><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><ul><li><p>一个结构体（<code>struct</code>）就是一组字段（field）</p><pre><code class="go">type Vertex struct &#123;    X int    Y int&#125;func main() &#123;    fmt.Println(Vertex&#123;1, 2&#125;)&#125;</code></pre></li><li><p>结构体字段使用点号来访问</p><pre><code class="go">func main() &#123;    v := Vertex&#123;1, 2&#125;    v.X = 4    fmt.Println(v, v.X, v.Y)&#125;</code></pre></li></ul><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><ul><li><p>结构体字段可以通过结构体指针来访问</p></li><li><p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code> 就可以</p><pre><code class="go">func main() &#123;    v := Vertex&#123;1, 2&#125;    p = &amp;v    p.X = 1e9    fmt.Println(v)&#125;</code></pre></li></ul><h4 id="结构体文法"><a href="#结构体文法" class="headerlink" title="结构体文法"></a>结构体文法</h4><ul><li><p>结构体文法通过直接列出字段的值来新分配一个结构体</p></li><li><p>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</p></li><li><p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针</p><pre><code class="go">type Vertex struct &#123;    X, Y int&#125;var (    v1 = Vertex&#123;1, 2&#125;  // 创建一个 Vertex 类型的结构体    &#123;1, 2&#125;     v2 = Vertex&#123;X: 1&#125;  // Y:0 被隐式地赋予    &#123;1, 0&#125;     v3 = Vertex&#123;&#125;      // X:0 Y:0    &#123;0, 0&#125;     p  = &amp;Vertex&#123;1, 2&#125; // 创建一个 *Vertex 类型的结构体（指针）   &amp;&#123;1, 2&#125;)</code></pre></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p><pre><code class="go">var a [2]string  // 会将变量 a 声明为拥有 10 个整数的数组a[0] = &quot;Hello&quot;a[1] = &quot;World&quot;  </code></pre></li><li><p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组</p></li></ul><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><ul><li><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p></li><li><p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p></li><li><p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p><pre><code class="go">a[low : high] // 选择一个半开区间，包括第一个元素，但排除最后一个元素</code></pre><pre><code class="go">primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125;var s []int = primes[1:4] // 创建了一个切片，它包含 primes 中下标从 1 到 3 的元素 fmt.Println(s)  // 输出：[3 5 7]</code></pre></li><li><p>切片就像数组的引用，切片并不存储任何数据，它只是描述了底层数组中的一段</p></li><li><p>更改切片的元素会修改其底层数组中对应的元素，与它共享底层数组的切片都会观测到这些修改</p></li></ul><h4 id="切片文法"><a href="#切片文法" class="headerlink" title="切片文法"></a>切片文法</h4><ul><li><p>切片文法类似于没有长度的数组文法。</p></li><li><p>这是一个数组文法：</p><pre><code class="go">[3]bool&#123;true, true, false&#125;</code></pre></li><li><p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p><pre><code class="go">[]bool&#123;true, true, false&#125;</code></pre></li></ul><h4 id="切片的默认行为"><a href="#切片的默认行为" class="headerlink" title="切片的默认行为"></a>切片的默认行为</h4><ul><li><p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p></li><li><p>切片下界的默认值为 <code>0</code>，上界则是该切片的长度</p><pre><code class="go">var a [10]int// 以下切片是等价的a[0:10]a[:10]a[0:]a[:]</code></pre></li></ul><h4 id="切片的长度与容量"><a href="#切片的长度与容量" class="headerlink" title="切片的长度与容量"></a>切片的长度与容量</h4><ul><li><p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p></li><li><p>切片的长度就是它所包含的元素个数。</p></li><li><p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p></li><li><p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取</p><pre><code class="go">func main() &#123;    s := []int&#123;2, 3, 5, 7, 11, 13&#125;    printSlice(s)    // 截取切片使其长度为 0    s = s[:0]    printSlice(s)    // 拓展其长度    s = s[:4]    printSlice(s)    // 舍弃前两个值    s = s[2:]    printSlice(s)&#125;func printSlice(s []int) &#123;    fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)&#125;</code></pre></li></ul><h4 id="nil-切片"><a href="#nil-切片" class="headerlink" title="nil 切片"></a>nil 切片</h4><ul><li><p>切片的零值是 <code>nil</code>。</p></li><li><p>nil 切片的长度和容量为 0 且没有底层数组</p><pre><code class="go">var s []int    // s == nilfmt.Println(s, len(s), cap(s))  // [] 0 0</code></pre></li></ul><h4 id="用-make-创建切片"><a href="#用-make-创建切片" class="headerlink" title="用 make 创建切片"></a>用 make 创建切片</h4><ul><li><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p></li><li><p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p><pre><code class="go">a := make([]int, 5)  // len(a)=5</code></pre></li><li><p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p><pre><code class="go">b := make([]int, 0, 5)  // len(b)=0, cap(b)=5b = b[:cap(b)]  // len(b)=5, cap(b)=5b = b[1:]      // len(b)=4, cap(b)=4</code></pre></li></ul><h4 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a>切片的切片</h4><ul><li><p>切片可包含任何类型，甚至包括其它的切片</p><pre><code class="go">func main() &#123;    // 创建一个井字板（经典游戏）    board := [][]string&#123;        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,    &#125;    // 两个玩家轮流打上 X 和 O    board[0][0] = &quot;X&quot;    board[2][2] = &quot;O&quot;    board[1][2] = &quot;X&quot;    board[1][0] = &quot;O&quot;    board[0][2] = &quot;X&quot;    for i := 0; i &lt; len(board); i++ &#123;        fmt.Printf(&quot;%s\n&quot;, strings.Join(board[i], &quot; &quot;))    &#125;&#125;</code></pre></li></ul><h4 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h4><ul><li><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数</p><pre><code class="go">func append(s []T, vs ...T) []T</code></pre></li><li><p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾</p></li><li><p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片</p></li><li><p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组</p></li></ul><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><ul><li><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p></li><li><p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本</p><pre><code class="go">var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;func main() &#123;    for i, v := range pow &#123;        fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)    &#125;&#125;</code></pre></li><li><p>可以将下标或值赋予 <code>_</code> 来忽略它</p><pre><code class="go">for i, _ := range powfor _, value := range pow</code></pre></li><li><p>若你只需要索引，忽略第二个变量即可。</p><pre><code class="go">for i := range pow</code></pre></li></ul><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><ul><li><p>映射将键映射到值</p></li><li><p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键</p></li><li><p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用</p><pre><code class="go">var m map[key_type]value_typem = make(map[key_type]value_type)</code></pre></li><li><p>短声明写法</p><pre><code class="go">m := make(map[string]int)  // m := make(map[key_type]value_type)</code></pre></li><li><p>映射的文法与结构体相似，不过必须有键名</p><pre><code class="go">type Vertex struct &#123;    Lat, Long float64&#125;var m = map[string]Vertex&#123;    &quot;Bell Labs&quot;: Vertex&#123;        40.68433, -74.39967,    &#125;,    &quot;Google&quot;: Vertex&#123;        37.42202, -122.08408,    &#125;,&#125;</code></pre></li><li><p>若顶级类型只是一个类型名，你可以在文法的元素中省略它</p><pre><code class="go">var m = map[string]Vertex&#123;    &quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;,    &quot;Google&quot;:    &#123;37.42202, -122.08408&#125;,&#125;</code></pre></li></ul><h4 id="修改映射"><a href="#修改映射" class="headerlink" title="修改映射"></a>修改映射</h4><ul><li><p>在映射 <code>m</code> 中插入或修改元素：</p><pre><code class="go">m[key] = elem</code></pre></li><li><p>获取元素：</p><pre><code class="go">elem = m[key]</code></pre></li><li><p>删除元素：</p><pre><code class="go">delete(m, key)</code></pre></li><li><p>通过双赋值检测某个键是否存在：</p><pre><code class="go">elem, ok = m[key]</code></pre></li><li><p>若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明</p><pre><code class="go">elem, ok := m[key]</code></pre></li><li><p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code></p></li><li><p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值</p><pre><code class="go">v, ok := m[&quot;Answer&quot;]fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)  // The value: 0 Present? false</code></pre></li><li><p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值</p></li></ul><h4 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h4><ul><li><p>函数也是值。它们可以像其它值一样传递。</p></li><li><p>函数值可以用作函数的参数或返回值</p><pre><code class="go">hypot := func(x, y float64) float64 &#123;    return math.Sqrt(x*x + y*y)&#125;</code></pre></li></ul><h4 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h4><ul><li><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p></li><li><p>例如，函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code> 变量上</p><pre><code class="go">func adder() func(int) int &#123;    sum := 0    return func(x int) int &#123;        sum += x        return sum    &#125;&#125;func main() &#123;    pos, neg := adder(), adder()    for i := 0; i &lt; 10; i++ &#123;        fmt.Println(            pos(i),            neg(-2*i),        )    &#125;&#125;</code></pre></li></ul><h3 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>Go 没有类。不过你可以为结构体类型定义方法。</p></li><li><p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p></li><li><p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p></li><li><p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者</p><pre><code class="go">type Vertex struct &#123;    X, Y float64&#125;func (v Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    fmt.Println(v.Abs())&#125;</code></pre></li><li><p>记住：方法只是个带接收者参数的函数。</p></li><li><p>现在这个 <code>Abs</code> 的写法就是个正常的函数，功能并没有什么变化</p><pre><code class="go">func Abs(v Vertex) float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    fmt.Println(Abs(v))&#125;</code></pre></li><li><p>也可以为非结构体类型声明方法。</p></li><li><p>在此例中，我们看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code></p><pre><code class="go">func (f MyFloat) Abs() float64 &#123;    if f &lt; 0 &#123;        return float64(-f)    &#125;    return float64(f)&#125;func main() &#123;    f := MyFloat(-math.Sqrt2)    fmt.Println(f.Abs())&#125;</code></pre></li><li><p>只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法（就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p></li></ul><h4 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h4><ul><li><p>可以为指针接收者声明方法。</p></li><li><p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p></li><li><p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法</p><pre><code class="go">type Vertex struct &#123;    X, Y float64&#125;func (v Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale(f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    v.Scale(10)    fmt.Println(v.Abs())&#125;</code></pre></li><li><p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p></li><li><p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作。（对于函数的其它参数也是如此。）<code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p></li></ul><h4 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h4><ul><li><p>注意：带指针参数的函数必须接受一个指针</p><pre><code class="go">func ScaleFunc(v *Vertex, f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    ScaleFunc(v, 5)  // 编译错误！    ScaleFunc(&amp;v, 5) // OK&#125;</code></pre></li><li><p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针</p><pre><code class="go">func (v *Vertex) Scale(f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    v.Scale(5)  // OK    p := &amp;v    p.Scale(10) // OK    &#125;</code></pre></li><li><p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code></p></li><li><p>同样的事情也发生在相反的方向。</p></li><li><p>接受一个值作为参数的函数必须接受一个指定类型的值</p><pre><code class="go">func AbsFunc(v Vertex) float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    fmt.Println(AbsFunc(v))  // OK    fmt.Println(AbsFunc(&amp;v)) // 编译错误！&#125;</code></pre></li><li><p>而以值为接收者的方法被调用时，接收者既能为值又能为指针</p><pre><code class="go">func (v Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    var v Vertex    fmt.Println(v.Abs()) // OK    p := &amp;v    fmt.Println(p.Abs()) // OK&#125;</code></pre></li><li><p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code></p></li></ul><h4 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h4><ul><li><p>使用指针接收者的原因有二：</p><ol><li>首先，方法能够修改其接收者指向的值。</li><li>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</li></ol></li><li><p>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 <code>Abs</code> 并不需要修改其接收者。</p><pre><code class="go">func (v *Vertex) Scale(f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func (v *Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := &amp;Vertex&#123;3, 4&#125;    fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs())    v.Scale(5)    fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())&#125;</code></pre></li><li><p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用</p></li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p></li><li><p>接口类型的变量可以保存任何实现了这些方法的值</p><pre><code class="go">type Abser interface &#123;    Abs() float64&#125;func main() &#123;    var a Abser    f := MyFloat(-math.Sqrt2)    v := Vertex&#123;3, 4&#125;    a = f  // a MyFloat 实现了 Abser    a = &amp;v // a *Vertex 实现了 Abser    fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123;    if f &lt; 0 &#123;        return float64(-f)    &#125;    return float64(f)&#125;type Vertex struct &#123;    X, Y float64&#125;func (v *Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;</code></pre></li></ul><h4 id="接口与隐式实现"><a href="#接口与隐式实现" class="headerlink" title="接口与隐式实现"></a>接口与隐式实现</h4><ul><li><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p></li><li><p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p></li><li><p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p><pre><code class="go">type I interface &#123;    M()&#125;type T struct &#123;    S string&#125;// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。func (t T) M() &#123;    fmt.Println(t.S)&#125;func main() &#123;    var i I = T&#123;&quot;hello&quot;&#125;    i.M()&#125;</code></pre></li></ul><h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><ul><li><p>接口也是值。它们可以像其它值一样传递。</p></li><li><p>接口值可以用作函数的参数或返回值。</p></li><li><p>在内部，接口值可以看做包含值和具体类型的元组：<code>(value, type)</code></p></li><li><p>接口值保存了一个具体底层类型的具体值。</p></li><li><p>接口值调用方法时会执行其底层类型的同名方法。</p><pre><code class="go">type I interface &#123;    M()&#125;type T struct &#123;    S string&#125;func (t *T) M() &#123;    fmt.Println(t.S)&#125;type F float64func (f F) M() &#123;    fmt.Println(f)&#125;func main() &#123;    var i I    i = &amp;T&#123;&quot;Hello&quot;&#125;    describe(i)    i.M()    i = F(math.Pi)    describe(i)    i.M()&#125;func describe(i I) &#123;    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)&#125;</code></pre></li></ul><h4 id="底层值为-nil-的接口值"><a href="#底层值为-nil-的接口值" class="headerlink" title="底层值为 nil 的接口值"></a>底层值为 nil 的接口值</h4><ul><li>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</li><li>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code> 方法）。</li><li><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</li><li>nil 接口值既不保存值也不保存具体类型。</li><li>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</li></ul><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><ul><li><p>指定了零个方法的接口值被称为 <em>空接口：</em></p><pre><code>interface&#123;&#125;</code></pre></li><li><p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p></li><li><p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。</p><pre><code class="go">func main() &#123;    var i interface&#123;&#125;    describe(i)    i = 42    describe(i)    i = &quot;hello&quot;    describe(i)&#125;func describe(i interface&#123;&#125;) &#123;    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)&#125;</code></pre></li></ul><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><ul><li><p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。</p><pre><code class="go">t := i.(T)</code></pre></li><li><p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p></li><li><p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个恐慌。</p></li><li><p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p><pre><code class="go">t, ok := i.(T)</code></pre></li><li><p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p></li><li><p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p></li><li><p>请注意这种语法和读取一个映射时的相同之处</p><pre><code class="go">func main() &#123;    var i interface&#123;&#125; = &quot;hello&quot;    s := i.(string)    fmt.Println(s)    s, ok := i.(string)    fmt.Println(s, ok)    f, ok := i.(float64)    fmt.Println(f, ok)    f = i.(float64) // 报错(panic)    fmt.Println(f)&#125;</code></pre></li></ul><h4 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h4><ul><li><p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。</p></li><li><p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p><pre><code>switch v := i.(type) &#123;case T:    // v 的类型为 Tcase S:    // v 的类型为 Sdefault:    // 没有匹配，v 与 i 的类型相同&#125;</code></pre></li><li><p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</p></li><li><p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p><pre><code class="go">func do(i interface&#123;&#125;) &#123;    switch v := i.(type) &#123;    case int:        fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2)    case string:        fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v))    default:        fmt.Printf(&quot;I don&#39;t know about type %T!\n&quot;, v)    &#125;&#125;func main() &#123;    do(21)    do(&quot;hello&quot;)    do(true)&#125;</code></pre></li></ul><h4 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h4><ul><li><p><a href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p><pre><code class="go">type Stringer interface &#123;    String() string&#125;</code></pre></li><li><p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p><pre><code class="go">type Person struct &#123;    Name string    Age  int&#125;func (p Person) String() string &#123;    return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)&#125;func main() &#123;    a := Person&#123;&quot;Arthur Dent&quot;, 42&#125;    z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125;    fmt.Println(a, z)&#125;</code></pre></li></ul><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><ul><li><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p></li><li><p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p><pre><code class="go">type error interface &#123;    Error() string&#125;</code></pre></li><li><p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p></li><li><p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p><pre><code class="go">i, err := strconv.Atoi(&quot;42&quot;)if err != nil &#123;    fmt.Printf(&quot;couldn&#39;t convert number: %v\n&quot;, err)    return&#125;fmt.Println(&quot;Converted integer:&quot;, i)</code></pre></li><li><p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败</p><pre><code class="go">type MyError struct &#123;    When time.Time    What string&#125;func (e *MyError) Error() string &#123;    return fmt.Sprintf(&quot;at %v, %s&quot;,        e.When, e.What)&#125;func run() error &#123;    return &amp;MyError&#123;        time.Now(),        &quot;it didn&#39;t work&quot;,    &#125;&#125;func main() &#123;    if err := run(); err != nil &#123;        fmt.Println(err)    &#125;&#125;</code></pre></li></ul><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><ul><li><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p></li><li><p>Go 标准库包含了该接口的<a href="https://go-zh.org/search?q=Read#Global">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p></li><li><p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p><pre><code class="go">func (T) Read(b []byte) (n int, err error)</code></pre></li><li><p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p></li><li><p>示例代码创建了一个 <a href="https://go-zh.org/pkg/strings/#Reader"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出</p><pre><code class="go">func main() &#123;    r := strings.NewReader(&quot;Hello, Reader!&quot;)    b := make([]byte, 8)    for &#123;        n, err := r.Read(b)        fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)        fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])        if err == io.EOF &#123;            break        &#125;    &#125;&#125;</code></pre></li></ul><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul><li><p><a href="https://go-zh.org/pkg/image/#Image"><code>image</code></a> 包定义了 <code>Image</code> 接口：</p><pre><code class="go">package imagetype Image interface &#123;    ColorModel() color.Model    Bounds() Rectangle    At(x, y int) color.Color&#125;</code></pre></li><li><p><strong>注意:</strong> <code>Bounds</code> 方法的返回值 <code>Rectangle</code> 实际上是一个 <a href="https://go-zh.org/pkg/image/#Rectangle"><code>image.Rectangle</code></a>，它在 <code>image</code> 包中声明。</p></li><li><p>参阅<a href="https://go-zh.org/pkg/image/#Image">文档</a>了解全部信息</p></li><li><p><code>color.Color</code> 和 <code>color.Model</code> 类型也是接口，但是通常因为直接使用预定义的实现 <code>image.RGBA</code> 和 <code>image.RGBAModel</code> 而被忽视了。这些接口和类型由 <a href="https://go-zh.org/pkg/image/color/"><code>image/color</code></a> 包定义</p><pre><code class="go">func main() &#123;    m := image.NewRGBA(image.Rect(0, 0, 100, 100))    fmt.Println(m.Bounds())    fmt.Println(m.At(0, 0).RGBA())&#125;</code></pre></li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="Go-程"><a href="#Go-程" class="headerlink" title="Go 程"></a>Go 程</h4><ul><li><p>Go 程（goroutine）是由 Go 运行时管理的轻量级线程。</p><pre><code>go f(x, y, z)</code></pre></li><li><p>会启动一个新的 Go 程并执行</p><pre><code>f(x, y, z)</code></pre></li><li><p><code>f</code>, <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go 程中，而 <code>f</code> 的执行发生在新的 Go 程中。</p></li><li><p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。<a href="https://go-zh.org/pkg/sync/"><code>sync</code></a> 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法</p></li></ul><h4 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h4><ul><li><p>信道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p><pre><code class="go">ch &lt;- v    // 将 v 发送至信道 ch。v := &lt;-ch  // 从 ch 接收值并赋予 v。</code></pre></li><li><p>（“箭头”就是数据流的方向。）</p></li><li><p>和映射与切片一样，信道在使用前必须创建：</p><pre><code class="go">ch := make(chan int)</code></pre></li><li><p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p></li><li><p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果</p><pre><code class="go">func sum(s []int, c chan int) &#123;    sum := 0    for _, v := range s &#123;        sum += v    &#125;    c &lt;- sum // 将和送入 c&#125;func main() &#123;    s := []int&#123;7, 2, 8, -9, 4, 0&#125;    c := make(chan int)    go sum(s[:len(s)/2], c)    go sum(s[len(s)/2:], c)    x, y := &lt;-c, &lt;-c // 从 c 中接收    fmt.Println(x, y, x+y)&#125;</code></pre></li></ul><h4 id="带缓冲的信道"><a href="#带缓冲的信道" class="headerlink" title="带缓冲的信道"></a>带缓冲的信道</h4><ul><li><p>信道可以是 <em>带缓冲的</em>。将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道：</p><pre><code class="go">ch := make(chan int, 100)</code></pre></li><li><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><pre><code class="go">func main() &#123;    ch := make(chan int, 2)    ch &lt;- 1    ch &lt;- 2    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)&#125;</code></pre></li></ul><h4 id="range-和-close"><a href="#range-和-close" class="headerlink" title="range 和 close"></a>range 和 close</h4><ul><li><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p><pre><code>v, ok := &lt;-ch</code></pre></li><li><p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p></li><li><p>循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p></li><li><p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p></li><li><p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p><pre><code class="go">func fibonacci(n int, c chan int) &#123;    x, y := 0, 1    for i := 0; i &lt; n; i++ &#123;        c &lt;- x        x, y = y, x+y    &#125;    close(c)&#125;func main() &#123;    c := make(chan int, 10)    go fibonacci(cap(c), c)    for i := range c &#123;        fmt.Println(i)    &#125;&#125;</code></pre></li></ul><h4 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h4><ul><li><p><code>select</code> 语句使一个 Go 程可以等待多个通信操作。</p></li><li><p><code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行</p><pre><code class="go">func fibonacci(c, quit chan int) &#123;    x, y := 0, 1    for &#123;        select &#123;        case c &lt;- x:            x, y = y, x+y        case &lt;-quit:            fmt.Println(&quot;quit&quot;)            return        &#125;    &#125;&#125;func main() &#123;    c := make(chan int)    quit := make(chan int)    go func() &#123;        for i := 0; i &lt; 10; i++ &#123;            fmt.Println(&lt;-c)        &#125;        quit &lt;- 0    &#125;()    fibonacci(c, quit)&#125;</code></pre></li></ul><h4 id="默认选择"><a href="#默认选择" class="headerlink" title="默认选择"></a>默认选择</h4><ul><li><p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。</p></li><li><p>为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p><pre><code class="go">select &#123;case i := &lt;-c:    // 使用 idefault:    // 从 c 中接收会阻塞时执行&#125;</code></pre></li></ul><h4 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h4><ul><li><p>我们已经看到信道非常适合在各个 Go 程间进行通信。</p></li><li><p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p></li><li><p>这里涉及的概念叫做 互斥（<code>mutual*exclusion</code>），我们通常使用 互斥锁（Mutex）这一数据结构来提供这种机制。</p></li><li><p>Go 标准库中提供了 <a href="https://go-zh.org/pkg/sync/#Mutex"><code>sync.Mutex</code></a> 互斥锁类型及其两个方法：</p><ul><li><code>Lock</code></li><li><code>Unlock</code></li></ul></li><li><p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。参见 <code>Inc</code> 方法。</p></li><li><p>我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见 <code>Value</code> 方法</p></li></ul><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><ul><li>Go <a href="https://go-zh.org/doc/">文档</a></li><li><a href="https://go-zh.org/doc/code.html">如何使用Go编程</a></li><li><a href="https://go-zh.org/pkg/">包手册</a></li><li><a href="https://go-zh.org/ref/spec">语言规范</a></li><li>进一步探索 Go 的并发模型，参阅 <a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go 并发模型</a>(<a href="https://talks.go-zh.org/2012/concurrency.slide">幻灯片</a>)以及<a href="https://www.youtube.com/watch?v=QDDwwePbDtw">深入 Go 并发模型</a>(<a href="https://talks.go-zh.org/2013/advconc.slide">幻灯片</a>)并阅读<a href="https://go-zh.org/doc/codewalk/sharemem/">通过通信共享内存</a>的代码之旅</li><li><a href="https://vimeo.com/53221558">一个简单的编程环境</a>(<a href="https://talks.go-zh.org/2012/simple.slide">幻灯片</a>)</li><li><a href="https://go-zh.org/doc/articles/wiki/">编写 Web 应用</a>的指南</li><li><a href="https://go-zh.org/doc/codewalk/functions/">函数：Go 中的一等公民</a>展示了有趣的函数类型</li><li><a href="https://blog.go-zh.org/">Go 博客</a>有着众多关于 Go 的文章和信息</li><li><a href="https://www.mikespook.com/tag/golang/">mikespook 的博客</a>中有大量中文的关于 Go 的文章和翻译</li><li>开源电子书 <a href="https://github.com/astaxie/build-web-application-with-golang">Go Web 编程</a>和 <a href="https://github.com/Unknwon/the-way-to-go_ZH_CN">Go 入门指南</a>能够帮助你更加深入的了解和学习 Go 语言</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Go 语言是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，它用批判吸收的眼光，融合 C 语言、Java 等众家之长，将简洁、高效演绎得淋漓尽致。Golang非常适合用来做网络并发方面的服务，比如消息推送、监控、容器等。初次学习我选择的是 &lt;a href=&quot;https://go-zh.org/&quot;&gt;Go 编程语言&lt;/a&gt;指南，指南涵盖了该语言的大部分重要特性，放在以下为所记笔记，另附有随堂代码放在 &lt;a href=&quot;https://github.com/Bezhuang/Learn-CS/tree/main/Learn%20Programming/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85&quot;&gt;Github 仓库&lt;/a&gt;中，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go" scheme="http://blog.zhuangzhihao.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>银行 ATM 系统实现</title>
    <link href="http://blog.zhuangzhihao.top/ATM%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.zhuangzhihao.top/ATM%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-02-04T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2022年寒假二刷复习完 Java SE 的全部知识点后，为了更加熟练掌握 Java 面向对象的特性，进一步掌握编程技巧和调试技巧，根据<a href="https://www.bilibili.com/video/BV1Cv411372m">黑马程序员项目指导</a>模拟实现一个银行 ATM 系统软件，以下为项目过程中记录的笔记和项目介绍文档，源代码保存在 <a href="https://github.com/Bezhuang/Learn-CS/tree/main/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/ATM-system">Github 仓库</a>中，可供参考。</p></blockquote><a id="more"></a><h3 id="银行-ATM-系统技术选型分析"><a href="#银行-ATM-系统技术选型分析" class="headerlink" title="银行 ATM 系统技术选型分析"></a>银行 ATM 系统技术选型分析</h3><ul><li>面向对象编程：每个用户对象要对应一个账户对象，所以需要设计账户类 <code>Account</code></li><li>使用集合容器：系统需要提供一个容器用于存储这些账户对象的信息，选用 <code>ArrayList</code> 集合</li><li>程序流程控制：需要结合分支、循环、跳转等相关操作控制程序的业务逻辑</li><li>使用常见API：内容比较，分析，数据处理等需要用到 <code>String</code> 等常用 API</li></ul><h3 id="账户类、首页设计"><a href="#账户类、首页设计" class="headerlink" title="账户类、首页设计"></a>账户类、首页设计</h3><ul><li><p>每个用户一个账户对象，需要设计账户类 <code>Account</code>，账户类至少包含（卡号、用户名、余额、取现额度、密码）</p></li><li><p>需要定义一个 <code>ArrayList</code> 的集合用于存储账户对象</p><pre><code class="java">ArrayList accounts = new ArrayList&lt;&gt;();</code></pre></li><li><p>需要展示欢迎页包含2个功能：注册开户、登录账户</p></li></ul><h3 id="用户开户功能实现"><a href="#用户开户功能实现" class="headerlink" title="用户开户功能实现"></a>用户开户功能实现</h3><ul><li><p>开户功能应该独立定义成方法，并传入当前集合对象给该方法</p><pre><code class="java">public static void register(ArrayList&lt;Account&gt; accounts) &#123;…&#125;</code></pre></li><li><p>需要提示用户输入个人信息，开户的卡号是系统自动生成的8位数</p><pre><code class="java">public static String createCardId()&#123;…&#125;</code></pre></li><li><p>注意自动生成的卡号不能与其他用户的卡号重复</p></li><li><p>最终把用户开户的信息封装成 <code>Account</code> 对象，存入到集合中</p></li></ul><h3 id="用户登录功能实现"><a href="#用户登录功能实现" class="headerlink" title="用户登录功能实现"></a>用户登录功能实现</h3><ul><li><p>定义方法</p><pre><code class="java">public static void login(ArrayList&lt;Account&gt; accounts) &#123;…&#125;</code></pre></li><li><p>需要根据卡号去集合中查询对应的账户对象</p></li><li><p>如果找到了账户对象，说明卡号存在，继续输入密码</p></li><li><p>如果密码也正确，则登录成功</p></li></ul><h3 id="用户操作页设计、查询账户、退出账户功能"><a href="#用户操作页设计、查询账户、退出账户功能" class="headerlink" title="用户操作页设计、查询账户、退出账户功能"></a>用户操作页设计、查询账户、退出账户功能</h3><ul><li>用户登录成功后，需要进入用户操作页</li><li>查询就是直接展示当前登录成功的账户对象的信息</li><li>退出账户是需要回到首页的</li></ul><h3 id="用户存款、取款功能设计"><a href="#用户存款、取款功能设计" class="headerlink" title="用户存款、取款功能设计"></a>用户存款、取款功能设计</h3><ul><li>存款和取款都是拿到当前用户的账户对象</li><li> 通过调用账户对象的 <code>set</code> 方法修改其余额</li></ul><h3 id="用户转账功能"><a href="#用户转账功能" class="headerlink" title="用户转账功能"></a>用户转账功能</h3><ul><li>转账功能要分析对方账户是否存在的问题</li><li>还要分析自己的余额是否足够的问题</li></ul><h3 id="用户密码修改功能、销户功能"><a href="#用户密码修改功能、销户功能" class="headerlink" title="用户密码修改功能、销户功能"></a>用户密码修改功能、销户功能</h3><ul><li>修改密码就是把当前对象的密码属性使用 <code>set</code> 方法进行更新</li><li>销户是从集合对象中删除当前对象，并回到首页</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2022年寒假二刷复习完 Java SE 的全部知识点后，为了更加熟练掌握 Java 面向对象的特性，进一步掌握编程技巧和调试技巧，根据&lt;a href=&quot;https://www.bilibili.com/video/BV1Cv411372m&quot;&gt;黑马程序员项目指导&lt;/a&gt;模拟实现一个银行 ATM 系统软件，以下为项目过程中记录的笔记和项目介绍文档，源代码保存在 &lt;a href=&quot;https://github.com/Bezhuang/Learn-CS/tree/main/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/ATM-system&quot;&gt;Github 仓库&lt;/a&gt;中，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://blog.zhuangzhihao.top/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Accenture Coding Virtual Experience Program</title>
    <link href="http://blog.zhuangzhihao.top/Accenture-Coding-Virtual-Experience/"/>
    <id>http://blog.zhuangzhihao.top/Accenture-Coding-Virtual-Experience/</id>
    <published>2022-01-15T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The Accenture Know-the-Code Virtual Experience Program covers the fundamentals of software development, including object-oriented programming, code refactoring, and agile delivery. It empowers me to explore what a career in software development could look like at Accenture while practicing my coding skills. The following are the notes I took during this virtual experience.</p></blockquote><a id="more"></a><div class="row">    <embed src="/pdf/Accenture-Coding-Virtual-Experience.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Task-1-Object-Oriented-Programming"><a href="#Task-1-Object-Oriented-Programming" class="headerlink" title="Task 1: Object Oriented Programming"></a>Task 1: Object Oriented Programming</h3><h4 id="Background-Information"><a href="#Background-Information" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Recently, a company has brought on Accenture to help with the development of its e-commerce website written in Java using the Spring Boot framework. The first task they need help with is searching for products</li><li>One of the UX designers at Accenture has already implemented the new search capability in the UI</li><li>My responsibility is to implement the search capability in our backend Java app</li></ul><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Expose an HTTP GET request on the path <code>/api/products/search</code></li><li>The request should take a single parameter named “<code>query</code>” which will be the text that was entered in the search bar</li><li>The request will return a Collection of <code>ProductItem</code> which are the matching products for the search</li></ul><h4 id="Implement-a-new-controller-to-handle-searching"><a href="#Implement-a-new-controller-to-handle-searching" class="headerlink" title="Implement a new controller to handle searching"></a>Implement a new controller to handle searching</h4><ol><li>Download and unzip the mock-company-webapp codebase</li><li>Open the application in IDEA with Gradle support</li><li>Follow the README.md instructions for setting up the development environment</li><li>Implement the “<code>search</code>” method of the class <code>SearchController</code>, the relevant code is outlined with a TODO comment</li><li>The controller should use the “<code>productItemRepository</code>” to interface with the product database</li><li>Review the tests and implement the controller to the spec</li></ol><h4 id="Practical-skills-gained"><a href="#Practical-skills-gained" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Object Oriented Programming</li><li>Java</li><li>Spring</li></ul><h3 id="Task-2-Code-Refactoring"><a href="#Task-2-Code-Refactoring" class="headerlink" title="Task 2: Code Refactoring"></a>Task 2: Code Refactoring</h3><h4 id="Background-Information-1"><a href="#Background-Information-1" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Now we’ve identified some code in the <code>ReportController</code> class that seems to be doing similar product searching</li><li>I need to refactor the <code>SearchController</code> logic into a new <code>SearchService</code> class that can be used in the <code>SearchController</code> as well as in the <code>ReportController</code></li></ul><h4 id="Requirements-1"><a href="#Requirements-1" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Logic moved from <code>SearchController</code> to <code>SearchService</code></li><li><code>SearchController</code> and <code>ReportController</code> both updated to use the <code>SearchService</code></li><li>All unit tests pass</li></ul><h4 id="Refactor-controllers-to-a-shared-service"><a href="#Refactor-controllers-to-a-shared-service" class="headerlink" title="Refactor controllers to a shared service"></a>Refactor controllers to a shared service</h4><ol><li>Follow the README.md instructions for setting up the development environment</li><li>Create the new <code>SearchService</code> class in the “<code>services</code>” package. All of the search logic from the <code>SearchController</code> should be moved into a function in this class for reusability. The relevant code is outlined with a TODO comment</li><li>Using <code>@Autowired</code>, inject the <code>SearchService</code> into the <code>SearchController</code> and <code>ReportController</code></li><li>Refactor both controller classes to use the service by rewriting their functions to use the new service</li><li>Ensure unit tests all pass</li></ol><h4 id="Practical-skills-gained-1"><a href="#Practical-skills-gained-1" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Java</li><li>Spring</li></ul><h3 id="Task-3-Continuous-Integration"><a href="#Task-3-Continuous-Integration" class="headerlink" title="Task 3: Continuous Integration"></a>Task 3: Continuous Integration</h3><h4 id="Background-Information-2"><a href="#Background-Information-2" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Continuous Integration is the practice of automating the integration of code changes from multiple contributors into a single software project</li><li>It’s a primary DevOps best practice, allowing developers to frequently merge code changes into a central repository where building and test runs can occur</li><li>Use the most popular Continuous Integration tool, Jenkins</li><li>Creating a <code>Jenkinsfile</code> that will build and test the application on all branches of the repository</li></ul><h4 id="Requirements-2"><a href="#Requirements-2" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>GitHub account created, Git CLI setup, mock-company-webapp repository forked and cloned</li><li><code>Jenkinsfile</code> defined with stages setting it up to run on commit to any branch in the repository</li><li>Continuous Integration server runs <code>build/test</code> and succeeds</li><li>Change made to code that breaks test</li><li>Continuous Integration server runs <code>build/test</code> and fails</li></ul><h4 id="Simulating-Jenkins-using-the-Jenkinsfile-Runner-Action-in-a-GitHub-Workflow"><a href="#Simulating-Jenkins-using-the-Jenkinsfile-Runner-Action-in-a-GitHub-Workflow" class="headerlink" title="Simulating Jenkins using the Jenkinsfile Runner Action in a GitHub Workflow"></a>Simulating Jenkins using the <code>Jenkinsfile</code> Runner Action in a GitHub Workflow</h4><ol><li>Create an account with GitHub and fork the mock-company-webapp repository</li><li>Setup the Git CLI on workstation and “<code>clone</code>” the repository you forked to workstation</li><li>Install the Pipelines application from the GitHub marketplace to use Jenkins directly</li><li>use the Simulated Jenkins for GitHub link to add a <code>.github/workflows/workflow.yml</code> to the repository.</li><li>Add the following stages to the <code>Jenkinsfile</code>, the relevant code is outlined with a TODO comment.<ul><li>Build: <code>./gradlew assemble</code></li><li>Test: <code>./gradlew test</code></li></ul></li><li>Continue to tweak the <code>Jenkinsfile</code> until the build is successful</li><li>Change the <code>SearchService</code> to always return <code>Collections.emptyList()</code> in order to break the tests.</li><li>Commit the change and validate the Continuous Integration build fails which proves that we’ve properly set up Continuous Integration guard rails, that will catch failing tests each time a commit is made by a developer</li></ol><h4 id="Practical-skills-gained-2"><a href="#Practical-skills-gained-2" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Continuous Integration</li><li>Jenkins</li><li>DevOps</li></ul><h3 id="Task-4-Agile-Planning"><a href="#Task-4-Agile-Planning" class="headerlink" title="Task 4: Agile Planning"></a>Task 4: Agile Planning</h3><h4 id="Background-Information-3"><a href="#Background-Information-3" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>In an Agile planning session, developers are given a set of large software features that they then must break up into smaller units of work, called stories, that can be completed within a one to three week period, called a sprint</li><li>A story is an informal, general explanation of a software feature written from the perspective of the end user or customer and is made up of the following components:<ul><li>Who the feature is for</li><li>What they need</li><li>Why they need it</li><li>What shows it’s done</li></ul></li></ul><h4 id="Requirements-3"><a href="#Requirements-3" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Stories are written in the following format: As a <code>&lt;who the feature is for&gt;</code>, I need to be able to <code>&lt;what they need&gt;</code> so I can <code>&lt;why they need it&gt;</code></li><li>The “<code>what shows it’s done</code>”, called acceptance criteria, must be provided with the story as well</li><li>Stories are then pointed or sized which means to assign some kind of value indicating the difficulty of implementing the story</li><li>Use a T-Shirt size strategy assigning a value of small/medium/large to each story</li><li>It’s very important that stories are broken down as small as they can be so try and keep them either small or medium</li><li>This allows for better concurrency throughout the sprint and easier completion within a single sprint</li></ul><h4 id="planning-a-sprint-to-implement-the-checkout-feature-of-the-site"><a href="#planning-a-sprint-to-implement-the-checkout-feature-of-the-site" class="headerlink" title="planning a sprint to implement the checkout feature of the site"></a>planning a sprint to implement the checkout feature of the site</h4><ul><li>Create a document that defines around 10 to 20 stories around the checkout feature</li><li>Pull in a subset of these stories based on our capacity to work on in the next sprint</li><li>Make sure the stories are broken up as small as possible, and the acceptance criteria is testable</li></ul><h4 id="Practical-skills-gained-3"><a href="#Practical-skills-gained-3" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Agile Methodology</li><li>Software Development Lifecycle (SDLC)</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;The Accenture Know-the-Code Virtual Experience Program covers the fundamentals of software development, including object-oriented programming, code refactoring, and agile delivery. It empowers me to explore what a career in software development could look like at Accenture while practicing my coding skills. The following are the notes I took during this virtual experience.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="程序人生" scheme="http://blog.zhuangzhihao.top/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
    <category term="Spring" scheme="http://blog.zhuangzhihao.top/tags/Spring/"/>
    
    <category term="Spring Boot" scheme="http://blog.zhuangzhihao.top/tags/Spring-Boot/"/>
    
    <category term="Gradle" scheme="http://blog.zhuangzhihao.top/tags/Gradle/"/>
    
    <category term="Jenkins" scheme="http://blog.zhuangzhihao.top/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-12-09T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。我选择的课程是哈工大的<a href="https://www.icourse163.org/learn/HIT-154005">国家精品课</a>和谢希仁版教材，以下为所记课堂笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h4><ul><li>计算机网络就是一些互联的、自治的计算机系统的集合。</li><li>自治计算机就是能够进行自我管理、配置和维护的计算机。</li><li>计算机网络包括硬件、软件、协议三大部分。<ul><li>硬件由主机、通信处理机、通信线路和交换设备组成。</li></ul></li><li>从工作方式上看，计算机网络可分为边缘部分和核心部分。</li><li>从功能组成上看，计算机网络由通信子网和资源子网两部分构成。<ul><li>通信子网包括物理层、数据链路层和网络层。</li></ul></li><li>数据通信是计算机网络最基本和最重要的功能。</li><li>资源共享包括数据资源、软件资源以及硬件资源。</li></ul><h4 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h4><ul><li>实体是任何可发送或接收信息的硬件或软件进程。</li><li>对等层是不同机器上的同一层，对等实体是同一层上的实体。</li><li>协议是控制2个对等实体进行通信的规则。</li><li>接口又称服务访问点，没有接口就不能提供服务。从物理层开始，每一层都向上层提供服务访问点。</li><li>服务数据单元 SDU，协议控制信息 PCI，接口控制信息 ICI。</li><li>协议数据单元 PDU，表示的是同等层对等实体间传送的数据单元。<code>n-SDU</code>+<code>n-PCI</code>=<code>n-PDU</code>，<code>n-PDU</code>=<code>(n-1)-SDU</code></li><li>接口数据单元 IDU，表示的是在相邻层接口间传送的数据单元。<code>n-SDU</code>+<code>n-ICI</code>=<code>n-IDU</code></li><li>服务至下层为相邻上层提供的功能调用。只有那些能够被高一层实体看得见的功能才成为服务。</li><li>面向连接的服务（TCP），面向无连接的服务（IP和UDP）。</li><li>第n层的实体使用第n-1层的服务，向第n+1层提供本层的服务。该服务是第n层及其下各层所提供的服务的总和。</li><li>最高层向用户提供服务，下一层提供服务的实现细节对上一层透明。</li><li>OSI参考模型具有7层结构，而TCP/IP模型仅有4层结构。<ul><li>应用层（用户对用户），提供系统与用户的接口。文件传输、访问和管理、电子邮件服务。FTP，smtp，pop3，HTTP。</li><li>传输层（应用对应用，进程对进程），负责主机中2个进程之间的通信。为端到端连接提供可靠的运输服务、流量控制、差错控制、服务质量管理。TCP、udp、ARQ。</li><li>网络层（主机对主机），为传输层提供服务、组包和拆包、路由选择、拥塞控制。ICMP、Arp、RARP、IP、IGMP。</li><li>网络接口层 = 数据链路层 + 物理层</li><li>数据链路层，将网络层传下来的IP数据报组装成帧数。PPP、HDLC。</li><li>物理层，为数据端设备提供传送数据通路，传输比特流。 </li><li>应用层 = 应用层 + 表示层 + 会话层</li><li>会话层的主要功能是在2个节点间建立维护和释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传送。</li><li>表示层负责处理在2个内部数据表示结构不同的通信系统间交换信息的表示格式，数据压缩及解压。</li><li>TCP/IP模型没有明确区分服务、接口、协议，且网络层仅有无连接。OSI参考模型网络层有连接和无连接，但传输层仅面向连接。</li></ul></li></ul><h4 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h4><ul><li>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</li><li>数据传输率是由总时延决定的，而带宽仅决定了发送时延。</li><li>发送时延 = 数据帧长度（bit）/ 发送速率（bit/s）</li><li>传播时延 = 信道长度（m）/ 电磁波在信道上的传播速度（m/s）</li><li>时延带宽积 = 传播时延 × 带宽</li><li>利用率包括信道利用率和网络利用率（全网络的信道利用率的加权平均值）。</li><li>1 MB/s = 8 Mbit/s</li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><h4 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h4><ul><li>数据是传送信息的实体。而信号是数据的电气或电磁的表现。</li><li>基带对应数字信号，宽带对应模拟信号。</li><li>数据传输方式分为串行传输和并行传输。通信方式分为同步通信和异步通信。通信模式分为单向通信、双向交替通信、双向同时通信。</li><li>波特率（码元传输速率）表示单位时间内数字通信系统所传输的码元个数，单位波特（Baud）。</li><li>比特率（信息传输速率）表示单位时间内通信数字系统所传输的二进制码元个数，单位比特数（bit/s）。</li><li>每比特只能表示两种信号变化，可看成二进制。</li><li>带宽表示在单位时间内从网络中的某一点到另一点所能通过的最高数据率（网络的通信线路所能传送数据的能力）。单位比特每秒（bit/s）。</li><li>在通信领域，带宽是指信号最高频率与最低频率之差（Hz）。因此将模拟信号转换成数字信号时，采样频率必须大于等于最大频率f的2倍。</li><li>奈奎斯特定理给出了在无噪声情况下码元的最大传输速率。f表示理想低通信道的带宽。N表示每个码元的离散电平的数目。<ul><li>$C_{\max }=f_1<em>\log _{2}N=2f</em>\log _{2}N$</li></ul></li><li>信噪比是信号的平均功率和噪声的平均功率之比。S/N（dB）‘</li><li>香农公式给出了信号传输速率的极限。W为信道的带宽。<ul><li>$C_{\max }=W*\log _{2}\left( 1+\dfrac{S}{N}\right)$</li></ul></li><li>要使信息的极限传输速率提高，就必须提高信道的带宽或信道中的信噪比。实际信道的传输速率要比极限速率低不少。</li><li>模拟数据和数字数据都可以转化成模拟信号（调制）或数字信号（编码）。</li><li>数据传输方式包括电路交换、报文交换和分组交换。<ul><li>电路交换一定面向连接。通信时延小、实时性强、有序传输，但信道利用率低、缺乏统一标准、灵活性差。</li><li>报文交换，报文携带有目的地址、源地址。无需建立连接、动态分配线路，但报文大小没限制，要求网络节点需要有较大的存储缓存空间。</li><li>分组交换仍采用存储转发传输方式。将一个长报文分割成若干个较短的分组。加速传输、简化存储管理、减少出错概率和重发数据量，但存在传输时延、可能出现失序、丢失或重复分组现象。</li><li>TCP可以向应用层提供面向连接的服务，而UDP在传输层是无连接的。</li><li>分组交换可分为面向连接的虚电路方式和面向无连接的数据报方式，二者都由网络层提供。</li><li>数据报无需建立连接、提高吞吐量、对故障适应力强，每个分组包含完整的源地址和目的地址，可靠通信由用户主机来保证。</li><li>虚电路时延小、按序到达，每个分组包含一个虚电路号，可靠通信由网络来保证。</li></ul></li></ul><h4 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h4><ul><li>传输介质分为导向性传输介质和非导向性传输介质。<ul><li>导向性传输介质包含双绞线、同轴电缆和光纤。</li><li>双绞线分为无屏蔽双绞线和屏蔽双绞线。</li><li>同轴电缆分为基带同轴电缆（50Ω）和宽带同轴电缆（75Ω）。</li><li>光纤分为单模光纤（远距离）和多模光纤（近距离）。</li><li>非导向性传输介质有短波、微波、红外线与可见光等。</li></ul></li><li>传输介质并不是物理层，在传输介质中传输的是信号。物理层主要的功能就是确定与传输介质的接口有关的一些特性，即物理层接口的特性，如机械特性、电气特性、功能特性、规程特性。</li><li>物理层设备主要包含中继器和集线器。放大器放大的是模拟信号，中继器放大的是数字信号。</li><li>集线器实际就是一个多端口的中继器（Hub）。集线器在一个时钟周期内只能传输一组信息。集线器不能隔离冲突域。</li><li>通过中继器或集线器连接起来的几个网段仍然是一个局域网。使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用CSMA/CD协议，共享逻辑上的总线。</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h4><ul><li>数据链路层在物理层所提供的服务的基础上向网络层提供服务，分为无确认的无连接服务、有确认的无连接服务和有确认的有连接服务。</li><li>数据链路层的主要功能分为链路管理、帧同步、差错控制、透明传输。</li><li>当2个主机互相传送信息时，网络层的分组。必须封装成帧，并以帧的格式进行传送。即将一段数据的前后分别添加首部和尾部形成帧，首部和尾部中有很多控制信息，如帧定界。</li></ul><h4 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h4><ul><li>组帧方法分为字符计数法、字节填充的首尾界符法、比特填充的首尾标志法、物理编码违例法。</li><li>在网络中以帧为最小单位进行传输，所以组帧既要有首部又要加尾部，确定接收端清楚该帧在一串比特流中从哪里开始、到哪里结束。</li><li>字符计数法用一个特殊的字符表示一帧的开始，用一个计数字段表明该帧包含的字节数，计数字段提供的字节数包含自身所占的一个字节。</li><li>首尾界符法选定2个字符（SOH/EOT）作为每一个帧的开始和结束。字符填充的首尾界符法是将数据中可能出现的控制字符<code>SOH</code>和<code>EOT</code>在接收端不解释为控制字符。</li><li>比特填充的首尾标志法使用<code>01111110</code>作为帧的开始和结束标志。零比特填充法每有5个连续的<code>1</code>马上在其后插入<code>0</code>，接收方每收到5个连续的<code>1</code>自动删除后面紧跟的<code>0</code>恢复原始数据。</li><li>物理编码违例法利用物理介质上的编码的违法标志来区分帧的开始和结束，例如在曼彻斯特编码中高-高和低-低电平的编码方式是无效的，用来作为帧的起始和结束标志。</li></ul><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><ul><li>检错编码分为奇偶校验码和循环冗余码。<ul><li>奇偶校验码是在信息码后面加1位校验码，分为奇校验和偶校验。奇校验是添加1位校验码后使得整个码字里面<code>1</code>的个数是奇数。</li><li>循环冗余码（CRC）是在发送端产生一个冗余码，附加在信息位后面一起发送到接收端，接收端收到的信息按发送端形成循冗余码同样的算法进行校验，如果发现错误则通知发送端重发。</li><li>CRC的本质是模-2除法的余数，采用的除数不同，CRC的类型也就不一样。</li><li>循环冗余码具有r检测位的多项式能够检测出所有小于或等于r的突发错误，长度大于r+1的错误逃脱的概率是 $\dfrac{1}{2^{r}}$。</li></ul></li><li>常见的纠错编码是海明码，在 k 位信息字段中插入若干位数据用于监督码字里的哪一位数据发生变化，具有一位纠错能力。<ul><li>确认校验码的位数 r：$2^{r}-1\geq k+r$</li><li>校验码$P_i$在编码中的位置为$2^{i-1}$</li><li>出错位$e_n$等于所有有关位$M_n$互为异或，求出$P_i$，按序写出海明码</li><li>校验海明码：出错位$e_n$等于所有有关位$M_n$互为异或，求出$e_n$</li><li>出错位$e_n$对应的十进制数就是出错的位数</li></ul></li></ul><h4 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h4><ul><li>流量控制就是要控制发送方发送数据的速率使接收方来得及接收，分为停止-等待流量控制和滑动窗口流量控制。<ul><li>停止-等待流量控制就是发送方发出一帧，等接收方收到一帧后返回应答信号，再发送下一帧。</li><li>滑动窗口流量控制允许一次发送多个帧。在任意时刻发送方都维持一组连续的允许发送的帧的序号，称为发送窗口。同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送端每收到一个帧的确认，发送窗口就向前移动1个帧的位置。</li><li>只有在接收窗口向前滑动时，发送窗口才有可能向前滑动。</li><li>只要当接收窗口大小为1时，则可保证帧按序接受。</li></ul></li><li>端到端的可靠传输就是在传输层使用面向连接的TCP，而不是数据链路层。</li><li>可靠传输一般使用确认和超时重传两种机制共同完成（ARQ自动请求重发）。</li><li>可靠传输机制包括停止-等待协议、后退N帧协议和选择重传协议。<ul><li>停止等待协议就是发送窗口和接收窗口大小均为1。帧一般分为数据帧和确认帧。</li><li>后退N帧协议：发送方连续发送若干个数据帧，如果收到接收方的确认帧接着发送数据，如果某个帧出错，接收方只能简单丢弃该帧及后续所有帧。增加吞吐量，但造成一定浪费。</li><li>后退N帧协议接收窗口大小=1，$1&lt;发送窗口大小W_{T}\leq 2^{n}-1$。n为对帧编号的比特数。</li><li>选择重传（SR）协议：当一帧出错时，后续帧先存入接收方的缓冲区中,同时要求发送方重传出错帧。提高信道利用率但增加缓冲空间。</li><li>选择重传协议的接收窗口尺寸和发送窗口尺寸都大于1，以便能一次性接受多个帧。发送窗口的最大尺寸也不能超过序列号范围的一半。当发送窗口等于接收窗口=$2^{n}-1$时达到最大效率。</li><li>按序到达的且没有被交付给主机的帧被放在接收缓存里。不按序到达的数据且没有错误的帧放在接收窗口里。不直接给主机，等缺少的帧收到后再一起放到接收缓存。</li></ul></li></ul><h4 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h4><ul><li>静态分配信道的方法是信道划分介质访问控制。动态分配信道的方法分为随机访问介质访问控制和轮询访问介质访问控制。</li><li>多路复用技术是在一条介质上同时携带多个传输信号，使多个计算机或终端设备共享信道资源，提高信道的利用率。实现信道划分介质访问控制。</li><li>信道划分介质访问控制分为频分多路复用、时分多路复用、波分多路复用和码分多路复用。<ul><li>频分多路复用时如果复用数增加，那么信号的频率带宽增加。</li><li>统计时分复用是一种动态的时间分配。</li><li>波分多路复用就是光的频分多路复用。</li><li>码分多路复用，又称为码分多址（CDMA），既共享信道的频率又共享时间，主要用于无线通信系统。</li><li>任意2个站点的码片向量的规格化内积一定为1。任意站点的码片向量与该码片向量自身的规格化内积一定为1。任何站点的码片向量和该码片的反码向量的规格化内积一定为负1。</li></ul></li><li>动态划分信道分为随机接入（争用性协议）和受控接入。<ul><li>ALOHA协议：不检测发送数据，一段时间没收到确认即为发送冲突，发生冲突的节点等待一段随机事件后再发送数据。</li><li>时分ALOHA：所有节点的时间被划分为间隔相同的时隙，并规定每个节点就会等到下一个时隙到来时才可发送数据。</li><li>载波侦听多路访问（CSMA）协议：每个节点发送数据之前，都使用载波侦听技术来判定通信信道是否空闲，在局域网中被广泛的应用。</li><li>1-坚持CSMA：监听到信道空闲时，立即发送数据，否则继续监听。</li><li>p-坚持CSMA：监听到信道空闲时，以概率P发送数据，以概率(1-P)延迟一段时间并重新监听。</li><li>非坚持CSMA。监听到信道空闲时，立即发送数据，否则延迟一段随机的时间再重新监听。</li><li>CSMA/CD协议（带冲突检测的载波侦听多路访问协议）：检测超过发送站点本身发送的载波信号的幅度，由此判断出冲突的存在，并向总线上发一串阻塞信号。</li><li>CSMA/CD工作流程：先听后发，边听边发，冲突停发，随机重发。</li><li>CSMACD用于信道使用半双工的网络环境，而对于使用全双工的网络环境，则无需采用这种介质访问控制技术。</li><li>争用期（$2\tau$）：以太网端到端的往返时延，又称冲突窗口或碰撞窗口。只有经过争用期还没有检测到冲突，才能肯定这次发送不会发生冲突。</li><li>以太网规定最短帧长为64B，凡长度小于64B的都是由于冲突而异常停止的无效帧。以太网端到端的单程时延实际上小于争用期的一半（25.6μs）。</li><li>最短有效帧长和最远2个站的距离及传输速率成正比。</li><li>截断二进制指数类型退避算法：发生碰撞的站在停止发送数据后要推迟一个随机时间才能发送数据，基本退避时间一般取争用期（$2\tau$），重传需要推迟的平均时间随重传次数的增大而增大。</li><li>CSMA/CA协议主要用在无线局域网中，在CSMA的基础上增加了冲突避免的功能。</li><li>CSMA/CA协议要对正确接收到的数据帧进行确认。</li></ul></li><li>轮询访问介质访问控制主要用于在令牌环局域网中。典型的轮询访问介质访问控制协议就是令牌传递协议。</li></ul><h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><ul><li>局域网（local area network，LAN）是指一个较小范围内的多台计算机或其他通信设备通过双绞线、同轴电缆等连接介质互联起来，以达到资源和信息共享目的的互联网络。<ul><li>局域网有较高的数据率、较低的时延和较小的误码率，具有广播功能，便于系统的扩展和演变。</li><li>局域网的主要技术要素包括网络拓扑结构传输介质与介质访问控制方法。局域网的主要拓扑结构包括星型网环形网总线型网和树型网（星型网和总线型网的结合）。双绞线为局域网的主流传输介质。</li><li>局域网的主要介质访问控制方法包括CSMA/CD、令牌总线和令牌环。前两种作用于总线型网，令牌环作用于环形网。</li><li>局域网对应OSI参考模型中的数据链路层和物理层，并将数据链路层拆分为2个子层，逻辑链路控制（LLC）子层和媒体接入控制（MAC）子层。</li></ul></li><li>以太网采用总线拓扑结构。所有计算机都共享一条总线信息，以广播方式发送，使用CSMACD技术对总线进行访问控制。<ul><li>以太网采用无连接的工作方式，不对发送的数据帧进行编号，也不要求对发送方发送确认。以太网提供的服务是不可靠服务，所以有重传机制，且差错纠正由传输层的TCP完成。</li><li>数据传输速率达到或超过100Mbit/s的以太网称为高速以太网。100base-T以太网称为快速以太网。吉比特以太网成为千兆以太网,允许在全双工和半双工两种方式工作。在半双工方式下工作时必须使用CSMA/CD协议进行冲突检测。</li></ul></li><li>无线局域网分为有固定基础设施和无固定基础设施两类。IEEE802.11规定有固定基础设施的无线局域网的最小构建为基本服务集（BSS），BSS中的基站称为接入点（AP）。<ul><li>基本服务集可以是孤立的，也可以通过接入点连接到一个主干分配系统（DS）构成扩展的服务器（ESS），ESS还可通过门桥（portal）设备为无线用户提供到非IEEE802.11无线局域网的接入。</li><li>IEEE802.11标准中的物理层有跳频扩频（FHSS）、直接序列扩频（DSS）、红外线（IR）3种实现方法。</li><li>IEEE802.11标准中的MAC层在物理层上，包括2个子层，从下往上依次为分布协调功能（DCF）子层和点协调功能（PCF）子层。在带有碰撞避免功能的CSMA/CA协议的基础上增加确认机制。</li></ul></li><li>广域网是覆盖范围很广的长距离网络，由一些节点交换机以及连接这些交换机的链路组成。节点交换机完成分组存储转发的功能。<ul><li>广域网是通过交换机连接多个局域网组成，因特网是由广域网和局域网共同通过路由器相连。</li><li>局域网使用的协议主要在数据链路层，而广域网使用的协议主要在网络层。</li><li>广域网的路由选择协议负责搜索分组从某个节点到目的节点的最佳传输路由，以便构成路由表，从路由表再构造出转发分组的转发表，分组是通过转发表进行转发的。</li></ul></li><li>点对点协议（PPP）由一个将IP数据报封装到串行链路的方法、一个用于建立配置和测试数据链路连接的链路控制协议（LCP）和一套用来建立和配置不同的网络层协议的网络控制协议（NCP），其中每个协议支持不同的网络层协议。<ul><li>PPP是一个面向字节的协议，不需要纠错（只负责检错）、流量控制（由TCP负责）、序号（不可靠的传输协议）、多点线路，只支持全双工链路。</li></ul></li><li>高级数据链路控制（HDLC）协议是ISO制定的面向比特的数据链路控制协议，可适用于链路的非平衡配置（一个主站控制整个链路的工作）和平衡配置（链路两端2个站都是复合站）。<ul><li>PPP帧比HDLC协议帧多一个2字节的协议字段，当协议字段值为Ox0021时表示信息字段是IP数据报。</li><li>PPP不使用序号和确认机制，只保证无差错接收（通过硬件进行循环冗余码校验），HDLC协议的信息帧使用了编号和确认机制。</li></ul></li></ul><h4 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h4><ul><li>在物理层拓展局域网使用中继器和集线器扩大冲突域，但总吞吐量未提高，且不能互联使用不同以太网技术的局域网。</li><li>在数据链路层扩展局域网使用网桥，具有过滤帧的功能。网桥至少有2个端口，每一个端口与一个网段相连。<ul><li>网桥从一个端口接收一个帧，先暂存到缓存中，若未出现差错，且发往目的站MAC地址属于另一网段，则通过查找转发表将该帧从对应端口发出。</li><li>网桥过滤通信量、扩大物理范围、提高可靠性、可互连不同物理层、不同MAC子层和不同速率的以太网，但存储转发增加时延，且在MAC层并没有流量控制功能，用户过多会因传播过多的广播信息而产生网络拥塞（广播风暴）。</li><li>网桥包括透明网桥（选择的不是最佳路由）和源选径网桥（选择的是最佳路由）。最佳路由并不一定是经过路由器最少的路由，也可以是发送帧往返时间最短的路由（实现负载平衡）。</li></ul></li><li>局域网交换机实质上是工作在数据链路层的多端口网桥。局域网交换机的每个端口都直接与主机或集线器相连，并且一般都工作在全双工方式。<ul><li>交换机总容量 = 端口数×每个端口带宽（半双工）or 端口数×每个端口带宽×2（全双工）</li><li>交换机分为直通式交换和存储转发式交换，工作原理与网桥类似。</li><li>网桥的端口一般连接到局域网的网段，而以太网交换机的每个端口一般都直接与主机相连，也可连接到Hub。</li></ul></li><li>一块网卡发出一个广播，能收到这个广播的所有网卡集合为一个广播域。通常情况下，一个网段就是一个冲突域，一个局域网就是一个广播域。</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h4><ul><li>网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务，并且网络层不提供服务质量的承诺。</li><li>这样的好处在于网络造价大大降低，运行方式灵活。</li></ul><h4 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h4><ul><li>网际协议IP是TCP/IP体系中两个最主要的协议之一。其中，与IP协议配套使用的有三种协议：<ul><li>地址解析协议ARP</li><li>网际控制报文协议ICMP</li><li>网际组管理协议IGMP</li></ul></li><li>其中，ICMP、IGMP协议是往基层向上提供的两种服务</li></ul><h4 id="互联网络"><a href="#互联网络" class="headerlink" title="互联网络"></a>互联网络</h4><ul><li>因为用户的需求是多种多样的，没有一种单一的网络能够适应所有用户的需求,所以不同的网络之间，将网络互联起来需要使用一些中间设备。<ul><li>物理层使用的中间设备是转发器</li><li>数据链路层使用的中间设备是网桥或者桥接器</li><li>网络层使用的中间设备是路由器</li><li>网络层以上使用的中间设备叫网关</li></ul></li></ul><h5 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h5><ul><li><p>物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和网络层以上各层使用的地址</p></li><li><p>在发送数据时，数据从高层下到底层，然后才到通信链路上使用IP的IP数据报一旦交给了数据链路层，就被封装成MAC帧（MAC地址）</p></li></ul><h5 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h5><ul><li><p>已知一个机器的IP地址，如何找出其所对应的硬件地址呢？这就是ARP的主要任务。</p><ul><li>ARP协议的主要内容在于从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。</li></ul></li></ul><ul><li>工作原理：一个主机都设有一个ARP高速缓存，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。</li></ul><h4 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h4><ul><li>一个IP数据报由首部（20 字节+可选字段）和数据两部分组成</li></ul><h4 id="划分子网和构建超网"><a href="#划分子网和构建超网" class="headerlink" title="划分子网和构建超网"></a>划分子网和构建超网</h4><ul><li><p>两级IP到三级IP</p><ul><li><p>两级IP（&lt;网络号&gt;，&lt;主机号&gt;）的缺陷：</p></li><li><p>IP地址的空间利用率有时很低</p><ul><li>两级IP地址不够灵活</li></ul></li><li><p>给每一个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏。</p></li><li><p>三级IP地址：将其中二级IP的主机号取出并高x位变成子网络，形成网络号+子网号+主机号的地址格式</p></li><li><p>划分子网：划分子网属于一个单位内部的事情，它将二级IP地址变为三级IP地址</p></li></ul></li></ul><h4 id="无分类编制CIDR"><a href="#无分类编制CIDR" class="headerlink" title="无分类编制CIDR"></a>无分类编制CIDR</h4><ul><li><p>CIDR取消了传统的A类、B类和C类地址以及划分子网的概念，并且用网络前缀代替网络号和子网号，后面的部分指明主机。因此，CIDR使IP地址从三级地址(使用子网掩码)，又回到了两级地址（无分类的两级编址）。</p></li><li><p>CIDR把网络前缀相同的连续的IP地址组成一个”CIDR地址块”只要知道CIDR地址块中的任何一个地址，就可以知道这地址块的起始地址(即最小地址)和最大地址，以及地址块中的地址数。具体看如下例子</p></li><li><p>地址掩码：是一连串的1和0组成，而1的个数救赎网络前缀长度。在斜线记法中。斜线后面的数字就是地址掩码中1的个数。</p></li><li><p>构成超网：由于一个CIDR地址块中含有很多地址，所以在路由表中就利用CIDR地址块来查找目标网络，这种地址的聚合常称为路由聚合，也称构成超网。</p></li></ul><h4 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h4><ul><li><p>最长前缀匹配之前，使用CIDR时，每个项目由网络前缀和下一跳地址组成。但是在查找路由表时会得到不止一个匹配结果该怎么办呢？</p></li><li><p>此时应该选择匹配结果中，有最长网络前缀的路由。因为网络前缀越长，可分配的地址数就越少，其地址信息路由就越具体</p></li></ul><h4 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h4><ul><li><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP是互联网的标准协议，但不是高层协议。其种类如下：</p><ul><li>ICMP差错报告报文</li></ul></li></ul><ul><li><p>ICMP询问报文</p></li><li><p>ICMP的应用在于分组网间探测PING，以用来测试两台主机之间的连通性。</p></li></ul><h4 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h4><ul><li><p>路由选择协议分为两大类：</p><ul><li>内部网关协议</li></ul></li></ul><ul><li><p>外部网关协议</p></li><li><p>内部网关协议</p><ul><li>RIP是内部网关协议中最先得到广泛应用的协议，也被称为路由信息协议，但是其很少被使用。其主要特点如下：<ul><li>仅和相邻路由器交换信息。</li><li>路由器交换的信息是当前路由器所知道的全部信息，即自己现在的路由</li><li>按固定的时间间隔交换路由信息，例如，每隔30秒。</li><li>因此，RIP有如下的优缺点。</li><li>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。</li><li>RIP 协议最大的优点就是实现简单，开销较小。</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li></ul></li></ul></li><li><p>OSPF最主要的特征就是使用分布式的链路状态协议，其主要特点：</p><ul><li>使用洪泛法向本自治系统中所有路由器发送信息。</li></ul></li></ul><ul><li><p>发送的信息是与本路由器相邻的所有路由器的链路状态。</p></li><li><p>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p></li></ul><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><ul><li>解决IP地址耗尽的根本措施在于采用具有更大地址空间的新版本IP，即IPv6。它有两大部分组成：基本首部，有效载荷</li><li>IPv6采用的是点分十六进制的记法，把每个十六位的值用十六进制表示，并且各个值之间用冒号分割</li><li>冒号十六进制允许零压缩，但只能使用一次零压缩</li><li>冒号十六进制可以结合使用点分十进制记法的后缀。</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h4><ul><li>运输层功能<ul><li>运输层应用进程之间提供端到端的逻辑通信。这与网络层的区别在于网络层是为主机之间提供逻辑通信的</li><li>运输层需要对收到的报文进行差错检验</li><li>运输层有两种不同的运输协议，即面向连接的TCP和无连接的UDP</li></ul></li><li>TCP/IP的运输层有两个不同的协议：<ul><li>用户数据报协议UDP</li><li>传输控制协议TCP</li></ul></li><li>UDP协议特点<ul><li>提供无连接服务</li><li>尽最大努力交付</li><li>面向报文，UDP 一次交付一个完整的报文</li><li>没有拥塞控制，网络拥塞不会使源主机的发送速率降低</li><li>支持一对一、一对多、多对一和多对多的交互通信</li><li>首部开销小，只有 8 个字节</li><li>应用：对可靠性要求不高，需要传送的数据不多，使用频率不高。并且可以实时应用。</li></ul></li><li>TCP协议特点<ul><li>提供面向连接的服务</li><li>可靠传输：主要以字节为单位的滑动窗口和超时重传时间的选择</li><li>面向字节流</li><li>拥塞控制：避免由于对网络中某资源的需求超过可用资源，令网络的性能变坏</li><li>TCP 的流量控制：让发送方的发送速率不要太快</li><li>总结：TCP和UDP协议的区别</li></ul></li><li>TCP的特点<ul><li>面向连接协议</li><li>提供交互保证</li><li>较UDP实时性低</li><li>TCP首部开销20个字节</li><li>TCP速度较慢</li><li>拥塞机制</li><li>TCP将数据看成一连串的字节</li><li>重量级协议，资源占用多</li><li>只有点对点连接</li></ul></li><li>UDP的特点<ul><li>无连接协议</li><li>尽最大努力交付，不提供有序、序列保证</li><li>较好的实时性</li><li>首部开销8字节</li><li>运行速度较快</li><li>无拥塞机制</li><li>面向报文</li><li>轻量级</li><li>一对一，一对多，多对多</li></ul></li><li>运输层的端口<ul><li>运行在计算机中的进程是用进程标识符来标志的。但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。<br>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。</li><li>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。有时我们会改换接收报文的进程，但并不需要通知所有发送方。所以我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</li><li>解决这个问题的方法就是在运输层使用协议端口号 (protocol port number)，或通常简称为端口(port)。虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP来完成。</li></ul></li></ul><h4 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h4><ul><li><p>以字节单位的滑动窗口</p><ul><li><p>TCP使用流水线传输和滑动窗口协议实现高效、可靠的传输。TCP 的滑动窗口是以字节为单位的。</p></li><li><p>发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。</p></li></ul></li></ul><ul><li>发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。</li></ul><ul><li>接收窗口表示：只允许接收落入窗口内的数据。</li></ul><ul><li><p>超时重传时间的选择</p><ul><li>重传机制是 TCP 中最重要和最复杂的问题之一。</li><li>TCP 每发送一个报文段，就对这个报文段设置一次计时器。</li><li>只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。</li><li>重传时间的选择是 TCP 最复杂的问题之一。</li></ul></li><li><p>利用滑动窗口实现流量控制</p><ul><li>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</li><li>流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li><li>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。</li></ul></li><li><p>拥塞机制</p><ul><li>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。</li><li>最坏结果：系统崩溃。</li></ul></li><li><p>网络拥塞往往是由许多因素引起的。例如：</p><ul><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li><li>总的来说，出现拥塞的原因在于对资源的需求大于可用资源</li></ul></li><li><p>TCP的拥塞控制方法</p><ul><li><p>慢开始与拥塞窗口</p><ul><li><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。</p></li><li><p>TCP发送方维持一个拥塞窗口 cwnd</p></li><li><p>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。</p></li><li><p>发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况</p></li><li><p>只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。</p></li><li><p>但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p></li><li><p>其中，对于拥塞的判断，有以下两个指标：1.重传定时器超时。2.收到三个重复的ACK。</p></li></ul></li></ul></li></ul><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><ul><li><p>应用层协议主要定义运行在不同端系统上的应用程序进程之间如何相互传递信息</p></li><li><p>常用的几种协议：DNS、FTP、HTTP、DHCP 的作用</p><ul><li>DNS：域名系统DNS是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。DNS同时占用TCP协议与UDP协议的53号端口。</li><li>FTP：文件传送协议FTP是互联网上使用的最广泛的文件传送协议。FTP使用的传输层协议是</li><li>TCP，FTP 传数据流占用20号端口，FTP传控制流占用21号端口。</li><li>HTTP：HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。HTTP使用传输层协议为TCP，端口号为80。</li><li>DHCP：互联网目前广泛使用的动态主机配置协议DHCP，它提供一种机制，成为即插即用联网。DHCP使用UDP，端口号为67和68。</li></ul></li><li><p>在应用层，用到DNS协议，作用是域名解析，HTTP协议浏览器和服务器之间的交互访问协议。</p></li><li><p>在传输层，运用UDP域名解析协议使用的运输层协议，TCP浏览器和WWW服务器之间建立连接，提供可靠的数据传输。</p></li><li><p>在网际层IP，IP数据报传输和路由选择，ICMP提供网络传输中的差错检测，ARP将本机缺省的网关IP地址映射成物理地址（MAC地址）</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/learn/HIT-154005&quot;&gt;国家精品课&lt;/a&gt;和谢希仁版教材，以下为所记课堂笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-11-29T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的<a href="https://www.icourse163.org/course/SUDA-1001752241">国家精品课</a>和汤子瀛版教材，以下为所记课堂笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><h4 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h4><ul><li>冯诺依曼模型：运算器、存储器、控制器、输入设备和输出设备</li><li>引入操作系统的目的：提供一个计算机用户与计算机硬件系统之间的接口、有效的控制和管理计算机系统中的各种硬件和软件资源、合理地组织计算机系统的工作流程</li><li>操作系统是计算机系统的资源管理程序</li><li>操作系统的核心是控制和协调进程的运行，解决进程之间的通信</li><li>操作系统的发展：无操作系统阶段 -&gt; 单道批处理系统 -&gt; 多道批处理系统</li></ul><h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><ul><li>并行性：2个或多个事件在同一时刻发生</li><li>并发性：2个或多个事件在同一时间间隔内发生</li><li>并发和共享是操作系统的2个最基本的特征，二者之间互为存在条件</li><li>资源共享方式：互斥共享、同时访问</li><li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物</li><li>异步性</li></ul><h4 id="操作系统的功能和服务"><a href="#操作系统的功能和服务" class="headerlink" title="操作系统的功能和服务"></a>操作系统的功能和服务</h4><ul><li>处理器管理：进程控制、进程同步、进程通信、进程调度</li><li>存储器管理：内存分配、内存保护、内存扩充</li><li>设备管理：设备分配、设备传输控制、设备独立性</li><li>文件管理：文件存储空间的管理、目录管理、文件操作管理、文件保护</li><li>用户接口：命令接口、程序接口、图形接口<ul><li>联机命令接口又称交互式命令结构</li><li>脱机命令接口又称批处理命令接口</li></ul></li><li>操作系统3种基本类型：批处理操作系统、分时操作系统、实时操作系统</li><li>其他操作系统：嵌入式操作系统、集群系统、网络操作系统、分布式操作系统</li></ul><h4 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h4><ul><li>处理器的执行状态分为核心态与用户态<ul><li>核心态是操作系统管理程序执行时机器所处的状态</li><li>用户态是用户程序执行时机器所处的状态</li></ul></li><li>特权指令是只能由操作系统内核部分使用，不允许用户直接使用的指令，如I/O指令、设置中断屏蔽指令、清内存指令、存储保护指令和设置时钟指令</li><li>内核的指令操作工作在核心态<ul><li>时钟管理</li><li>中断机制</li><li>原语</li><li>系统控制的数据结构及处理</li></ul></li><li>异常，也称内中断，是由错误引起的</li><li>通常异常会引起中断，而中断未必是由异常引起的</li><li>系统调用（API）：进程控制、文件系统控制、系统控制、内存管理、网络管理、socket 管控、制用户管理以及进程间通信</li></ul><h4 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h4><ul><li>操作系统的体系结构主要包括模块组合结构、层次结构和微内核结构</li><li>模块组合结构<ul><li>接口简单直接，系统的效率相对较高</li><li>系统结构不清晰、可扩展性差、可适应性差</li></ul></li><li>层次结构<ul><li>按功能的调用次序排列成若干层</li><li>组织和依赖关系清晰明了，可读性、可适应性及可靠性都得到了增强</li><li>通常要将为进程提供服务的系统调用模块放在系统的内层。</li></ul></li><li>微内核结构<ul><li>客户服务器模式（C/S 模式）</li><li>每个服务进程运行在独立的用户进程中，可靠性好，灵活性好，便于维护</li><li>适合分布式处理的计算环境</li><li>效率不高，尤其是通信频繁的系统</li></ul></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li><p>在计算机操作系统中，进程是资源分配的基本单位，也是独立运行的基本单位</p><ul><li>程序顺序执行时的特征：顺序性，封闭性，可再现性</li><li>程序的并发执行的特征：间断性，失去封闭性，不可再现性</li></ul></li><li><p>程序并发执行且其结果具有可再现性的条件（Bernstein 条件）</p><ul><li>R(p1) ∩ W(p2) = ∅</li><li>R(p2) ∩ W(p1) = ∅</li><li>W(p1) ∩ W(p2) = ∅</li></ul></li><li><p>进程的特征：动态性、并发性、独立性、异步性、结构特征（程序段、数据段和进程控制块）</p></li><li><p>进程和程序的关系</p><ul><li>进程和程序的关系程序是静止的</li><li>进程是暂时的，程序是永久的</li><li>进程的组成包括程序段、数据块和进程控制块（Process Control Block）</li><li>通过多次执行，一个程序可以产生多个不同的进程，通过调用关系，一个进程可以执行多个程序</li><li>进程可创建其他进程，而程序不能形成新的程序</li></ul></li><li><p>由程序段、相关数据段和PCB三部分构成的是进程映像，也叫进程实体</p><ul><li>映像是静态的，进程是动态的，进程是进程实体的运行过程</li></ul></li><li><p>进程和作业的区别</p><ul><li>作业是用户需要计算机完成某项任务而要求计算机所做的工作的集合</li><li>作业提交、作业收容、作业执行、作业完成</li><li>进程是已提交完毕的作业的执行过程，是资源分配的基本单位</li><li>作业是用户向计算机提交任务的任务实体，而进程是完成用户任务的执行实体</li><li>这个作业可由多个进程组成，而必须至少由一个进程组成，但一个进程不能构成多个作业</li></ul></li><li><p>进程的组成</p><ul><li>进程控制块（PCB）：标识进程的存在，刻画执行瞬间特征的数据机构</li><li>其他组成部分：程序段、数据段、进程标识符（PID）、进程当前状态、进程队列指针、程序和数据地址，进程优先级、CPU 现场保护区、通信信息、家族联系、占有资源清单</li></ul></li><li><p>PCB 是进程存在的唯一标志</p><ul><li>PCB 存在是为了保证程序的并发执行</li><li>创建进程实质上是创建进程的 PCB，而撤销进程实质上是撤销进程的 PCB</li><li>系统总是通过 PCB 对进程进行控制的</li></ul></li><li><p>进程的5种基本状态：就续状态、执行状态、阻塞状态、创建状态、结束状态</p><ul><li>执行状态只能由就绪状态转换，而无法由阻塞状态直接转换</li><li>不能从就绪状态变为阻塞状态</li><li>进程状态是唯一的</li></ul></li><li><p>进程的创建</p><ul><li>进程创建是通过创建原语实现的</li><li>申请一个空闲 PCB，并指定唯一的 PID -&gt; 分配必要的资源 -&gt; 将新进程的PCB初始化 -&gt; 插入到就绪队列</li><li>导致进程创建的事件：用户登录、作业调度和请求服务</li></ul></li><li><p>撤销一个进程：撤销原语</p><ul><li>找到被撤销进程的PCB -&gt; 停止该进程的执行 -&gt; 回收被撤销进程所占用的资源 -&gt; 回收PCB</li></ul></li><li><p>进程的阻塞与唤醒：两条低级进程通讯原语</p><ul><li>阻塞原语（P 原语）的功能是将进行进程由执行状态转为阻塞状态</li><li>唤醒原语（V 原语）的功能是将进程由阻塞状态变为就绪状态</li><li>一个进程由执行状态变为阻塞状态，是由这个进程自己调用阻塞原语去完成的</li><li>进程由阻塞状态变为就绪状态，是由另一个发现者进程调用唤醒原语去实现的。一般这个发现者进程与被唤醒进程是合作的并发进程</li></ul></li><li><p>调度是决定将系统资源分配给哪个进程，进程切换是实际分配系统资源</p><ul><li>进程切换一定会产生中断，但处理器模式切换不一定产生进程切换</li></ul></li><li><p>进程的互斥与同步就是一种进程间的通信方式</p><ul><li>高级进程通信方式：共享存储器系、消息传递系统、管道（共享文件）通信系统</li></ul></li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程是进程内一个相对独立的可调度的执行单元<ul><li>内核级线程依赖于内核，一个内核级线程由于 I/O 操作而阻塞时不会影响其他线程的运行</li><li>用户级线程不依赖于操作系统核心，由于操作系统内核不了解用户线程的存在，当一个线程阻塞时，整个进程必须等待</li></ul></li><li>进程与线程<ul><li>线程谁独立调度的基本单位，进程是拥有资源的基本单位</li><li>线程不拥有资源，但线程可以访问其隶属进程的系统资源</li><li>进程之间可以并发执行，同一进程内的多个线程之间也可以并发执行</li><li>多线程之间的同步与通信非常容易实现</li></ul></li><li>多线程模型：多对一模型，一对一模型，多对多模型（将多个用户级线程映射到多个内核级线程）</li></ul><h4 id="处理器的三级调度"><a href="#处理器的三级调度" class="headerlink" title="处理器的三级调度"></a>处理器的三级调度</h4><ul><li>高级调度（作业调度）：从外存上处于后备状态的作业中选择一个或多个，给他们分配内存等必要资源并建立相应的进程，以便该作业具有获得竞争处理器的权利<ul><li>作业调度每次要接纳多少个作业进入内存取决于多道程序的并发程度</li><li>多道程序的并发程度应根据系统的规模和运算速度来决定</li><li>应将哪些作业从外存调入内存取决于所采取的调度算法</li></ul></li><li>中级调度（交换调度）：按照给定的原则和策略，将处于外存对换区中具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待</li><li>低级调度（进程调度）：按照某种策略和方法，从就绪队列中选取一个进程，将处理器先分配给他<ul><li>进程调度的运行频率很高</li><li>作业调度的结果是为作业创造进程，而进程调度的结果是进程被执行</li></ul></li><li>衡量调度算法的性能： CPU利用率、系统吞吐量、响应时间、周转时间<ul><li>作业的周转时间 = 作业的完成时间 - 作业的提交时间</li><li>平均周转时间：多个作业周转时间的平均值</li><li>带权周转时间是作业周转时间与运行时间的比</li></ul></li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><ul><li>处理器分配的任务由进程调度程序完成</li><li>进程调度的功能：记录系统中所有进程的有关情况以及状态特征，选择获得处理器的进程和处理器分配</li><li>引起进程调度的原因<ul><li>当前运行进程运行结束</li><li>当前运行进程因某种原因从运行状态进入阻塞状态</li><li>执行完系统调用等系统程序后返回用户进程</li><li>在采用抢占调度方式的系统中，一个更高优先级的进程要求使用处理器</li><li>在分时系统中分配给该进程的时间片已用完</li></ul></li><li>不能进行进程调度的情况<ul><li>处理中断的过程中</li><li>在操作系统内核程序临界区中</li><li>其他需要完全屏蔽中断的原子操作过程中</li></ul></li><li>进程调度的方式：抢占方式、非抢占方式</li></ul><h4 id="常见调度算法"><a href="#常见调度算法" class="headerlink" title="常见调度算法"></a>常见调度算法</h4><ul><li>先来先服务调度算法（作业调度、进程调度）<ul><li>FCFS：按照进程进入就绪队列的先后次序来分配处理器</li></ul></li><li>短作业优先调度算法（作业调度、进程调度）<ul><li>SJF：把处理器分配给最快完成的作业或进程</li></ul></li><li>优先级调度算法（作业调度、进程调度）<ul><li>静态优先级是在创建进程时确定的，确定之后整个进程运行期间不再改变</li><li>按进程类、作业的资源要求、用户类型和要求确定静态优先级</li><li>动态优先级是指在创建进程时根据进程的特点及相关情况确定一个优先级</li><li>根据进程占有CPU时间的长短和就绪进程等待CPU时间的长短确定动态优先级</li><li>基于优先级的调度算法还可按调度方式的不同，分为非抢占优先级调度算法和抢占优先级调度算法</li><li>在优先级相同的情况下，通常按照先来先服务或者短作业优先的顺序执行</li></ul></li><li>时间片轮转调度算法（进程调度）<ul><li>分时系统必须满足系统对响应时间的要求</li><li>就绪队列中的进程数与时间片的大小成反比</li><li>系统的处理能力决定时间片的大小</li></ul></li><li>高响应比优先调度算法（作业调度）<ul><li>响应比 = 作业响应时间 / 估计运行时间</li><li>作业响应时间 = 作业等待时间 + 估计运行时间</li></ul></li><li>多级反馈队列调度算法（作业调度）<ul><li>时间片轮转调度算法和优先级调度算法的综合与发展</li></ul></li></ul><h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><ul><li><p>互斥是间接相互制约关系，而同步是直接相互制约关系</p></li><li><p>只要是同类进程即为互斥关系，不同类进程即为同步关系</p></li><li><p>临界资源：同时仅允许一个进程使用的资源</p><ul><li>进入区、临界区、退出区、剩余区</li><li>临界区：进程中用于访问临界资源的代码，又称临界段</li><li>临界资源是必须互斥访问的资源，这种资源同时只能被一个进程所使用，但需要这种资源的进程不止一个，因此需要对使用临界资源的进程进行管理</li><li>每个进程的临界区代码可以不相同</li></ul></li><li><p>互斥的要求：空闲让进，忙则等待，有限等待，让权等待</p></li><li><p>互斥实现方法</p><ul><li>软件实现方法</li><li>互斥实现的硬件方法：中断屏蔽、硬件指令</li><li>硬件方法适用范围广，支持多个临界区，但不能实现让权等待</li></ul></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>信号量 <code>(s,q)</code> 及同步原语<ul><li>整型变量 s 表示系统中某类资源的数目，q 是一个初始状态为空的队列</li><li>信号量的值仅能由 P 操作（wait）操作和 V 操作（signal）操作改变，操作系统利用它的状态对进程和资源进行管理</li><li> P 操作相当于申请资源，V 操作相当于释放资源</li></ul></li><li>信号量分为整型信号量和记录型信号量（资源信号量）<ul><li>记录型信号量添加了链表结构用于链接所有等待该资源的进程，解决忙等的问题</li></ul></li><li>信号量可以用来实现进程互斥和描述前趋关系</li></ul><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><ul><li>生产者-消费者问题<ul><li>P(full) / P(empty) 与 P(mutex) 的顺序不可倒，必须先对资源信号量进行 P 操作，再对互斥信号量进行 P 操作。否则会导致死锁</li><li>互斥信号量就是给同类进程准备的</li></ul></li><li>读者写者问题（许多进程共享数据区）<ul><li>读者不互斥，写者必须互斥</li><li>读者优先，公平情况和写者优先三种不同算法</li></ul></li><li>哲学家进餐问题<ul><li>最多允许4个哲学家同时进餐</li><li>仅当一个哲学家左右两边的筷子同时可用时，他才可以拿起筷子</li><li>将哲学家编号要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子</li></ul></li><li>理发师问题</li><li>信号量机制问题的解题步骤分析<ul><li>关系分析</li><li>确定临界资源</li><li>整理思路</li></ul></li><li>实现同步互斥的 P、V 操作必须成对出现，先进行 P 操作进入临界区，后进行 V 操作退出临界区</li><li> P、V操作要分别紧靠临界区的头尾部</li><li>通常用于互斥的信号量初值设为 1</li></ul><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><ul><li>管程定义了一个数据结构和能为并发进程所执行的一组操作<ul><li>局部于管程的数据只能被局部于管程内的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程，即进程互斥地通过调用内部过程进入管程</li></ul></li><li>管程的互斥访问完全由编译程序在编译时自动添加</li><li>为实现进程间的同步，管程还必须包含若干用于同步的设施<ul><li>局限于管程并仅能从管程内进行访问的若干变量，用于区别各种不同的等待原因</li><li>在条件变量上进行操作的两个函数过程，wait 和 signal</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>死锁的概念<ul><li>参死锁的进程至少有两个</li><li>每个参与死锁的进程均等待资源</li><li>参与死锁的进程中至少有两个进程占有资源</li><li>死锁进程是系统中当前进程集合的一个子集</li></ul></li><li>死锁产生的原因是竞争资源<ul><li>一个资源是否属于可剥夺资源，完全取决于资源本身的性质</li></ul></li><li>死锁产生的必要条件<ul><li>互斥条件</li><li>不剥夺条件</li><li>请求于保持条件：可采用预先静态分配方法</li><li>环路等待条件：可采用有序资源分配法</li></ul></li><li>处理死锁的方法：鸵鸟算法、预防死锁、避免死锁、检测及解除死锁（被动）<ul><li>死锁预防对系统加的限制条件通常很严格，对系统的并发性会产生很大的副作用</li><li>死锁避免往往在资源被分配出去之前，要计算分配之后系统是否安全</li></ul></li><li>死锁的避免<ul><li>系统在进行资源分配之前，先计算资源分配的安全性（安全序列）</li><li>并非所有不安全状态都是死锁状态，死锁是不安全状态的真子集</li><li>银行家算法</li></ul></li><li>死锁的检测和解除<ul><li>系统资源分配图（system resource allocation graph）可定义为一个二元组</li><li><code>SRAG = (V,E)</code></li><li>死锁定理：不同简化顺序将得到相同的不可简化图。系统状态 S 为死锁状态的条件是当且仅当 S 状态的资源分配图是不可完全简化的</li><li>死锁检测算法：available、allocation、request、临时变量（work与finish）</li><li>死锁解除：剥夺资源，撤销进程，进程回退</li></ul></li><li>进程与饿死<ul><li>当等待时间给进程推进和响应带来明显影响时，发生进程饥饿</li><li>当饥饿到一定程度，进程所赋予的任务即使完成也不再具有实际意义时，进程被饿死</li><li>活锁：在忙时等待条件下发生的饥饿</li><li>饥饿和饿死与资源分配策略有关，因而可从公平性方面考虑防止饥饿与饿死</li></ul></li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h4><ul><li>内存管理的功能是为多道程序的运行提供良好的环境<ul><li>内存的分配和回收：记住内存空间的使用情况、实施内存的分配、回收系统或用户释放的内存空间</li><li>地址变换：将逻辑地址转换为物理地址</li><li>扩充内存：虚拟存储技术或其他自动覆盖技术</li><li>存储保护：由硬件和软件配合完成</li></ul></li><li>应用程序的编译、链接与装入<ol><li>经过编译程序将源代码编译为若干个目标模块</li><li>通过链接程序将编译好的目标模块以及所需的库函数链接在一起，形成完整的装入模块</li><li>通过装入程序将这些装入模块装入内存并执行</li></ol></li><li>源程序（名地址）-&gt; 目标程序（逻辑地址）-&gt; 可执行程序（物理地址）<ul><li>对程序设计者来说，数据的存放地址由数据名称决定，称为名地址或符号名地址，即为源程序的地址空间</li><li>当链接程序将多个模块链接为装入模块时，链接程序会按照各个模块的相对地址，将其地址构成统一的从0号单元开始编址的相对地址</li><li>当装入程序将可执行代码装入内存时，程序的逻辑地址与程序存在内存的实际地址，通常不同这就需要通过地址转换将逻辑地址转为物理地址，这个过程叫重定位</li></ul></li><li>程序链接的 3 种方式<ul><li>静态链接：在程序运行之前，先将各目标模块及所需的库函数连接成一个完整的可执行程序（装入模块），之后不再拆开</li><li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式</li><li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是物理地址便于修改和更新，便于实现对目标模块的共享</li></ul></li><li>程序装入的 3 种方式<ul><li>绝对装入：在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码</li><li>可重定位装入：根据内存当前情况将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，容易实现，无需增加硬件地址变换机构</li><li>动态运行装入：允许程序运行时在内存中移动位置，在程序执行过程中，每当访问到相应指令或数据时，才将要访问的程序或数据的相对地址转换为物理地址，可以将程序分配到不连续的存储区中</li></ul></li><li>在重定位中通常会设一个重定位寄存器，用来存放进程分配的内存空间的地址（基址寄存器）<ul><li>当 CPU 需要访问内存时，将逻辑地址转换为物理地址</li><li>物理地址 = 基址计算器内容 + 逻辑地址</li></ul></li><li>逻辑地址和物理地址<ul><li>逻辑地址是指由程序产生的与段相关的偏移部分地址（与页无关，因为只有段对用户可见）</li><li>物理地址是指出现在 CPU 外部地址总线上的寻址物理内存的地址信号，是逻辑地址变换后的最终结果地址，物理地址空间是指内存中物理地址单元的集合</li><li>从逻辑地址到物理地址的转换过程由硬件自动完成，这个转换过程叫做地址重定位</li></ul></li><li>内存保护<ol><li>界限寄存器方法<ul><li>上、下界寄存器方法：分别存放作业的结束地址和开始地址</li><li>基址和限长寄存器方法</li></ul></li><li>存储保护键方法：给每个存储块分配一个单独的保护键</li></ol></li></ul><h4 id="交换与覆盖"><a href="#交换与覆盖" class="headerlink" title="交换与覆盖"></a>交换与覆盖</h4><ul><li>覆盖技术，就是把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位<ul><li>把程序执行时并不要求同时装入内存的复盖组成一组，称为覆盖段</li><li>将这个覆盖段分配到同一存储区域，这个存储区域称为覆盖区</li><li>覆盖区与覆盖段一一对应</li><li>覆盖技术只能覆盖与覆盖程序段无关的程序段</li><li>为了使一个覆盖区能被相应覆盖段中每个覆盖在不同时刻共享，其大小应由覆盖段中最大覆盖来确定</li><li>覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时执行程序的代码量超过主存时，程序仍然不能运行</li></ul></li><li>交换技术就是把暂时不用的某个程序及数据部分从内存移到外存中，以便腾出必要的内存空间，或把指定的程序或数据从外存读到相应的内存中，并将控制权转让给他，让其在系统上运行的一种内存扩充技术<ul><li>处理器三级调度中的中级调度就是采用了交换技术</li><li>与覆盖技术相比，交换技术不要求程序员给出程序段之间的覆盖结构，且交换主要是在进程或作业之间进行，而覆盖主要在同一个作业或进程中进行</li><li>交换进程由换出和换入两个过程组成</li><li>交换技术的特点是打破了一个程序一旦进入主存便一直运行到结束的限制，但运行的进程大小仍然受实际主存的限制</li><li>交换需要备份存储</li><li>影响交换时间的因素主要是转移时间</li><li>如果换出进程，必须确保该进程完全空闲</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统</li><li>交换通常在有许多进程运行，且内存空间紧张时开始启动，而在系统负荷减轻时暂停</li></ul></li></ul><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ul><li>内部碎片和外部碎片<ul><li>内部碎片是指已经分配给作业，但不能被利用的内部空间</li><li>外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块</li></ul></li><li>单一连续分配：将内存分为两个连续存储区域，其中一个存储区域固定的分配给操作系统使用，通常放在内存低地址部分，另一个存储区域给用户作业使用<ul><li>通常用户作业只占用所有分配空间的一部分，剩下一部分实际上浪费掉了</li><li>单一连续分配方式采用静态分配，适合单道程序，可采用覆盖技术</li><li>作业一旦进入内存，就要等到其结束后才能释放内存，因此这种分配方式不支持虚拟存储器的实现，无法实现多道程序共享主存</li><li>单一连续分配会产生内部碎片</li></ul></li><li>固定分区分配：将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序<ul><li>分区的大小可以不等，但事先必须确定，在运行时不能改变</li><li>当有空闲分区时，便从后备队列中选择一个适当大小的作业装入运行</li><li>固定分区分配中程序通常采用静态重定位方式装入内存</li><li>固定分区分配的优点是可用于多道程序系统最简单的存储分配，缺点是不能实现多进程共享一个主存区，利用率较低，会产生内部碎片</li></ul></li><li>动态分区分配：作业进入主存时，根据作业的大小动态的建立分区，并使分区的大小正好满足作业的需要，因此系统中分区的大小是可变的，分区数目也是可变的<ul><li>空闲分区表、空闲分区链</li><li>首次适应算法（FF）、下次适应算法（NF）、最佳适应算法（BF）、最差适应算法（WF）</li><li>分区回收</li><li>分区分配的动态管理：拼接技术、动态重定位分区分配技术</li></ul></li><li>动态分区分配的优缺点<ul><li>优点：实现了多道程序共用主存、管理方案相对简单、实现存储保护的手段比较简单</li><li>缺点：主存利用不够充分，存在外部碎片、无法实现多进程共享存储器信息、无法实现主存的扩充，进程地址空间受实际存储空间的限制</li></ul></li></ul><h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><ul><li>非连续分配允许一个程序分散地装入到不相邻的内存分区中</li><li>非连续分配管理方式根据分区大小是否固定为分页存储管理方式和分段存储管理方式</li><li>分页存储管理方式根据运行作业时是否需要把作业的所有页都装入内存才能运行而分为基本分页存储管理方式和请求分页存储管理方式</li><li>基本分页存储管理方式（物理单位）<ul><li>分页原理：用户作业的地址空间被划分成若干个大小相等的区域，称为页或页面</li><li>将主存的存储空间分成与页面大小相等的区域，称为块或物理块</li><li>在为作业分配存储空间时，总是以块为单位来分配，可以将作业中的任意一页放到主存的任意一块中</li><li>主存中与页面大小相等的物理块也可称为页框</li><li>为了将逻辑地址上连续的页号映射到物理内存中后成为离散分布的多个物理块，需要将每个页面和每个物理块一一对应，这种映射关系体现在页表中</li><li>每个页表项由页号和块号组成</li><li>基本地址变换机构：页表寄存器（PTR）</li><li>具有快表（TLB）的地址的地址变换机构：具有并行查找功能的高度缓冲存储器</li><li>两级页表和多级页表</li></ul></li><li>基本分页存储管理方式优缺点<ul><li>优点：内存利用率高、实现了离散分配、便于存储访问控制、无外部碎片</li><li>缺点：需要硬件支持（快表）、内存访问效率下降、共享困难、内部碎片</li></ul></li><li>基本分段存储管理方式（逻辑单位）<ul><li>逻辑地址结构由段号 S 和段内位移 W（段内偏移量）组成</li><li>段的长度不定</li><li>作业空间地址是二维的</li><li>段表及地址变换过程</li></ul></li><li>基本分段存储管理方式优缺点<ul><li>优点：便于程序模块化处理和处理变换的数据结构、便于动态链接和共享、无内部碎片</li><li>缺点：与分页类似，需要硬件支持、为满足分段的动态增长和减少外部碎片，要采用拼接手段、分段的最大尺寸受到主存可用空间的限制、有外部碎片</li></ul></li></ul><h4 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h4><ul><li><p>在真实的操作系统中，通常采用段页式存储管理，段面向用户，页面向硬件</p></li><li><p>虚拟内存解决的问题</p><ul><li>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：①作业很大时，不能全部装入内存，导致大作业无法运行；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li><li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li></ul></li><li><p>虚拟内存的实现：</p><ul><li>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行</li><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</li><li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。</li></ul></li></ul><h4 id="请求分页管理"><a href="#请求分页管理" class="headerlink" title="请求分页管理"></a>请求分页管理</h4><ul><li>请求分页管理：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</li><li>缺页中断： 在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断</li><li>缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，同时要注意，若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面</li><li>理解缺页，缺页就像货架上缺少了商品，需要从仓库里调取商品，就先暂停这个货架的销售，等商品调取完毕再重新出售。</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li><p>置换算法的评价指标是：缺页的次数，某种算法让缺页次数最低，调度效率最高，那就是最优的算法</p></li><li><p>最佳置换算法：每次淘汰的页面都是以后永久不用或最长时间不使用的页面，保证最低的缺页率。显然，这种需要预测未来的算法不可能实现。</p></li><li><p>先进先出算法FIFO：缺页时，淘汰最早进入的页面。算法简单，但局限性也明显，例如某些经常使用的页面一直被换进换出，和使用频率低的页面有相同的被换出的机会。</p></li><li><p>最近最久未使用置换算法LRU：每次淘汰的页面都是最近最久未使用的页面。需要在页面中添加一个记录项，记录上次被访问以来经历的时间t，当需要淘汰页面时，选择时间t最大的淘汰，也就是最久未使用的淘汰。算法设计虽好，但开销很大，实现困难。</p></li><li><p>时钟置换算法：时钟置换算法也可以称为最近未使用算法。是一种性能和开销均衡的算法。</p></li><li><p>简单的时钟算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)</p></li></ul><h3 id="I-O原理"><a href="#I-O原理" class="headerlink" title="I/O原理"></a>I/O原理</h3><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><ul><li><p>文件可以分为两类：</p><ul><li><p>无结构文件：文件内部数据就是一系列二进制流或字符流。最典型的就是txt文件。</p></li><li><p>有结构文件：由一组相似的记录组成，又称记录式文件。典型的excel表、数据库表等。</p></li></ul></li><li><p>有结构文件的逻辑结构又分顺序文件、索引文件、索引顺序文件，注意逻辑结构是展示给用户的，是文件的组织形式，例如是一张顺序存储的excel表格，还是一张excel索引表加上excel顺序表，还是多级索引加顺序，而不是在计算机上的存储方式。</p></li><li><p>顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p></li><li><p>顺序存储即逻辑相邻的文件物理上也相邻，链式存储即在末尾添加新的文件。</p></li><li><p>记录的类型又分为可变长和不可变长记录</p></li></ul><ul><li>索引顺序文件：索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项，索引表项的地址直接指向顺序文件所在区域，再顺序查找到所需的文件，从而节省了很大的空间。(例如我们可以通过An Qi找到An Kang、An Jie等，而不用在索引表中存放这么多信息。另外索引项之间不需要有按照逻辑关系排列)</li><li>多级索引顺序文件：在索引顺序文件的基础上再增加层次深度，可以减少查找的次数(顺序查找范围缩小了)</li></ul><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><ul><li><p>文件目录可以分为：单级目录结构、两级目录结构、多级目录结构(树形目录结构)</p></li><li><p>单极目录结构：顾名思义，所有的文件放在一个目录中，类似于一个仓库把所有文件不加整理的堆放在一起，显然效率会很低下</p></li><li><p>两级目录结构:主要分为主文件目录和用户文件目录。类似于仓库中加了几个员工货架，不同员工的货物放在不同货架，但在一个货架中文件还是采用堆砌式的存储。</p></li><li><p>多级目录结构，又称树形目录结构:我们当前主流操作系统都是多级目录结构，简而言之就是文件目录可以一级一级的延申，从而文件更有条理。</p></li><li><p>FCB(文件控制块)，首先来看一张图，如果文件目录都以这种表的形式进行信息查找，会大大降低运行效率，增加系统负担。</p></li><li><p>提出对策，其实在查找各级目录的过程中，只需要用到文件名这个信息，可以考虑让目录表瘦身来提升效率。</p></li><li><p>索引结点指针指向索引结点(文件名之外的其他信息就存放在结点中，从而按需读取，提升效率)</p></li><li><p>每一个文件都有一个FCB，记录了文件的地址、信息、权限等等属性</p></li></ul><h4 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h4><ul><li><p>最重要的三种物理结构：顺序、链接、索引，其中最主要使用的是索引文件，可以随机访问，同时增删效率高</p></li><li><p>文件的物理结构是文件分配在计算机存储上的分配方式。分配的基本单位是 物理块,可以构想一下，一个大文件，如一首音乐23MB，难道直接一整个塞入硬盘吗？显然可能会出现一些问题，硬盘的空间也需要不断调整，就像内存分页一样，硬盘也被分为小的物理块号方便进行调度。</p></li><li><p>连续分配</p><ul><li>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</li><li>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</li></ul></li><li><p>链式分配</p><ul><li>隐式：采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul></li></ul><ul><li><p>显式：直观理解就是在隐式的基础上添加了一张表，从表上能看出不同物理块号的下一块的地址</p></li><li><p>结论：采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问i 号逻辑块时，并不需要依次访问之前的0 ~ i-1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多</p></li><li><p>显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。</p></li><li><p>索引分配</p><ul><li>索引就是文件分成不同的物理块存入磁盘，对每个物理块都有一个索引与之对应，需要读写时就通过索引表查询其物理地址进行相关操作</li></ul></li></ul><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><ul><li><p>磁道：每一圈就是一个磁道，最内侧磁道面积最小，所以数据密度最大</p></li><li><p>扇区：磁道被划分为小的磁盘块</p></li><li><p>一个盘片可能有两个盘面;每个盘面对应一个磁头；所有磁头连在一起，共进退；每个盘面的相对位置的磁道组成柱面</p></li></ul><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><ul><li><p>磁盘调度算法要解决的核心问题就是寻道时间，即移动磁头的时间，而其他的启动时间、传输时间都很迅速，不是最主要的时间消耗</p></li><li><p>先来先服务FCFS</p><ul><li>根据进程请求房屋内磁盘的现后顺序进行调度。符合惯性思维，但在很多时候，效果很差。</li></ul></li><li><p>最短寻找时间优先(学过数据结构与算法的话，核心思想就是贪心算法)，该算法会优先处理与当前磁头最近的磁道的需求</p><ul><li>那么很可能磁头就会如图所示的移动，也会存在饥饿问题：磁头只在一个小区域移动，而不能满足需要远距离移动的需求。例如不断有18-&gt;38，38-&gt;18的需求，那磁头就不会执行18-&gt;150的请求，从而产生饥饿</li></ul></li><li><p>扫描算法</p><ul><li>核心思想，只有磁头移动到最外侧磁道的时候才能往内侧移动，移动到最内侧的时候才能向外侧移动。这样就不会产生饥饿问题。</li></ul></li></ul><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><ul><li>文件共享分两种链接方式，硬链接和软连接<ul><li>硬链接就是在另一个用户的目录中，索引结点指针直接指向了发送分享的用户的索引节点，从而实现了共享，count的数量代表文件正在被几个用户使用。</li><li>软连接，类似于快捷方式，记录了原文件的路径，然后层层查找。</li></ul></li></ul><h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><ul><li><p>文件保护有三种方式口令、加密、访问控制</p><ul><li>口令：为文件设置一串口令，就像打开手机需要先解锁。</li></ul></li></ul><ul><li><p>加密：使用加密方法对文件加密，只有拥有正确的解密方法才能解密，有点像不同军队之间进行通信，要实现进行加密，要是想窥探敌情，就要对密文进行破解。</p></li><li><p>访问控制：每个文件的FCB或者索引结点中设置访问控制表，如windows中，设置了很多的访问权限，例如</p></li></ul><h4 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h4><ul><li><p>I/O就是输入输出，I/O设备就是可以将数据输入到计算机或将计算机数据输出的设备，常见的：鼠标、键盘、音响、显示器、打印机、话筒、摄像头等等。</p></li><li><p>I/O控制器:CPU无法直接控制I/O设备，需要一个电子部件去充当中间人，这个部件就是I/O控制器，CPU控制I/O控制器，I/O控制器控制I/O设备。</p></li><li><p>假如我们的CPU能够控制I/O设备，那不同的厂商、不同型号的设备，都要对应进行编码，显然是不切实际的，所以CPU要采用通用调度方式调度I/O设备从而需要I/O控制器。</p></li><li><p>Java语言中，调用System.out.Println()，这本身并不能在显示器上打印，而需要通过操作系统调用write方法，接着调用字符设备接口，命令显示器写</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的&lt;a href=&quot;https://www.icourse163.org/course/SUDA-1001752241&quot;&gt;国家精品课&lt;/a&gt;和汤子瀛版教材，以下为所记课堂笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的<a href="https://www.icourse163.org/course/hit-309001">国家精品课</a>，配合天勤高分笔记，以下为所记课堂笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h3><h4 id="计算机系统的多层次结构"><a href="#计算机系统的多层次结构" class="headerlink" title="计算机系统的多层次结构"></a>计算机系统的多层次结构</h4><ul><li>硬件：<ol><li>微程序机器层M0（微指令系统），由硬件直接执行微指令</li><li>传统机器M1（机器语言机器），用微程序解释机器指令</li></ol></li><li>软件：<ol><li>虚拟机器M2（操作系统机器），用机器语言解释操作系统</li><li>汇编语言M3（汇编语言机器），用汇编程序翻译成机器语言程序</li><li>虚拟机器M4（高级语言机器），用编译程序翻译成汇编语言程序</li></ol></li></ul><h4 id="冯·诺依曼机"><a href="#冯·诺依曼机" class="headerlink" title="冯·诺依曼机"></a>冯·诺依曼机</h4><ul><li><p>基本工作方式：控制流驱动方式</p></li><li><p>最根本的特征：采用存储程序原理，即按地址访问并顺序执行指令</p></li><li><p>指令和数据均以二进制形式存放在存储器中</p></li><li><p>CPU区分依据是：指令周期的不同阶段</p></li><li><p>冯·诺依曼计算机：以运算器为中心</p></li><li><p>现代的计算器：以存储器为中心</p></li><li><p>5大部件：存储器、运算器、控制器、输入设备、输出设备（适配器）</p></li><li><p>三大部分：CPU（运算器、控制器）、I/O设备（输入设备、输出设备）、主存储器</p></li><li><p>哈佛结构：将指令和数据放在两个独立的存储器，允许在一个机器周期内同时获得指令和操作数，提高了执行速度</p></li></ul><h4 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h4><ul><li><p>机器字长：</p><ul><li>CPU一次能处理数据的位数，通常与CPU的寄存器位数有关，字长越长，精度越高</li><li>机器的字长也会影响机器的运算速度：字长较短，运算位数多，可能需要多次运算才能完成</li><li>对硬件造价有影响：直接影响ALU、数据总线以及存储字长的位数</li></ul></li><li><p>存储容量：主存容量、辅存容量</p></li></ul><ul><li><p>运算速度：</p><ul><li>吞吐量和响应时间</li><li>主频和CPU时钟周期</li><li>CPI：执行一条指令所需的时钟周期数</li><li>CPU执行时间：指运行一个程序所花费的时间。取决于：主频、CPI、指令条数</li><li>MIPS：每秒执行多少百万条指令</li><li>MFLOPS：每秒执行多少百万次浮点运算（标志系统性能最有用参数）</li><li>GFLOPS：每秒执行多少十亿次浮点运算</li><li>TFLOPS：每秒执行多少万亿次浮点运算</li></ul></li></ul><h3 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h3><h4 id="汉字的编码"><a href="#汉字的编码" class="headerlink" title="汉字的编码"></a>汉字的编码</h4><ul><li>输入码（外码）：区位码、国际码、拼音码、电报码、表形码等</li><li>内码：0、1（机器码）</li><li>输出码：汉字字形码</li><li>汉字编码包括汉字的输入编码、汉字内码、汉字字形。用两个字节表示一个汉字，每个字节用七位码。区位码是4位十进制数，前2位是区码，后2位是位码</li><li>国标码是将十进制的区位码转换为十六进制后，再在每个字节上加上20H。为了方便计算机区分中文字符和英文字符，将国标码两个字节的最高位都改为“1”，这就是汉字内码（十六进制）</li></ul><h4 id="字符串的存放"><a href="#字符串的存放" class="headerlink" title="字符串的存放"></a>字符串的存放</h4><ul><li>小端模式：按先存储低位字节、后存储高位字节的顺序存放字符串的内容</li><li>大端模式：按先存储高位字节、后存储低位字节的顺序存放字符串的内容</li></ul><h4 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h4><ul><li>奇偶校验码：只能检出一位错误，不能确定出错的位置；只能检验处奇数位错误，不能检测出偶数位错误。<ul><li>奇校验码：整个校验码中“1”的个数为奇数。</li><li>偶校验码：整个校验码中“1”的个数为偶数。</li></ul></li><li>海明（汉明）检验码：可检出错位位置</li><li>循环冗余校验（CRC）码：可检出错误位置（通过除法运算）</li></ul><h4 id="原码、反码、补码、移码"><a href="#原码、反码、补码、移码" class="headerlink" title="原码、反码、补码、移码"></a>原码、反码、补码、移码</h4><ul><li>原码、补码、反码三种机器数的最高位均是符号位</li><li>当真值为正时，原码、补码、反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同</li><li>当真值为负时，原码、补码、反码的表示形式不同，但其符号位都用“1”表示，而数值部分补码是原码的“求反加1”，反码是原码的“每位求反”。</li><li>同一个真值的移码和补码仅差一个符号位。</li><li>4、不同机器数表示±0时，其形式不同。</li><li>[+0]原≠[-0]原， [+0]反≠[-0]反，[+0]补=[-0]补，[+0]移=[-0]移</li><li>当机器字长确定后，补码比原码、反码能多表示一个负数</li><li>移码只能表示整数，用它表示浮点数的阶码时，能方便地判断阶码的大小</li></ul><h4 id="补码定点数的加-减运算"><a href="#补码定点数的加-减运算" class="headerlink" title="补码定点数的加/减运算"></a>补码定点数的加/减运算</h4><ul><li>基本公式：（将符号位和数值部分一起参加运算，并且将符号位产生的进位自然丢掉即可）</li><li>加法：[A]补+[B]补=[A+B]补</li><li>减法：[A-B]补=[A]补+[-B]补（[-B]补由[B]补连同符号位在内，每位取反，末尾加1）</li></ul><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><ul><li>用一位符号判断溢出：实际参加操作的两个数符号相同，结果又与原操作数的符号不同，即为溢出</li><li>用两位符号位判断溢出：当2位符号位不同时，表示溢出，否则，无溢出。不论是否发生溢出，高位（第1位）符号永远代表真正的符号。（变形补码，运算时多一位）</li><li>01正溢出（上溢）；10负溢出（下溢）</li><li>采用一位符号位根据数据位的进位情况判断溢出。如果符号位的进位与最高数位的进位不同，则表示结果溢出</li></ul><h4 id="浮点数的加-减运算"><a href="#浮点数的加-减运算" class="headerlink" title="浮点数的加/减运算"></a>浮点数的加/减运算</h4><ul><li>对阶：两个数的小数点位置对齐（使阶码相等），两个数的阶码相减求阶差，使小阶的尾数向右移位，每右移一位，阶码加1</li><li>尾数求和：将对阶后的两个尾数按定点加（减）运算规则进行运算</li><li>规格化：补码规格化形式为[S]补 00.1××××；[S]补 11.0××××<ul><li>左规：尾数出现00.0××××或11.1××××时，需左规。尾数左移一位，阶码减1</li><li>右规：尾数出现01.××××或10.××××时，表示尾数溢出，但在浮点运算中不算溢出，可通过右规处理。尾数右移一位，阶码加1</li></ul></li><li>舍入：在对阶和右规的过程中，可能会将尾数的低位丢失，引起误差，影响精度，用舍入法来提高尾数的精度<ul><li>“0舍1入”法：被移去的最高位数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。又溢出时，再右规……</li><li>“恒置1”法：不论丢掉的最高数位是“1”还是“0”，都使尾数末位恒置“1”。</li><li>两种方法同样都有使尾数变大和变小两种可能</li></ul></li><li>溢出判断（是否溢出由阶码的符号决定）<ul><li>上溢：阶码[j]补=01，×××，作溢出处理</li><li>下溢：阶码[j]补=10，×××，按机器零处理</li></ul></li></ul><h4 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h4><ul><li><p>上溢：当浮点数阶码大于最大阶码时，上溢，机器停止运算，进行中断溢出处理。</p></li><li><p>下溢：当浮点数阶码小于最小阶码时，下溢，溢出的数绝对值很小，通常将位数各位强制为0，按机器零处理，机器可以继续运行。</p></li></ul><h4 id="8位二进制整数范围"><a href="#8位二进制整数范围" class="headerlink" title="8位二进制整数范围"></a>8位二进制整数范围</h4><ul><li>原码、反码：-127—+127</li><li>补码、移码：-128—+127</li></ul><h4 id="标准IEEE-754标准"><a href="#标准IEEE-754标准" class="headerlink" title="标准IEEE 754标准"></a>标准IEEE 754标准</h4><ul><li><p>现代计算机中，浮点数一般采用IEEE制定的国际标准：</p></li><li><p>常用的浮点数有三种：阶码用移码表示</p></li><li><p>短实数、长实数、临时实数的偏移量用十六进制数表示分别为7FH（127）、3FFH、3FFFH</p></li><li><p>尾数部分通常是用原码、规格化表示，即非“0”的有效位最高位总是“1”，但在IEEE标准中，有效位呈如下形式：1▲ff…ffff</p></li><li><p>其中▲表示假想的二进制小数点。在实际表示中，对短实数和长实数，这个整数位的1省略，称隐藏位；对于临时实数不采用隐藏位方案</p></li></ul><h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><h4 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h4><ul><li><p>存储器主要性能指标：速度、容量、每位价格（位价）</p></li><li><p>一般来说，速度越高，位价越高；容量越大，位价越低；容量越大，速度越低。</p></li><li><p>层次结构主要体现在缓存-主存和主存-辅存这两个层次上。</p><ul><li>缓存-主存：主要解决CPU和主存速度不匹配问题（由硬件自动完成）数据调动对任何程序员透明。</li><li>主存-辅存：主要解决存储系统的容量问题（由硬件和操作系统共同完成）数据调动对应用程序员透明</li></ul></li></ul><h4 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h4><ul><li>一般取2ms，对动态RAM的全部基本单元电路必作一次刷新，称为刷新周期，又称再生周期。刷新的单位是行，仅需要行地址。</li><li>集中刷新：在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作，称“死时间”或“死区”。（全部一起刷）</li><li>分散刷新：对每行存储单元的刷新分到每个存取周期内完成。优点：没有死区。缺点：存取周期加长，整个系统速度降低。（一个个刷）</li><li>异步刷新：是前两种方式的结合，既缩短“死时间”，又充分利用最大刷新时间间隔为2ms的特点。（一行行刷）</li><li>一行行刷的平均刷新时间<ul><li>行数 = 芯片容量 / 每行存储单元个数</li><li>平均刷新时间 = 间隔最长 / 行数</li></ul></li></ul><h5 id="存储容量的扩展"><a href="#存储容量的扩展" class="headerlink" title="存储容量的扩展"></a>存储容量的扩展</h5><ul><li>位扩展<ul><li>增加存储字长</li><li>例如：2片1K4位的存储芯片可组成1K8位的存储器。</li><li>注意：其中一片的数据线作为高4位D7-D4，另一片的数据线作为低4位D3-D0。</li></ul></li><li>字扩展<ul><li>增加存储器字的数量</li><li>例如：2片1K8位的存储芯片可组成一个2K8位的存储器。</li><li>注意：两片都连地址线A0-A9。（从低位连起）</li></ul></li><li>字、位扩展<ul><li>既增加存储字的数量又增加存储字长。</li></ul></li></ul><h4 id="双口RAM和多模块存储器"><a href="#双口RAM和多模块存储器" class="headerlink" title="双口RAM和多模块存储器"></a>双口RAM和多模块存储器</h4><ul><li>为了提高CPU访问存储器的速度，可以采用双端口存储器（空间并行）、多模块存储器（时间并行）等技术，都属于并行技术。</li></ul><h4 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h4><ul><li>为了提高访存速度（CPU速度比存储器快，同时从存储器中取出n条指令，可以充分利用CPU资源，提高运行速度）</li><li>单体多字系统<ul><li>在一个存取周期内，从同一地址取出n条指令，然后逐条将指令送至CPU执行，即每隔1/n存取周期，主存向CPU送一条指令，增大了存储器的带宽，提高了存储器的工作速度。</li><li>例如：从同一地址取出4条指令，为单体四字结构，每字W位。按地址在一个存取周期内可读出4*W位的指令或数据，使主存带宽提高到4倍。</li><li>缺点：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。</li></ul></li><li>多体并行系统</li><li>采用多提模块组成的存储器。每个模块可以并行工作，也可以交叉工作。<ul><li>低位交叉编址<ul><li>程序连续存放在相邻体中（交叉存储）。低位地址表示体号，高位地址表示体内地址。<br>地址的低n为片选。</li><li>优点：相邻地址单元的数据放在不同组，各组可以并行工作，能较好提高存储器的带宽。</li><li>缺点：某一组出现故障，会影响整个存储器的正常工作。</li></ul></li><li>高位交叉编址<ul><li>按体内地址顺序存放（顺序存储）。高位地址表示体号，低位地址表示体内地址。</li><li>地址的高n位片选。</li><li>优点： 某一组的故障不影响其他组，且容易通过添加模块来扩充容量。</li><li>缺点：相邻地址单元的数据放在同一组存储单元，各组间串行工作，不利于提升存储器的带宽。</li></ul></li></ul></li></ul><h4 id="Cache中主存块之间的映射方式"><a href="#Cache中主存块之间的映射方式" class="headerlink" title="Cache中主存块之间的映射方式"></a>Cache中主存块之间的映射方式</h4><ul><li>由主存地址映射到Cache地址称为地址映射</li><li>直接映射<ul><li>主存数据只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无需使用替换算法）。</li><li>优点：实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。</li><li>缺点：不够灵活，降低命中率。</li></ul></li><li>全相联映射<ul><li>允许主存中每一字块映射到Cache中的任何一块位置上。可以从已被占满的Cache中替换出任一旧字块。</li><li>通常采用昂贵的“按内容寻址”的相联存储器来完成。</li><li>优点：灵活，命中率高，缩小了块冲突率，空间利用率高。</li><li>缺点：地址变换速度慢，实现成本高</li></ul></li><li>组相联映射（上述两种映射的折中）<ul><li>将Cache空间分成大小相同的组，主存的一个数据块可以装入到一组内的任何一个位置（组间采取直接映射，组内采取全相联映射）。</li></ul></li></ul><h4 id="Cache中主存块的替换算法"><a href="#Cache中主存块的替换算法" class="headerlink" title="Cache中主存块的替换算法"></a>Cache中主存块的替换算法</h4><ul><li>先进先出（First-In-First-Out，FIFO）算法</li><li>近期最少使用（Least Recently Used，LRU）算法</li><li>随机法</li></ul><h4 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h4><ul><li>磁盘寻址的最小单位是扇区。</li><li>道密度：沿磁盘半径方向单位长度的磁道数。</li><li>位密度：单位长度磁道上记录二进制的位数。</li><li>平均寻道时间：从一个磁道转移到另一个磁道的平均时间。（全部寻道时间的一半）</li><li>平均等待时间：旋转等待的平均时间。（转一周时间的一半）</li><li>一扇区的传送时间：T=1 / (转速×扇区数)</li><li>存取一个扇区的时间：T=每个扇区位数 / (转速×扇区数)</li><li>平均存取时间=平均寻道时间 + 平均等待时间 + 传输时间</li><li>每个记录面的磁道数：K=[(外直径-内直径)/2]*磁道密度</li><li>盘组格式化容量：C = 记录面数 * K * 每个扇区字节数 * 扇区数</li><li>盘组非格式化容量：CN = 记录面数 * K * 最内圈磁道周长 * 内层位密度</li><li>WE 为写允许信号：低电平0为写，高电平1为读</li><li>CS为片选信号：低电平0有效</li><li>借位/进位C：1=结果的最高位发生了进位，0=结果的最高位未发生进位</li><li>溢出标志位V：1=溢出，0=没有溢出</li></ul><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><h4 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h4><ul><li>寻址模式是大多数中央处理器 （CPU）设计中的指令集架构的一个方面</li><li>在给定指令集架构中定义的各种寻址模式决定了该架构中的机器语言指令如何识别每个指令的操作数</li><li>寻址模式指定如何通过使用寄存器中保存的信息和/或机器指令中包含的常量或其他地方包含的常量来计算操作数的有效存储器地址。</li></ul><h4 id="CISC和RISE"><a href="#CISC和RISE" class="headerlink" title="CISC和RISE"></a>CISC和RISE</h4><ul><li>从硬件角度来看CISC处理的是不等长指令集，它必须对不等长指令进行分割，因此在执行单一指令的时候需要进行较多的处理工作。而RISC执行的是等长精简指令集，CPU在执行指令的时候速度较快且性能稳定。因此在并行处理方面RISC明显优于CISC，RISC可同时执行多条指令，它可将一条指令分割成若干个进程或线程，交由多个处理器同时执行。由于RISC执行的是精简指令集，所以它的制造工艺简单且成本低廉。</li><li>从软件角度来看，CISC运行的则是我们所熟识的DOS、Windows操作系统。而且它拥有大量的应用程序。因为全世界有65%以上的软件厂商都理为基于CISC体系结构的PC及其兼容机服务的，象赫赫有名的Microsoft就是其中的一家。而RISC在此方面却显得有些势单力薄。虽然在RISC上也可运行DOS、Windows，但是需要一个翻译过程，所以运行速度要慢许多。</li></ul><h4 id="地址指令操作数物理位置的三种形式"><a href="#地址指令操作数物理位置的三种形式" class="headerlink" title="地址指令操作数物理位置的三种形式"></a>地址指令操作数物理位置的三种形式</h4><ul><li>寄存器——寄存器型（RR型）；</li><li>寄存器——存储器型指令（RS型）；</li><li>存储器——存储器型（SS型）。</li></ul><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><h4 id="计算机工作过程"><a href="#计算机工作过程" class="headerlink" title="计算机工作过程"></a>计算机工作过程</h4><ul><li>加电——》产生reset信号——》执行程序——》停机——》停电</li><li>产生reset信号的任务<ul><li>任务一：使计算机处于初始状态</li><li>任务二：从PC中取出指令地址</li></ul></li><li>控制器作用是协调并控制计算机各部件执行程序的指令序列</li></ul><h4 id="控制器的组成"><a href="#控制器的组成" class="headerlink" title="控制器的组成"></a>控制器的组成</h4><ul><li>控制器的功能<ul><li>取指令：发出指令地址，取出指令的内容</li></ul></li><li>分析指令<ul><li>对操作码译码产生操作相应部件的控制信号</li><li>根据寻址方式形成操作数地址</li></ul></li><li>执行指令<ul><li>根据分析指令后产生控制信号、操作数地址信号序列，通过CPU及输入输出设备的执行实现每条指令的功能</li><li>结果回送存储器</li><li>形成下条指令的地址</li></ul></li><li>控制程序和数据的输入和结果输出</li><li>对异常情况和某些请求的处理<ul><li>异常情况的处理：例如算术运算的溢出、数据传送奇偶错</li><li>某些请求的处理</li><li>“中断请求”信号</li><li>DMA请求信号</li></ul></li><li>控制器的组成<ul><li>程序计数器（PC）：即地址寄存器，用来存放当前正在执行的指令地址或即将要执行的下一条指令地址</li><li>指令寄存器（IR）：用以存放当前正在执行的指令，以便在指令执行过程中控制完成一条指令的全部功能</li><li>指令译码器或操作码译码器：对指令寄存器中的操作码进行分析解释，产生相应的控制信号</li><li>脉冲源及启停线路：脉冲源参数一定评率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号，在机器刚加电时，还应产生一个总清信号（reset）</li><li>时序控制信号形成部件：当程序启动后，在CLK时钟作用下，根据当前正在执行的指令的需要，产生相应的时序控制信号，并根据被控制功能部件的反馈信号调整时序控制信号<ul><li>控制存储器</li><li>微指令寄存器：控制字段+下址</li></ul></li></ul></li><li>周期概念<ul><li>指令周期：完成一条指令所需的时间，包括取指令、分析指令、执行指令</li><li>机器周期：也称为CPU周期，是CPU从内存中读取一个指令的时间，通常等于取指周期</li><li>时钟周期：称为节拍脉冲或T周期，是基准脉冲信号</li><li>三条假设<ul><li>程序是存放在主存中的，当执行完一条指令后才从主存中取下一条指令（非流水线）</li><li>指令的长度是固定的，并限制了寻址方式的多样化</li><li>在程序运行前，程序和数据都已存在主存中</li></ul></li></ul></li><li>指令执行过程（运算器和控制器配合）</li><li>组成控制器的基本电路<ul><li>具有记忆功能的触发器以及由它组成的寄存器，计数器和存储单元</li><li>没有记忆功能的门电路及由它组成的加法器，算术逻辑运算单元（ALU）和各种逻辑电路</li></ul></li><li>控制器的功能就是按每一条指令的要求产生所需的控制信号</li><li>产生控制信号的方法<ul><li>微程序控制</li><li>硬布线控制</li></ul></li></ul><h4 id="微程序控制计算机的基本工作原理"><a href="#微程序控制计算机的基本工作原理" class="headerlink" title="微程序控制计算机的基本工作原理"></a>微程序控制计算机的基本工作原理</h4><ul><li>微指令：在微程序控制的计算机中，将由同时发出的控制信号所执行的一组微操作</li><li>微命令：将指令分为若干条微指令，按次序执行这些微指令。组成微指令的操作即微命令</li><li>微程序：计算机的程序由指令序列构成，而计算机每条指令的功能均由微指令序列解释完成，这些微指令序列的集合就叫做微程序</li><li>控制存储器<ul><li>微程序一般是存放在专门的存储器中的，由于该存储器主要存放控制命令（信号）与下一条执行的微指令地址（简称下址）</li><li>存储单元内容<ul><li>微指令的控制信号——控制位</li><li>下条微指令的地址——下址字段</li></ul></li><li>存储芯片：ROM</li></ul></li><li>执行一条指令实际上就是执行一段存放在控制存储器中的微程序</li><li>实现微程序控制的基本原理<ul><li>控制信号（23条）</li><li>加法的过程</li><li>微指令格式：控制字段+下址字段</li><li>23个控制位，12个下址位——》容量为4K</li><li>取址微指令的操作对所有指令都是相同的，所以是一条公用的微指令，其下址由操作码译码产生</li></ul></li><li>微程序控制器</li><li>时序信号及工作脉冲的形成</li><li>停机和停电的区别</li><li>停机：电压稳定、存放内容保持、重启PC内容为断点指令地址</li><li>停电：电压消失、RAM的内容消失、重启PC内容为第一条指令地址</li></ul><h4 id="微程序设计技术"><a href="#微程序设计技术" class="headerlink" title="微程序设计技术"></a>微程序设计技术</h4><ul><li>如何缩短微指令字长<ul><li>直接控制法（容量太小）<ul><li>编译方法：每一位代表一个控制信号，直接送往相应的控制点</li><li>优点：控制简单</li><li>缺点：微指令字长过大</li></ul></li><li>字段直接编译法<ul><li>选出互斥的微指令</li><li>每个字段都要留出一个代码，表示本段不发出任何指令（000）</li><li>优点：节省微指令的字长</li><li>缺点：增加了额外的硬件开销</li></ul></li><li>字段间接编译法<ul><li>指令之间相互联系的情况</li><li>举例：A为0-7，B为0-3，如果是直接编译——3+2=5，如果是间接编译——3+1=4</li><li>编码方法：在字段直接编译法中，译码输出端要兼由另一字段中的某些微命令配合解释</li><li>优点：减少了微指令长度</li><li>缺点：可能削弱微指令的并行控制能力，同时增加硬件开销</li></ul></li><li>常熟源字段E</li></ul></li><li>如何减少微指令长度<ul><li>现行微指令/微地址<ul><li>现行微指令：当前正在执行的指令</li><li>现行微地址：存放现行微指令的控制器存储单元</li></ul></li><li>后继微指令/微地址<ul><li>后继微指令：下一条要执行的微指令</li><li>后继微地址：存放后继微指令的控制器存储单元</li></ul></li><li>增量与下址字段结合产生后继微指令的方法<ul><li>下址字段分成：转移控制字段BCF和转移地址字段BAF<ul><li>BCF：控制微程序的转移情况</li><li>BAF：转移后的微指令所在地址</li></ul></li><li>BAF有两种情况<ul><li>与uPC的位数相等——转移灵活，但增加微指令长度</li><li>比uPC短——转移地址收到限制，但可缩短微指令长度</li></ul></li><li>优点：微指令的下址字段很短，仅用于选择输入uPC计数器的某条线路有效</li><li>缺点：微程序转移不灵活，使得微程序在控存中的物理空间分配有困难</li></ul></li><li>多路转移方式：一条微指令存在多个转移分支的情况称为多路转移</li><li>微中断<ul><li>微中断请求信号是由程序中断请求信号引起的</li><li>在完成现行指令的微程序后响应该微中断请求</li><li>由硬件产生对应微中断处理程序在控存中的入口地址</li></ul></li></ul></li><li>如何提高微程序的执行速度<ul><li>微指令格式</li><li>水平型微指令——直接控制，字段编译（直接、间接）<ul><li>特点：在一条微指令中定义并并行执行多个微命令</li></ul></li><li>垂直型微指令<ul><li>特点：不强调实现微指令的并行控制功能</li><li>定义：采用微操作码编译法，由操作码规定微指令的功能</li></ul></li><li>微程序控制存储器<ul><li>一般采用ROM存储器</li><li>也可采用RAM，为防止断电后内容消失，则必须开机后将外存中存放的微程序调入控存RAM，然后才能执行程序。</li><li>当前为了能不断扩展指令系统，通常采用ROM+RAM</li></ul></li><li>动态微程序设计<ul><li>定义：能根据用户要求改变微程序</li><li>优点：是计算机能更灵活、有效的适应于各种不同的应用目标</li></ul></li><li>控制存储器的操作<ul><li>串行方式</li><li>并行方式——比串行多了微指令寄存器</li><li>微周期=max(取微指令时间,执行微指令时间)</li><li>由于取微指令、执行微指令同时进行，故对于某些后继微地址的产生根据处理结果而定的微指令，则延迟一个微周期再取微指令</li></ul></li></ul></li></ul><h4 id="硬布线控制的计算机（RISC）——特点快"><a href="#硬布线控制的计算机（RISC）——特点快" class="headerlink" title="硬布线控制的计算机（RISC）——特点快"></a>硬布线控制的计算机（RISC）——特点快</h4><ul><li>形成操作控制信号的逻辑框图</li><li>操作控制信号的产生<ul><li>取值周期cy1所产生的信号对所有指令都是相同的，即与当前执行的指令无关，逻辑式得到最简单的形式</li><li>通常，同一个控制控制信号在若干条指令的某些周期（或再加上一些条件）中都需要，为此需要把它们组合起来</li><li>同种类型的指令所需要的控制信号大部分是相同的，仅有少量区别</li><li>在确定指令的操作码时（即对具体指令赋予二进制操作码），为了便于逻辑表达式的化简以减少逻辑电路数量，往往给予特别关注</li></ul></li><li>设计组合逻辑电路从而产生需要的控制信号的步骤<ol><li>实际逻辑问题</li><li>真值表</li><li>公式化简</li><li>逻辑电路图</li></ol></li><li>设计目标：使用最少的电路元件达到最高的操作速度</li></ul><h4 id="流水线工作原理"><a href="#流水线工作原理" class="headerlink" title="流水线工作原理"></a>流水线工作原理</h4><ul><li>每条指令的执行时间不变</li><li>每条指令处理结果的时间缩短</li><li>流水线处理速率最高时=流水线处于满载的稳定状态</li><li>流水线处理速率最低时=流水线未满载状态</li><li>为了满足在重叠时间段不同指令的机器周期能够完成指定的操作，将时间段=操作完成的最长时间</li><li>为了保证一个周期内流水线的输入信号不变，相邻时间段之间必须设置锁存器或寄存器</li><li>除了指令执行流水线，还有运算操作流水线</li><li>流水线阻塞<ul><li>数据相关产生</li><li>假设第二条指令需要的操作数是第一条指令运算的结果，那么出现了数据相关</li><li>指令执行时间不同产生</li><li>程序转移的影响</li><li>异常情况响应中断</li></ul></li></ul><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><h4 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h4><ul><li>cache-&gt;主存-&gt;辅存</li></ul><h4 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h4><ul><li>cache的工作原理<ul><li>局部性原理</li><li>主存地址和cache地址（P166 图7.2）</li><li>块长：块长一般取一个主存周期所能调出的信息长度（一般为16个字）</li><li>cache的容量和块的大小是影响cache的效率的重要因素</li><li>命中率：CPU所要访问的信息是否在cache中的比率，而将所要访问的信息不在cache中的比率称为失败率</li><li>一致性策略<ul><li>标志交换方式（写回法）</li><li>通过式写入（写通法）</li><li>写操作直接对主存进行，而不写入cache</li></ul></li><li>cache的平均存取时间=h*tc+(1-h)(tc+tm)</li><li>最好替换策略：按照被替换的字块是下一段时间最少使用的，由替换部件实现</li></ul></li><li>cache组织地址映像<ul><li>直接映像<ul><li>cache中许多空的位置被浪费</li><li>主存地址：主存字块标记+cache字块地址+字块内地址</li></ul></li><li>全相联映像<ul><li>成本太高而不能采用</li><li>主存地址：主存字块标记+字块内地址</li><li>优点</li><li>方式灵活，缩小了块发生冲突的概率</li><li>缺点</li><li>增加了标识位位数</li><li>增加了寻找主存块在cache中对应块的时间</li></ul></li><li>组相联映像<ul><li>直接映像和全相联映像的折衷</li><li>主存地址：主存字块标记+组地址+块内地址</li></ul></li></ul></li></ul><h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><ul><li>存储管理部件（MMU）</li><li>现代计算机一般都有辅助存储器，但具有辅存的存储系统不一定是虚拟存储系统</li><li>虚拟存储系统的特点<ul><li>允许用户程序用比主存大的多的空间来访问主存</li><li>每次访存都要进行虚实地址的转换</li></ul></li></ul><h3 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h3><ul><li>半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器</li></ul><h4 id="辅助存储器的种类"><a href="#辅助存储器的种类" class="headerlink" title="辅助存储器的种类"></a>辅助存储器的种类</h4><ul><li>磁表面存储器<ul><li>数字式磁记录：硬盘、软盘和磁带</li><li>模拟式磁记录：录音、录像设备</li></ul></li><li>光存储器：光盘</li></ul><h5 id="串行存储器"><a href="#串行存储器" class="headerlink" title="串行存储器"></a>串行存储器</h5><ul><li>顺序存取存储器</li><li>直接存取存储器</li></ul><h5 id="辅助存储器的技术指标"><a href="#辅助存储器的技术指标" class="headerlink" title="辅助存储器的技术指标"></a>辅助存储器的技术指标</h5><ul><li>存储密度：单位长度或单位面积磁层表面磁层所存储的二进制信息量</li><li>道密度：沿磁盘半径方向单位长度的磁道数称为道密度，单位为道/英寸tpi或道/毫米tpmm</li><li>位密度或线密度：单位长度磁道所能记录二进制信息的位数叫位密度或线密度，单位为位/英寸bpi或位/毫米bpmm</li><li>每个磁道所存储的信息量是一样的</li><li>存储容量：C = n × k × s</li><li>寻址时间：平均寻址时间Ta=平均找道时间Ts+平均等待时间Tw</li><li>数据传输率：Dr = D × V</li><li>误码率</li><li>价格</li></ul><h4 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h4><ul><li>固定磁头和移动磁头</li><li>可换盘和固定盘</li></ul><h4 id="磁盘存储器-1"><a href="#磁盘存储器-1" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h4><ul><li>温彻斯特磁盘简称温盘</li><li>磁盘存储器由驱动器（HDD），控制器（HDC）和盘片组成</li><li>最外面的同心圆叫0磁道，最里面的同心圆假设称为n磁道</li><li>驱动器的定位驱动系统实现快速精准的磁头定位</li><li>主轴系统的作用是带动盘片按额定转速稳定旋转</li><li>数据控制系统的作用是控制数据的写入和读出，包括寻址，磁头旋转，写电流控制，读出放大，数据分离</li><li>磁盘控制器有两个方向的接口<ul><li>与主机的接口</li><li>与驱动器（设备）的接口</li></ul></li></ul><h4 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h4><ul><li>采用光存储技术</li><li>利用激光写入和读出</li><li>第一代光存储技术采用非磁性介质，不可擦写</li><li>第二代光存储技术，采用磁性介质，可擦写</li><li>光盘的存储原理<ul><li>只读型和只写一次型：热作用（物理或化学变化）</li><li>可擦写光盘：热磁效应</li></ul></li></ul><h3 id="输出输出（I-O）设备-系统"><a href="#输出输出（I-O）设备-系统" class="headerlink" title="输出输出（I/O）设备/系统"></a>输出输出（I/O）设备/系统</h3><h4 id="设备控制器（I-O）的基本功能"><a href="#设备控制器（I-O）的基本功能" class="headerlink" title="设备控制器（I/O）的基本功能"></a>设备控制器（I/O）的基本功能</h4><ul><li>实现主机和外部设备之间的数据传送</li><li>实现数据缓冲，以达到主机同外部设备之间的速度匹配</li><li>接受主机的命令，提供设备接口的设备，并按照主机的命令控制设备</li></ul><h4 id="I-O-编址方式"><a href="#I-O-编址方式" class="headerlink" title="I/O 编址方式"></a>I/O 编址方式</h4><ul><li>统一编址：用取数、存数指令</li><li>不统一编址：有专门的 I/O 指令</li></ul><h4 id="I-O-与主机的连接方式"><a href="#I-O-与主机的连接方式" class="headerlink" title="I/O 与主机的连接方式"></a>I/O 与主机的连接方式</h4><ul><li>辐射式连接<ul><li>每台设备都配有一套</li><li>控制线路和一组信号线</li><li>不便于增删设备</li></ul></li><li>总线连接<ul><li>便于增删设备</li></ul></li></ul><h4 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h4><ul><li>人机交互设备：键盘、鼠标等</li><li>计算机信息的驻留设备：硬盘、光盘等</li><li>机——机通信设备：MODEN等</li></ul><h4 id="为什么要设置接口？"><a href="#为什么要设置接口？" class="headerlink" title="为什么要设置接口？"></a>为什么要设置接口？</h4><ul><li>实现设备的选择</li><li>实现数据缓冲达到速度匹配</li><li>实现数据串 并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反映设备的状态（“忙”、“就绪”、“中断请求”）</li></ul><h4 id="中断服务程序的流程"><a href="#中断服务程序的流程" class="headerlink" title="中断服务程序的流程"></a>中断服务程序的流程</h4><ul><li>保护现场<ul><li>程序断点的保护</li><li>寄存器内容的保护</li></ul></li><li>中断服务<ul><li>对不同的 I/O 设备具有不同内容的设备服务</li></ul></li><li>恢复现场：出栈指令</li><li>中断返回：中断返回指令</li></ul><h4 id="单重中断和多重中断"><a href="#单重中断和多重中断" class="headerlink" title="单重中断和多重中断"></a>单重中断和多重中断</h4><ul><li>单重中断：不允许中断 现行的 中断服务程序</li><li>多重中断：允许级别更高 的中断源（现行的 中断服务程序）</li></ul><h4 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h4><ul><li>主存和 I/O 之间有一条直接数据通道</li><li>CPU 和 I/O 并行工作</li><li>DMA 的三种工作方式<ul><li>CPU暂停方式</li><li>CPU周期窃取方式</li><li>直接访问存储器</li></ul></li><li>DMA 接口功能<ul><li>向 CPU 申请 DMA 传送</li><li>处理总线 控制权的转交</li><li>管理 系统总线、控制 数据传送</li><li>确定 数据传送的 首地址和长度，修正 传送过程中的数据地址和长度</li><li>DMA 传送结束时，给出操作完成信号</li></ul></li><li>DMA 传送过程：预处理、数据传送、后处理</li></ul><h4 id="外设接口"><a href="#外设接口" class="headerlink" title="外设接口"></a>外设接口</h4><ul><li>设备与主机相连时，必须按照规定的物理互连特性、电气特性等进行连接，这些特性的技术规范称为接口标准</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/course/hit-309001&quot;&gt;国家精品课&lt;/a&gt;，配合天勤高分笔记，以下为所记课堂笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-11-09T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.845Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构<a href="https://www.icourse163.org/course/ZJU-93001">国家精品课</a>，以下为所记课堂笔记，另外我在开源仓库中还保持了浙大慕课版本的<a href="https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">代码</a>，可供参考。</p></blockquote><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="C-C-语言基础"><a href="#C-C-语言基础" class="headerlink" title="C/C++语言基础"></a>C/C++语言基础</h4><ul><li>数据类型<ul><li>结构型 <code>int a[maxSize];</code></li><li>指针型 <code>int *a;</code></li><li>链表结点<pre><code class="C">typedef struct Node&#123;  int data;  struct Node *next;&#125;Node;</code></pre></li><li>二叉树结点<pre><code class="C">typedef struct BTNode&#123;  int data;  struct BTNode *lchild;  struct BTNode *rchild;&#125;BTNode;</code></pre></li><li>动态申请数组空间<pre><code class="C">int *p;p=(int *)malloc(n * sizeof(int));</code></pre></li></ul></li><li>函数<ul><li>函数参数的引用型定义<pre><code class="cpp">int a=0;void f(int &amp;x)&#123;  ++x;&#125;f(a);</code></pre></li><li>数组作参数的引用型定义<pre><code class="cpp">void f(int x[][maxSize], int n)&#123;···;&#125;</code></pre></li></ul></li></ul><h4 id="算法的时间复杂度和空间复杂度"><a href="#算法的时间复杂度和空间复杂度" class="headerlink" title="算法的时间复杂度和空间复杂度"></a>算法的时间复杂度和空间复杂度</h4><ul><li>时间复杂度 <ul><li>$T(n)=O(f(n)中增长最快的项的系数)$</li><li>将最坏的情况作为算法时间复杂度的度量</li><li>$O(1)≤O(\log_{2}\left(n\right)≤O(n)≤O(n\log_{2}\left(n\right)≤O(n^2)≤O(2^n)$（常对幂指阶）</li><li>取最深层循环内的语句所描述的操作为基本操作，由循环基本执行的次数为规模n，计算函数 $f(n)$</li></ul></li><li>空间复杂度：算法在运行时所需存储空间的度量，主要考虑在算法运行过程中临时占用的存储空间大小<ul><li>空间复杂度 = 函数递归调用的深度</li></ul></li></ul><h4 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h4><ul><li>数据是对客观事物的符号表示</li><li>数据元素是数据的基本单位</li><li>数据对象是性质相同的数据元素的集合</li><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合<ul><li>数据的逻辑结构是对数据之间关系的描述，分为线性结构（一个数据元素的次序集合）和非线性结构（树、图）</li><li>数据的存储（物理）结构是数据的逻辑结构在计算机中的表示（映像），包括数据元素的表示和关系的表示</li></ul></li><li>数据元素之间的关系：顺序映像和非顺序映像</li><li>数据结构中常用储存方法：顺序存储（数组）、链式存储（指针）、索引存储 <code>&lt;关键字, 地址&gt;</code>、散列存储（根据结点的关键字通过散列函数直接计算出该结点的存储地址）</li></ul><h4 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h4><ul><li>算法的特性：有穷性、确定性、输入、输出、可行性</li><li>算法的设计目标：正确性、可读性、健壮性、高效率和低存储量需求</li></ul><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h4 id="线性表的基本概念"><a href="#线性表的基本概念" class="headerlink" title="线性表的基本概念"></a>线性表的基本概念</h4><ul><li>线性表是具有相同特性数据元素的一个有限序列，长度 $n≥0$</li><li>线性表只有一个表头元素，一个表尾元素，除表头表尾元素外其他元素只有一个直接前驱和一个直接后继（有序性）</li><li>顺序表：随机访问特性、要求占用连续的存储空间、做插入操作要移动多个元素</li><li>链表：不支持随机访问、结点的存储空间利用率稍低、支持存储空间的动态分配</li><li>头指针指向链表的第一个结点、头结点指向带头结点链表的第一个结点</li><li>单链表、双链表、循环单链表、循环双链表、静态链表（数据元素分量+指针分量）</li></ul><h4 id="线性表的结构体定义"><a href="#线性表的结构体定义" class="headerlink" title="线性表的结构体定义"></a>线性表的结构体定义</h4><ul><li>顺序表<pre><code class="cpp">typedef struct&#123;  int data[maxSize];   //考试写这两行  int length;         //&#125;Sqlist;</code></pre></li><li>单链表<pre><code class="cpp">typedef struct LNode&#123;  int data;  struct LNode *next;&#125;LNode//构造LNode型结点LNode *A = (LNode*)malloc(sizeof(LNode));</code></pre></li><li>双链表<pre><code class="cpp">typedef struct DLNode&#123;  int data;  struct DLNode *prior;  struct DLNode *next;&#125;DLNode;</code></pre></li></ul><h4 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h4><ul><li><p>插入元素</p><ul><li>1 ≤ i ≤ ListLength(L）</li></ul><pre><code class="cpp">int ListInsert(SeqList *L,int i,ElemType *e)&#123;  int k；  if(L-&gt;length==MAXSIZE)/*顺序线性表已经满*/    return ERROR;  if（i&lt;1 || i&gt;L-&gt;length+1)/*当 i 不在范围内时*/    return ERROR;  if(i&lt;=L-&gt;length)  &#123;            /*若插入数据位置不在表尾*/    for(k=L-&gt;length-1；k&gt;=i-1；k--)    /*将要插入位置后的数据元素向后移动一位*/      L-&gt;data[k+1]=L-&gt;data[k];  &#125;  L-&gt;data[i-1]=e;/*将新元素插入*/  L-&gt;length++;  return OK;&#125;</code></pre></li><li><p>删除元素</p><pre><code class="cpp">int ListDelete(SqList *L,int i,ElemType *e)&#123;  int k;  if (L-&gt;length==0)/*线性表为空*/    return ERROR;  if(i&lt;1|| i&gt;L-&gt;length)/*删除位置不正确*/    return ERROR;  *e=L-&gt;data[i-1];  if(i&lt;L-&gt;1ength)  &#123;    /*如果删除不是最后位置*/    for（k=i；k&lt;L-&gt;length;k++)/*将删除位置后继元素前移*/    L-&gt;data[k-1]=L-&gt;data[k];  &#125;  L-&gt;length--；  return OK;&#125;</code></pre></li><li><p>查找元素</p><pre><code class="cpp">int findElem (Sqlist L, int e)&#123;  int i;  for (i=0; i&lt;L.length; ++i)    if (e==L.data[i])      return i;  return -1;&#125;</code></pre></li><li><p>求指定位置元素</p><pre><code class="cpp">int getElem(Sqlist L, int p, int &amp;e)  if(p&lt;0||p&gt;L.length-1)    return 0;  e=L.data[p];  return 1;</code></pre></li></ul><h4 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h4><ul><li><p>尾插法建立链表C</p><pre><code class="cpp">void createlistR(LNode *&amp;C, int a[], int n)&#123;  LNode *s, *r;  //s指向新申请结点，r指向C的终端结点  int i;  C=(LNode *)malloc(sizeof(LNode));  //申请C的头结点空间  C-&gt;next=NULL;  r=C;  for (i=0; i&lt;n; ++i)  &#123;    s=(LNode *)malloc(sizeof(LNode));    s-&gt;data=a[i];    r-&gt;next=s;    r=r-&gt;next;  &#125;  r-&gt;next=NULL;&#125;</code></pre></li><li><p>归并成递减的单链表</p><pre><code class="cpp">void merge (LNode *A, LNode *B, LNode *C)&#123;  LNode *p=A-&gt;next;  LNode *q=B-&gt;next;  LNode *s;  C=A;  C-&gt;next=NULL;  free(B);  while(p!=NULL&amp;&amp;q!=NULL)  &#123;    /*下面的if else体现了头插法*/    if(p-&gt;data&lt;=q-&gt;data)    &#123;      s=p;p-&gt;next;      s-&gt;next=C-&gt;next;      C-next=s;    &#125;    else    &#123;      s=q;q=q-&gt;next;      s-&gt;next=C-&gt;next;      C-&gt;next=s;    &#125;  &#125;  while(p!=NULL)  &#123;    s=p;    p=p-&gt;next;    s-&gt;next=C-&gt;next;    C-&gt;next=s;  &#125;  while(q!=NULL)  &#123;    s=q;    q=q-&gt;next;    s-&gt;next=C-&gt;next;    C-&gt;next=s;  &#125;&#125;</code></pre></li><li><p>单链表获取元素</p><ul><li>用 e 返回表中第 i 个数据元素的值</li></ul><pre><code class="cpp">int GetElem(LinkList L,int i,ElemType *e)&#123;  int j=1;    /*j 为计数器*/  LinkList p;    /*声明一节点 p*/  p=L-&gt;next;    /*p 指向链表 L 的第一个节点*/  while(p &amp;&amp; j&lt;i)   &#123;     /*当 p 不为空并且计数器不等于 i 时，循环继续*/    p=p-&gt;next； /*p 指向下一个节点*/    ++j;  &#125;  if(!p || j &gt; i)    return ERROR;  *e = p-&gt;data;  return OK;&#125;</code></pre></li><li><p>单链表插入元素</p><pre><code class="cpp">int ListInsert(LinkList *L,int i,ElemType e)&#123;  int j=1；    LinkList p,s;    p=*L；    while (p &amp;&amp; j&lt;i)     /*寻找第 i 个节点*/    &#123;        p=p-&gt;next;        ++j；    &#125;  if (!p || j&gt;i)  return ERROR;     /*第 i 个元素不存在*/  s=(LinkList *) malloc (sizeof(Node));    /*生成新节点（C 标准函数）*/  s-&gt;data=e;  s-&gt;next=p-&gt;next;    //将 p 的后继节点赋值给 s 的后继*）  p-&gt;next=s;       //将 s 赋值给 p 的后继  return OK;&#125;</code></pre></li></ul><h4 id="双链表的操作"><a href="#双链表的操作" class="headerlink" title="双链表的操作"></a>双链表的操作</h4><ul><li><p>尾插法建立双链表</p><pre><code class="cpp">void createDlistR(DLNode *&amp;L, int a[], int n)&#123;  DLNode *s, *r;  //s指向新申请结点，r指向C的终端结点  int i;  L=(DLNode *)malloc(sizeof(DLNode));  L-&gt;prior=NULL;  L-&gt;next=NULL;  r=L;    //和单链表一样，r始终指向终端节点，开始头节点也是尾节点  for (i=0; i&lt;n; ++i)  &#123;    s=(DLNode *)malloc(sizeof(DLNode));    s-&gt;data=a[i];    r-&gt;next=s;    s-&gt;prior=r;    r=s;  &#125;  r-&gt;next=NULL;&#125;</code></pre></li><li><p>双链表寻找结点</p><pre><code class="cpp">DLNoded* findNode(DLNode *C, int x)&#123;  DLNode *p=C-&gt;next;  while(p!=NULL)  &#123;    if(p-&gt;data==x)        break;    p=p-&gt;next;  &#125;  return p;  //如果找到，则P中内容是结点地址，如果没找到，则P中内容是NULL&#125;</code></pre></li><li><p>双链表插入结点</p><pre><code class="cpp">s-&gt;prior = p; s-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = s; p-&gt;next = s; </code></pre></li><li><p>双链表删除结点</p><pre><code class="cpp">p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; free(p)     //释放空间，不要漏掉</code></pre></li><li><p>链表的逆置</p><pre><code class="cpp">ListNode* reverseList(ListNode head)&#123;  if(head == NULL || head-&gt;next == NULL)      return head;      ListNode* newhead = reverseList(head-&gt;next);   //递归到链尾      head-&gt;next-&gt;next = head;    //反转链表      head-&gt;next = NULL;    //将指针置NULL      return newhead;    //newhead始终指向新链表的头&#125;</code></pre></li></ul><h4 id="循环链表的操作"><a href="#循环链表的操作" class="headerlink" title="循环链表的操作"></a>循环链表的操作</h4><ul><li><p>逆置循环链表</p><ul><li>只交换节点中的数据成员 data，其他的前后指针不变</li></ul><pre><code class="cpp">void Reverse () &#123;   LinkList * begin = _head;   LinkList * end = _tail;   while (begin != end &amp;&amp; begin-&gt;_prev != end)   &#123;      swap(begin-&gt;_data, end-&gt;_data);      begin = begin-&gt;_next;      end = end-&gt;_prev;   &#125; &#125; </code></pre></li><li><p>删除顺序表中值在 min 和 max 之间的数</p><ul><li>对顺序表进行遍历查找介于 min 与 max 之间的数然后进行删除</li></ul><pre><code class="cpp">void Delete(Seqlist *L,int min,int max)&#123;  int i=0,n=0;  while(i&lt;L-&gt;length)   &#123;        if(L-&gt;elem[i]&gt;=min &amp;&amp; L-&gt;elem[i]&lt;=max)            n++;         else            L-&gt;elem[i-n]=L-&gt;elem[i];        i++;    &#125;  L-&gt;length -= n;   if(L-&gt;length==0)  printf(&quot;the sqlist ie empty/n&quot;); &#125; </code></pre></li></ul><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="栈和队列的基本概念"><a href="#栈和队列的基本概念" class="headerlink" title="栈和队列的基本概念"></a>栈和队列的基本概念</h4><ul><li>栈是一种只能在一端进行插入或删除操作的线性表（FILO）<ul><li>栈顶（Top）动态变化，栈底固定不变</li></ul></li><li>队列为仅允许在表的一端进行插入，在表的另一端进行删除的线性表（FIFO）<ul><li>队头（Front）可进行删除，队尾（Rear）可进行插入</li></ul></li></ul><h4 id="栈和队列的结构体定义"><a href="#栈和队列的结构体定义" class="headerlink" title="栈和队列的结构体定义"></a>栈和队列的结构体定义</h4><ul><li><p>顺序栈的定义</p><pre><code class="cpp">typedef struct&#123;  int data[maxSize];  int top;&#125; SqStack;</code></pre></li><li><p>链栈结点的定义</p><pre><code class="cpp">typedef struct LNode&#123;  int data;  struct LNode *next;&#125;  LNode;</code></pre></li><li><p>顺序队列的定义</p><pre><code class="cpp">typedef struct&#123;  int data[maxSize];  int front;  int rear;&#125; SqQueue;</code></pre></li><li><p>链队结点的定义</p><pre><code class="cpp">typedef struct QNode&#123;  int data;  struct QNode *next;&#125; QNode;</code></pre></li><li><p>链队类型的定义</p><pre><code class="cpp">typedef struct&#123;  QNode *front;  QNode *rear;&#125; LiQueue;</code></pre></li></ul><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ul><li><p>栈空状态：<code>st.top==-1</code></p></li><li><p>栈满状态：<code>st.top==maxSize-1</code></p></li><li><p>非法状态：栈满后继续入站上溢，栈空继续出栈下溢</p></li><li><p>定义一个栈并初始化：<code>int stack[maxSize]; int top==-1</code></p></li><li><p>进栈：先移动指针再进栈</p><ul><li><code>stack[++top]=x</code>;</li></ul><pre><code class="cpp">int push(SqStack &amp;st,int x)&#123;  if(st.top==maxSize-1)    return 0;  ++(st.top);  st.data[st.top]=x;  return 1;&#125;</code></pre></li><li><p>出栈：先取出元素，再移动指针</p><ul><li><code>x=stack[top--];</code></li></ul><pre><code class="cpp">int pop(SqStack &amp;st,int &amp;x)&#123;  if(st.stop==-1)    return 0;    //栈空不能出栈  x = st.data[st.top];  --(st.top);  return 1;&#125;</code></pre></li></ul><h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><ul><li>栈空状态：<code>lst-&gt;next==NULL</code></li><li>不存在栈满状态</li><li>进栈：头插法建立链表中的插入操作<ul><li><code>p-&gt;next=lst-&gt;next; lst-&gt;next=p;</code></li></ul></li><li>出栈：单链表的删除操作，出栈元素保存在 x 中<ul><li><code>p-lst-&gt;next; x=p-&gt;data; lst-&gt;next=p-&gt;next; free(p);</code></li></ul></li></ul><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ul><li><p>解决假溢出：<code>front=(front+1)%maxSize</code></p></li><li><p>队空状态：<code>qu.rear==qu.front</code></p></li><li><p>队满状态：<code>(qu.rear+1)%maxSize==qu.front</code></p></li><li><p>初始化队列：队首和队尾指针重合，并且指向0</p><ul><li><code>qu.front=qu.rear=0;</code></li></ul></li><li><p>进队算法</p><pre><code class="cpp">int enQueue(SqQueue qu)&#123;  if((qu.rear+1)%maxSize==qu.front)    return 0  qu.rear=(qu.rear+1)%maxSize;    //先移动指针  qu.data[qu.rear]=x;    //再存入元素  return 1;&#125;</code></pre></li><li><p>出队算法</p><pre><code class="cpp">int denQueue(SqQueue &amp;qu, int &amp;x)&#123;  if(qu.rear==qu.front)    return 0;  qu.front=((qu.front+1)%maxSize)    //先移动指针  x=qu.data[qu.front];  return 1;&#125;</code></pre></li></ul><h4 id="链队（尽量避免使用）"><a href="#链队（尽量避免使用）" class="headerlink" title="链队（尽量避免使用）"></a>链队（尽量避免使用）</h4><ul><li><p>队空状态：<code>lqu-&gt;rear==NULL</code> 或者 <code>lqu-&gt;front==NULL</code></p></li><li><p>不存在队满状态</p></li><li><p>初始化链队</p><pre><code class="cpp">void initQueue(LiQueue *&amp;lqu)&#123;  lqu=(LiQueue*)malloc(sizeof(LiQueue));  lqu-&gt;front=lqu-&gt;rear=NULL;&#125;</code></pre></li><li><p>进队操作：<code>lqu-&gt;rear-&gt;next=p;  lqu-&gt;rear=p;</code></p></li><li><p>出队操作：<code>p=lqu-&gt;front; lqu-&gt;front=p-&gt;next; x=p-&gt;data; free(p);</code></p></li></ul><h4 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h4><ul><li><p>入栈：push(x)，除栈顶元素：pop() – 移，获取栈顶元素：top() ，返回栈是否为空：empty()</p><pre><code class="cpp">// Push element x onto stack.void push(int x)&#123;  q1.push(x);&#125;// Removes the element on top of the stack and returns thatint pop()&#123;  int length1 =  q1size();  for(int i-0; i&lt; length1- 1; i++)  &#123;    q2.push(q1.front());    q1. pop();  &#125;  data= q1.front()    int length2= q2size():  for(int j=0;j&lt; length2; j++)  &#123;    q1.push(q2.front());    q2.pop();  &#125;  return data;&#125;// Get the top element. *int top()    int length1 = q1.size();    int data;    for (int i=0; i&lt; length1- 1; i++)  &#123;    q2.push(q1.front());    q1.pop();  &#125;    data= q1.front();    return data;&#125;// Returns whether the stack isemptybool empty()&#123;  if(q1.empty()&amp;&amp;q2.empty())    return true;  else        return false;&#125;</code></pre></li></ul><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="串数据类型的定义"><a href="#串数据类型的定义" class="headerlink" title="串数据类型的定义"></a>串数据类型的定义</h4><ul><li><p>串是限定了元素为字符的线性表，<code>char str[]=&quot;abcdef&quot;;</code></p></li><li><p>空格串不是空串</p></li><li><p>串赋值：对数组中的每个元素进行逐一赋值操作</p><ul><li><code>strassign(str,&quot;cur input&quot;);</code></li></ul></li><li><p>取串长度</p><ul><li><code>return str.length;</code></li></ul></li><li><p>串比较操作</p><pre><code class="cpp">int strcompare(Str s1, Str s2)&#123;  for(int i=0;i&lt;s1.length&amp;&amp;i&lt;s2.length;++i)      if(s1.ch[i]!=s2.ch[i])      return s1.ch[i]-s2.ch[i];  return s1.length - s2.length;&#125;</code></pre></li></ul><h4 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h4><ul><li><p>KMP 算法</p><pre><code class="cpp">void getnext(str substr, int next[])&#123;  int i=1, j=0;    next[1]=0;    while (i&lt;substr.length)  &#123;    if (j==0||substr.ch[i]==substr.ch[j])    &#123;      ++i, ++j;      next[i]=j;    &#125;    else      j=next[j];  &#125;&#125;int KMP (Str str, Str substr, int next[])&#123;   int i=j=1;  while(i&lt;=str.length&amp;&amp;j&lt;=substr.length)  &#123;     if (j==0||str.ch[i]==substr.ch[j])      ++i, ++j;    else      j=next[ j];    if (j&gt;substr.length)       return i-substr.length;    else      return 0;  &#125;&#125;</code></pre><h3 id="矩阵与广义表"><a href="#矩阵与广义表" class="headerlink" title="矩阵与广义表"></a>矩阵与广义表</h3><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><ul><li><p>矩阵的转置</p><pre><code class="cpp">void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            B[j][i] = A[i][j];&#125;</code></pre></li><li><p>矩阵相加</p><pre><code class="cpp">void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            C[i][j] = A[i][j] + B[i][j];&#125;</code></pre></li><li><p>矩阵相乘</p><pre><code class="cpp">void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; k;++j)        &#123;            C[i][j] = 0;            for int(h = 0;h &lt; n;++h)                C[i][j] += A[i][j] * B[i][j];        &#125;&#125;</code></pre></li><li><p>相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵</p><ul><li>对称矩阵、三角阵、对角矩阵</li></ul></li></ul><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><ul><li>表元素可以是原子或者广义表的一种线性表的扩展结构</li><li>广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数</li><li>当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</li><li>原子结点有两个域：标志域和数据域</li><li>广义表结点有三个域：标志域，头指针域与尾指针域</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><ul><li>树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成<ul><li>结点不仅包含数据元素，并且包含指向子树的分支</li><li>结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值</li><li>树的高度是树中结点的最大层次，根结点的高度为树的高度</li></ul></li><li>树的双亲存储结构：<code>int tree[maxSize]</code></li><li>树的链式存储结构<ul><li>邻接表：孩子存储结构</li><li>孩子兄弟存储结构</li></ul></li></ul><h4 id="二叉树的概念和性质"><a href="#二叉树的概念和性质" class="headerlink" title="二叉树的概念和性质"></a>二叉树的概念和性质</h4><ul><li><p>二叉树的定义</p><ul><li>每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2</li><li>子树有左右顺序之分，不能颠倒</li></ul></li><li><p>满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层</p></li><li><p>完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的</p></li><li><p>二叉树的主要性质</p><ol><li><p>非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$</p></li><li><p>在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$</p></li><li><p>二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p><ul><li>若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）</li><li>若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点</li><li>若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点</li></ul></li><li><p>Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac{C_{2n}^{n}}{n+1}$  棵不同的二叉树</p></li><li><p>在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$</p></li></ol></li><li><p>二叉树的顺序存储结构最适用于完全二叉树</p></li><li><p>二叉树的链式存储结构</p><pre><code class="cpp">typedef struct BTNode&#123;    char  data;    //数据域    struct BTNoode* lchild;    struct BTNode* rchild;&#125; BTNode;</code></pre></li></ul><h4 id="二叉树的遍历算法"><a href="#二叉树的遍历算法" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><ul><li><p>先序遍历</p><pre><code class="cpp">/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123;    StackNode* S;   //定义一个栈指针    BitNode* p;   //工作指针    S = NULL;    p = root;    S = InitStack(S);   //初始化栈    if (NULL == p)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;     //end if    while (p || !StackEmpty(S))    &#123;     //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p);    //p 所指节点入栈            printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）            p = p-&gt;lchild ;     //指向 p 的左孩子         &#125;//end if        else        &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树            StackPop(S, p);            p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈        &#125;    //end else    &#125;    //end while    free(S);&#125;    //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123;    if (root)    &#123;        printf(&quot;%d &quot;, root-&gt;data);        preOrder(root-&gt;lchild);        preOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>中序遍历</p><pre><code class="cpp">/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123;    StackNode* S; //定义一个栈指针    BitNode* p; //工作指针    S = NULL;    p = root;    S = InitStack(S); //初始化栈    if (NULL == p) &#123; //如果是空树        printf(&quot;树为空！\n&quot;) ;        return;    &#125;//end if    while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p); //将节点入栈            p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子        &#125;//end if        else        &#123;            StackPop(S, p); //p 左子树为空则出栈            printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点            p = p-&gt;rchild; //向右子树移动        &#125;//end else    &#125;//end while    free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123;    if (root)    &#123;        inOrder(root-&gt;lchild);        printf(&quot;%d &quot;, root-&gt;data);        inOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>后序遍历</p><pre><code class="CPP">/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123;    StackNode* S; BiTNode* cur, * pre;//定义一个栈指针    S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点    if (NULL == root)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;//end if    pre = NULL; cur = NULL;    StackPush(S, T); //根节点入栈    while (!StackEmpty(S))    &#123; //若栈非空        cur = NULL;        StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/        if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||            (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))        &#123;            printf(&quot;%c &quot;, cur-&gt;data);            pre = cur;            StackPop(S, cur);        &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。        else        &#123;            if (cur-&gt;rchild != NULL)                StackPush(S, cur-&gt;rchild);            if (cur-&gt;lchild != NULL)                StackPush(S, cur-&gt;lchild);        &#125;//end else    &#125;//end while    free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123;    if (root)    &#123;        postOrder(root-&gt;lchild);        postOrder(root-&gt;rchild);        printf(&quot;%d &quot;, root-&gt;data);    &#125; &#125;</code></pre></li><li><p>层次遍历：自上而下，自左向右</p><ul><li>首先，将二叉树的祖先节点入队列</li><li>然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队</li></ul><pre><code class="cpp">void LayerOrder(BiTreeNode* head)&#123;    LQueue Q;    Initiate_Queue(&amp;Q);    BiTreeNode* p;    if (head != NULL) AppendQueue(&amp;Q, head);    while (QueueNotEmpty(&amp;Q)) &#123;        p = QueueDelete(&amp;Q);        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);        if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);    &#125;&#125; </code></pre></li></ul><h4 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ul><li><p>哈夫曼树又叫做最优二叉树，它的特点是带权路径最短</p><ul><li>树的路径长度是指从根到每个节点的路径长度之和</li><li>带权路径长度是从该节点到根节之间的路径长度乘以结点的权值</li><li>树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和</li></ul></li><li><p>求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度</p><pre><code class="cpp">ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0  &#123;      if (FBT == NULL) //空树返回0          return 0;      else      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点              return FBT-&gt;data * len;          else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增              return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);      &#125;  &#125;  </code></pre></li><li><p>哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针  </p><pre><code class="cpp">struct BTreeNode* CreateHuffman(ElemType a[], int n)  &#123;      int i, j;      struct BTreeNode **b, *q;      b = malloc(n*sizeof(struct BTreeNode));      for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点      &#123;          b[i] = malloc(sizeof(struct BTreeNode));          b[i]-&gt;data = a[i];          b[i]-&gt;left = b[i]-&gt;right = NULL;      &#125;      for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树      &#123;          //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标          int k1 = -1, k2;          for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵          &#123;              if (b[j] != NULL &amp;&amp; k1 == -1)              &#123;                  k1 = j;                  continue;              &#125;              if (b[j] != NULL)              &#123;                  k2 = j;                  break;              &#125;          &#125;          for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小          &#123;              if (b[j] != NULL)              &#123;                  if (b[j]-&gt;data &lt; b[k1]-&gt;data)                  &#123;                      k2 = k1;                      k1 = j;                  &#125;                  else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                      k2 = j;              &#125;          &#125;          //由最小权值树和次最小权值树建立一棵新树，q指向树根结点          q = malloc(sizeof(struct BTreeNode));          q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;          q-&gt;left = b[k1];          q-&gt;right = b[k2];          b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置          b[k2] = NULL;//k2位置为空      &#125;      free(b); //删除动态建立的数组b      return q; //返回整个哈夫曼树的树根指针  &#125;  </code></pre></li><li><p>哈夫曼编码</p><ul><li>每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树</li><li>将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码</li><li>从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码</li><li>哈夫曼编码产生的是最短前缀码</li></ul><pre><code class="cpp">void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0  &#123;      static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一      if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)          &#123;              int i;              printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);              for (i = 0; i &lt; len; i++)                  printf(&quot;%d&quot;, a[i]);              printf(&quot;\n&quot;);          &#125;          else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a          &#123;   //的对应元素中，向下深入一层时len值增1              a[len] = 0;              HuffManCoding(FBT-&gt;left, len + 1);              a[len] = 1;              HuffManCoding(FBT-&gt;right, len + 1);          &#125;      &#125;  &#125;  </code></pre></li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><ul><li>图由结点的有穷集合的 V 和边的集合  E 组成（<code>G(V,E)</code>）</li><li>图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示</li><li>路径长度：路径上边或者弧的数目</li><li>顶点的度：顶点关联边的数目<ul><li>有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度</li><li>在有向图中，顶点的度就是两者之和</li><li>在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量</li><li>在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量</li></ul></li></ul><h4 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h4><ul><li><p>邻接矩阵</p><ul><li>图的顺序存储结构</li><li>用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息</li><li>无向图中邻接矩阵是个对称矩阵</li><li>0表示无边，1表示有边</li><li>顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 </li><li>邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费</li></ul><pre><code class="cpp">typedef struct&#123;  int no;  char info;&#125; VertexType;typedef struct&#123;  int edges[maxSize][maxSize];    //有权图中int改为float  int n,e;    //顶点数和边数  VertexType vex[maxSize];    //存放结点信息&#125; MGragh;</code></pre></li><li><p>邻接表</p><ul><li>数组和链表相结合的存储方法，图的链式存储结构</li><li>图中顶点用一个一维数组存储</li><li>图中每个顶点 $V_i$ 的所有邻接点构成一个线性表</li><li>顶点表的各个结点由 data 和 Firstedge 两个域表示<ul><li>data 是数据域，存储顶点信息</li><li>firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点</li></ul></li><li>边表结点由 adjvex 和 next 两个域组成<ul><li>adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标</li><li>next 存储边表中下一个结点指针</li></ul></li><li>有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表</li></ul><pre><code class="cpp">typedef struct ArcNode&#123;    int adnex;    //该边所指向的结点的位置    struct ArcNode * nextarc;    //指向下一条边的指针    int info;    //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123;    char data;    //顶点信息    ArcNode* firstarc;    //指向第一条边的指针&#125;VNode;typedef struct&#123;    VNode adjlist[maxSize];    //邻接表    int n, e;    //顶点数和边数&#125; AGraph;    //图的邻接表类型</code></pre></li><li><p>十字链表</p><ul><li>在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表</li><li>定点表<ul><li>firstin：入边表头指针，指向顶点入边表的第一个结点</li><li>firstout：出边表头指针，指向顶点出边表第一个结点</li></ul></li><li>边表<ul><li>tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标</li><li>headlink 入边表指针域，指向终点相同的下一条边</li><li>taillink 是指边表指针域，指向起点相同的下一条边</li></ul></li></ul></li><li><p>邻接多重表</p><ul><li>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标</li><li>ilink 指向依附项点 ivex 的下一条边</li><li>jlink 指向依附顶点 jvex 的下一条边</li></ul></li></ul></li></ul><h4 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h4><ul><li><p>深度优先遍历（DFS，Depth First Search） </p><ul><li>首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了</li><li>若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问</li><li>深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123;    for (v = 0;v &lt; G.vexnum;++v)        visited[v] = false;    //初始化标记数组    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历            DFS(G, v);&#125;void DFS(Graph G, int v)&#123;    visit(v);    visited[v] = true; //定义为已访问    for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))        if (!visited[w])            DFS(G, w);&#125;</code></pre></li><li><p>广度优先遍历（BFS，Breadth First Search）</p><ul><li>首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点</li><li>然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完</li><li>BFS 遍历的方式类似于树的层次遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组void BFSTraverse(Graph G)&#123;    for (i = 0;i &lt; G.vexnum;++i)        visited[v] = false;    //初始化标记数组    InitQueue(Q);    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历            BFS(G, v);&#125;void BFS(Graph G, int v)&#123;    visit(v);    visited[v] = true;    //定义为已访问    while (!isEmpty(Q))    &#123;        DeQueue(Q, v);        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])            &#123;                visit(w);                visited[w] = true;                EnQueue(Q, w)            &#125;    //if    &#125;    //while&#125;</code></pre><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4></li><li><p>Prim 算法</p><ul><li>从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树</li><li>然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树</li><li>以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树</li></ul><pre><code class="cpp">void prim (G,T)&#123;    T = ∅;    U = &#123;w&#125;;    while ((V - U) != ∅  )    &#123; //若图中不含全部顶点        设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;        T = T∪ (u，v); //边归入树        U = U∪ &#123;v&#125;;     //顶点归入树    &#125;&#125;</code></pre></li><li><p>Kruskal 算法</p><ul><li>将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止</li><li>Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图</li><li>普里姆算法和克鲁斯卡尔算法都是针对于无向图的</li><li>判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树<ul><li>通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合</li><li>通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合</li></ul></li></ul><pre><code class="cpp">void kruskal（V，T）&#123;    T = V;    //初始化树，仅含顶点    numS = n;    //不连分量的数目    while (numS &gt; 1)    &#123;        从 E 中取出权值最小的边（v,u）;        if（v 和 u 属于 T 中不同的连通分量）        &#123;            T = T∪（u，v）;//将此边加入到生成树中；            numS--; //不连通的分量减少 1        &#125;    &#125;&#125;</code></pre><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4></li><li><p>Dijkstra 算法</p><ul><li>通常用于求图中某一顶点到其余各顶点的最短路径</li><li>设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组</li><li>第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）</li><li>第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度</li></ul></li><li><p>Dijkstra 算法步骤</p><ol><li>初始时，S 只包含源点，即 S＝{v}，v 的距离为 0，U 包含除 v 外的其他顶点，即:U={其 余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$</li><li>从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）</li><li>以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离</li><li>重复步骤 b 和 c 直到所有顶点都包含在 S 中</li></ol><pre><code class="cpp">void Dijkstra(int v0)&#123;  　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中      int n=MAXNUM;  　　for(int i=1; i&lt;=n; ++i) 　　 &#123;      　　dist[i] = A[v0][i];      　　S[i] = false;                                // 初始都未用过该点      　　if(dist[i] == MAXINT)                　　prev[i] = -1; 　　     else             　　prev[i] = v0;   　　&#125;   　 dist[v0] = 0;   　 S[v0] = true; 　　 　　 for(int i=2; i&lt;=n; i++) 　　 &#123;       　　int mindist = MAXINT;       　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值      　　 for(int j=1; j&lt;=n; ++j)      　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)      　　    &#123;         　　       u = j;                             // u保存当前邻接点中距离最小的点的号码          　 　      mindist = dist[j];       　　   &#125;       　　S[u] = true;        　　for(int j=1; j&lt;=n; j++)       　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)       　　    &#123;           　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径             　    　&#123;                   　　dist[j] = dist[u] + A[u][j];    //更新dist                    　　prev[j] = u;                    //记录前驱顶点             　　    &#125;        　    　&#125;   　　&#125;&#125;</code></pre></li><li><p>Floyd 算法</p><ul><li>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包</li><li>Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$</li><li>Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离</li><li>对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离</li></ul></li><li><p>Floyd 算法步骤</p><ul><li>从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它</li></ul><pre><code class="cpp">for (k = 1;k &lt;= n;k++)    for (i = 1;i &lt;= n;i++)        for (j = 1;j &lt;= n;j++)            if (a[i][j] &gt; a[i][k] + a[k][j])                a[i][j] = a[i][k] + a[k][j];</code></pre><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4></li><li><p>对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边</p><ol><li>从 DAG 图中选择一个没有前驱的节点并输出</li><li>从图中删除该节点和所有以它为起点的有向边</li><li>重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止</li></ol><pre><code class="cpp">bool topologicalSort(Graph GL)&#123;    EdgeNode* e;    int top = 0; //用于栈指针下标     int count = 0; // 用于统计输出顶点的个数     int* stack; // 建栈将入度为 0 的顶点入栈     stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));    for (i = 0; i &lt; GL-&gt;numVertexes; i++)        if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈             stack[++top] = i;    while (top != 0)    &#123;        gettop = stack[top--];        printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);        count++; //输出 i 号顶点，并计数         for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;            k = e-&gt;adjvex;            if (!(--GL-&gt;adjList[k].in))                //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                 stack[++top] = k;        &#125;    &#125;    if (count &lt; GL-&gt;numVertexes) return false;    else return true;&#125;</code></pre><blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构<a href="https://www.icourse163.org/course/ZJU-93001">国家精品课</a>，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的<a href="https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">代码</a>，可供参考。其他部分笔记详见<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A">数据结构（上）</a>和<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B">数据结构（下）</a></p></blockquote><!--more--><h3 id="矩阵与广义表-1"><a href="#矩阵与广义表-1" class="headerlink" title="矩阵与广义表"></a>矩阵与广义表</h3><h4 id="矩阵-1"><a href="#矩阵-1" class="headerlink" title="矩阵"></a>矩阵</h4><ul><li><p>矩阵的转置</p><pre><code class="cpp">void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            B[j][i] = A[i][j];&#125;</code></pre></li><li><p>矩阵相加</p><pre><code class="cpp">void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            C[i][j] = A[i][j] + B[i][j];&#125;</code></pre></li><li><p>矩阵相乘</p><pre><code class="cpp">void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; k;++j)        &#123;            C[i][j] = 0;            for int(h = 0;h &lt; n;++h)                C[i][j] += A[i][j] * B[i][j];        &#125;&#125;</code></pre></li><li><p>相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵</p><ul><li>对称矩阵、三角阵、对角矩阵</li></ul></li></ul><h4 id="广义表-1"><a href="#广义表-1" class="headerlink" title="广义表"></a>广义表</h4><ul><li>表元素可以是原子或者广义表的一种线性表的扩展结构</li><li>广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数</li><li>当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</li><li>原子结点有两个域：标志域和数据域</li><li>广义表结点有三个域：标志域，头指针域与尾指针域</li></ul><h3 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念-1"><a href="#树的基本概念-1" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><ul><li>树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成<ul><li>结点不仅包含数据元素，并且包含指向子树的分支</li><li>结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值</li><li>树的高度是树中结点的最大层次，根结点的高度为树的高度</li></ul></li><li>树的双亲存储结构：<code>int tree[maxSize]</code></li><li>树的链式存储结构<ul><li>邻接表：孩子存储结构</li><li>孩子兄弟存储结构</li></ul></li></ul><h4 id="二叉树的概念和性质-1"><a href="#二叉树的概念和性质-1" class="headerlink" title="二叉树的概念和性质"></a>二叉树的概念和性质</h4><ul><li><p>二叉树的定义</p><ul><li>每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2</li><li>子树有左右顺序之分，不能颠倒</li></ul></li><li><p>满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层</p></li><li><p>完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的</p></li><li><p>二叉树的主要性质</p><ol><li><p>非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$</p></li><li><p>在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$</p></li><li><p>二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p><ul><li>若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）</li><li>若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点</li><li>若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点</li></ul></li><li><p>Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac{C_{2n}^{n}}{n+1}$  棵不同的二叉树</p></li><li><p>在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$</p></li></ol></li><li><p>二叉树的顺序存储结构最适用于完全二叉树</p></li><li><p>二叉树的链式存储结构</p><pre><code class="cpp">typedef struct BTNode&#123;    char  data;    //数据域    struct BTNoode* lchild;    struct BTNode* rchild;&#125; BTNode;</code></pre></li></ul><h4 id="二叉树的遍历算法-1"><a href="#二叉树的遍历算法-1" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><ul><li><p>先序遍历</p><pre><code class="cpp">/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123;    StackNode* S;   //定义一个栈指针    BitNode* p;   //工作指针    S = NULL;    p = root;    S = InitStack(S);   //初始化栈    if (NULL == p)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;     //end if    while (p || !StackEmpty(S))    &#123;     //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p);    //p 所指节点入栈            printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）            p = p-&gt;lchild ;     //指向 p 的左孩子         &#125;//end if        else        &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树            StackPop(S, p);            p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈        &#125;    //end else    &#125;    //end while    free(S);&#125;    //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123;    if (root)    &#123;        printf(&quot;%d &quot;, root-&gt;data);        preOrder(root-&gt;lchild);        preOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>中序遍历</p><pre><code class="cpp">/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123;    StackNode* S; //定义一个栈指针    BitNode* p; //工作指针    S = NULL;    p = root;    S = InitStack(S); //初始化栈    if (NULL == p) &#123; //如果是空树        printf(&quot;树为空！\n&quot;) ;        return;    &#125;//end if    while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p); //将节点入栈            p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子        &#125;//end if        else        &#123;            StackPop(S, p); //p 左子树为空则出栈            printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点            p = p-&gt;rchild; //向右子树移动        &#125;//end else    &#125;//end while    free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123;    if (root)    &#123;        inOrder(root-&gt;lchild);        printf(&quot;%d &quot;, root-&gt;data);        inOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>后序遍历</p><pre><code class="CPP">/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123;    StackNode* S; BiTNode* cur, * pre;//定义一个栈指针    S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点    if (NULL == root)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;//end if    pre = NULL; cur = NULL;    StackPush(S, T); //根节点入栈    while (!StackEmpty(S))    &#123; //若栈非空        cur = NULL;        StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/        if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||            (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))        &#123;            printf(&quot;%c &quot;, cur-&gt;data);            pre = cur;            StackPop(S, cur);        &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。        else        &#123;            if (cur-&gt;rchild != NULL)                StackPush(S, cur-&gt;rchild);            if (cur-&gt;lchild != NULL)                StackPush(S, cur-&gt;lchild);        &#125;//end else    &#125;//end while    free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123;    if (root)    &#123;        postOrder(root-&gt;lchild);        postOrder(root-&gt;rchild);        printf(&quot;%d &quot;, root-&gt;data);    &#125; &#125;</code></pre></li><li><p>层次遍历：自上而下，自左向右</p><ul><li>首先，将二叉树的祖先节点入队列</li><li>然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队</li></ul><pre><code class="cpp">void LayerOrder(BiTreeNode* head)&#123;    LQueue Q;    Initiate_Queue(&amp;Q);    BiTreeNode* p;    if (head != NULL) AppendQueue(&amp;Q, head);    while (QueueNotEmpty(&amp;Q)) &#123;        p = QueueDelete(&amp;Q);        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);        if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);    &#125;&#125; </code></pre></li></ul><h4 id="哈夫曼树和哈夫曼编码-1"><a href="#哈夫曼树和哈夫曼编码-1" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ul><li><p>哈夫曼树又叫做最优二叉树，它的特点是带权路径最短</p><ul><li>树的路径长度是指从根到每个节点的路径长度之和</li><li>带权路径长度是从该节点到根节之间的路径长度乘以结点的权值</li><li>树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和</li></ul></li><li><p>求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度</p><pre><code class="cpp">ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0  &#123;      if (FBT == NULL) //空树返回0          return 0;      else      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点              return FBT-&gt;data * len;          else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增              return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);      &#125;  &#125;  </code></pre></li><li><p>哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针  </p><pre><code class="cpp">struct BTreeNode* CreateHuffman(ElemType a[], int n)  &#123;      int i, j;      struct BTreeNode **b, *q;      b = malloc(n*sizeof(struct BTreeNode));      for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点      &#123;          b[i] = malloc(sizeof(struct BTreeNode));          b[i]-&gt;data = a[i];          b[i]-&gt;left = b[i]-&gt;right = NULL;      &#125;      for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树      &#123;          //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标          int k1 = -1, k2;          for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵          &#123;              if (b[j] != NULL &amp;&amp; k1 == -1)              &#123;                  k1 = j;                  continue;              &#125;              if (b[j] != NULL)              &#123;                  k2 = j;                  break;              &#125;          &#125;          for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小          &#123;              if (b[j] != NULL)              &#123;                  if (b[j]-&gt;data &lt; b[k1]-&gt;data)                  &#123;                      k2 = k1;                      k1 = j;                  &#125;                  else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                      k2 = j;              &#125;          &#125;          //由最小权值树和次最小权值树建立一棵新树，q指向树根结点          q = malloc(sizeof(struct BTreeNode));          q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;          q-&gt;left = b[k1];          q-&gt;right = b[k2];          b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置          b[k2] = NULL;//k2位置为空      &#125;      free(b); //删除动态建立的数组b      return q; //返回整个哈夫曼树的树根指针  &#125;  </code></pre></li><li><p>哈夫曼编码</p><ul><li>每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树</li><li>将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码</li><li>从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码</li><li>哈夫曼编码产生的是最短前缀码</li></ul><pre><code class="cpp">void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0  &#123;      static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一      if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)          &#123;              int i;              printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);              for (i = 0; i &lt; len; i++)                  printf(&quot;%d&quot;, a[i]);              printf(&quot;\n&quot;);          &#125;          else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a          &#123;   //的对应元素中，向下深入一层时len值增1              a[len] = 0;              HuffManCoding(FBT-&gt;left, len + 1);              a[len] = 1;              HuffManCoding(FBT-&gt;right, len + 1);          &#125;      &#125;  &#125;  </code></pre></li></ul><h3 id="图-1"><a href="#图-1" class="headerlink" title="图"></a>图</h3><h4 id="图的基本概念-1"><a href="#图的基本概念-1" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><ul><li>图由结点的有穷集合的 V 和边的集合  E 组成（<code>G(V,E)</code>）</li><li>图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示</li><li>路径长度：路径上边或者弧的数目</li><li>顶点的度：顶点关联边的数目<ul><li>有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度</li><li>在有向图中，顶点的度就是两者之和</li><li>在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量</li><li>在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量</li></ul></li></ul><h4 id="图的存储结构-1"><a href="#图的存储结构-1" class="headerlink" title="图的存储结构"></a>图的存储结构</h4><ul><li><p>邻接矩阵</p><ul><li>图的顺序存储结构</li><li>用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息</li><li>无向图中邻接矩阵是个对称矩阵</li><li>0表示无边，1表示有边</li><li>顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 </li><li>邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费</li></ul><pre><code class="cpp">typedef struct&#123;  int no;  char info;&#125; VertexType;typedef struct&#123;  int edges[maxSize][maxSize];    //有权图中int改为float  int n,e;    //顶点数和边数  VertexType vex[maxSize];    //存放结点信息&#125; MGragh;</code></pre></li><li><p>邻接表</p><ul><li>数组和链表相结合的存储方法，图的链式存储结构</li><li>图中顶点用一个一维数组存储</li><li>图中每个顶点 $V_i$ 的所有邻接点构成一个线性表</li><li>顶点表的各个结点由 data 和 Firstedge 两个域表示<ul><li>data 是数据域，存储顶点信息</li><li>firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点</li></ul></li><li>边表结点由 adjvex 和 next 两个域组成<ul><li>adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标</li><li>next 存储边表中下一个结点指针</li></ul></li><li>有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表</li></ul><pre><code class="cpp">typedef struct ArcNode&#123;    int adnex;    //该边所指向的结点的位置    struct ArcNode * nextarc;    //指向下一条边的指针    int info;    //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123;    char data;    //顶点信息    ArcNode* firstarc;    //指向第一条边的指针&#125;VNode;typedef struct&#123;    VNode adjlist[maxSize];    //邻接表    int n, e;    //顶点数和边数&#125; AGraph;    //图的邻接表类型</code></pre></li><li><p>十字链表</p><ul><li>在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表</li><li>定点表<ul><li>firstin：入边表头指针，指向顶点入边表的第一个结点</li><li>firstout：出边表头指针，指向顶点出边表第一个结点</li></ul></li><li>边表<ul><li>tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标</li><li>headlink 入边表指针域，指向终点相同的下一条边</li><li>taillink 是指边表指针域，指向起点相同的下一条边</li></ul></li></ul></li><li><p>邻接多重表</p><ul><li>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标</li><li>ilink 指向依附项点 ivex 的下一条边</li><li>jlink 指向依附顶点 jvex 的下一条边</li></ul></li></ul></li></ul><pre><code>#### 图的遍历算法- 深度优先遍历（DFS，Depth First Search）   - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了  - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问  - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历  ```cpp  bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问  void DFSTraverse(Graph G)  &#123;      for (v = 0;v &lt; G.vexnum;++v)          visited[v] = false;    //初始化标记数组      for (v = 0;v &lt; G.vexnum;++v)          if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历              DFS(G, v);  &#125;  void DFS(Graph G, int v)  &#123;      visit(v);      visited[v] = true; //定义为已访问      for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))          if (!visited[w])              DFS(G, w);  &#125;  ```- 广度优先遍历（BFS，Breadth First Search）  - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点  - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完  - BFS 遍历的方式类似于树的层次遍历  ```cpp  bool visited[Max_Vex];    //定义访问标记数组  void BFSTraverse(Graph G)  &#123;      for (i = 0;i &lt; G.vexnum;++i)          visited[v] = false;    //初始化标记数组      InitQueue(Q);      for (v = 0;v &lt; G.vexnum;++v)          if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历              BFS(G, v);  &#125;  void BFS(Graph G, int v)  &#123;      visit(v);      visited[v] = true;    //定义为已访问      while (!isEmpty(Q))      &#123;          DeQueue(Q, v);          for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))              if (!visited[w])              &#123;                  visit(w);                  visited[w] = true;                  EnQueue(Q, w)              &#125;    //if      &#125;    //while  &#125;  ```#### 最小生成树- Prim 算法  - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树  - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树  - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树  ```cpp  void prim (G,T)  &#123;      T = ∅;      U = &#123;w&#125;;      while ((V - U) != ∅  )      &#123; //若图中不含全部顶点          设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;          T = T∪ (u，v); //边归入树          U = U∪ &#123;v&#125;;     //顶点归入树      &#125;  &#125;  ```- Kruskal 算法  - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止  - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图  - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的  - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树    - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合    - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合  ```cpp  void kruskal（V，T）  &#123;      T = V;    //初始化树，仅含顶点      numS = n;    //不连分量的数目      while (numS &gt; 1)      &#123;          从 E 中取出权值最小的边（v,u）;          if（v 和 u 属于 T 中不同的连通分量）          &#123;              T = T∪（u，v）;//将此边加入到生成树中；              numS--; //不连通的分量减少 1          &#125;      &#125;  &#125;  ```#### 最短路径- Dijkstra 算法  - 通常用于求图中某一顶点到其余各顶点的最短路径  - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组  - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）  - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度- Dijkstra 算法步骤  1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$  2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）  3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离  4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中  ```cpp  void Dijkstra(int v0)  &#123;    　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中        int n=MAXNUM;    　　for(int i=1; i&lt;=n; ++i)   　　 &#123;        　　dist[i] = A[v0][i];        　　S[i] = false;                                // 初始都未用过该点        　　if(dist[i] == MAXINT)                  　　prev[i] = -1;   　　     else               　　prev[i] = v0;     　　&#125;     　 dist[v0] = 0;     　 S[v0] = true; 　　   　　 for(int i=2; i&lt;=n; i++)   　　 &#123;         　　int mindist = MAXINT;         　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值        　　 for(int j=1; j&lt;=n; ++j)        　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)        　　    &#123;           　　       u = j;                             // u保存当前邻接点中距离最小的点的号码            　 　      mindist = dist[j];         　　   &#125;         　　S[u] = true;          　　for(int j=1; j&lt;=n; j++)         　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)         　　    &#123;             　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径               　    　&#123;                     　　dist[j] = dist[u] + A[u][j];    //更新dist                      　　prev[j] = u;                    //记录前驱顶点               　　    &#125;          　    　&#125;     　　&#125;  &#125;  ```- Floyd 算法  - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包  - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$  - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离  - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离- Floyd 算法步骤  - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　  - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它  ```cpp  for (k = 1;k &lt;= n;k++)      for (i = 1;i &lt;= n;i++)          for (j = 1;j &lt;= n;j++)              if (a[i][j] &gt; a[i][k] + a[k][j])                  a[i][j] = a[i][k] + a[k][j];  ```#### 拓扑排序- 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边  1. 从 DAG 图中选择一个没有前驱的节点并输出  2. 从图中删除该节点和所有以它为起点的有向边  3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止  ```cpp  bool topologicalSort(Graph GL)  &#123;      EdgeNode* e;      int top = 0; //用于栈指针下标       int count = 0; // 用于统计输出顶点的个数       int* stack; // 建栈将入度为 0 的顶点入栈       stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));      for (i = 0; i &lt; GL-&gt;numVertexes; i++)          if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈               stack[++top] = i;      while (top != 0)      &#123;          gettop = stack[top--];          printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);          count++; //输出 i 号顶点，并计数           for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;              k = e-&gt;adjvex;              if (!(--GL-&gt;adjList[k].in))                  //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                   stack[++top] = k;          &#125;      &#125;      if (count &lt; GL-&gt;numVertexes) return false;      else return true;  &#125;  ```  &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下)  &lt;!--more--&gt;  ### 矩阵与广义表  #### 矩阵  - 矩阵的转置    ```cpp    void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                B[j][i] = A[i][j];    &#125;    ```  - 矩阵相加    ```cpp    void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                C[i][j] = A[i][j] + B[i][j];    &#125;    ```  - 矩阵相乘    ```cpp    void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; k;++j)            &#123;                C[i][j] = 0;                for int(h = 0;h &lt; n;++h)                    C[i][j] += A[i][j] * B[i][j];            &#125;    &#125;    ```  - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵    - 对称矩阵、三角阵、对角矩阵  #### 广义表  - 表元素可以是原子或者广义表的一种线性表的扩展结构  - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数  - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾  - 原子结点有两个域：标志域和数据域  - 广义表结点有三个域：标志域，头指针域与尾指针域  ### 树  #### 树的基本概念  - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成    - 结点不仅包含数据元素，并且包含指向子树的分支    - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值    - 树的高度是树中结点的最大层次，根结点的高度为树的高度  - 树的双亲存储结构：`int tree[maxSize]`  - 树的链式存储结构    - 邻接表：孩子存储结构    - 孩子兄弟存储结构  #### 二叉树的概念和性质  - 二叉树的定义    - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2    - 子树有左右顺序之分，不能颠倒  - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层  - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的  - 二叉树的主要性质    1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$    2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$    3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$    4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：       - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）       - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点       - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点    5. Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$  棵不同的二叉树    6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$  - 二叉树的顺序存储结构最适用于完全二叉树  - 二叉树的链式存储结构    ```cpp    typedef struct BTNode    &#123;        char  data;    //数据域        struct BTNoode* lchild;        struct BTNode* rchild;    &#125; BTNode;    ```  #### 二叉树的遍历算法  - 先序遍历    ```cpp    /*二叉树的非递归先序遍历*/    void PreTraverseTree2(BitNode * root)    &#123;        StackNode* S;   //定义一个栈指针        BitNode* p;   //工作指针        S = NULL;        p = root;        S = InitStack(S);   //初始化栈        if (NULL == p)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;     //end if        while (p || !StackEmpty(S))        &#123;     //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p);    //p 所指节点入栈                printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）                p = p-&gt;lchild ;     //指向 p 的左孩子             &#125;//end if            else            &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树                StackPop(S, p);                p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈            &#125;    //end else        &#125;    //end while        free(S);    &#125;    //end PreTraverseTree2    /*二叉树的递归先序遍历*/    void preOrder(BiTNode *root)    &#123;        if (root)        &#123;            printf(&quot;%d &quot;, root-&gt;data);            preOrder(root-&gt;lchild);            preOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 中序遍历    ```cpp    /*二叉树的非递归中序遍历*/    void InOrderTraverseTree2(BitNode* root)    &#123;        StackNode* S; //定义一个栈指针        BitNode* p; //工作指针        S = NULL;        p = root;        S = InitStack(S); //初始化栈        if (NULL == p) &#123; //如果是空树            printf(&quot;树为空！\n&quot;) ;            return;        &#125;//end if        while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p); //将节点入栈                p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子            &#125;//end if            else            &#123;                StackPop(S, p); //p 左子树为空则出栈                printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点                p = p-&gt;rchild; //向右子树移动            &#125;//end else        &#125;//end while        free(S);    &#125;//end InOrderTraverseTree2    /*二叉树的递归中序遍历*/    void inOrder(BiTNode* root)    &#123;        if (root)        &#123;            inOrder(root-&gt;lchild);            printf(&quot;%d &quot;, root-&gt;data);            inOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 后序遍历    ```CPP    /*二叉树非递归后序遍历*/    void LastTraverseTree2(BiTNode* root)    &#123;        StackNode* S; BiTNode* cur, * pre;//定义一个栈指针        S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点        if (NULL == root)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;//end if        pre = NULL; cur = NULL;        StackPush(S, T); //根节点入栈        while (!StackEmpty(S))        &#123; //若栈非空            cur = NULL;            StackGetTop(S, cur); //将栈顶节点赋给 cur    /*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。    如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是    其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/            if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||                (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))            &#123;                printf(&quot;%c &quot;, cur-&gt;data);                pre = cur;                StackPop(S, cur);            &#125;//end if    //若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素    //的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。            else            &#123;                if (cur-&gt;rchild != NULL)                    StackPush(S, cur-&gt;rchild);                if (cur-&gt;lchild != NULL)                    StackPush(S, cur-&gt;lchild);            &#125;//end else        &#125;//end while        free(S);    &#125;//end LastTraverseTree2    /*二叉树递归后序遍历*/    void postOrder(BiTNode* root)    &#123;        if (root)        &#123;            postOrder(root-&gt;lchild);            postOrder(root-&gt;rchild);            printf(&quot;%d &quot;, root-&gt;data);        &#125;     &#125;    ```  - 层次遍历：自上而下，自左向右    - 首先，将二叉树的祖先节点入队列    - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队    ```cpp    void LayerOrder(BiTreeNode* head)    &#123;        LQueue Q;        Initiate_Queue(&amp;Q);        BiTreeNode* p;        if (head != NULL) AppendQueue(&amp;Q, head);        while (QueueNotEmpty(&amp;Q)) &#123;            p = QueueDelete(&amp;Q);            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);            if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);        &#125;    &#125;     ```  #### 哈夫曼树和哈夫曼编码  - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短    - 树的路径长度是指从根到每个节点的路径长度之和    - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值    - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和  - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度    ```cpp    ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0      &#123;          if (FBT == NULL) //空树返回0              return 0;          else          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点                  return FBT-&gt;data * len;              else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增                  return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);          &#125;      &#125;      ```  - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针      ```cpp    struct BTreeNode* CreateHuffman(ElemType a[], int n)      &#123;          int i, j;          struct BTreeNode **b, *q;          b = malloc(n*sizeof(struct BTreeNode));          for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点          &#123;              b[i] = malloc(sizeof(struct BTreeNode));              b[i]-&gt;data = a[i];              b[i]-&gt;left = b[i]-&gt;right = NULL;          &#125;          for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树          &#123;              //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标              int k1 = -1, k2;              for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵              &#123;                  if (b[j] != NULL &amp;&amp; k1 == -1)                  &#123;                      k1 = j;                      continue;                  &#125;                  if (b[j] != NULL)                  &#123;                      k2 = j;                      break;                  &#125;              &#125;              for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小              &#123;                  if (b[j] != NULL)                  &#123;                      if (b[j]-&gt;data &lt; b[k1]-&gt;data)                      &#123;                          k2 = k1;                          k1 = j;                      &#125;                      else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                          k2 = j;                  &#125;              &#125;              //由最小权值树和次最小权值树建立一棵新树，q指向树根结点              q = malloc(sizeof(struct BTreeNode));              q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;              q-&gt;left = b[k1];              q-&gt;right = b[k2];              b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置              b[k2] = NULL;//k2位置为空          &#125;          free(b); //删除动态建立的数组b          return q; //返回整个哈夫曼树的树根指针      &#125;      ```  - 哈夫曼编码    - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树    - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码    - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码    - 哈夫曼编码产生的是最短前缀码    ```cpp    void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0      &#123;          static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一          if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)              &#123;                  int i;                  printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);                  for (i = 0; i &lt; len; i++)                      printf(&quot;%d&quot;, a[i]);                  printf(&quot;\n&quot;);              &#125;              else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a              &#123;   //的对应元素中，向下深入一层时len值增1                  a[len] = 0;                  HuffManCoding(FBT-&gt;left, len + 1);                  a[len] = 1;                  HuffManCoding(FBT-&gt;right, len + 1);              &#125;          &#125;      &#125;      ```  ### 图  #### 图的基本概念  - 图由结点的有穷集合的 V 和边的集合  E 组成（`G(V,E)`）  - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示  - 路径长度：路径上边或者弧的数目  - 顶点的度：顶点关联边的数目    - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度    - 在有向图中，顶点的度就是两者之和    - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量    - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量  #### 图的存储结构  - 邻接矩阵    - 图的顺序存储结构    - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息    - 无向图中邻接矩阵是个对称矩阵    - 0表示无边，1表示有边    - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度     - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费    ```cpp    typedef struct    &#123;      int no;      char info;    &#125; VertexType;    typedef struct    &#123;      int edges[maxSize][maxSize];    //有权图中int改为float      int n,e;    //顶点数和边数      VertexType vex[maxSize];    //存放结点信息    &#125; MGragh;    ```  - 邻接表    - 数组和链表相结合的存储方法，图的链式存储结构    - 图中顶点用一个一维数组存储    - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表    - 顶点表的各个结点由 data 和 Firstedge 两个域表示      - data 是数据域，存储顶点信息      - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点    - 边表结点由 adjvex 和 next 两个域组成      - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标      - next 存储边表中下一个结点指针    - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表    ```cpp    typedef struct ArcNode    &#123;        int adnex;    //该边所指向的结点的位置        struct ArcNode * nextarc;    //指向下一条边的指针        int info;    //该边的相关信息(如权值)    &#125; ArcNode;    typedef struct    &#123;        char data;    //顶点信息        ArcNode* firstarc;    //指向第一条边的指针    &#125;VNode;    typedef struct    &#123;        VNode adjlist[maxSize];    //邻接表        int n, e;    //顶点数和边数    &#125; AGraph;    //图的邻接表类型    ```  - 十字链表    - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表    - 定点表      - firstin：入边表头指针，指向顶点入边表的第一个结点      - firstout：出边表头指针，指向顶点出边表第一个结点    - 边表      - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标      - headlink 入边表指针域，指向终点相同的下一条边      - taillink 是指边表指针域，指向起点相同的下一条边  - 邻接多重表    - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标    - ilink 指向依附项点 ivex 的下一条边    - jlink 指向依附顶点 jvex 的下一条边  #### 图的遍历算法  - 深度优先遍历（DFS，Depth First Search）     - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了    - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问    - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问    void DFSTraverse(Graph G)    &#123;        for (v = 0;v &lt; G.vexnum;++v)            visited[v] = false;    //初始化标记数组        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历                DFS(G, v);    &#125;    void DFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true; //定义为已访问        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])                DFS(G, w);    &#125;    ```  - 广度优先遍历（BFS，Breadth First Search）    - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点    - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完    - BFS 遍历的方式类似于树的层次遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组    void BFSTraverse(Graph G)    &#123;        for (i = 0;i &lt; G.vexnum;++i)            visited[v] = false;    //初始化标记数组        InitQueue(Q);        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历                BFS(G, v);    &#125;    void BFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true;    //定义为已访问        while (!isEmpty(Q))        &#123;            DeQueue(Q, v);            for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))                if (!visited[w])                &#123;                    visit(w);                    visited[w] = true;                    EnQueue(Q, w)                &#125;    //if        &#125;    //while    &#125;    ```  #### 最小生成树  - Prim 算法    - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树    - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树    - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树    ```cpp    void prim (G,T)    &#123;        T = ∅;        U = &#123;w&#125;;        while ((V - U) != ∅  )        &#123; //若图中不含全部顶点            设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;            T = T∪ (u，v); //边归入树            U = U∪ &#123;v&#125;;     //顶点归入树        &#125;    &#125;    ```  - Kruskal 算法    - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止    - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图    - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的    - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树      - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合      - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合    ```cpp    void kruskal（V，T）    &#123;        T = V;    //初始化树，仅含顶点        numS = n;    //不连分量的数目        while (numS &gt; 1)        &#123;            从 E 中取出权值最小的边（v,u）;            if（v 和 u 属于 T 中不同的连通分量）            &#123;                T = T∪（u，v）;//将此边加入到生成树中；                numS--; //不连通的分量减少 1            &#125;        &#125;    &#125;    ```  #### 最短路径  - Dijkstra 算法    - 通常用于求图中某一顶点到其余各顶点的最短路径    - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组    - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）    - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度  - Dijkstra 算法步骤    1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$    2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）    3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离    4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中    ```cpp    void Dijkstra(int v0)    &#123;      　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中          int n=MAXNUM;      　　for(int i=1; i&lt;=n; ++i)     　　 &#123;          　　dist[i] = A[v0][i];          　　S[i] = false;                                // 初始都未用过该点          　　if(dist[i] == MAXINT)                    　　prev[i] = -1;     　　     else                 　　prev[i] = v0;       　　&#125;       　 dist[v0] = 0;       　 S[v0] = true; 　　     　　 for(int i=2; i&lt;=n; i++)     　　 &#123;           　　int mindist = MAXINT;           　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值          　　 for(int j=1; j&lt;=n; ++j)          　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)          　　    &#123;             　　       u = j;                             // u保存当前邻接点中距离最小的点的号码              　 　      mindist = dist[j];           　　   &#125;           　　S[u] = true;            　　for(int j=1; j&lt;=n; j++)           　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)           　　    &#123;               　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径                 　    　&#123;                       　　dist[j] = dist[u] + A[u][j];    //更新dist                        　　prev[j] = u;                    //记录前驱顶点                 　　    &#125;            　    　&#125;       　　&#125;    &#125;    ```  - Floyd 算法    - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包    - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$    - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离    - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离  - Floyd 算法步骤    - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　    - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它    ```cpp    for (k = 1;k &lt;= n;k++)        for (i = 1;i &lt;= n;i++)            for (j = 1;j &lt;= n;j++)                if (a[i][j] &gt; a[i][k] + a[k][j])                    a[i][j] = a[i][k] + a[k][j];    ```  #### 拓扑排序  - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边    1. 从 DAG 图中选择一个没有前驱的节点并输出    2. 从图中删除该节点和所有以它为起点的有向边    3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止    ```cpp    bool topologicalSort(Graph GL)    &#123;        EdgeNode* e;        int top = 0; //用于栈指针下标         int count = 0; // 用于统计输出顶点的个数         int* stack; // 建栈将入度为 0 的顶点入栈         stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));        for (i = 0; i &lt; GL-&gt;numVertexes; i++)            if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈                 stack[++top] = i;        while (top != 0)        &#123;            gettop = stack[top--];            printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);            count++; //输出 i 号顶点，并计数             for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;                k = e-&gt;adjvex;                if (!(--GL-&gt;adjList[k].in))                    //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                     stack[++top] = k;            &#125;        &#125;        if (count &lt; GL-&gt;numVertexes) return false;        else return true;    &#125;    ```  &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下)  &lt;!--more--&gt;  ### 矩阵与广义表  #### 矩阵  - 矩阵的转置    ```cpp    void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                B[j][i] = A[i][j];    &#125;    ```  - 矩阵相加    ```cpp    void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                C[i][j] = A[i][j] + B[i][j];    &#125;    ```  - 矩阵相乘    ```cpp    void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; k;++j)            &#123;                C[i][j] = 0;                for int(h = 0;h &lt; n;++h)                    C[i][j] += A[i][j] * B[i][j];            &#125;    &#125;    ```  - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵    - 对称矩阵、三角阵、对角矩阵  #### 广义表  - 表元素可以是原子或者广义表的一种线性表的扩展结构  - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数  - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾  - 原子结点有两个域：标志域和数据域  - 广义表结点有三个域：标志域，头指针域与尾指针域  ### 树  #### 树的基本概念  - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成    - 结点不仅包含数据元素，并且包含指向子树的分支    - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值    - 树的高度是树中结点的最大层次，根结点的高度为树的高度  - 树的双亲存储结构：`int tree[maxSize]`  - 树的链式存储结构    - 邻接表：孩子存储结构    - 孩子兄弟存储结构  #### 二叉树的概念和性质  - 二叉树的定义    - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2    - 子树有左右顺序之分，不能颠倒  - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层  - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的  - 二叉树的主要性质    1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$    2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$    3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$    4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：       - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）       - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点       - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点    5. Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$  棵不同的二叉树    6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$  - 二叉树的顺序存储结构最适用于完全二叉树  - 二叉树的链式存储结构    ```cpp    typedef struct BTNode    &#123;        char  data;    //数据域        struct BTNoode* lchild;        struct BTNode* rchild;    &#125; BTNode;    ```  #### 二叉树的遍历算法  - 先序遍历    ```cpp    /*二叉树的非递归先序遍历*/    void PreTraverseTree2(BitNode * root)    &#123;        StackNode* S;   //定义一个栈指针        BitNode* p;   //工作指针        S = NULL;        p = root;        S = InitStack(S);   //初始化栈        if (NULL == p)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;     //end if        while (p || !StackEmpty(S))        &#123;     //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p);    //p 所指节点入栈                printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）                p = p-&gt;lchild ;     //指向 p 的左孩子             &#125;//end if            else            &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树                StackPop(S, p);                p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈            &#125;    //end else        &#125;    //end while        free(S);    &#125;    //end PreTraverseTree2    /*二叉树的递归先序遍历*/    void preOrder(BiTNode *root)    &#123;        if (root)        &#123;            printf(&quot;%d &quot;, root-&gt;data);            preOrder(root-&gt;lchild);            preOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 中序遍历    ```cpp    /*二叉树的非递归中序遍历*/    void InOrderTraverseTree2(BitNode* root)    &#123;        StackNode* S; //定义一个栈指针        BitNode* p; //工作指针        S = NULL;        p = root;        S = InitStack(S); //初始化栈        if (NULL == p) &#123; //如果是空树            printf(&quot;树为空！\n&quot;) ;            return;        &#125;//end if        while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p); //将节点入栈                p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子            &#125;//end if            else            &#123;                StackPop(S, p); //p 左子树为空则出栈                printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点                p = p-&gt;rchild; //向右子树移动            &#125;//end else        &#125;//end while        free(S);    &#125;//end InOrderTraverseTree2    /*二叉树的递归中序遍历*/    void inOrder(BiTNode* root)    &#123;        if (root)        &#123;            inOrder(root-&gt;lchild);            printf(&quot;%d &quot;, root-&gt;data);            inOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 后序遍历    ```CPP    /*二叉树非递归后序遍历*/    void LastTraverseTree2(BiTNode* root)    &#123;        StackNode* S; BiTNode* cur, * pre;//定义一个栈指针        S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点        if (NULL == root)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;//end if        pre = NULL; cur = NULL;        StackPush(S, T); //根节点入栈        while (!StackEmpty(S))        &#123; //若栈非空            cur = NULL;            StackGetTop(S, cur); //将栈顶节点赋给 cur    /*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。    如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是    其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/            if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||                (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))            &#123;                printf(&quot;%c &quot;, cur-&gt;data);                pre = cur;                StackPop(S, cur);            &#125;//end if    //若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素    //的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。            else            &#123;                if (cur-&gt;rchild != NULL)                    StackPush(S, cur-&gt;rchild);                if (cur-&gt;lchild != NULL)                    StackPush(S, cur-&gt;lchild);            &#125;//end else        &#125;//end while        free(S);    &#125;//end LastTraverseTree2    /*二叉树递归后序遍历*/    void postOrder(BiTNode* root)    &#123;        if (root)        &#123;            postOrder(root-&gt;lchild);            postOrder(root-&gt;rchild);            printf(&quot;%d &quot;, root-&gt;data);        &#125;     &#125;    ```  - 层次遍历：自上而下，自左向右    - 首先，将二叉树的祖先节点入队列    - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队    ```cpp    void LayerOrder(BiTreeNode* head)    &#123;        LQueue Q;        Initiate_Queue(&amp;Q);        BiTreeNode* p;        if (head != NULL) AppendQueue(&amp;Q, head);        while (QueueNotEmpty(&amp;Q)) &#123;            p = QueueDelete(&amp;Q);            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);            if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);        &#125;    &#125;     ```  #### 哈夫曼树和哈夫曼编码  - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短    - 树的路径长度是指从根到每个节点的路径长度之和    - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值    - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和  - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度    ```cpp    ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0      &#123;          if (FBT == NULL) //空树返回0              return 0;          else          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点                  return FBT-&gt;data * len;              else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增                  return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);          &#125;      &#125;      ```  - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针      ```cpp    struct BTreeNode* CreateHuffman(ElemType a[], int n)      &#123;          int i, j;          struct BTreeNode **b, *q;          b = malloc(n*sizeof(struct BTreeNode));          for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点          &#123;              b[i] = malloc(sizeof(struct BTreeNode));              b[i]-&gt;data = a[i];              b[i]-&gt;left = b[i]-&gt;right = NULL;          &#125;          for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树          &#123;              //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标              int k1 = -1, k2;              for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵              &#123;                  if (b[j] != NULL &amp;&amp; k1 == -1)                  &#123;                      k1 = j;                      continue;                  &#125;                  if (b[j] != NULL)                  &#123;                      k2 = j;                      break;                  &#125;              &#125;              for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小              &#123;                  if (b[j] != NULL)                  &#123;                      if (b[j]-&gt;data &lt; b[k1]-&gt;data)                      &#123;                          k2 = k1;                          k1 = j;                      &#125;                      else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                          k2 = j;                  &#125;              &#125;              //由最小权值树和次最小权值树建立一棵新树，q指向树根结点              q = malloc(sizeof(struct BTreeNode));              q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;              q-&gt;left = b[k1];              q-&gt;right = b[k2];              b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置              b[k2] = NULL;//k2位置为空          &#125;          free(b); //删除动态建立的数组b          return q; //返回整个哈夫曼树的树根指针      &#125;      ```  - 哈夫曼编码    - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树    - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码    - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码    - 哈夫曼编码产生的是最短前缀码    ```cpp    void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0      &#123;          static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一          if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)              &#123;                  int i;                  printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);                  for (i = 0; i &lt; len; i++)                      printf(&quot;%d&quot;, a[i]);                  printf(&quot;\n&quot;);              &#125;              else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a              &#123;   //的对应元素中，向下深入一层时len值增1                  a[len] = 0;                  HuffManCoding(FBT-&gt;left, len + 1);                  a[len] = 1;                  HuffManCoding(FBT-&gt;right, len + 1);              &#125;          &#125;      &#125;      ```  ### 图  #### 图的基本概念  - 图由结点的有穷集合的 V 和边的集合  E 组成（`G(V,E)`）  - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示  - 路径长度：路径上边或者弧的数目  - 顶点的度：顶点关联边的数目    - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度    - 在有向图中，顶点的度就是两者之和    - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量    - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量  #### 图的存储结构  - 邻接矩阵    - 图的顺序存储结构    - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息    - 无向图中邻接矩阵是个对称矩阵    - 0表示无边，1表示有边    - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度     - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费    ```cpp    typedef struct    &#123;      int no;      char info;    &#125; VertexType;    typedef struct    &#123;      int edges[maxSize][maxSize];    //有权图中int改为float      int n,e;    //顶点数和边数      VertexType vex[maxSize];    //存放结点信息    &#125; MGragh;    ```  - 邻接表    - 数组和链表相结合的存储方法，图的链式存储结构    - 图中顶点用一个一维数组存储    - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表    - 顶点表的各个结点由 data 和 Firstedge 两个域表示      - data 是数据域，存储顶点信息      - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点    - 边表结点由 adjvex 和 next 两个域组成      - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标      - next 存储边表中下一个结点指针    - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表    ```cpp    typedef struct ArcNode    &#123;        int adnex;    //该边所指向的结点的位置        struct ArcNode * nextarc;    //指向下一条边的指针        int info;    //该边的相关信息(如权值)    &#125; ArcNode;    typedef struct    &#123;        char data;    //顶点信息        ArcNode* firstarc;    //指向第一条边的指针    &#125;VNode;    typedef struct    &#123;        VNode adjlist[maxSize];    //邻接表        int n, e;    //顶点数和边数    &#125; AGraph;    //图的邻接表类型    ```  - 十字链表    - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表    - 定点表      - firstin：入边表头指针，指向顶点入边表的第一个结点      - firstout：出边表头指针，指向顶点出边表第一个结点    - 边表      - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标      - headlink 入边表指针域，指向终点相同的下一条边      - taillink 是指边表指针域，指向起点相同的下一条边  - 邻接多重表    - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标    - ilink 指向依附项点 ivex 的下一条边    - jlink 指向依附顶点 jvex 的下一条边  #### 图的遍历算法  - 深度优先遍历（DFS，Depth First Search）     - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了    - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问    - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问    void DFSTraverse(Graph G)    &#123;        for (v = 0;v &lt; G.vexnum;++v)            visited[v] = false;    //初始化标记数组        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历                DFS(G, v);    &#125;    void DFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true; //定义为已访问        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])                DFS(G, w);    &#125;    ```  - 广度优先遍历（BFS，Breadth First Search）    - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点    - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完    - BFS 遍历的方式类似于树的层次遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组    void BFSTraverse(Graph G)    &#123;        for (i = 0;i &lt; G.vexnum;++i)            visited[v] = false;    //初始化标记数组        InitQueue(Q);        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历                BFS(G, v);    &#125;    void BFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true;    //定义为已访问        while (!isEmpty(Q))        &#123;            DeQueue(Q, v);            for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))                if (!visited[w])                &#123;                    visit(w);                    visited[w] = true;                    EnQueue(Q, w)                &#125;    //if        &#125;    //while    &#125;    ```  #### 最小生成树  - Prim 算法    - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树    - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树    - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树    ```cpp    void prim (G,T)    &#123;        T = ∅;        U = &#123;w&#125;;        while ((V - U) != ∅  )        &#123; //若图中不含全部顶点            设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;            T = T∪ (u，v); //边归入树            U = U∪ &#123;v&#125;;     //顶点归入树        &#125;    &#125;    ```  - Kruskal 算法    - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止    - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图    - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的    - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树      - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合      - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合    ```cpp    void kruskal（V，T）    &#123;        T = V;    //初始化树，仅含顶点        numS = n;    //不连分量的数目        while (numS &gt; 1)        &#123;            从 E 中取出权值最小的边（v,u）;            if（v 和 u 属于 T 中不同的连通分量）            &#123;                T = T∪（u，v）;//将此边加入到生成树中；                numS--; //不连通的分量减少 1            &#125;        &#125;    &#125;    ```  #### 最短路径  - Dijkstra 算法    - 通常用于求图中某一顶点到其余各顶点的最短路径    - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组    - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）    - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度  - Dijkstra 算法步骤    1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$    2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）    3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离    4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中    ```cpp    void Dijkstra(int v0)    &#123;      　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中          int n=MAXNUM;      　　for(int i=1; i&lt;=n; ++i)     　　 &#123;          　　dist[i] = A[v0][i];          　　S[i] = false;                                // 初始都未用过该点          　　if(dist[i] == MAXINT)                    　　prev[i] = -1;     　　     else                 　　prev[i] = v0;       　　&#125;       　 dist[v0] = 0;       　 S[v0] = true; 　　     　　 for(int i=2; i&lt;=n; i++)     　　 &#123;           　　int mindist = MAXINT;           　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值          　　 for(int j=1; j&lt;=n; ++j)          　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)          　　    &#123;             　　       u = j;                             // u保存当前邻接点中距离最小的点的号码              　 　      mindist = dist[j];           　　   &#125;           　　S[u] = true;            　　for(int j=1; j&lt;=n; j++)           　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)           　　    &#123;               　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径                 　    　&#123;                       　　dist[j] = dist[u] + A[u][j];    //更新dist                        　　prev[j] = u;                    //记录前驱顶点                 　　    &#125;            　    　&#125;       　　&#125;    &#125;    ```  - Floyd 算法    - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包    - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$    - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离    - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离  - Floyd 算法步骤    - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　    - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它    ```cpp    for (k = 1;k &lt;= n;k++)        for (i = 1;i &lt;= n;i++)            for (j = 1;j &lt;= n;j++)                if (a[i][j] &gt; a[i][k] + a[k][j])                    a[i][j] = a[i][k] + a[k][j];    ```  #### 拓扑排序  - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边    1. 从 DAG 图中选择一个没有前驱的节点并输出    2. 从图中删除该节点和所有以它为起点的有向边    3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止    ```cpp    bool topologicalSort(Graph GL)    &#123;        EdgeNode* e;        int top = 0; //用于栈指针下标         int count = 0; // 用于统计输出顶点的个数         int* stack; // 建栈将入度为 0 的顶点入栈         stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));        for (i = 0; i &lt; GL-&gt;numVertexes; i++)            if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈                 stack[++top] = i;        while (top != 0)        &#123;            gettop = stack[top--];            printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);            count++; //输出 i 号顶点，并计数             for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;                k = e-&gt;adjvex;                if (!(--GL-&gt;adjList[k].in))                    //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                     stack[++top] = k;            &#125;        &#125;        if (count &lt; GL-&gt;numVertexes) return false;        else return true;    &#125;    ```  &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下)  &lt;!--more--&gt;  ### 矩阵与广义表  #### 矩阵  - 矩阵的转置    ```cpp    void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                B[j][i] = A[i][j];    &#125;    ```  - 矩阵相加    ```cpp    void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                C[i][j] = A[i][j] + B[i][j];    &#125;    ```  - 矩阵相乘    ```cpp    void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; k;++j)            &#123;                C[i][j] = 0;                for int(h = 0;h &lt; n;++h)                    C[i][j] += A[i][j] * B[i][j];            &#125;    &#125;    ```  - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵    - 对称矩阵、三角阵、对角矩阵  #### 广义表  - 表元素可以是原子或者广义表的一种线性表的扩展结构  - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数  - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾  - 原子结点有两个域：标志域和数据域  - 广义表结点有三个域：标志域，头指针域与尾指针域  ### 树  #### 树的基本概念  - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成    - 结点不仅包含数据元素，并且包含指向子树的分支    - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值    - 树的高度是树中结点的最大层次，根结点的高度为树的高度  - 树的双亲存储结构：`int tree[maxSize]`  - 树的链式存储结构    - 邻接表：孩子存储结构    - 孩子兄弟存储结构  #### 二叉树的概念和性质  - 二叉树的定义    - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2    - 子树有左右顺序之分，不能颠倒  - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层  - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的  - 二叉树的主要性质    1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$    2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$    3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$    4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：       - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）       - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点       - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点    5. Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$  棵不同的二叉树    6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$  - 二叉树的顺序存储结构最适用于完全二叉树  - 二叉树的链式存储结构    ```cpp    typedef struct BTNode    &#123;        char  data;    //数据域        struct BTNoode* lchild;        struct BTNode* rchild;    &#125; BTNode;    ```  #### 二叉树的遍历算法  - 先序遍历    ```cpp    /*二叉树的非递归先序遍历*/    void PreTraverseTree2(BitNode * root)    &#123;        StackNode* S;   //定义一个栈指针        BitNode* p;   //工作指针        S = NULL;        p = root;        S = InitStack(S);   //初始化栈        if (NULL == p)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;     //end if        while (p || !StackEmpty(S))        &#123;     //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p);    //p 所指节点入栈                printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）                p = p-&gt;lchild ;     //指向 p 的左孩子             &#125;//end if            else            &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树                StackPop(S, p);                p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈            &#125;    //end else        &#125;    //end while        free(S);    &#125;    //end PreTraverseTree2    /*二叉树的递归先序遍历*/    void preOrder(BiTNode *root)    &#123;        if (root)        &#123;            printf(&quot;%d &quot;, root-&gt;data);            preOrder(root-&gt;lchild);            preOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 中序遍历    ```cpp    /*二叉树的非递归中序遍历*/    void InOrderTraverseTree2(BitNode* root)    &#123;        StackNode* S; //定义一个栈指针        BitNode* p; //工作指针        S = NULL;        p = root;        S = InitStack(S); //初始化栈        if (NULL == p) &#123; //如果是空树            printf(&quot;树为空！\n&quot;) ;            return;        &#125;//end if        while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p); //将节点入栈                p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子            &#125;//end if            else            &#123;                StackPop(S, p); //p 左子树为空则出栈                printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点                p = p-&gt;rchild; //向右子树移动            &#125;//end else        &#125;//end while        free(S);    &#125;//end InOrderTraverseTree2    /*二叉树的递归中序遍历*/    void inOrder(BiTNode* root)    &#123;        if (root)        &#123;            inOrder(root-&gt;lchild);            printf(&quot;%d &quot;, root-&gt;data);            inOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 后序遍历    ```CPP    /*二叉树非递归后序遍历*/    void LastTraverseTree2(BiTNode* root)    &#123;        StackNode* S; BiTNode* cur, * pre;//定义一个栈指针        S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点        if (NULL == root)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;//end if        pre = NULL; cur = NULL;        StackPush(S, T); //根节点入栈        while (!StackEmpty(S))        &#123; //若栈非空            cur = NULL;            StackGetTop(S, cur); //将栈顶节点赋给 cur    /*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。    如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是    其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/            if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||                (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))            &#123;                printf(&quot;%c &quot;, cur-&gt;data);                pre = cur;                StackPop(S, cur);            &#125;//end if    //若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素    //的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。            else            &#123;                if (cur-&gt;rchild != NULL)                    StackPush(S, cur-&gt;rchild);                if (cur-&gt;lchild != NULL)                    StackPush(S, cur-&gt;lchild);            &#125;//end else        &#125;//end while        free(S);    &#125;//end LastTraverseTree2    /*二叉树递归后序遍历*/    void postOrder(BiTNode* root)    &#123;        if (root)        &#123;            postOrder(root-&gt;lchild);            postOrder(root-&gt;rchild);            printf(&quot;%d &quot;, root-&gt;data);        &#125;     &#125;    ```  - 层次遍历：自上而下，自左向右    - 首先，将二叉树的祖先节点入队列    - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队    ```cpp    void LayerOrder(BiTreeNode* head)    &#123;        LQueue Q;        Initiate_Queue(&amp;Q);        BiTreeNode* p;        if (head != NULL) AppendQueue(&amp;Q, head);        while (QueueNotEmpty(&amp;Q)) &#123;            p = QueueDelete(&amp;Q);            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);            if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);        &#125;    &#125;     ```  #### 哈夫曼树和哈夫曼编码  - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短    - 树的路径长度是指从根到每个节点的路径长度之和    - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值    - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和  - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度    ```cpp    ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0      &#123;          if (FBT == NULL) //空树返回0              return 0;          else          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点                  return FBT-&gt;data * len;              else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增                  return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);          &#125;      &#125;      ```  - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针      ```cpp    struct BTreeNode* CreateHuffman(ElemType a[], int n)      &#123;          int i, j;          struct BTreeNode **b, *q;          b = malloc(n*sizeof(struct BTreeNode));          for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点          &#123;              b[i] = malloc(sizeof(struct BTreeNode));              b[i]-&gt;data = a[i];              b[i]-&gt;left = b[i]-&gt;right = NULL;          &#125;          for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树          &#123;              //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标              int k1 = -1, k2;              for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵              &#123;                  if (b[j] != NULL &amp;&amp; k1 == -1)                  &#123;                      k1 = j;                      continue;                  &#125;                  if (b[j] != NULL)                  &#123;                      k2 = j;                      break;                  &#125;              &#125;              for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小              &#123;                  if (b[j] != NULL)                  &#123;                      if (b[j]-&gt;data &lt; b[k1]-&gt;data)                      &#123;                          k2 = k1;                          k1 = j;                      &#125;                      else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                          k2 = j;                  &#125;              &#125;              //由最小权值树和次最小权值树建立一棵新树，q指向树根结点              q = malloc(sizeof(struct BTreeNode));              q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;              q-&gt;left = b[k1];              q-&gt;right = b[k2];              b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置              b[k2] = NULL;//k2位置为空          &#125;          free(b); //删除动态建立的数组b          return q; //返回整个哈夫曼树的树根指针      &#125;      ```  - 哈夫曼编码    - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树    - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码    - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码    - 哈夫曼编码产生的是最短前缀码    ```cpp    void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0      &#123;          static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一          if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)              &#123;                  int i;                  printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);                  for (i = 0; i &lt; len; i++)                      printf(&quot;%d&quot;, a[i]);                  printf(&quot;\n&quot;);              &#125;              else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a              &#123;   //的对应元素中，向下深入一层时len值增1                  a[len] = 0;                  HuffManCoding(FBT-&gt;left, len + 1);                  a[len] = 1;                  HuffManCoding(FBT-&gt;right, len + 1);              &#125;          &#125;      &#125;      ```  ### 图  #### 图的基本概念  - 图由结点的有穷集合的 V 和边的集合  E 组成（`G(V,E)`）  - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示  - 路径长度：路径上边或者弧的数目  - 顶点的度：顶点关联边的数目    - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度    - 在有向图中，顶点的度就是两者之和    - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量    - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量  #### 图的存储结构  - 邻接矩阵    - 图的顺序存储结构    - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息    - 无向图中邻接矩阵是个对称矩阵    - 0表示无边，1表示有边    - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度     - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费    ```cpp    typedef struct    &#123;      int no;      char info;    &#125; VertexType;    typedef struct    &#123;      int edges[maxSize][maxSize];    //有权图中int改为float      int n,e;    //顶点数和边数      VertexType vex[maxSize];    //存放结点信息    &#125; MGragh;    ```  - 邻接表    - 数组和链表相结合的存储方法，图的链式存储结构    - 图中顶点用一个一维数组存储    - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表    - 顶点表的各个结点由 data 和 Firstedge 两个域表示      - data 是数据域，存储顶点信息      - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点    - 边表结点由 adjvex 和 next 两个域组成      - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标      - next 存储边表中下一个结点指针    - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表    ```cpp    typedef struct ArcNode    &#123;        int adnex;    //该边所指向的结点的位置        struct ArcNode * nextarc;    //指向下一条边的指针        int info;    //该边的相关信息(如权值)    &#125; ArcNode;    typedef struct    &#123;        char data;    //顶点信息        ArcNode* firstarc;    //指向第一条边的指针    &#125;VNode;    typedef struct    &#123;        VNode adjlist[maxSize];    //邻接表        int n, e;    //顶点数和边数    &#125; AGraph;    //图的邻接表类型    ```  - 十字链表    - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表    - 定点表      - firstin：入边表头指针，指向顶点入边表的第一个结点      - firstout：出边表头指针，指向顶点出边表第一个结点    - 边表      - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标      - headlink 入边表指针域，指向终点相同的下一条边      - taillink 是指边表指针域，指向起点相同的下一条边  - 邻接多重表    - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标    - ilink 指向依附项点 ivex 的下一条边    - jlink 指向依附顶点 jvex 的下一条边  #### 图的遍历算法  - 深度优先遍历（DFS，Depth First Search）     - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了    - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问    - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问    void DFSTraverse(Graph G)    &#123;        for (v = 0;v &lt; G.vexnum;++v)            visited[v] = false;    //初始化标记数组        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历                DFS(G, v);    &#125;    void DFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true; //定义为已访问        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])                DFS(G, w);    &#125;    ```  - 广度优先遍历（BFS，Breadth First Search）    - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点    - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完    - BFS 遍历的方式类似于树的层次遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组    void BFSTraverse(Graph G)    &#123;        for (i = 0;i &lt; G.vexnum;++i)            visited[v] = false;    //初始化标记数组        InitQueue(Q);        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历                BFS(G, v);    &#125;    void BFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true;    //定义为已访问        while (!isEmpty(Q))        &#123;            DeQueue(Q, v);            for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))                if (!visited[w])                &#123;                    visit(w);                    visited[w] = true;                    EnQueue(Q, w)                &#125;    //if        &#125;    //while    &#125;    ```  #### 最小生成树  - Prim 算法    - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树    - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树    - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树    ```cpp    void prim (G,T)    &#123;        T = ∅;        U = &#123;w&#125;;        while ((V - U) != ∅  )        &#123; //若图中不含全部顶点            设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;            T = T∪ (u，v); //边归入树            U = U∪ &#123;v&#125;;     //顶点归入树        &#125;    &#125;    ```  - Kruskal 算法    - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止    - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图    - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的    - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树      - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合      - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合    ```cpp    void kruskal（V，T）    &#123;        T = V;    //初始化树，仅含顶点        numS = n;    //不连分量的数目        while (numS &gt; 1)        &#123;            从 E 中取出权值最小的边（v,u）;            if（v 和 u 属于 T 中不同的连通分量）            &#123;                T = T∪（u，v）;//将此边加入到生成树中；                numS--; //不连通的分量减少 1            &#125;        &#125;    &#125;    ```  #### 最短路径  - Dijkstra 算法    - 通常用于求图中某一顶点到其余各顶点的最短路径    - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组    - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）    - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度  - Dijkstra 算法步骤    1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$    2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）    3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离    4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中    ```cpp    void Dijkstra(int v0)    &#123;      　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中          int n=MAXNUM;      　　for(int i=1; i&lt;=n; ++i)     　　 &#123;          　　dist[i] = A[v0][i];          　　S[i] = false;                                // 初始都未用过该点          　　if(dist[i] == MAXINT)                    　　prev[i] = -1;     　　     else                 　　prev[i] = v0;       　　&#125;       　 dist[v0] = 0;       　 S[v0] = true; 　　     　　 for(int i=2; i&lt;=n; i++)     　　 &#123;           　　int mindist = MAXINT;           　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值          　　 for(int j=1; j&lt;=n; ++j)          　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)          　　    &#123;             　　       u = j;                             // u保存当前邻接点中距离最小的点的号码              　 　      mindist = dist[j];           　　   &#125;           　　S[u] = true;            　　for(int j=1; j&lt;=n; j++)           　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)           　　    &#123;               　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径                 　    　&#123;                       　　dist[j] = dist[u] + A[u][j];    //更新dist                        　　prev[j] = u;                    //记录前驱顶点                 　　    &#125;            　    　&#125;       　　&#125;    &#125;    ```  - Floyd 算法    - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包    - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$    - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离    - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离  - Floyd 算法步骤    - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　    - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它    ```cpp    for (k = 1;k &lt;= n;k++)        for (i = 1;i &lt;= n;i++)            for (j = 1;j &lt;= n;j++)                if (a[i][j] &gt; a[i][k] + a[k][j])                    a[i][j] = a[i][k] + a[k][j];    ```  #### 拓扑排序  - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边    1. 从 DAG 图中选择一个没有前驱的节点并输出    2. 从图中删除该节点和所有以它为起点的有向边    3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止    ```cpp    bool topologicalSort(Graph GL)    &#123;        EdgeNode* e;        int top = 0; //用于栈指针下标         int count = 0; // 用于统计输出顶点的个数         int* stack; // 建栈将入度为 0 的顶点入栈         stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));        for (i = 0; i &lt; GL-&gt;numVertexes; i++)            if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈                 stack[++top] = i;        while (top != 0)        &#123;            gettop = stack[top--];            printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);            count++; //输出 i 号顶点，并计数             for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;                k = e-&gt;adjvex;                if (!(--GL-&gt;adjList[k].in))                    //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                     stack[++top] = k;            &#125;        &#125;        if (count &lt; GL-&gt;numVertexes) return false;        else return true;    &#125;    ```  &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下)  &lt;!--more--&gt;  ### 矩阵与广义表  #### 矩阵  - 矩阵的转置    ```cpp    void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                B[j][i] = A[i][j];    &#125;    ```  - 矩阵相加    ```cpp    void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                C[i][j] = A[i][j] + B[i][j];    &#125;    ```  - 矩阵相乘    ```cpp    void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; k;++j)            &#123;                C[i][j] = 0;                for int(h = 0;h &lt; n;++h)                    C[i][j] += A[i][j] * B[i][j];            &#125;    &#125;    ```  - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵    - 对称矩阵、三角阵、对角矩阵  #### 广义表  - 表元素可以是原子或者广义表的一种线性表的扩展结构  - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数  - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾  - 原子结点有两个域：标志域和数据域  - 广义表结点有三个域：标志域，头指针域与尾指针域  ### 树  #### 树的基本概念  - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成    - 结点不仅包含数据元素，并且包含指向子树的分支    - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值    - 树的高度是树中结点的最大层次，根结点的高度为树的高度  - 树的双亲存储结构：`int tree[maxSize]`  - 树的链式存储结构    - 邻接表：孩子存储结构    - 孩子兄弟存储结构  #### 二叉树的概念和性质  - 二叉树的定义    - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2    - 子树有左右顺序之分，不能颠倒  - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层  - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的  - 二叉树的主要性质    1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$    2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$    3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$    4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：       - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）       - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点       - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点    5. Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$  棵不同的二叉树    6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$  - 二叉树的顺序存储结构最适用于完全二叉树  - 二叉树的链式存储结构    ```cpp    typedef struct BTNode    &#123;        char  data;    //数据域        struct BTNoode* lchild;        struct BTNode* rchild;    &#125; BTNode;    ```  #### 二叉树的遍历算法  - 先序遍历    ```cpp    /*二叉树的非递归先序遍历*/    void PreTraverseTree2(BitNode * root)    &#123;        StackNode* S;   //定义一个栈指针        BitNode* p;   //工作指针        S = NULL;        p = root;        S = InitStack(S);   //初始化栈        if (NULL == p)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;     //end if        while (p || !StackEmpty(S))        &#123;     //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p);    //p 所指节点入栈                printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）                p = p-&gt;lchild ;     //指向 p 的左孩子             &#125;//end if            else            &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树                StackPop(S, p);                p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈            &#125;    //end else        &#125;    //end while        free(S);    &#125;    //end PreTraverseTree2    /*二叉树的递归先序遍历*/    void preOrder(BiTNode *root)    &#123;        if (root)        &#123;            printf(&quot;%d &quot;, root-&gt;data);            preOrder(root-&gt;lchild);            preOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 中序遍历    ```cpp    /*二叉树的非递归中序遍历*/    void InOrderTraverseTree2(BitNode* root)    &#123;        StackNode* S; //定义一个栈指针        BitNode* p; //工作指针        S = NULL;        p = root;        S = InitStack(S); //初始化栈        if (NULL == p) &#123; //如果是空树            printf(&quot;树为空！\n&quot;) ;            return;        &#125;//end if        while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p); //将节点入栈                p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子            &#125;//end if            else            &#123;                StackPop(S, p); //p 左子树为空则出栈                printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点                p = p-&gt;rchild; //向右子树移动            &#125;//end else        &#125;//end while        free(S);    &#125;//end InOrderTraverseTree2    /*二叉树的递归中序遍历*/    void inOrder(BiTNode* root)    &#123;        if (root)        &#123;            inOrder(root-&gt;lchild);            printf(&quot;%d &quot;, root-&gt;data);            inOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 后序遍历    ```CPP    /*二叉树非递归后序遍历*/    void LastTraverseTree2(BiTNode* root)    &#123;        StackNode* S; BiTNode* cur, * pre;//定义一个栈指针        S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点        if (NULL == root)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;//end if        pre = NULL; cur = NULL;        StackPush(S, T); //根节点入栈        while (!StackEmpty(S))        &#123; //若栈非空            cur = NULL;            StackGetTop(S, cur); //将栈顶节点赋给 cur    /*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。    如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是    其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/            if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||                (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))            &#123;                printf(&quot;%c &quot;, cur-&gt;data);                pre = cur;                StackPop(S, cur);            &#125;//end if    //若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素    //的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。            else            &#123;                if (cur-&gt;rchild != NULL)                    StackPush(S, cur-&gt;rchild);                if (cur-&gt;lchild != NULL)                    StackPush(S, cur-&gt;lchild);            &#125;//end else        &#125;//end while        free(S);    &#125;//end LastTraverseTree2    /*二叉树递归后序遍历*/    void postOrder(BiTNode* root)    &#123;        if (root)        &#123;            postOrder(root-&gt;lchild);            postOrder(root-&gt;rchild);            printf(&quot;%d &quot;, root-&gt;data);        &#125;     &#125;    ```  - 层次遍历：自上而下，自左向右    - 首先，将二叉树的祖先节点入队列    - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队    ```cpp    void LayerOrder(BiTreeNode* head)    &#123;        LQueue Q;        Initiate_Queue(&amp;Q);        BiTreeNode* p;        if (head != NULL) AppendQueue(&amp;Q, head);        while (QueueNotEmpty(&amp;Q)) &#123;            p = QueueDelete(&amp;Q);            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);            if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);        &#125;    &#125;     ```  #### 哈夫曼树和哈夫曼编码  - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短    - 树的路径长度是指从根到每个节点的路径长度之和    - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值    - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和  - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度    ```cpp    ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0      &#123;          if (FBT == NULL) //空树返回0              return 0;          else          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点                  return FBT-&gt;data * len;              else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增                  return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);          &#125;      &#125;      ```  - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针      ```cpp    struct BTreeNode* CreateHuffman(ElemType a[], int n)      &#123;          int i, j;          struct BTreeNode **b, *q;          b = malloc(n*sizeof(struct BTreeNode));          for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点          &#123;              b[i] = malloc(sizeof(struct BTreeNode));              b[i]-&gt;data = a[i];              b[i]-&gt;left = b[i]-&gt;right = NULL;          &#125;          for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树          &#123;              //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标              int k1 = -1, k2;              for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵              &#123;                  if (b[j] != NULL &amp;&amp; k1 == -1)                  &#123;                      k1 = j;                      continue;                  &#125;                  if (b[j] != NULL)                  &#123;                      k2 = j;                      break;                  &#125;              &#125;              for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小              &#123;                  if (b[j] != NULL)                  &#123;                      if (b[j]-&gt;data &lt; b[k1]-&gt;data)                      &#123;                          k2 = k1;                          k1 = j;                      &#125;                      else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                          k2 = j;                  &#125;              &#125;              //由最小权值树和次最小权值树建立一棵新树，q指向树根结点              q = malloc(sizeof(struct BTreeNode));              q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;              q-&gt;left = b[k1];              q-&gt;right = b[k2];              b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置              b[k2] = NULL;//k2位置为空          &#125;          free(b); //删除动态建立的数组b          return q; //返回整个哈夫曼树的树根指针      &#125;      ```  - 哈夫曼编码    - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树    - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码    - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码    - 哈夫曼编码产生的是最短前缀码    ```cpp    void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0      &#123;          static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一          if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)              &#123;                  int i;                  printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);                  for (i = 0; i &lt; len; i++)                      printf(&quot;%d&quot;, a[i]);                  printf(&quot;\n&quot;);              &#125;              else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a              &#123;   //的对应元素中，向下深入一层时len值增1                  a[len] = 0;                  HuffManCoding(FBT-&gt;left, len + 1);                  a[len] = 1;                  HuffManCoding(FBT-&gt;right, len + 1);              &#125;          &#125;      &#125;      ```  ### 图  #### 图的基本概念  - 图由结点的有穷集合的 V 和边的集合  E 组成（`G(V,E)`）  - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示  - 路径长度：路径上边或者弧的数目  - 顶点的度：顶点关联边的数目    - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度    - 在有向图中，顶点的度就是两者之和    - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量    - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量  #### 图的存储结构  - 邻接矩阵    - 图的顺序存储结构    - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息    - 无向图中邻接矩阵是个对称矩阵    - 0表示无边，1表示有边    - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度     - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费    ```cpp    typedef struct    &#123;      int no;      char info;    &#125; VertexType;    typedef struct    &#123;      int edges[maxSize][maxSize];    //有权图中int改为float      int n,e;    //顶点数和边数      VertexType vex[maxSize];    //存放结点信息    &#125; MGragh;    ```  - 邻接表    - 数组和链表相结合的存储方法，图的链式存储结构    - 图中顶点用一个一维数组存储    - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表    - 顶点表的各个结点由 data 和 Firstedge 两个域表示      - data 是数据域，存储顶点信息      - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点    - 边表结点由 adjvex 和 next 两个域组成      - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标      - next 存储边表中下一个结点指针    - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表    ```cpp    typedef struct ArcNode    &#123;        int adnex;    //该边所指向的结点的位置        struct ArcNode * nextarc;    //指向下一条边的指针        int info;    //该边的相关信息(如权值)    &#125; ArcNode;    typedef struct    &#123;        char data;    //顶点信息        ArcNode* firstarc;    //指向第一条边的指针    &#125;VNode;    typedef struct    &#123;        VNode adjlist[maxSize];    //邻接表        int n, e;    //顶点数和边数    &#125; AGraph;    //图的邻接表类型    ```  - 十字链表    - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表    - 定点表      - firstin：入边表头指针，指向顶点入边表的第一个结点      - firstout：出边表头指针，指向顶点出边表第一个结点    - 边表      - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标      - headlink 入边表指针域，指向终点相同的下一条边      - taillink 是指边表指针域，指向起点相同的下一条边  - 邻接多重表    - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标    - ilink 指向依附项点 ivex 的下一条边    - jlink 指向依附顶点 jvex 的下一条边  #### 图的遍历算法  - 深度优先遍历（DFS，Depth First Search）     - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了    - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问    - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问    void DFSTraverse(Graph G)    &#123;        for (v = 0;v &lt; G.vexnum;++v)            visited[v] = false;    //初始化标记数组        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历                DFS(G, v);    &#125;    void DFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true; //定义为已访问        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])                DFS(G, w);    &#125;    ```  - 广度优先遍历（BFS，Breadth First Search）    - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点    - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完    - BFS 遍历的方式类似于树的层次遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组    void BFSTraverse(Graph G)    &#123;        for (i = 0;i &lt; G.vexnum;++i)            visited[v] = false;    //初始化标记数组        InitQueue(Q);        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历                BFS(G, v);    &#125;    void BFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true;    //定义为已访问        while (!isEmpty(Q))        &#123;            DeQueue(Q, v);            for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))                if (!visited[w])                &#123;                    visit(w);                    visited[w] = true;                    EnQueue(Q, w)                &#125;    //if        &#125;    //while    &#125;    ```  #### 最小生成树  - Prim 算法    - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树    - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树    - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树    ```cpp    void prim (G,T)    &#123;        T = ∅;        U = &#123;w&#125;;        while ((V - U) != ∅  )        &#123; //若图中不含全部顶点            设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;            T = T∪ (u，v); //边归入树            U = U∪ &#123;v&#125;;     //顶点归入树        &#125;    &#125;    ```  - Kruskal 算法    - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止    - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图    - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的    - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树      - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合      - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合    ```cpp    void kruskal（V，T）    &#123;        T = V;    //初始化树，仅含顶点        numS = n;    //不连分量的数目        while (numS &gt; 1)        &#123;            从 E 中取出权值最小的边（v,u）;            if（v 和 u 属于 T 中不同的连通分量）            &#123;                T = T∪（u，v）;//将此边加入到生成树中；                numS--; //不连通的分量减少 1            &#125;        &#125;    &#125;    ```  #### 最短路径  - Dijkstra 算法    - 通常用于求图中某一顶点到其余各顶点的最短路径    - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组    - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）    - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度  - Dijkstra 算法步骤    1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$    2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）    3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离    4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中    ```cpp    void Dijkstra(int v0)    &#123;      　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中          int n=MAXNUM;      　　for(int i=1; i&lt;=n; ++i)     　　 &#123;          　　dist[i] = A[v0][i];          　　S[i] = false;                                // 初始都未用过该点          　　if(dist[i] == MAXINT)                    　　prev[i] = -1;     　　     else                 　　prev[i] = v0;       　　&#125;       　 dist[v0] = 0;       　 S[v0] = true; 　　     　　 for(int i=2; i&lt;=n; i++)     　　 &#123;           　　int mindist = MAXINT;           　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值          　　 for(int j=1; j&lt;=n; ++j)          　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)          　　    &#123;             　　       u = j;                             // u保存当前邻接点中距离最小的点的号码              　 　      mindist = dist[j];           　　   &#125;           　　S[u] = true;            　　for(int j=1; j&lt;=n; j++)           　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)           　　    &#123;               　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径                 　    　&#123;                       　　dist[j] = dist[u] + A[u][j];    //更新dist                        　　prev[j] = u;                    //记录前驱顶点                 　　    &#125;            　    　&#125;       　　&#125;    &#125;    ```  - Floyd 算法    - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包    - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$    - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离    - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离  - Floyd 算法步骤    - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　    - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它    ```cpp    for (k = 1;k &lt;= n;k++)        for (i = 1;i &lt;= n;i++)            for (j = 1;j &lt;= n;j++)                if (a[i][j] &gt; a[i][k] + a[k][j])                    a[i][j] = a[i][k] + a[k][j];    ```  #### 拓扑排序  - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边    1. 从 DAG 图中选择一个没有前驱的节点并输出    2. 从图中删除该节点和所有以它为起点的有向边    3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止    ```cpp    bool topologicalSort(Graph GL)    &#123;        EdgeNode* e;        int top = 0; //用于栈指针下标         int count = 0; // 用于统计输出顶点的个数         int* stack; // 建栈将入度为 0 的顶点入栈         stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));        for (i = 0; i &lt; GL-&gt;numVertexes; i++)            if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈                 stack[++top] = i;        while (top != 0)        &#123;            gettop = stack[top--];            printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);            count++; //输出 i 号顶点，并计数             for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;                k = e-&gt;adjvex;                if (!(--GL-&gt;adjList[k].in))                    //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                     stack[++top] = k;            &#125;        &#125;        if (count &lt; GL-&gt;numVertexes) return false;        else return true;    &#125;    ```</code></pre><h3 id="矩阵与广义表-2"><a href="#矩阵与广义表-2" class="headerlink" title="矩阵与广义表"></a>矩阵与广义表</h3><h4 id="矩阵-2"><a href="#矩阵-2" class="headerlink" title="矩阵"></a>矩阵</h4><ul><li><p>矩阵的转置</p><pre><code class="cpp">void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            B[j][i] = A[i][j];&#125;</code></pre></li><li><p>矩阵相加</p><pre><code class="cpp">void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            C[i][j] = A[i][j] + B[i][j];&#125;</code></pre></li><li><p>矩阵相乘</p><pre><code class="cpp">void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; k;++j)        &#123;            C[i][j] = 0;            for int(h = 0;h &lt; n;++h)                C[i][j] += A[i][j] * B[i][j];        &#125;&#125;</code></pre></li><li><p>相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵</p><ul><li>对称矩阵、三角阵、对角矩阵</li></ul></li></ul><h4 id="广义表-2"><a href="#广义表-2" class="headerlink" title="广义表"></a>广义表</h4><ul><li>表元素可以是原子或者广义表的一种线性表的扩展结构</li><li>广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数</li><li>当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</li><li>原子结点有两个域：标志域和数据域</li><li>广义表结点有三个域：标志域，头指针域与尾指针域</li></ul><h3 id="树-2"><a href="#树-2" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念-2"><a href="#树的基本概念-2" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><ul><li>树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成<ul><li>结点不仅包含数据元素，并且包含指向子树的分支</li><li>结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值</li><li>树的高度是树中结点的最大层次，根结点的高度为树的高度</li></ul></li><li>树的双亲存储结构：<code>int tree[maxSize]</code></li><li>树的链式存储结构<ul><li>邻接表：孩子存储结构</li><li>孩子兄弟存储结构</li></ul></li></ul><h4 id="二叉树的概念和性质-2"><a href="#二叉树的概念和性质-2" class="headerlink" title="二叉树的概念和性质"></a>二叉树的概念和性质</h4><ul><li><p>二叉树的定义</p><ul><li>每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2</li><li>子树有左右顺序之分，不能颠倒</li></ul></li><li><p>满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层</p></li><li><p>完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的</p></li><li><p>二叉树的主要性质</p><ol><li><p>非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$</p></li><li><p>在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$</p></li><li><p>二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p><ul><li>若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）</li><li>若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点</li><li>若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点</li></ul></li><li><p>Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac{C_{2n}^{n}}{n+1}$  棵不同的二叉树</p></li><li><p>在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$</p></li></ol></li><li><p>二叉树的顺序存储结构最适用于完全二叉树</p></li><li><p>二叉树的链式存储结构</p><pre><code class="cpp">typedef struct BTNode&#123;    char  data;    //数据域    struct BTNoode* lchild;    struct BTNode* rchild;&#125; BTNode;</code></pre></li></ul><h4 id="二叉树的遍历算法-2"><a href="#二叉树的遍历算法-2" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><ul><li><p>先序遍历</p><pre><code class="cpp">/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123;    StackNode* S;   //定义一个栈指针    BitNode* p;   //工作指针    S = NULL;    p = root;    S = InitStack(S);   //初始化栈    if (NULL == p)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;     //end if    while (p || !StackEmpty(S))    &#123;     //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p);    //p 所指节点入栈            printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）            p = p-&gt;lchild ;     //指向 p 的左孩子         &#125;//end if        else        &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树            StackPop(S, p);            p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈        &#125;    //end else    &#125;    //end while    free(S);&#125;    //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123;    if (root)    &#123;        printf(&quot;%d &quot;, root-&gt;data);        preOrder(root-&gt;lchild);        preOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>中序遍历</p><pre><code class="cpp">/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123;    StackNode* S; //定义一个栈指针    BitNode* p; //工作指针    S = NULL;    p = root;    S = InitStack(S); //初始化栈    if (NULL == p) &#123; //如果是空树        printf(&quot;树为空！\n&quot;) ;        return;    &#125;//end if    while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p); //将节点入栈            p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子        &#125;//end if        else        &#123;            StackPop(S, p); //p 左子树为空则出栈            printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点            p = p-&gt;rchild; //向右子树移动        &#125;//end else    &#125;//end while    free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123;    if (root)    &#123;        inOrder(root-&gt;lchild);        printf(&quot;%d &quot;, root-&gt;data);        inOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>后序遍历</p><pre><code class="CPP">/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123;    StackNode* S; BiTNode* cur, * pre;//定义一个栈指针    S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点    if (NULL == root)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;//end if    pre = NULL; cur = NULL;    StackPush(S, T); //根节点入栈    while (!StackEmpty(S))    &#123; //若栈非空        cur = NULL;        StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/        if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||            (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))        &#123;            printf(&quot;%c &quot;, cur-&gt;data);            pre = cur;            StackPop(S, cur);        &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。        else        &#123;            if (cur-&gt;rchild != NULL)                StackPush(S, cur-&gt;rchild);            if (cur-&gt;lchild != NULL)                StackPush(S, cur-&gt;lchild);        &#125;//end else    &#125;//end while    free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123;    if (root)    &#123;        postOrder(root-&gt;lchild);        postOrder(root-&gt;rchild);        printf(&quot;%d &quot;, root-&gt;data);    &#125; &#125;</code></pre></li><li><p>层次遍历：自上而下，自左向右</p><ul><li>首先，将二叉树的祖先节点入队列</li><li>然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队</li></ul><pre><code class="cpp">void LayerOrder(BiTreeNode* head)&#123;    LQueue Q;    Initiate_Queue(&amp;Q);    BiTreeNode* p;    if (head != NULL) AppendQueue(&amp;Q, head);    while (QueueNotEmpty(&amp;Q)) &#123;        p = QueueDelete(&amp;Q);        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);        if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);    &#125;&#125; </code></pre></li></ul><h4 id="哈夫曼树和哈夫曼编码-2"><a href="#哈夫曼树和哈夫曼编码-2" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ul><li><p>哈夫曼树又叫做最优二叉树，它的特点是带权路径最短</p><ul><li>树的路径长度是指从根到每个节点的路径长度之和</li><li>带权路径长度是从该节点到根节之间的路径长度乘以结点的权值</li><li>树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和</li></ul></li><li><p>求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度</p><pre><code class="cpp">ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0  &#123;      if (FBT == NULL) //空树返回0          return 0;      else      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点              return FBT-&gt;data * len;          else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增              return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);      &#125;  &#125;  </code></pre></li><li><p>哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针  </p><pre><code class="cpp">struct BTreeNode* CreateHuffman(ElemType a[], int n)  &#123;      int i, j;      struct BTreeNode **b, *q;      b = malloc(n*sizeof(struct BTreeNode));      for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点      &#123;          b[i] = malloc(sizeof(struct BTreeNode));          b[i]-&gt;data = a[i];          b[i]-&gt;left = b[i]-&gt;right = NULL;      &#125;      for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树      &#123;          //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标          int k1 = -1, k2;          for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵          &#123;              if (b[j] != NULL &amp;&amp; k1 == -1)              &#123;                  k1 = j;                  continue;              &#125;              if (b[j] != NULL)              &#123;                  k2 = j;                  break;              &#125;          &#125;          for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小          &#123;              if (b[j] != NULL)              &#123;                  if (b[j]-&gt;data &lt; b[k1]-&gt;data)                  &#123;                      k2 = k1;                      k1 = j;                  &#125;                  else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                      k2 = j;              &#125;          &#125;          //由最小权值树和次最小权值树建立一棵新树，q指向树根结点          q = malloc(sizeof(struct BTreeNode));          q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;          q-&gt;left = b[k1];          q-&gt;right = b[k2];          b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置          b[k2] = NULL;//k2位置为空      &#125;      free(b); //删除动态建立的数组b      return q; //返回整个哈夫曼树的树根指针  &#125;  </code></pre></li><li><p>哈夫曼编码</p><ul><li>每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树</li><li>将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码</li><li>从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码</li><li>哈夫曼编码产生的是最短前缀码</li></ul><pre><code class="cpp">void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0  &#123;      static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一      if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)          &#123;              int i;              printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);              for (i = 0; i &lt; len; i++)                  printf(&quot;%d&quot;, a[i]);              printf(&quot;\n&quot;);          &#125;          else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a          &#123;   //的对应元素中，向下深入一层时len值增1              a[len] = 0;              HuffManCoding(FBT-&gt;left, len + 1);              a[len] = 1;              HuffManCoding(FBT-&gt;right, len + 1);          &#125;      &#125;  &#125;  </code></pre></li></ul><h3 id="图-2"><a href="#图-2" class="headerlink" title="图"></a>图</h3><h4 id="图的基本概念-2"><a href="#图的基本概念-2" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><ul><li>图由结点的有穷集合的 V 和边的集合  E 组成（<code>G(V,E)</code>）</li><li>图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示</li><li>路径长度：路径上边或者弧的数目</li><li>顶点的度：顶点关联边的数目<ul><li>有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度</li><li>在有向图中，顶点的度就是两者之和</li><li>在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量</li><li>在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量</li></ul></li></ul><h4 id="图的存储结构-2"><a href="#图的存储结构-2" class="headerlink" title="图的存储结构"></a>图的存储结构</h4><ul><li><p>邻接矩阵</p><ul><li>图的顺序存储结构</li><li>用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息</li><li>无向图中邻接矩阵是个对称矩阵</li><li>0表示无边，1表示有边</li><li>顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 </li><li>邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费</li></ul><pre><code class="cpp">typedef struct&#123;  int no;  char info;&#125; VertexType;typedef struct&#123;  int edges[maxSize][maxSize];    //有权图中int改为float  int n,e;    //顶点数和边数  VertexType vex[maxSize];    //存放结点信息&#125; MGragh;</code></pre></li><li><p>邻接表</p><ul><li>数组和链表相结合的存储方法，图的链式存储结构</li><li>图中顶点用一个一维数组存储</li><li>图中每个顶点 $V_i$ 的所有邻接点构成一个线性表</li><li>顶点表的各个结点由 data 和 Firstedge 两个域表示<ul><li>data 是数据域，存储顶点信息</li><li>firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点</li></ul></li><li>边表结点由 adjvex 和 next 两个域组成<ul><li>adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标</li><li>next 存储边表中下一个结点指针</li></ul></li><li>有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表</li></ul><pre><code class="cpp">typedef struct ArcNode&#123;    int adnex;    //该边所指向的结点的位置    struct ArcNode * nextarc;    //指向下一条边的指针    int info;    //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123;    char data;    //顶点信息    ArcNode* firstarc;    //指向第一条边的指针&#125;VNode;typedef struct&#123;    VNode adjlist[maxSize];    //邻接表    int n, e;    //顶点数和边数&#125; AGraph;    //图的邻接表类型</code></pre></li><li><p>十字链表</p><ul><li>在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表</li><li>定点表<ul><li>firstin：入边表头指针，指向顶点入边表的第一个结点</li><li>firstout：出边表头指针，指向顶点出边表第一个结点</li></ul></li><li>边表<ul><li>tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标</li><li>headlink 入边表指针域，指向终点相同的下一条边</li><li>taillink 是指边表指针域，指向起点相同的下一条边</li></ul></li></ul></li><li><p>邻接多重表</p><ul><li>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标</li><li>ilink 指向依附项点 ivex 的下一条边</li><li>jlink 指向依附顶点 jvex 的下一条边</li></ul></li></ul><h4 id="图的遍历算法-1"><a href="#图的遍历算法-1" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h4><ul><li><p>深度优先遍历（DFS，Depth First Search） </p><ul><li>首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了</li><li>若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问</li><li>深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123;    for (v = 0;v &lt; G.vexnum;++v)        visited[v] = false;    //初始化标记数组    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历            DFS(G, v);&#125;void DFS(Graph G, int v)&#123;    visit(v);    visited[v] = true; //定义为已访问    for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))        if (!visited[w])            DFS(G, w);&#125;</code></pre></li><li><p>广度优先遍历（BFS，Breadth First Search）</p><ul><li>首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点</li><li>然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完</li><li>BFS 遍历的方式类似于树的层次遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组void BFSTraverse(Graph G)&#123;    for (i = 0;i &lt; G.vexnum;++i)        visited[v] = false;    //初始化标记数组    InitQueue(Q);    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历            BFS(G, v);&#125;void BFS(Graph G, int v)&#123;    visit(v);    visited[v] = true;    //定义为已访问    while (!isEmpty(Q))    &#123;        DeQueue(Q, v);        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])            &#123;                visit(w);                visited[w] = true;                EnQueue(Q, w)            &#125;    //if    &#125;    //while&#125;</code></pre></li></ul><h4 id="最小生成树-1"><a href="#最小生成树-1" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li><p>Prim 算法</p><ul><li>从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树</li><li>然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树</li><li>以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树</li></ul><pre><code class="cpp">void prim (G,T)&#123;    T = ∅;    U = &#123;w&#125;;    while ((V - U) != ∅  )    &#123; //若图中不含全部顶点        设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;        T = T∪ (u，v); //边归入树        U = U∪ &#123;v&#125;;     //顶点归入树    &#125;&#125;</code></pre></li><li><p>Kruskal 算法</p><ul><li>将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止</li><li>Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图</li><li>普里姆算法和克鲁斯卡尔算法都是针对于无向图的</li><li>判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树<ul><li>通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合</li><li>通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合</li></ul></li></ul><pre><code class="cpp">void kruskal（V，T）&#123;    T = V;    //初始化树，仅含顶点    numS = n;    //不连分量的数目    while (numS &gt; 1)    &#123;        从 E 中取出权值最小的边（v,u）;        if（v 和 u 属于 T 中不同的连通分量）        &#123;            T = T∪（u，v）;//将此边加入到生成树中；            numS--; //不连通的分量减少 1        &#125;    &#125;&#125;</code></pre></li></ul><h4 id="最短路径-1"><a href="#最短路径-1" class="headerlink" title="最短路径"></a>最短路径</h4><ul><li><p>Dijkstra 算法</p><ul><li>通常用于求图中某一顶点到其余各顶点的最短路径</li><li>设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组</li><li>第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）</li><li>第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度</li></ul></li><li><p>Dijkstra 算法步骤</p><ol><li>初始时，S 只包含源点，即 S＝{v}，v 的距离为 0，U 包含除 v 外的其他顶点，即:U={其 余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$</li><li>从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）</li><li>以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离</li><li>重复步骤 b 和 c 直到所有顶点都包含在 S 中</li></ol><pre><code class="cpp">void Dijkstra(int v0)&#123;  　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中      int n=MAXNUM;  　　for(int i=1; i&lt;=n; ++i) 　　 &#123;      　　dist[i] = A[v0][i];      　　S[i] = false;                                // 初始都未用过该点      　　if(dist[i] == MAXINT)                　　prev[i] = -1; 　　     else             　　prev[i] = v0;   　　&#125;   　 dist[v0] = 0;   　 S[v0] = true; 　　 　　 for(int i=2; i&lt;=n; i++) 　　 &#123;       　　int mindist = MAXINT;       　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值      　　 for(int j=1; j&lt;=n; ++j)      　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)      　　    &#123;         　　       u = j;                             // u保存当前邻接点中距离最小的点的号码          　 　      mindist = dist[j];       　　   &#125;       　　S[u] = true;        　　for(int j=1; j&lt;=n; j++)       　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)       　　    &#123;           　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径             　    　&#123;                   　　dist[j] = dist[u] + A[u][j];    //更新dist                    　　prev[j] = u;                    //记录前驱顶点             　　    &#125;        　    　&#125;   　　&#125;&#125;</code></pre></li><li><p>Floyd 算法</p><ul><li>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包</li><li>Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$</li><li>Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离</li><li>对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离</li></ul></li><li><p>Floyd 算法步骤</p><ul><li>从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它</li></ul><pre><code class="cpp">for (k = 1;k &lt;= n;k++)    for (i = 1;i &lt;= n;i++)        for (j = 1;j &lt;= n;j++)            if (a[i][j] &gt; a[i][k] + a[k][j])                a[i][j] = a[i][k] + a[k][j];</code></pre></li></ul><h4 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul><li><p>对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边</p><ol><li>从 DAG 图中选择一个没有前驱的节点并输出</li><li>从图中删除该节点和所有以它为起点的有向边</li><li>重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止</li></ol><pre><code class="cpp">bool topologicalSort(Graph GL)&#123;    EdgeNode* e;    int top = 0; //用于栈指针下标     int count = 0; // 用于统计输出顶点的个数     int* stack; // 建栈将入度为 0 的顶点入栈     stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));    for (i = 0; i &lt; GL-&gt;numVertexes; i++)        if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈             stack[++top] = i;    while (top != 0)    &#123;        gettop = stack[top--];        printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);        count++; //输出 i 号顶点，并计数         for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;            k = e-&gt;adjvex;            if (!(--GL-&gt;adjList[k].in))                //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                 stack[++top] = k;        &#125;    &#125;    if (count &lt; GL-&gt;numVertexes) return false;    else return true;&#125;</code></pre></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><ul><li>排序：将原本无序的序列重新排列成有序序列的过程，这个序列中的每一项可能是单独的数据元素，也可能是一条记录</li><li>记录由多个数据元素组成的，既可以按照记录的主关键字排序（主关键字唯一标识一条记录），也可以按照记录的次关键字排序</li><li>稳定性：当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关键字的相对位置，如果没有发生变化就是稳定的，否则就是不稳定的</li><li>排序算法的分类<ul><li>插入类的排序：直接插入、折半插入、希尔排序</li><li>交换类的排序：冒泡排序、快速排序</li><li>选择类的排序：简单选择、堆选择</li><li>归并类的排序：二路归并</li><li>基数类的排序：多关键字排序</li></ul></li></ul><h4 id="插入类的排序"><a href="#插入类的排序" class="headerlink" title="插入类的排序"></a>插入类的排序</h4><ul><li><p>插入排序</p><pre><code class="cpp">void InsertSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int i,j;    //i是次数，也即排好的个数;j是继续排    for(i=1;i&lt;len;++i)        for(j=i;j&gt;0;--j)            if(h[j]&lt;h[j-1]) Swap(h[j],h[j-1]);            else break;    return;&#125;</code></pre></li><li><p>希尔排序</p><ul><li>缩小增量排序：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序</li><li>随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</li></ul><pre><code class="cpp">void ShellSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    for(int div=len/2;div&gt;=1;div/=2)        for(int k=0;k&lt;div;++k)            for(int i=div+k;i&lt;len;i+=div)                for(int j=i;j&gt;k;j-=div)                    if(h[j]&lt;h[j-div]) Swap(h[j],h[j-div]);                    else break;    return;&#125;</code></pre></li></ul><h4 id="交换类的排序"><a href="#交换类的排序" class="headerlink" title="交换类的排序"></a>交换类的排序</h4><ul><li><p>快速排序</p><pre><code class="cpp">void QuickSort(SeqList R，int low，int high) &#123; //对 R[low..high]快速排序     int pivotpos； //划分后的基准记录的位置         if (low &lt; high) &#123; //仅当区间长度大于 1 时才须排序             pivotpos = Partition(R，low，high)； //对 R[low..high]做划分                 QuickSort(R，low，pivo t   pos-1)； //对左区间递归排序                 QuickSort(R，pivotp o s+1，high)； //对右区间递归排序         &#125;&#125; //QuickSort</code></pre></li><li><p>冒泡排序</p><ul><li>通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置</li></ul><pre><code class="cpp">void BubbleSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    //i是次数，j是具体下标    for(int i=0;i&lt;len-1;++i)        for(int j=0;j&lt;len-1-i;++j)            if(h[j]&gt;h[j+1])                Swap(h[j],h[j+1]);    return;&#125;</code></pre></li></ul><h4 id="选择类的排序"><a href="#选择类的排序" class="headerlink" title="选择类的排序"></a>选择类的排序</h4><ul><li><p>选择排序</p><ul><li>初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</li><li>每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置</li></ul><pre><code class="cpp">void SelectionSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int minindex,i,j;    //i是次数，也即排好的个数;j是继续排    for(i=0;i&lt;len-1;++i)    &#123;        minindex=i;        for(j=i+1;j&lt;len;++j)        &#123;            if(h[j]&lt;h[minindex]) minindex=j;        &#125;        Swap(h[i],h[minindex]);    &#125;    return;&#125;</code></pre></li><li><p>堆排序</p><ul><li>堆实际上是一棵完全二叉树，堆的每一个父节点都大于（或小于）其子节点，堆的每个左子树和右子树也是一个堆</li><li>最大堆（大顶堆）：堆的每个父节点都大于其孩子节点；最小堆（小顶堆）：堆的每个父节点都小于其孩子节点</li><li>堆的第一个元素要么是最大值（大顶堆），要么是最小值（小顶堆），这样在排序的时候（假设共 n 个节点），直接将第一个元素和最后一个元素进行交换，然后从第一个元素开始进行向下调整至第 n-1 个元素。所以，如果需要升序，就建一个大堆，需要降序，就建一个小堆</li></ul><pre><code class="cpp">void HeapSort(SeqIAst R)&#123; //对 R[1..n]进行堆排序，不妨用 R[0]做暂存单元     int i；        BuildHeap(R)； //将 R[1-n]建成初始堆         for (i = n;i &gt; 1；  i  -)        &#123; //对当前无序区 R[1..i]进行堆排序，共做 n-1 趟            R[0] = R[1];            R[1] = R[i];            R[i] = R[0];//将堆顶和堆中最后一个记录交换             Heapify(R，1 ，i-1); //将 R[1..i-1]重新调整为堆，仅有 R[1]可能违反堆性质         &#125; //endfor &#125; //HeapSort</code></pre></li></ul><h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><ul><li><p>MERGE-SORT：利用归并的思想实现的排序方法，采用经典的分治（divide-and-conquer）策略</p></li><li><p>递归拆分子序列，将两个已经有序的子序列合并成一个有序序列</p><pre><code class="cpp">void MergeSortDC(SeqList R，int low，int high) &#123;//用分治法对 R[low..high]进行二路归并排序  int mid；  if(low&lt;high)&#123; //区间长度大于 1  mid=(low+high)/2； //分解  MergeSortDC(R，low，mid); //递归地对 R[low..mid]排序  MergeSortDC(R，mid+1，high)； //递归地对 R[mid+1..high]排序  Merge(R，low，mid，high)； //组合，将两个有序区归并为一个有序区  &#125; &#125;//MergeSortDC </code></pre></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li><p>不需要比较关键字的大小，根据关键字中各位的值，通过对排序的N个元素进行若干趟分配与收集来实现排序的</p></li><li><p>时间复杂度为 $O\left( d\left( n+r_{d}\right) \right)$</p><pre><code class="cpp">int GetMaxDight(int* h, int len)&#123;    if(h==NULL) return 0;    if(len&lt;1) return 0;    int max=h[0];    for(int i=1;i&lt;len;++i)    &#123;        if(h[i]&gt;max) max=h[i];    &#125;    int digit=1;    while(max/10!=0)    &#123;        max/=10;        ++digit;    &#125;    return digit;&#125;int GetReminder(int value,int digit)&#123;    int div=1;    for(int i=1;i&lt;digit;++i)        div*=10;    return value/div%10;&#125;void RadixSort_LSD(int* h, int len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int digit=GetMaxDight(h,len);    //printf(&quot;MaxDigit:%d\n&quot;, digit);    int count[10]=&#123;0&#125;;    int *tmp=(int*)calloc(len,sizeof(int));    for(int d=1;d&lt;=digit;++d)    &#123;        memset(count,0,sizeof(count));        for(int i=0;i&lt;len;++i)        &#123;            count[GetReminder(h[i],d)]++;        &#125;        //求右边界        for(int i=1;i&lt;10;++i)        &#123;            count[i]+=count[i-1];        &#125;        for(int i=len-1;i&gt;=0;--i)        &#123;            int r=GetReminder(h[i],d);            int index=count[r];            tmp[index-1]=h[i];            count[r]--;        &#125;        memcpy(h,tmp,len*sizeof(int));    &#125;    free(tmp);&#125;void RadixSort_LSD_Reverse(int* h, int len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int digit=GetMaxDight(h,len);    //printf(&quot;MaxDigit:%d\n&quot;, digit);    int count[10]=&#123;0&#125;;    int *tmp=(int*)calloc(len,sizeof(int));    for(int d=1;d&lt;=digit;++d)    &#123;        memset(count,0,sizeof(count));        for(int i=0;i&lt;len;++i)        &#123;            count[GetReminder(h[i],d)]++;        &#125;        //printf(&quot;haha\n&quot;);        //求右边界        for(int i=8;i&gt;=0;--i)        &#123;            count[i]+=count[i+1];        &#125;        for(int i=len-1;i&gt;=0;--i)        &#123;            int r=GetReminder(h[i],d);            int index=count[r];            tmp[index-1]=h[i];            count[r]--;        &#125;        memcpy(h,tmp,len*sizeof(int));    &#125;    free(tmp);&#125;</code></pre></li></ul><h4 id="排序知识点总结"><a href="#排序知识点总结" class="headerlink" title="排序知识点总结"></a>排序知识点总结</h4><ul><li>快速排序、希尔排序、归并排序、堆排序的平均时间复杂度都是 $O\left( n\log _{2}n\right)$，其他都是 $O(n^2)$</li><li>快速排序的空间复杂度为 $O\left( \log <em>{2}n\right)$，归并排序的空间复杂度为 $O\left( n\right)$，基数排序的空间复杂度为 $O\left( r</em>{d}\right)$，其他都是 $O(1)$</li><li>快速排序、希尔排序、简单选择排序、堆排序是不稳定的，其他都是稳定的</li><li>交换类和选择类的排序，经过一趟排序能够保证一个关键字到达最终位置</li><li>简单选择排序和折半插入排序的关键字比较次数和原始序列无关</li><li>交换类的排序趟数和原始序列有关</li><li>直接插入按顺序查找的方式，而折半插入按折半查找的方式排序</li><li>借助于比较进行排序的算法在最坏情况下的时间复杂度至少为 $O\left( n\log _{2}n\right)$</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h4><ul><li><p>给定一个值 K，在含有 n 个记录的表中找出关键字等于 K 的记录叫查找，记录即为关键字</p></li><li><p>通常把查找过程中对关键字的平均比较次数（也称平均查找长度）作为衡量一个查找算法优劣的标准</p></li><li><p>平均查找长度 $ASL=\sum ^{n}<em>{i=1}p</em>{i}\times c_{i}$</p><ul><li>$p_{i}$ 为查找第 i 个记录的概率，$c_{i}$ 为找到第 i 个记录所需要进行比较的次数（查找长度）</li></ul></li><li><p>顺序查找</p><ul><li>用待查找的关键字和给定序列中的各元素的关键字从左到右（或从右到左）依次进行比较，直到成功或失败</li><li>存储结构通常是顺序结构，也可是链式结构</li></ul><pre><code class="cpp">//顺序表的查找（不带监视哨）int SeqSearch(SSTable S, DataType x)&#123;    int i = 0;    while (i &gt; s.length &amp; S.list[i].key != x.key)        i++;    if (s.list[i].key == x.key)        return i + 1;    return 0;&#125;//顺序表的查找（带监视哨）int SeqSearch2(SSTable S, DataType x)&#123;    int i = S.length;    //将关键字存放在0位置处,防止越界    /*哨兵的主要作用就是在查找循环中监视下标i是否越界      一旦越界(i=0),因为可以和自己进行比较,循环判定条件      不成立就使得查找循环结束,就可以达到忽略判定边界条件的目的*/    s.list[o].key = x.key;    while (s.list[i].key != x.key)        i--;    return i;    // 实际上,一切为简化边界条件而引入的附加结点(元素)均可称为哨兵&#125;//顺序表的查找（链表实现）Node* Search(Lnode* head, int key)&#123;    LNode* p = head-&gt;next;    while (p != NUll)    &#123;        if (P-&gt;data == key)            return p;        p = p-&gt;next;    &#125;    return NULL;&#125;</code></pre></li><li><p>二分查找</p><ul><li>要求线性表是有序的</li><li>在给定序列是有序表的前提下，将表中间位置处的关键字和查找关键字比较，相 等则查找成功</li><li>否则从中间位置将表分成前后两个子表，如果中间位置处的关键字大于 查找关键字，则进一步查找前子表，否则查找后子表</li><li>重复以上过程，直到找到满足条件的记录，此时查找成功，或直到子表不存在为止，表示查找失败</li></ul><pre><code class="cpp">int BSearch(int arr[], int low, int high, int key) &#123;    while (low &lt;= high) &#123;        int mid = (low + high) / 2;        if (arr[mid == key])            return mid;        else if (arr[mid] &gt; key)            high = mid - 1;        else            low = mid + 1;    &#125;    return -1;&#125;</code></pre></li></ul><h4 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h4><ul><li><p>二叉排序树要么是空树,要么是满足下列要求的树</p><ul><li>若它的左子树不空，则左子树上所有的关键字的值均小于根节点关键字值</li><li>若它的右子树不空，则右子树上所有的关键字的值均大于根节点关键字值</li><li>左右子树又各是一棵二叉排序树</li></ul></li><li><p>Binary Search Tree 又被叫做二叉搜索树 or 二叉查找树</p></li><li><p>在对某个关键字进行查找的时候，首先和二叉排序树的根节点进行比较，若相等则査找成功</p></li><li><p>由于二叉排序树本身的性质，若该关键字小于根节点值，则再与其左子树进行比较,否则和其右子树进行比较，直到找到与之相等的节点，则查找成功</p></li><li><p>若待比较的位置来到空指针处，则表示査找失败，返回失败的标记</p><pre><code class="cpp">//非递归算法BTNode* BSTSearch(BTNode* p, int key) &#123;    while (p != NULL) &#123;        if (key == p-&gt;key)            return p;        else if (key &lt; p-&gt;key)            p = p-&gt;lChild;        else            p = p-&gt;rChild;    &#125;    return NULL;&#125;//递归算法BTNode* BSTSearch2(BTNode* p, int key) &#123;    if (p == NULL)        return NULL;    else&#123;        if (key == p-&gt;key)            return p;        else if (key &lt; p-&gt;key)            return BSTSearch2(p-&gt;lChild, key);        else            return BSTSearch2(p-&gt;rChild, key);    &#125;&#125;</code></pre></li></ul><h4 id="平衡二叉树（AVL-树）"><a href="#平衡二叉树（AVL-树）" class="headerlink" title="平衡二叉树（AVL 树）"></a>平衡二叉树（AVL 树）</h4><ul><li>平衡二叉树是一种特殊的二叉排序树，其左右子树都是平衡二叉树且左右子树高度之差的绝对值不超过1</li><li>一个节点的平衡因子为其左子树的高度减去右子树的高度，对于平衡二叉树，树中所有结点的平衡因子取值只可能是-1、0、1</li><li>若向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性，则首先要找出插入新节点后失去平衡的最小子树，然后再调整这颗子树使之成为平衡子树</li><li>当失去平衡的最小子树被调整为平衡子树后，无需调整原有其他所有的不平衡子树</li><li>最小不平衡子树：是以距离插入结点最近且以平衡因子绝对值大于1的结点作为跟的子树，又称为失去平衡的最小子树</li></ul><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><ul><li><p>Hash：根据给定的关键字来计算出关键字在表中的地址</p></li><li><p>Hash table（哈希表）：是根据关键码值（Key value）而直接进行访问的数据结构，=通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>给定表 M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希表，函数 f(key) 为哈希函数</p></li><li><p>键（key）：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分</p></li><li><p>槽（slot/bucket）：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器</p></li><li><p>哈希函数（hash function）：将 key 映射 map 到数据应该存放的槽 slot 所在位置的函数</p></li><li><p>哈希冲突（hash collision）：哈希函数将两个不同的键映射到同一个索引的情况</p><pre><code class="cpp">int h1(int x)&#123;  return (x%5);&#125;int h2(char* x)&#123;  int i,sum;  for(sum=0, i=0; x[i] != &#39;\0&#39;; i++)    sum += (int)x[i];  return (sum%5);&#125;int ELFhash(char*key)&#123;    unsigned long h=0;    while(*key)    &#123;        h = (h &lt;&lt; 4) + *key++;        unsigned long g = h &amp; 0xF0000000L;        if(g)            h ^= g &gt;&gt; 24;        h &amp;= ~g;    &#125;    return h % MOD;&#125;</code></pre></li><li><p>散列表的性能分析（查找成功时的平均查找长度）：找到表中已有表项的平均次数</p></li><li><p>装填因子是关键字个数和表长度的比值</p></li></ul><h3 id="常用算法补充"><a href="#常用算法补充" class="headerlink" title="常用算法补充"></a>常用算法补充</h3><ul><li><p>动态规划算法</p><ul><li>处理多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态</li><li>这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线）</li><li>动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处</li></ul><pre><code class="cpp">for (j = 1; j &lt;= m; j = j + 1) // 第一个阶段    xn[j] = 初始值;for (i = n - 1; i &gt; = 1; i = i - 1)// 其他n-1个阶段    for (j = 1; j &gt;= f(i); j = j + 1)//f(i)与i有关的表达式        xi[j] = j = max&#123; g(xi - 1[j1:j2]), ...... ,  g(xi - 1[jk:jk + 1]) &#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for (i = 2; i &lt;= n - 1; i = i + 1)&#123;    t = t - xi - 1[ji];    for (j = 1; j &gt;= f(i); j = j + 1)        if (t = xi[ji])            break;&#125;</code></pre></li><li><p>贪心算法</p><ul><li>在对问题求解时，总是做出在当前看来是最好的选择，局部最优解</li><li>整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的</li><li>贪心算法建立哈夫曼树</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct BTreeNode&#123;    int  data;    struct BTreeNode* left;    struct BTreeNode* right;&#125;btreenode;//建立哈夫曼树btreenode *CreateHuffman(int a[],int n)&#123;    int i;    btreenode *s[n+1], *ss;    for(int i = 0;i&lt;n;i++)&#123;        s[i] = new btreenode;  //初始化s指针数组，使每个指针元素指向a数组中对应的元素结点        s[i]-&gt;data = a[i];   //将树拆成森林，每棵树都只有一个根节点        s[i]-&gt;left = s[i]-&gt;right = NULL;    &#125;    for(int i  = 1;i&lt;n;i++)&#123;        //进行 n-1次循环建立哈夫曼树           int k = -1,t;           //k表示森林中具有最小权值的树根结点的下标，t为次最小的下标        for(int j = 0;j&lt;n;j++)&#123;   //k初始指向森林中第一棵树，t指向第二棵                if(s[j]&amp;&amp;k==-1)&#123;                   k = j;                   continue;                &#125;                if(s[j])&#123;                    t =  j;                    break;                &#125;        &#125;        for(int i = t;i&lt;n;i++)&#123;   //从当前森林中求出最小权值树和次最小 ；            if(s[i])&#123;                if(s[i]-&gt;data&lt;s[k]-&gt;data)&#123;        //比最小树小                    t = k;                    k = i;                &#125;                else if(s[i]-&gt;data&lt;s[t]-&gt;data)&#123;  //比次小树小                    t = i;                &#125;                else&#123;                    ;                &#125;            &#125;        &#125;           //由最小权值树和次最小权值树建立一棵新树，ss指向树根结点(以后依次建立)           ss  = new btreenode;     //ss = (btreenode *)malloc(sizeof(btreenode))           ss-&gt;data =   s[k]-&gt;data+s[t]-&gt;data;           ss-&gt;left =   s[k];           ss-&gt;right =  s[t];           s[k] =  ss;  //关键点:将ss赋给s[k](k为上述找到的最小树下标,但这是s[k]代表的值已改变，同时把s[t]失效的置空,                       //在这里起向下一个判断的作用if(s[j])&#123;t = j;break;&#125;           s[t] = NULL;    &#125;        free(s);   //释放分配空间        return ss;&#125;//求哈夫曼树的带权路径长度int WeightPathLength(btreenode* FBT, int len)&#123;          //参数len为树的层数    if(!FBT)&#123;        return 0;    &#125;    else&#123;        if(FBT-&gt;left ==NULL&amp;&amp;FBT-&gt;right ==NULL)//访问到叶子结点            return FBT-&gt;data*len;        else&#123;               //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增            return  WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);//一定要记得加1        &#125;    &#125;&#125;//哈夫曼编码void HuffManCoding(btreenode* FBT, int len)&#123;   //参数len为树的层数    static int a[20];                        //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减1    if(FBT)&#123;                                 //访问到叶子结点时输出其保存在数组a中的0和1序列编码        if(FBT-&gt;left == NULL&amp;&amp;FBT-&gt;right == NULL)&#123;             printf(&quot;结点权值为%d的编码:&quot;,FBT-&gt;data);             for(int i = 0;i&lt;len;i++)&#123;                 printf(&quot;%d&quot;,a[i]);            &#125;                printf(&quot;\n&quot;) ;        &#125;        else&#123;    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组                //a的对应元素中，向下深入一层时len值增1               a[len] = 0;               HuffManCoding(FBT-&gt;left,len+1);               a[len] = 1;               HuffManCoding(FBT-&gt;right,len+1);            &#125;    &#125;&#125;int main()&#123;    btreenode *s;    int n;    printf(&quot;从键盘输入待构造的哈夫曼树中带权叶子结点数n：&quot;);    while(true)&#123;        scanf(&quot;%d&quot;,&amp;n);        if(n&gt;0)&#123;            break;        &#125;        else&#123;            printf(&quot;-------输入不合法,请重新输入!!\n&quot;);        &#125;    &#125;    int *a = (int *)malloc(n *sizeof(int));    printf(&quot;从键盘输入%d个整数作为权值:&quot;,n);    for (int i = 0; i &lt; n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    s = CreateHuffman(a,n);    printf(&quot;哈夫曼树的带权路径长度：&quot;);    printf(&quot;%d\n&quot;, WeightPathLength(s, 0));    printf(&quot;树中每个叶子结点的哈夫曼编码：\n&quot;);    HuffManCoding(s,0);    return 0;&#125;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构&lt;a href=&quot;https://www.icourse163.org/course/ZJU-93001&quot;&gt;国家精品课&lt;/a&gt;，以下为所记课堂笔记，另外我在开源仓库中还保持了浙大慕课版本的&lt;a href=&quot;https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot;&gt;代码&lt;/a&gt;，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法与数据结构" scheme="http://blog.zhuangzhihao.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>白话机器学习算法</title>
    <link href="http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-30T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.845Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。<a href="https://book.douban.com/subject/30442187/">白话机器学习算法</a>一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。以下为阅读过程中所作的读书笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="为何需要数据科学"><a href="#为何需要数据科学" class="headerlink" title="为何需要数据科学"></a>为何需要数据科学</h3><ul><li>借助现代计算机和高级算法，我们能够做到以下几点：<ol><li>从大型数据集中发现隐藏的趋势</li><li> 充分利用发现的趋势做预测</li><li>计算每种结果出现的概率</li><li>快速获取准确结果</li></ol></li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4><ul><li>数据格式：数据点、数据集</li><li>变量（variable）：用于描述数据点，又叫属性、特征或维度<ul><li>二值变量（binary variable）：最简单的变量类型，只有2个可选值</li><li>分类变量（categorical variable）：用来表示有2个以上选择的情况</li><li>整型变量（integer variable）：用来表示整数</li><li>连续变量（continuous variable）：用来表示小数</li></ul></li><li>变量选择是一个试错的过程，需要根据反馈结果不断更换变量，选取那些最有希望的变量，以待进一步分析</li><li>特征工程（feature engineering）是将原始数据转化成更好的表达问题本质的特征的过程，使得将这些特征运用到预测模型中能提高对不可见数据的模型预测精度</li><li>解决数据缺失：近似、计算、移除</li></ul><h4 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h4><ul><li>无监督学习（unsupervised learning）：依靠算法从数据中找出隐藏的模式<ul><li>k 均值聚类、主成分分析、关联规则、社会网络分析</li><li>通过间接手段，可以对无监督学习模型输出的结果进行验证</li></ul></li><li>监督学习（supervised learning）：基于数据中已有的模式做预测<ul><li>回归分析、k 最近邻、支持向量机、决策树、随机森林（random forest）、神经网络</li></ul></li><li>强化学习（reinforcement learning）：使用数据中的模式做预测，并根据越来越多的反馈结果不断改进</li><li>除了要了解算法使用的任务类型外，还要了解各种算法对不同数据类型的分析能力，以及结果的本质</li></ul><h4 id="参数调优（parameter-tuning）"><a href="#参数调优（parameter-tuning）" class="headerlink" title="参数调优（parameter tuning）"></a>参数调优（parameter tuning）</h4><ul><li>不同的算法有不同的调节参数，即便是同一个算法，如果参数调的不一样，所产生的结果也各不相同</li><li>过拟合模型：过度敏感，把数据中的随机波动当成持久模式，对当前数据有着很高的预测准确度，但是对未知数据的预测准确度较差（泛化能力不强）</li><li>欠拟合模型（underfitting）：过于愚钝，很可能会忽视数据中的重要趋势，这会导致模型对当前数据和未知数据的预测准确度下降</li><li>理想拟合：算法能在识别主要趋势和忽视微小变化之间找到平衡，使最终得到的模型非常适合做预测</li><li>对于大多数模型而言，过拟合（overfitting）是常见问题，所以增加预测模型的复杂度能最大限度的减少预测误差，但容易出现预测边界过度复杂</li><li>通过正则化（regularization）引入惩罚参数，通过人为增大预测误差，对模型复杂度的增加进行惩罚，从而使算法同时考虑复杂度和准确度使模型保持简单，有助于提高模型的泛化能力</li></ul><h4 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h4><ul><li>使用一些评价指标来比较模型的预测准确度：预测准确率、混淆矩阵和均方根误差（root mean squared error）</li><li>分类指标（classification）<ul><li>预测准确率：正确预测所占的比率，无法通过预测准确率得知预测误差是如何产生的</li><li>混淆矩阵（confusion matrix）：在预测准确率的基础上添加假正类型和假负类型，辨别预测误差数</li></ul></li><li>回归指标<ul><li>由于回归预测使用连续值，因此误差一般被量化成预测值和实际值之差，惩罚随误差大小而不同</li><li>均方根误差：将每个误差都取平方，放大大误差，这使得均方根误差对异常值极其敏感，对这些值的惩罚力度也更大，避免较大的误差</li></ul></li><li>验证：评估模型对新数据的预测准确度，避免过拟合模型在面对当前数据表现良好而面对新数据时可能表现糟糕的情况</li><li>在评估模型时并不一定非要使用新数据，而是可以把当前的数据集划分成训练集（training dataset）和测试集（test dataset）<ul><li>训练集用来生成和调整预测模型，测试集用来充当新数据并评估模型的预测准确度</li><li>最好的模型针对测试集所做的预测一定是最准确的</li><li>为了使验证（validation）过程行之有效，需要不带偏差的把数据点随机分派到数据集和测试集中</li></ul></li><li>交叉验证（cross-validation）：使用同一个数据集进行训练和测试，避免因为原始数据集很小而无法留出足够的数据形成测试集的情况<ul><li>把数据集划分成若干组用来对模型进行反复测试</li><li>在单次迭代中除了某一组外其他各组都被用来训练预测模型，然后留下来的那组被用来测试模型</li><li>这个过程重复进行直到每一个组都测试过模型，并且只测试过一次</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>数据科学研究的 4 个主要步骤：<ol><li>准备待分析的数据</li><li>根据研究需求挑选合适的算法，为数据建立模型</li><li>对算法的参数进行调优，优化模型</li><li>根据准确度评价模型</li></ol></li></ul><h3 id="k-均值聚类（k-means-clustering）"><a href="#k-均值聚类（k-means-clustering）" class="headerlink" title="k 均值聚类（k-means clustering）"></a>k 均值聚类（k-means clustering）</h3><h4 id="定义群组"><a href="#定义群组" class="headerlink" title="定义群组"></a>定义群组</h4><ul><li>群组数量要足够大，以便提取有意义的模式用作商业决策参考，还要足够小，能够确保各个群组之间有明显的区别</li><li>使用陡坡图（scree plot）确定合适的群组数量<ul><li>陡坡图可以展现群组内散度随群组数量增加而降低的过程</li><li>陡坡图曲线的拐弯处表示最佳群组数量，此处的群组内散度较为合理</li></ul></li><li>通过检查群组成员与群组中心点的距离判断该群组的有效性（群组最好由密集的数据点组成）<ol><li>猜测每个群组的中心点，因为暂时不能确定通过猜测得到的中心点是否正确，所以称它们为伪中心点</li><li>把每个数据点分配给最近的伪中心点</li><li>根据群组成员的分布调整为中心点的位置</li><li>重复步骤 2 和步骤 3 直至群组成员不再发生变化</li></ol></li><li>聚类也可以在更多的维度上进行，虽然多维度分析很难进行可视化，但是可以借助程序计算数据点和群组中心点在多维度情形下的距离</li></ul><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul><li>每个数据点只能属于一个群组：恰好位于两个群组中间的数据点无法确定应属于哪个群组</li><li>群组被假定是正圆形的：若群组的实际形状是椭圆形，那么位于椭圆两端的数据点可能被划入邻近的其他群组</li><li>群组被假定是离散的：k 均值聚类既不允许群组重叠，也不允许它们相互嵌套</li><li>弥补局限性的方法：先用 k 均值聚类方法大致了解数据结构，再综合运用其他更高级的方法进行深入分析</li></ul><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>k 均值聚类用于把相似的数据点划入同一个群组，群组数量 k 必须事先指定</li><li>给数据点分组时，首先把各个数据点分配到距离最近的群组中，然后调整群组中心点的位置，重复这2个步骤直到群组中的成员不再发生变化</li><li>k 均值聚类最适用于正圆形、非重叠的群组</li></ul><h3 id="主成分分析（principal-component-analysis）"><a href="#主成分分析（principal-component-analysis）" class="headerlink" title="主成分分析（principal component analysis）"></a>主成分分析（principal component analysis）</h3><h4 id="主成分"><a href="#主成分" class="headerlink" title="主成分"></a>主成分</h4><ul><li>主成分分析用于找出最能区分数据点的变量，这种变量被称为主成分，数据点会沿着主成分的维度最大限度地分散开</li><li>主成分可以用已有的一个或多个变量表示</li><li>标准化（standardization）类似于使用百分位数表示每个变量，以此将所有变量统一到一个标准尺度上</li><li>采用主成分分析之后，可以不再通过试错法组合变量，而是通过精确计算各个变量的权重来获得最优变量组合</li></ul><h4 id="确定主成分数量"><a href="#确定主成分数量" class="headerlink" title="确定主成分数量"></a>确定主成分数量</h4><ul><li>由于主成分来源于原始变量，因此用来区分数据点的可用信息会受到原始变量个数的制约</li><li>为了让结果更简单、更通用，应该只选择前几个主成分进行可视化和后续分析<ul><li>将主成分按照其对数据点的区分效果进行排列</li><li>随着主成分个数增多，区分数据点的效果会变差</li><li>陡坡图曲线的拐弯处往往体现了最佳主成分数量</li></ul></li><li>对当前的数据样本进行解释时，使用的主成分越少，泛化能力就越强</li></ul><h4 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h4><ul><li>散度最大化：主成分分析有个重要假设，即数据点最分散的维度是最有用的</li><li>解释成分：主成分分析必须对其产生的成分进行解释，但有时可能很难解释变量按某种方式进行组合的原因</li><li>正交成分：主成分分析算法成分之间存在正交关系，然而真实信息维度之间可能不存在正交关系</li><li>弥补局限性的方法：独立成分分析（不需要假设正交关系，在确定成分时还无需考虑数据的散度）</li></ul><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>主成分分析是一种降维技巧，它使得我们可以使用较小的变量来描述数据，这些变量即为主成分</li><li>每个主成分都是原始变量的某种加权组合，最好的主成分可以用来改进数据分析和可视化</li><li>当信息最丰富的几个维度拥有最大的数据散度，并且彼此正交时，主成分分析能有最佳效果</li></ul><h3 id="关联规则（association-rule）"><a href="#关联规则（association-rule）" class="headerlink" title="关联规则（association rule）"></a>关联规则（association rule）</h3><h4 id="支持度、置信度和提升度"><a href="#支持度、置信度和提升度" class="headerlink" title="支持度、置信度和提升度"></a>支持度、置信度和提升度</h4><ul><li>识别关联规则的常用指标有3个：支持度、置信度和提升度</li><li>支持度：某个项集出现的频率，可以人为设定一个支持度阈值，当某个项集的支持度高于这个阈值时，就把它称为频繁项集</li><li>置信度：当 X 项出现时 Y 项同时出现的频率，记为 {X-&gt;Y} ，但它可能会错估某个关联规则的重要性</li><li>提升度：X 项和 Y 项一同出现的频率，同时考虑这两项各自出现的频率</li><li>{X-&gt;Y} 的提升度 = {X-&gt;Y} 的置信度 / {Y} 的支持度</li></ul><h4 id="先验原则（apriori-principal）"><a href="#先验原则（apriori-principal）" class="headerlink" title="先验原则（apriori principal）"></a>先验原则（apriori principal）</h4><ul><li>先验原则是指如果某个项集出现的不频繁那么包含它的任何更大的项集必定也出现的不频繁</li><li>寻找具有高支持度的项集<ol><li>列出只包含一个元素的项集</li><li>计算每个项集的支持度，保留那些满足最小支持度阈值条件的项集，淘汰不满足的项集</li><li>项候选项集中增加一个元素，并利用在步骤2中保留下来的项集产生所有可能的组合</li><li>重复步骤2和步骤3，为越来越大的项集确定支持度，直到没有待检查的新项集</li></ol></li><li>寻找具有高置信度或高提升度的关联规则<ul><li>因为置信度和提升度都是基于支持度计算出来的，因此一旦识别出具有高支持度的项集，寻找关联规则就不会那么费劲了</li></ul></li></ul><h4 id="局限性-2"><a href="#局限性-2" class="headerlink" title="局限性"></a>局限性</h4><ul><li>计算成本高：当库存量很大或者支持度阈值很低时，候选项集仍然会很多</li><li>假关联：当元素的数量很大时，偶尔会出现假关联，为了确保所发现的关联规则具有普遍性，应该对他们进行验证</li><li>弥补局限性的方法：使用高级数据结构对候选项集进行更高效的分类，从而减少比较的次数</li></ul><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul><li>关联规则用于揭示某一元素出现的频率以及它与其他元素的关系</li><li>识别关联规则的常用指标有3个<ol><li>{X} 的支持度表示 X 项出现的频率</li><li>{X-&gt;Y} 的置信度表示当 X 项出现时，Y 项同时出现的频率</li><li>{X-&gt;Y} 的提升度表示 X 项和 Y 项一同出现的频率，并且考虑每项各自出现的频率</li><li>利用先验原则可以淘汰一大部分非频繁项集，从而大大地加快搜索频繁相机的速度</li></ol></li></ul><h3 id="社会网络分析"><a href="#社会网络分析" class="headerlink" title="社会网络分析"></a>社会网络分析</h3><h4 id="Louvain-方法（Louvain-method）"><a href="#Louvain-方法（Louvain-method）" class="headerlink" title="Louvain 方法（Louvain method）"></a>Louvain 方法（Louvain method）</h4><ul><li>通过对节点分组可以找出网络中存在的群组，研究这些群组有助于理解网络各部分的区别和联系</li><li>Louvain 方法用来在网络中找出群组，它会尝试使用不同的聚类配置来做如下两种事：<ol><li>同一群组中各个节点间的边数和强度最大化</li><li>把属于不同群组的节点间的边数和强度最小化</li></ol></li><li>模块度用于表示上述两件事的完成程度，模块度越高，群组越理想</li><li>为了获得理想的聚类配置，Louvain 方法会不断迭代<ol><li>把每个节点看作一个群组，即一开始群组数和节点数相同</li><li>把一个节点重新分配给对提高模块度有最大帮助的群组，如果无法进一步提高，模块度节点保持不动，针对每个节点重复这个过程直到不能再分配</li><li>把步骤2中发现的每个群组作为一个节点构建出一个粗粒度网络，并且把以前的群间边合并成连接新结点且带权重的边</li><li>重复步骤2和步骤3直到无法再重新分配和合并</li></ol></li><li>Louvain 方法先发现小群组，然后在适当的情况下合并它们，帮助我们找出更重要的群组，但它有一定的局限性<ul><li>重要但较小的群组可能会被合并：需要检查在中间迭代阶段被发现的群组，如果有必要就把它们保留下来</li><li>有多种可能的聚类配置：若网络中包含重叠或嵌套的群组，需要依据其他信息源对群组予以验证</li></ul></li></ul><h4 id="PageRank-算法（PageRank-algorithm）"><a href="#PageRank-算法（PageRank-algorithm）" class="headerlink" title="PageRank 算法（PageRank algorithm）"></a>PageRank 算法（PageRank algorithm）</h4><ul><li>虽然群组可以反映出相互作用高度集中的区域，但是这些相互作用可能受占主导地位的节点支配，群组则围绕着这些主导节点形成，为了找出占主导地位的节点，需要对节点进行排序</li><li>PageRank 算法是谷歌公司最初用来为网页排名的算法之一，以 Larry Page 的姓氏命名</li><li>在PageRank 算法中，决定一个网页排名的因素有如下3个：<ol><li>链接数量：被其他网页链接的次数越多，该网页的访问者可能就越多</li><li>链接强度：这些链接被访问的次数越多，该网页的流量就越大</li><li>链接来源：如果被其他有较高排名的网页链接，那么该网页的排名也会升高</li></ol></li><li>尽管 PageRank 算法易于使用，但它有偏向于旧节点的局限性：如果一个新网页包含非常棒的内容但一开始访问者人数很少，那么它的排名就比较低</li><li>可以定期更新 PageRank 值，让新网页随着自身知名度的提高获得提高排名的机会</li></ul><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul><li>社会网络分析可用于绘制和分析多个实体之间的关系</li><li>Louvain 方法用于在一个网络中找出群组，具体做法是将群组内部的相互作用最大化，同时把群组之间的相互作用最小化，当群组大小相同且相互分离时，该方法的效果最佳</li><li>PageRank 算法根据链接的数量强度以及来源对网络中的节点进行排序，这个算法有助于找出网络中占主导地位的节点，但对链接数不太多的新节点并不友好</li></ul><h3 id="回归分析（regression-analysis）"><a href="#回归分析（regression-analysis）" class="headerlink" title="回归分析（regression analysis）"></a>回归分析（regression analysis）</h3><h4 id="趋势线"><a href="#趋势线" class="headerlink" title="趋势线"></a>趋势线</h4><ul><li>趋势线是做预测时常用的工具，他们很容易生成，也很容易理解</li><li>一般的趋势往往只涉及单个预测变量，这个变量用来产生预测结果，不过通过添加更多预测变量可以改善预测结果</li><li>回归分析不但可以通过考虑更多预测变量改善预测结果，还可以比较各个预测变量的强弱</li></ul><h4 id="梯度下降法（gradient-decent）"><a href="#梯度下降法（gradient-decent）" class="headerlink" title="梯度下降法（gradient decent）"></a>梯度下降法（gradient decent）</h4><ul><li>在回归分析中预测变量的权重是主要参数，通过解方程可以求得最优权重</li><li>梯度下降法先初步猜测合适的权重组合，再通过一个迭代过程，把这些权重应用于每个数据点做预测，然后调整权重以减少整体预测误差</li><li>这个过程类似于一步步走到山底下，每走一步梯度下降法都要判断从哪个方向下是最陡峭的，然后朝着那个方向重新校准权重，最终到达最低点，这个点的预测误差最小（经过优化的回归趋势线与梯度上的最低点相对应）</li><li>除了回归之外，梯度下降法也能用来优化其他模型中的参数，比如支持向量机和神经网络</li><li>梯度下降法的结果可能会受到初始参数值（下山起点）的影响，若起点下方恰好有一个小凹坑，那么梯度下降法可能会将其误认为是最优点</li><li>为了降低陷入这种凹坑的风险，可以使用随机梯度下降法，每次迭代并不是采用所有的数据点，而是只从其中选取一个来调整参数，引入多变性，有助于算法逃离凹坑</li></ul><h4 id="回归系数"><a href="#回归系数" class="headerlink" title="回归系数"></a>回归系数</h4><ul><li>在为回归预测变量求得最佳权重之后，需要对它们进行解释</li><li>回归系数：回归预测变量权重，它表示某个预测变量相比于其他预测变量的影响大小</li><li>预测变量的度量单位不同也会影响对回归系数的解释，因此应该在做回归分析之前先对预测变量的度量单位进行标准化，经过标准化之后预测变量的系数被称为标准化回归系数</li></ul><h4 id="相关系数（correlation-coefficient）"><a href="#相关系数（correlation-coefficient）" class="headerlink" title="相关系数（correlation coefficient）"></a>相关系数（correlation coefficient）</h4><ul><li>相关系数：当只存在一个预测变量时，该预测变量的标准化回归系数</li><li>关联方向：相关系数为正表示预测变量和结果变化的方向一致，为负则表示两者变化方向相反</li><li>关联强度：r 值越接近于 -1 或 1，预测变量的作用就越大，若值为 0 则表示预测变量和结果之间不存在关系</li><li>因为相关系数表示单个预测变量的绝对强度，所以相比于回归系数，相关系数在对预测变量进行排序时更可靠</li></ul><h4 id="局限性-3"><a href="#局限性-3" class="headerlink" title="局限性"></a>局限性</h4><ul><li>对异常值敏感：回归分析平等地对待所有的数据点，只要存在几个有异常值的数据点，就会给趋势线造成很大的影响，因此在做进一步分析之前，可以先使用散点图找出异常值</li><li>多重共线性问题（multicollinearity）：如果回归模型包含高度相关的预测变量，就会造成相关预测变量权重失真，因此可以使用更高级的技术，如套索回归或岭回归</li><li>弯曲的趋势：需要对预测变量的值进行转换，或使用支持向量机等其他算法</li><li>并不说明存在因果关系</li></ul><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul><li>回归分析用于寻找最佳拟合线（best-fit line），使得尽可能多的数据点位于这条线上或附近</li><li>趋势线由带权重的组合预测变量得到，这些权重被称为回归系数，表示某个预测变量相对于其他预测变量的影响强度</li><li>以下情况下，回归分析的效果最好：<ol><li>预测变量之间的关系不强</li><li>无异常值</li><li>趋势可以用直线表示</li></ol></li></ul><h3 id="k-最近邻算法（k-Nearest-Neighbors）和异常检测"><a href="#k-最近邻算法（k-Nearest-Neighbors）和异常检测" class="headerlink" title="k 最近邻算法（k-Nearest Neighbors）和异常检测"></a>k 最近邻算法（k-Nearest Neighbors）和异常检测</h3><h4 id="k-最近邻算法"><a href="#k-最近邻算法" class="headerlink" title="k 最近邻算法"></a>k 最近邻算法</h4><ul><li>k 最近邻算法根据周围数据点的类型对某个数据点进行分类（物以类聚，人以群分）</li><li>在 k 最近邻算法中，参数 k 表示周围数据点的个数，选择 k 值的过程叫做参数调优，它对预测的准确度起着至关重要的作用</li><li>使用不同的 k 值进行拟合：<ul><li>如果 k 值太小，数据点只与最近的邻居匹配，并且随机造成所产生的误差也会被放大</li><li>如果 k 值太大，数据点会尝试与更远的邻居匹配，其中隐含的模式会被忽略</li><li>只有当 k 值恰到好处时，数据点才会参考合适数量的邻居，使得误差相互抵消，有利于揭示数据中隐藏的趋势</li></ul></li><li>为实现理想拟合并把误差降到最低，可以使用交叉验证法对参数 k 进行调优</li><li>对于二分类问题，可以把 k 设置成一个奇数，以避免出现平局的情况</li><li>除了用来为数据点分类，k 最近邻算法还可以通过合计周围数据点的值来预测连续值</li><li>通过使用加权平均值，能够进一步改善预测结果，离数据点越近的邻居，其值越能反映该数据点的真实值，因此赋给它的权重应该更大</li></ul><h4 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h4><ul><li>k 最近邻算法不仅可以用来预测数据点的类别和取值，还可以用来识别异常，比如检测欺诈行为</li><li>在异常检测的过程中还可能会有新发现，比如发现之前被忽略的预测变量</li><li>事实上任何能够产生预测模型的算法都可以用来检测异常，比如在回归分析中，如果某个数据点明显偏离最佳拟合线，那么就会被识别为异常点</li><li>异常数据点既可能因缺失预测变量所致，也可能因预测模型缺少足够的训练数据所致</li><li>一旦找到异常数据点，就要将它们从数据集中移除，然后再训练预测模型，减少数据中包含的噪声，进而提高模型的准确度</li></ul><h4 id="局限性-4"><a href="#局限性-4" class="headerlink" title="局限性"></a>局限性</h4><ul><li>类别不平衡：可以使用加权投票法来取代少数服从多数原则，确保较近数据点类别的权重比较远的更大</li><li>预测变量过多：在多个维度上识别和处理近邻会导致你计算量大增，需要降维（dimension reduction）</li></ul><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul><li>k 最近邻算法根据周围数据点的类型对某个数据点进行分类</li><li>k 表示用作参考的数据点的个数，可以使用交叉验证法来确定</li><li>当预测变量数目不多，并且类别大小差别不大时，k 最近邻算法才能产生非常好的效果</li><li>不准确的分类可能会被标记为潜在异常</li></ul><h3 id="支持向量机（support-vector-machine）"><a href="#支持向量机（support-vector-machine）" class="headerlink" title="支持向量机（support vector machine）"></a>支持向量机（support vector machine）</h3><h4 id="勾画最佳分界线"><a href="#勾画最佳分界线" class="headerlink" title="勾画最佳分界线"></a>勾画最佳分界线</h4><ul><li>支持向量机的主要目标是得到一条能用于分组的最佳分界线，需要注意的是，能用于分组的分界线可能有很多条</li><li>为了找出最佳分界线，首先需要从一组中找出距离另一组最近的外围数据点，然后在两组的外围数据点之间画出最佳分界线，由于这些外围数据点在寻找最佳分界线的过程中起了支持作用，因此叫做支持向量</li><li>支持向量机的一个优点是计算速度很快，仅依靠外围数据点就能找到决策边界</li><li>这种对数据点子集的依赖也有缺点，这是因为决策边界对支持向量的位置比较敏感，选取不同的数据点作为训练数据，相应支持向量的位置也不同</li><li>支持向量机算法有一个关键特征——缓冲带<ul><li>缓冲带允许一定数量的训练数据点位于错误的一边，由此得到一条更软的分界线</li><li>缓冲带对异常值有更强的耐扰性，因此对新数据有更强的泛化能力</li><li>缓冲带通过调整惩罚参数得到，这个参数决定了对分类误差的宽容度，惩罚参数越大，宽容度就越大，缓冲带也就越宽</li><li>为了让模型对当前数据和新数据有较高的预测准确度，可以使用交叉验证法求得最佳惩罚参数</li></ul></li><li>支持向量机的另一个强项是找到决策边界的凸弧，它在发现错综复杂的凸弧时有着更出众的计算效率<ul><li>支持向量机的秘诀是核技巧（kernel trick）</li><li>支持向量机不会直接在在数据平面上绘制有凸弧的分界线，而是会首先把数据映射到高维空间，然后在高维空间中将数据点用直线分开，这些直线容易计算，并且当映射回低维空间时，也很容易转化成曲线</li></ul></li><li>支持向量机具备在高维空间操纵数据的能力，使得它在分析有多个变量的数据集时大受欢迎</li><li>支持向量机的常见应用场景包括遗传信息破译以及文本情感分析</li></ul><h4 id="局限性-5"><a href="#局限性-5" class="headerlink" title="局限性"></a>局限性</h4><ul><li>小数据集：由于支持向量机依靠支持向量确定决策边界，因此样本量少，用来对分界线进行准确定位的数据也少</li><li>多组数据：支持向量机每次只能对两组进行分类，如果存在2个以上的组，则需要对每一组都应用支持向量机（多类支持向量机）</li><li>两组之间存在大量重叠：靠近边界的数据点可能更容易发生分类错误，而且支持向量机没有给出每个数据点遭遇错误分类的概率，但可以通过数据点到决策边界的距离来估计其被正确分类的可能性</li></ul><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul><li>支持向量机用来把数据点分为两组，其方法是在两组的外围数据点（支持向量）的中间画一条分界线</li><li>支持向量机对异常值有较好的容忍度，它通过一个缓冲带允许少量数据点位于错误的一边，此外他还通过核技巧高效地求得带凸弧的决策边界</li><li>当需要把大样本中的数据点分为两组时，支持向量机能够发挥最佳作用</li></ul><h3 id="决策树（decision-tree）"><a href="#决策树（decision-tree）" class="headerlink" title="决策树（decision tree）"></a>决策树（decision tree）</h3><h4 id="生成决策树"><a href="#生成决策树" class="headerlink" title="生成决策树"></a>生成决策树</h4><ul><li>递归拆分（recursive partitioning）<ol><li>确定一个二元选择题，它能够把数据点拆分成两组，并最大限度地提高每组数据点的同质性</li><li>针对每个叶结点重复步骤1，直到满足终止条件</li></ol></li><li>终止条件可能有多个，可以使用交叉验证法进行选取<ul><li>每个叶节点的数据全属于同一类或有相同的值</li><li>叶节点包含的数据点少于5个</li><li>进一步分支会超出阈值并且不能提高同质性</li></ul></li><li>由于递归拆分只用最佳二元选择题来生成决策树，因此不显著的变量并不会影响结果</li><li>而且二元选择题往往围绕着最重要的值划分数据点，所以决策树对异常值有较强的耐扰性</li><li>决策树易于可视化，使我们更容易评估预测变量及其相互作用</li></ul><h4 id="局限性-6"><a href="#局限性-6" class="headerlink" title="局限性"></a>局限性</h4><ul><li>不稳定：决策树是通过把数据点分组生成的，数据中的细微变化可能影响拆分结果，并导致生成的决策树截然不同</li><li>容易产生过拟合：决策树每次拆分数据点时都力求找到最佳拆分方式</li><li>不准确：一开始就是用最佳二元选择题拆分数据点并不能保证结果最准确</li><li>弥补局限性的方法：每次拆分时可以不采用最佳拆分方式，而是尽量让决策树多样化，然后综合不同的决策树产生的预测结果，让最终预测结果具有更好的稳定性和准确性</li></ul><h4 id="决策树的多样化方法"><a href="#决策树的多样化方法" class="headerlink" title="决策树的多样化方法"></a>决策树的多样化方法</h4><ul><li>随机森林：随机选择不同的二元选择题，生成多棵决策树，然后综合这些决策树的预测结果</li><li>梯度提升（gradient boosting）：有策略地选择二元选择题，以逐步提高决策树的预测准确度，然后将所有的预测结果的加权平均数作为最终结果</li></ul><p>虽然随机森林的和梯度提升能够产生更准确的预测结果，但是它们往往比较复杂并且很难进行可视化（黑盒）</p><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><ul><li>决策树通过询问一系列二元选择题来做预测</li><li>若想生成决策树，就要不断拆分数据样本以获得同质组，直到满足终止条件，这个过程被称为递归拆分</li><li>虽然决策树易于使用和理解，但是容易造成过拟合问题，导致出现不一致的结果，为了尽量避免出现这种情况，可以采用随机森林等替代方法</li></ul><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><h4 id="集成模型"><a href="#集成模型" class="headerlink" title="集成模型"></a>集成模型</h4><ul><li>集成方法（ensembling）：通过组合有不同优缺点的模型来提高预测准确度的方法</li><li>集成模型：通过组合许多模型的预测结果得到的预测模型，在组合模型时，既可以遵循少数服从多数的原则，也可以取平均值</li><li>随机森林是决策树的集成模型</li><li>相比于子模型，集成模型的预测准确度更高，这是因为准确的预测模型会彼此强化，错误的则会彼此抵消<ul><li>为了达到这种效果，集成模型的子模型一定不能犯同类错误，换言之，子模型必须是不相关的</li></ul></li><li>自助聚集法：用来生成不相关的决策树的系统化方法</li></ul><h4 id="自助聚集法（bootstrap-aggregating）"><a href="#自助聚集法（bootstrap-aggregating）" class="headerlink" title="自助聚集法（bootstrap aggregating）"></a>自助聚集法（bootstrap aggregating）</h4><ul><li>自助聚集法用来生成数千棵决策树，这些树彼此有明显的不同</li><li>为使决策树之间的关联度最小化，每棵树都由训练数据集的一个随机子集产生，并且使用的是预测变量的一个随机子集，这让生成的决策树各不相同，但仍然保留了一定的预测能力</li><li>通过限制每次拆分时所用的预测变量，能够生成各不相同的决策树，从而避免发生过拟合问题</li><li>为进一步降低发生过拟合问题的可能性，可以增加随机森林中决策树的数量，使模型更通用、更准确</li></ul><h4 id="局限性-7"><a href="#局限性-7" class="headerlink" title="局限性"></a>局限性</h4><ul><li>随机森林由随机生成的决策树组成，并不存在明确的预测规则，这种不可解释性可能会带来一些伦理问题</li><li>因此随机森林适用于那些预测准确度比可解释性更重要的场合</li></ul><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><ul><li>随机森林的预测结果往往比单棵决策树更准确，这是因为它充分利用了两种技术：自助聚集法和集成方法</li><li>自助聚集法通过随机限制数据拆分过程所用的变量来生成一系列不相关的决策树</li><li>集成方法则把决策树的预测结果组合在一起</li><li>虽然随机森林的预测结果不具有可解释性，但仍然可以根据对预测结果的贡献度大小对各个预测变量进行排序</li></ul><h3 id="神经网络（neural-network）"><a href="#神经网络（neural-network）" class="headerlink" title="神经网络（neural network）"></a>神经网络（neural network）</h3><h4 id="神经网络的诞生"><a href="#神经网络的诞生" class="headerlink" title="神经网络的诞生"></a>神经网络的诞生</h4><ul><li>数据存储和共享技术取得进步：为训练神经网络提供了海量数据，有助于改善神经网络的性能</li><li>计算能力越来越强大：GPU的运行速度最快能达到CPU的150倍，能为在大数据集上训练神经网络提供强大的支持</li><li>算法获得改进</li></ul><h4 id="神经网络的构成"><a href="#神经网络的构成" class="headerlink" title="神经网络的构成"></a>神经网络的构成</h4><ul><li>输入层：该层处理输入图像的每个像素<ul><li>为提高预测准确度，可以使用卷积层</li><li>卷积层并不处理单个像素，而是识别像素组合的特征，这种分析只关注特征是否出现而不关注出现的位置</li><li>所以即使某些关键特征偏离了中心，神经网络仍然能够正确识别，这种特性叫做平移不变性（translational invariance）</li></ul></li><li>隐藏层：在像素进入神经网络之后，通过层层转换不断提高和那些标签已知的图像的相似度<ul><li>标签已知是指神经网络以前见过这些图像</li><li>虽然转换得越多，预测准确度就会越高，但是处理时间就会明显增加，一般来说几个隐藏层就足够了</li><li>每层的神经元数量要和图像的像素数成比例</li></ul></li><li>输出层：该层产生最终预测结果，在这一层中神经元可以只有一个，也可以和结果一样多</li><li>损失层：该层通常位于最后，并提供有关输入是否识别正确的反馈，如果不正确则给出误差量<ul><li>在训练神经网络的过程中，损失层至关重要，若预测准确，来自于损失层的反馈会强化产生该预测结果的激活路径</li><li>若预测错误，则错误会沿着路径逆向返回，这条路径上的神经元的激活条件就会被重新调整，以减少错误，这个过程称为反向传播（back propagation）</li></ul></li><li>通过不断重复这个训练过程，神经网络会学习输入信号和正确输出标签之间的联系，并且把这些联系作为激活规则（activation rule）编入每个神经元，因此为了提高神经网络的预测准确度，需要调整管理激活规则的部件</li></ul><h4 id="激活规则"><a href="#激活规则" class="headerlink" title="激活规则"></a>激活规则</h4><ul><li>为了产生预测结果，需要沿着一条路径依次激活神经元，每个神经元的激活过程都由其激活规则所控制，激活规则指定了输入信号的来源和强度，在神经网络的训练过程中激活规则会不断调整</li><li>良好的激活规则有助于产生准确的预测结果，其关键在于确定合适的权重和阈值</li><li>另外神经网络的其他参数也需要调整，比如隐藏层的数量、每层的神经元数量等。可以使用梯度下降法优化这些参数</li></ul><h4 id="局限性-8"><a href="#局限性-8" class="headerlink" title="局限性"></a>局限性</h4><ul><li>需要大样本：神经网络的复杂性使之能够识别带有复杂特征的输入，但前提是我们能为他提供大量训练数据，如果训练集太小就会出现过拟合问题</li><li>降低过拟合风险：<ul><li>二次取样（subsampling）：为了降低神经元对噪声的敏感度，需要对神经网络的输入进行平滑化处理，即针对信号样本取平均值</li><li>畸变：当缺少训练数据时，可以通过向每幅图像引入畸变，来产生更多数据，每幅畸变图像都可以作为新的输入，以此扩大训练数据的规模，畸变应该能够反映原数据集的特征（弹性变形）</li><li>丢弃（dropout）：为解决小的神经元集群之间彼此产生过度依赖，可以在训练期间随机丢弃一半的神经元，这些遭丢弃的神经元将处于未激活的状态，剩下的神经元则正常工作，下一次训练丢弃一组不同的神经元，迫使不同的神经元协同工作，从而揭示训练样本所包含的更多特征</li></ul></li><li>计算成本高：训练一个由几千个神经元组成的神经网络可能需要很长时间，一个简单的解决方法是升级硬件</li><li>另一个解决方法是调整算法，用稍低一些的预测准确度换取更快的处理速度<ul><li>随机梯度下降法：为了更新某一个参数，经典的梯度下降法在一次迭代中使用所有的训练样本，当数据集很大时这样做会耗时，随机梯度下降法是在每次迭代中只用一个训练样本来更新参数，虽然使用这个方法得到的最终参数可能不是最优的，但是准确度不会太低</li><li>小批次梯度下降法：虽然使用随机梯度下降法能够提升速度，但最终参数可能不准确，算法也可能无法收敛，导致某个参数上下波动，小批次梯度下降法是每次迭代使用训练样本的一个子集</li><li>全连接层：随着加入的神经元越来越多，路径的数量呈指数增长，为避免查看所有可能的组合，可以使初始层（处理更小、更低级的特征）的神经元部分连接，只有最后几层（处理更大、更高级的特征）才对相邻层的神经元进行全连接</li></ul></li><li>不可解释：神经网络由多层组成，每层都有几百个神经元，这些神经元有不同的激活规则控制，这使得我们很难准确地找到产生正确预测结果的输入信号组合<ul><li>但和回归分析不同，回归分析能明确地识别重要的预测变量，并比较它们的强度，神经网络的特性使之难以证明其使用得当，在涉及伦理问题时尤其如此</li></ul></li><li>尽管存在上述局限性，但是神经网络本身拥有的强大能力，使之得以应用于虚拟助手、自动驾驶等前沿领域，随着算法不断改进以及计算能力不断提升，神经网络将在物联网时代发挥关键作用</li></ul><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><ul><li>神经网络由多个神经元组成，训练期间，第1层的神经元首先被输入数据激活，然后将激活状态传播到后续各层的神经元，最终在输出层产生预测结果</li><li>一个神经元是否被激活取决于输入信号的来源和强度，这由其激活规则指定，激活规则会根据预测结果的反馈不断调整，这个过程被称为反向传播</li><li>在大数据集和先进的计算硬件可用的情况下，神经网络的表现最好，然而预测结果在大部分的时候都是无法解释的</li></ul><h3 id="A-B-测试（A-B-testing）和多臂老虎机（multi-arm-bandit-problem）"><a href="#A-B-测试（A-B-testing）和多臂老虎机（multi-arm-bandit-problem）" class="headerlink" title="A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）"></a>A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）</h3><h4 id="A-B-测试的局限性"><a href="#A-B-测试的局限性" class="headerlink" title="A/B 测试的局限性"></a>A/B 测试的局限性</h4><ul><li>测试结果具有偶然性：为提高测试结果的可信度可以增加受测人数，但是会导致另一个问题</li><li>潜在的收入损失：如果把受测顾客增加一倍，那么看到糟糕广告的人数也会增加一倍，这有流失的顾客的风险</li><li>这两个问题体现了 A/B 测试中的两个权衡因素：探索和利用</li></ul><h4 id="epsilon-递减策略（epsilon-decreasing-strategy）"><a href="#epsilon-递减策略（epsilon-decreasing-strategy）" class="headerlink" title="epsilon 递减策略（epsilon-decreasing strategy）"></a>epsilon 递减策略（epsilon-decreasing strategy）</h4><ul><li>epsilon 指的是探索时间与总时间的比例，随着对效果较好的广告越来越有信心，我们使 epsilon 值递减，这个方法属于强化学习的范畴</li><li>A/B 测试由探索和利用前后两个阶段组成，而在 epsilon 递减策略中，探索阶段和利用阶段是分散的，并且一开始时探索得多一些，越接近尾声，探索得越少</li></ul><h4 id="多臂老虎机"><a href="#多臂老虎机" class="headerlink" title="多臂老虎机"></a>多臂老虎机</h4><ul><li>假设有两台老虎机 A 和 B 可供选择，玩2000个回合，每个回合要么赢1美元，要么没有收益，老虎机 A 的返还率为50%，老虎机 B 的则为40%，但我们事先并不知道这些信息，问要怎么玩才能多赢钱？<ul><li>全探索：如果随机选择老虎机，平均会赢900美元</li><li>A/B 测试：用前200个回合探索哪台老虎机的返还率更高，然后在剩下的1800个回合中选择这台老虎机，平均会赢976美元，但由于两台老虎机的返还率接近，由此存在误判的可能性（误判概率8%）</li><li>为降低误判的风险，可以把A/B 测试的探索范围扩大到500个回合，这样做可以把误判概率降到1%，但是平均中奖金额也会减少到963美元</li><li>epsilon 递减策略：如果采用 epsilon 递减策略边探索边利用，平均会赢984美元，并且误判概率为4%，通过增加探索比例（增加 epsilon 值）能够降低误判概率，但仍会减少平均中奖金额</li><li>全利用：如果一开始就掌握内部消息并选择返还率最高的老虎机 A，平均会赢1000美元，但这个假设不现实</li></ul></li><li>由此看到，在不掌握内部消息的情况下，采用 epsilon 递减策略的收益最高，而且由于存在收敛性这一数学特征，由此 epsilon 递减策略能确保在回合数足够多的情况下找出返还率最高的老虎机</li><li>胜者为先：范加尔在曼联采用了一个非常规策略来决定罚点球的球员，第一个被指定罚点球的球员会负责到底，除非他没有打进球，接下来新换的球员继续负责罚点球，如果没有罚进就再换一名球员，依此类推<ul><li>频繁地换老虎机，会导致探索过多而利用过少，只比随机选择老虎机稍好一些，而且胜者为先策略只根据上一次的结果来评估老虎机，这忽略了老虎机之前的表现</li></ul></li></ul><h4 id="epsilon-递减策略的局限性"><a href="#epsilon-递减策略的局限性" class="headerlink" title="epsilon 递减策略的局限性"></a>epsilon 递减策略的局限性</h4><ul><li>采用 epsilon 递减策略的关键在于控制好 epsilon 值，如果 epsilon 值递减的过慢，就会失去利用老虎机的机会，而如果递减得过快，就可能会选错老虎机</li><li>epsilon 值的最佳递减速度主要取决于两台老虎机返还率的相似程度，采用汤普森取样方法，可以计算 epsilon 值</li><li>epsilon 递减策略还依赖于如下假设：<ul><li>返还率恒定不变</li><li>返还率与上一次游戏无关</li><li>玩游戏和观察返还率之间的延迟极小</li></ul></li></ul><h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><ul><li>多臂老虎机问题的实质是如何以最佳方式分配资源</li><li>一种策略是先探索可用选项，然后把所有剩余资源分配给表现最佳的选项，这个策略叫做 A/B 测试</li><li>另一个策略是给表现最佳的选项，逐渐分配更多的资源，这个策略叫做 epsilon 递减策略</li><li>虽然 epsilon 递减策略在大多数情况下能够提供比 A/B 测试更高的回报，但是确定资源分配的最佳更新速度并非易事</li></ul><h3 id="更多评价指标"><a href="#更多评价指标" class="headerlink" title="更多评价指标"></a>更多评价指标</h3><h4 id="分类指标"><a href="#分类指标" class="headerlink" title="分类指标"></a>分类指标</h4><ul><li>接受者操作特征曲线下面积（曲线下面积）：这个指标允许我们在最大化正例率和最小化假正例率之间做权衡<ul><li>正例率：被模型正确预测为正类别的样本所占的比例</li><li>正例率 = 正例数 / ( 正例数 + 假负例数 )</li><li>假正例率：被模型错误预测为正类别的样本所占的比例</li><li>假正例率 = 假正例数 / ( 假正例数 + 负例数 )</li><li>在极端情况下，可以把所有样本全部预测为正类别，以此实现正例率最大化（正例率为1），虽然这样做可以避免出现假负例但会明显增加假正例</li><li>接受者操作特征曲线（ROC 曲线）体现了最大化正例率和最小化假正例率之间的权衡</li><li>模型性能通过 ROC 曲线下方的面积来衡量，所以该指标被称为曲线下面积，模型的准确度越高，曲线越靠近左上角</li><li>完美的预测模型会产生一条曲线下面积为1的曲线（曲线下面积等于整个图形的面积）</li></ul></li><li>对数损失指标利用置信度来校正其对预测误差的惩罚，具体来说，模型对错误预测的置信度越高，惩罚就越重<ul><li>由于对数损失指标根据对预测结果的置信度来调整惩罚程度，因此它通常用于错误预测极其有害的情况</li></ul></li></ul><h4 id="回归指标"><a href="#回归指标" class="headerlink" title="回归指标"></a>回归指标</h4><ul><li>平均绝对误差：平等的惩罚所有预测误差，具体做法是对所有数据点的预测值和实际值之差取平均值</li><li>除了考虑误差大小之外，还可以通过均方根对数误差把误差方向纳入考虑范围</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。&lt;a href=&quot;https://book.douban.com/subject/30442187/&quot;&gt;白话机器学习算法&lt;/a&gt;一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。以下为阅读过程中所作的读书笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.zhuangzhihao.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>开发团队调度软件实战</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/</id>
    <published>2021-10-08T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在学习完 <a href="/Java%E5%9F%BA%E7%A1%80">Java 基础编程</a>的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。</p></blockquote><a id="more"></a><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3><ul><li>软件启动时，根据给定的数据创建公司部分成员列表（数组）</li><li>根据菜单提示，基于现有的公司成员，组建一个开发团队以开发一个新的项目</li><li>组建过程包括将成员插入到团队中，或从团队中删除某成员，还可以列出团队中现有成员的列表</li><li>开发团队成员包括架构师、设计师和程序员</li></ul><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ul><li>软件采用单级菜单方式工作，当软件运行时，主界面显示公司成员的列表</li><li>当选择“添加团队成员”菜单时，将执行从列表中添加指定（通过 ID）成员到开发团队的功能</li><li>如果添加操作因某种原因失败，将显示失败信息（失败原因视具体原因而不同）</li><li>当选择“删除团队成员”菜单时，将执行从开发团队中删除指定（通过 TeamID）成员的功能</li><li>当选择“团队列表”菜单时，将列出开发团队中的现有成员</li></ul><h3 id="软件设计结构"><a href="#软件设计结构" class="headerlink" title="软件设计结构"></a>软件设计结构</h3><ul><li>软件由 view、service、domain 三个模块组成<ul><li><code>com.atguigu.team.view</code> 模块为主控模块，负责菜单的显示和处理用户操作</li><li><code>com.atguigu.team.service</code> 模块为实体对象（Employee 及其子类如程序员等）的管理模块，<code>NameListService</code> 和 <code>TeamService</code> 类分别用各自的数组来管理公司员工和开发团队成员对象</li><li>domain 模块为 Employee 及其子类等 JavaBean 类所在的包</li></ul></li><li><code>com.atguigu.team.domain</code> 模块中包含了所有实体类<ul><li>其中 Programmer 及其子类，均会领用 Equipment</li></ul></li></ul><h3 id="创建项目基本组件"><a href="#创建项目基本组件" class="headerlink" title="创建项目基本组件"></a>创建项目基本组件</h3><ol><li>创建 <code>TeamSchedule</code> 项目，按照设计要求创建所有包，将项目提供的几个类复制到相应的包中<ul><li>view 包中：TSUtility.java</li><li>service包中：Data.java</li></ul></li><li>   按照设计要求，在 com.atguigu.team.domain 包中，创建 Equipment 接口及其各实现子类代码</li><li>   按照设计要求，在 com.atguigu.team.domain 包中，创建 Employee 类及其各子类代码</li><li>   检验代码的正确性</li></ol><h4 id="键盘访问的实现"><a href="#键盘访问的实现" class="headerlink" title="键盘访问的实现"></a>键盘访问的实现</h4><ul><li>项目 view 包中提供了 TSUtility.java 类，提供了以下静态方法，可用来方便地实现键盘访问<ul><li>public static char readMenuSelection()：该方法读取键盘，如果用户键入’1’-’4’中的任意字符，则方法返回。返回值为用户键入字符</li><li>public static void readReturn()：该方法提示并等待，直到用户按回车键后返回</li><li>public static int readInt()：该方法从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值</li><li>public static char readConfirmSelection()：从键盘读取‘Y’或’N’，并将其作为方法的返回值</li></ul></li></ul><h4 id="Equipment-接口及其实现子类的设计"><a href="#Equipment-接口及其实现子类的设计" class="headerlink" title="Equipment 接口及其实现子类的设计"></a>Equipment 接口及其实现子类的设计</h4><ul><li>根据需要提供各属性的 get/set 方法以及重载构造器</li><li>实现类实现接口的方法，返回各自属性的信息</li></ul><h4 id="Employee-类及其子类的设计"><a href="#Employee-类及其子类的设计" class="headerlink" title="Employee 类及其子类的设计"></a>Employee 类及其子类的设计</h4><ul><li>memberId 用来记录成员加入开发团队后在团队中的 ID</li><li>Status 是项目 service 包下自定义的类，声明三个对象属性，分别表示成员的状态<ol><li>FREE-空闲</li><li>BUSY-已加入开发团队</li><li>VOCATION-正在休假</li></ol></li><li>equipment 表示该成员领用的设备</li><li>bonus 表示奖金</li><li>stock 表示公司奖励的股票数量</li><li>可根据需要为类提供各属性的 get/set 方法以及重载构造器</li></ul><h4 id="Status-类"><a href="#Status-类" class="headerlink" title="Status 类"></a>Status 类</h4><ul><li><p>Status 枚举类位于 com.atguigu.team.service 包中，封装员工的状态</p><pre><code class="java">package com.atguigu.team.service;public class Status &#123;    private final String NAME;  private Status(String name) &#123;      this.NAME = name;  &#125;  public static final Status FREE = new Status(&quot;FREE&quot;);  public static final Status VOCATION = new Status(&quot;VOCATION&quot;);   public static final Status BUSY = new Status(&quot;BUSY&quot;);  public String getNAME() &#123;      return NAME;  &#125;  @Override  public String toString() &#123;      return NAME;  &#125;&#125;</code></pre></li></ul><h3 id="实现-service-包中的类"><a href="#实现-service-包中的类" class="headerlink" title="实现 service 包中的类"></a>实现 service 包中的类</h3><ol><li>   按照设计要求编写 NameListService 类</li><li>   在 NameListService 类中临时添加一个 main 方法中，作为单元测试方法</li><li>在方法中创建 NameListService 对象，然后分别用模拟数据调用该对象的各个方法，以测试是否正确<ul><li>测试应细化到包含了所有非正常的情况，以确保方法完全正确</li></ul></li><li>   重复以上3步，完成 TeamService 类的开发</li></ol><h4 id="NameListService-类的设计"><a href="#NameListService-类的设计" class="headerlink" title="NameListService 类的设计"></a>NameListService 类的设计</h4><ul><li>负责将 Data 中的数据封装到 Employee[] 数组中，同时提供相关操作 Employee[] 的方法</li><li>employees 用来保存公司所有员工对象</li><li>NameListService() 构造器<ul><li>根据项目提供的 Data 类构建相应大小的 employees 数组</li><li>再根据 Data 类中的数据构建不同的对象，包括 Employee、Programmer、Designer 和 Architect 对象，以及相关联的 Equipment 子类的对象</li><li>将对象存于数组中</li><li>Data类位于 com.atguigu.team.service 包中</li></ul></li><li>getAllEmployees()：获取当前所有员工<ul><li>返回：包含所有员工对象的数组</li></ul></li><li>getEmployee(id : int)：获取指定ID的员工对象<ul><li>参数：指定员工的 ID</li><li>返回：指定员工对象</li><li>异常：找不到指定的员工</li></ul></li><li>在 service 子包下提供自定义异常类：TeamException</li><li>另外，可根据需要自行添加其他方法或重载构造器</li></ul><h4 id="TeamService-类的设计"><a href="#TeamService-类的设计" class="headerlink" title="TeamService 类的设计"></a>TeamService 类的设计</h4><ul><li>关于开发团队成员的管理：添加、删除等</li><li>counter 为静态变量，用来为开发团队新增成员自动生成团队中的唯一 ID，即 memberId（应使用增1的方式）</li><li>MAX_MEMBER：表示开发团队最大成员数</li><li>team数组：用来保存当前团队中的各成员对象</li><li>total：记录团队成员的实际人数</li><li>getTeam() ：返回当前团队的所有对象<ul><li>返回：包含所有成员对象的数组，数组大小与成员人数一致</li></ul></li><li>addMember(e: Employee)：向团队中添加成员<ul><li>参数：待添加成员的对象</li><li>异常：添加失败，TeamException 中包含了失败原因</li></ul></li><li>removeMember(memberId: int)：从团队中删除成员<ul><li>参数：待删除成员的 memberId</li><li>异常：找不到指定 memberId 的员工，删除失败</li></ul></li><li>另外，可根据需要自行添加其他方法或重载构造器</li></ul><h3 id="实现-view-包中类"><a href="#实现-view-包中类" class="headerlink" title="实现 view 包中类"></a>实现 view 包中类</h3><ol><li>   按照设计要求编写 TeamView 类，逐一实现各个方法，并编译</li><li>   执行 main 方法中，测试软件全部功能</li></ol><h4 id="TeamView-类的设计"><a href="#TeamView-类的设计" class="headerlink" title="TeamView 类的设计"></a>TeamView 类的设计</h4><ul><li>listSvc 和 teamSvc 属性：供类中的方法使用</li><li>enterMainMenu()：主界面显示及控制方法</li><li>以下方法仅供 enterMainMenu() 调用：<ul><li>listAllEmployees()：以表格形式列出公司所有成员</li><li>getTeam()：显示团队成员列表操作</li><li>addMember()：实现添加成员操作</li><li>deleteMember()：实现删除成员操作</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在学习完 &lt;a href=&quot;/Java%E5%9F%BA%E7%A1%80&quot;&gt;Java 基础编程&lt;/a&gt;的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://blog.zhuangzhihao.top/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从2020的视角看线性代数</title>
    <link href="http://blog.zhuangzhihao.top/%E4%BB%8E2020%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://blog.zhuangzhihao.top/%E4%BB%8E2020%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</id>
    <published>2021-09-19T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.843Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2020 年 MIT 数学教授 Gilbert Strang 录制了一个关于线性代数的学习和教学的一个新的、启发性的课程，从矩阵 A 的列空间和组合这些列的乘法 Ax 开始，包括了线性代数的概览、正交向量、特征值和特征向量、以及奇异值和奇异向量等方面的内容。以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。</p></blockquote><a id="more"></a><h3 id="矩阵的列空间"><a href="#矩阵的列空间" class="headerlink" title="矩阵的列空间"></a>矩阵的列空间</h3><h4 id="常用矩阵"><a href="#常用矩阵" class="headerlink" title="常用矩阵"></a>常用矩阵</h4><ul><li><p>$A_{0}=\begin{bmatrix}<br>1 &amp; 3 &amp; 2 \<br>4 &amp; 12 &amp; 8 \<br>2 &amp; 6 &amp; 4<br>\end{bmatrix}$</p><ul><li>$A_{0}$ 所有的行向量在同一个方向并且所有的列向量在同一个方向</li></ul></li><li><p>$A_{1}=\begin{bmatrix}<br>1 &amp; 4 &amp; 2 \<br>4 &amp; 1 &amp; 3 \<br>5 &amp; 5 &amp; 5<br>\end{bmatrix}$</p><ul><li>$A_{1}$ 第一行加第二行等于第三行</li></ul></li><li><p>对称矩阵</p><ul><li><p>$S_{2}=\begin{bmatrix}<br>2 &amp; -1 \<br>-1 &amp; 2<br>\end{bmatrix}$</p></li><li><p>$S_{3}=\begin{bmatrix}<br>1 &amp; -1 &amp; 0 \<br>-1 &amp; 2 &amp; -1 \<br>0 &amp; -1 &amp; 1<br>\end{bmatrix}$</p></li><li><p>$S_{4}=\begin{bmatrix}<br>2 &amp; -1 &amp; 0 \<br>-1 &amp; 2 &amp; -1 \<br>0 &amp; -1 &amp; 2<br>\end{bmatrix}$</p></li></ul></li><li><p>正交矩阵</p><ul><li>$Q_{5}=\begin{bmatrix}<br>\cos \theta  &amp; -\sin \theta  \<br>sin\theta  &amp; \cos \theta<br>\end{bmatrix}$</li></ul></li><li><p>$A_{6}=\begin{bmatrix}<br>3 &amp; 0 \<br>4 &amp; 5<br>\end{bmatrix}$</p></li></ul><h4 id="A-的列空间（列的所有线性组合）"><a href="#A-的列空间（列的所有线性组合）" class="headerlink" title="A 的列空间（列的所有线性组合）"></a>A 的列空间（列的所有线性组合）</h4><ul><li><p>将矩阵乘以向量</p><ul><li><p>$Ax=\begin{bmatrix} 1 &amp; 4 &amp; 5 \ 3 &amp; 2 &amp; 5 \ 2 &amp; 1 &amp; 3 \end{bmatrix}\begin{bmatrix} x_{1} \ x_{2} \ x_{3} \end{bmatrix}=\begin{bmatrix} 1 \ 3 \ 2 \end{bmatrix}x_{1}+\begin{bmatrix} x \ 2 \ 1 \end{bmatrix}x_{2}+\begin{bmatrix} 5 \ 5 \ 3 \end{bmatrix}x_{3}$</p></li><li><p>$Ax$ 为一种特殊的列的线性组合</p></li><li><p>$A$ 的列空间 = $C(A)$ = 所有 $Ax$ 向量 = 各列的所有线性组合</p></li><li><p>$C(A)$ 是一个平面</p></li></ul></li></ul><h4 id="列空间的基"><a href="#列空间的基" class="headerlink" title="列空间的基"></a>列空间的基</h4><ul><li><p>$A=CR=\begin{bmatrix}<br>1 &amp; 4 \<br>3 &amp; 2 \<br>2 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br>1 &amp; 0 &amp; 1 \<br>0 &amp; 1 &amp; 1<br>\end{bmatrix}$</p><ul><li><p>行秩 = 列秩 = r = 2</p></li><li><p>C 是平面的两个独立列向量，而 R 则表示了 A 是如何通过 C 中的两个向量重组 A 的</p></li><li><p>R 的 r 行是行空间的一组基</p></li></ul></li><li><p>$A = CR$ 表明 A 的行秩等于列秩 </p><ul><li>C 的 r 列相互线性独立（由定义可知）</li><li>A 的每一列都是（C 的）这 r 列的线性组合（因为 A = CR）</li><li>R 的 r 行相互线性独立（这 r 列包含了 r × r 的矩阵 I ）</li><li>A 的每一行都是（C 的）这 r 行的线性组合（因为 A = CR）</li></ul></li><li><p>核心内容 </p><ul><li>C 的 r 列组成了 A 的列空间的基：维度 r </li><li>R 的 r 列组成了 A 的行空间的基：维度 r</li></ul></li><li><p>基包含两个向量 </p><ul><li>A 的秩等于 r = 2 </li><li>$n − r = 3 − 2 = 1$</li></ul></li><li><p>计数定理 </p><ul><li>$Ax = 0$ 有一组解 $x = (1, 1, −1)$ 有 $n − r$ 组独立解可使 $Ax = 0$ 成立</li></ul></li></ul><h4 id="秩为-1-的矩阵-A"><a href="#秩为-1-的矩阵-A" class="headerlink" title="秩为 1 的矩阵 A"></a>秩为 1 的矩阵 A</h4><ul><li>如果 A 的任意一列均为第一列的若干倍，那么 A 的每一行均为某行的若干倍</li><li>用 A = CR 来证明<ul><li>C 当中的一列 $v$ ⇒ R 当中的一行 $w$</li><li>$A=\left[ v\right] ^{\left[ w\right] }$ ⇒ 每一行都是 $w$ 的倍数</li></ul></li></ul><h4 id="A-CR-的优良性质"><a href="#A-CR-的优良性质" class="headerlink" title="A = CR 的优良性质"></a>A = CR 的优良性质</h4><ul><li>C 的列直接来源于 A：体现了此公式的内涵</li><li>R 变成了A 的行化简阶梯形</li><li>“行秩 = 列秩”这一结论变得显然：C = 列的基，R = 行的基</li></ul><h4 id="A-CR-不好的性质"><a href="#A-CR-不好的性质" class="headerlink" title="A = CR 不好的性质"></a>A = CR 不好的性质</h4><ul><li>C 和 R 可能是病态矩阵</li><li>如果 A 是可逆的，则有 C = A 和 R = I ⇒ A = AI，原地打转</li></ul><h3 id="线性代数概览"><a href="#线性代数概览" class="headerlink" title="线性代数概览"></a>线性代数概览</h3><h4 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h4><ul><li>若 $Ax = 0$ 则有 $\begin{bmatrix} 1 \ \vdots \ m \end{bmatrix}\left[ x\right]=\begin{bmatrix} 0 \ \vdots \ 0 \end{bmatrix}$，x 与 A 的各列均正交<ul><li>每个处于 A 的零空间当中的 x 都与 A 的行空间正交 </li><li>每个处于 $A^T$ 的零空间当中的 y 都与 A 的列空间正交</li></ul></li><li>$N\left( A\right) \bot C\left( A^{T}\right) $ 与 $N\left( A^{T}\right) \bot C\left( A\right) $<ul><li>两对正交子空间，其中一对子空间的维度之和等于 n，另一对等于 m</li></ul></li></ul><h4 id="宏观视角下的线性代数"><a href="#宏观视角下的线性代数" class="headerlink" title="宏观视角下的线性代数"></a>宏观视角下的线性代数</h4><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B001.png" style="zoom:67%;"></li><li>一对子空间处于 $R_{n}$ 之中，另一对处于$R_{m}$ 当中</li><li>从行空间变换为列空间——由此可知 A 是可逆的</li></ul><h4 id="列与行相乘（六组因式）"><a href="#列与行相乘（六组因式）" class="headerlink" title="列与行相乘（六组因式）"></a>列与行相乘（六组因式）</h4><ul><li>A = BC = 秩为 1 的矩阵之和（列乘以行：外积）</li><li>对矩阵相乘的全新理解（高层次），每次拿一列乘以一行是低层次的<ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B002.png" style="zoom:67%;"></li></ul></li><li>$A=\begin{bmatrix} 2 &amp; 3 \ 4 &amp; 7 \end{bmatrix}=\begin{bmatrix} 1 &amp; 0 \ 2 &amp; 1 \end{bmatrix}\begin{bmatrix} 2 &amp; 3 \ 0 &amp; 1 \end{bmatrix}=LU$ （将矩阵拆分成上下两个三角矩阵）<ul><li>$2x+3y=7$ ， $4x+7y=15$  ⇒ $x=2,y=1$</li><li>若两行发生交换，则 $PA = LU$ （P 指的是排列矩阵）</li></ul></li></ul><h4 id="用消元来解Ax-b（因式-A-LU）"><a href="#用消元来解Ax-b（因式-A-LU）" class="headerlink" title="用消元来解Ax = b（因式 A = LU）"></a>用消元来解Ax = b（因式 A = LU）</h4><ul><li>下三角矩阵 L 乘以上三角矩阵 U</li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B003.png" style="zoom:67%;"></li></ul><h3 id="正交向量"><a href="#正交向量" class="headerlink" title="正交向量"></a>正交向量</h3><h4 id="正交向量-–-矩阵-–-子空间"><a href="#正交向量-–-矩阵-–-子空间" class="headerlink" title="正交向量 – 矩阵 – 子空间"></a>正交向量 – 矩阵 – 子空间</h4><ul><li>$X^{T}y=0,y^{T}x=0,\left( x+y\right) ^{T}\left( x+y\right)=x^{T}<em>{x}+y^{T}</em>{y}$ （直角三角形）</li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B004.png" style="zoom:67%;"></li><li>$Q=\dfrac{1}{3}\begin{bmatrix} -1 &amp; 2 \ 2 &amp; -1 \ 2 &amp; 2 \end{bmatrix}$ ，$Q^{T}Q=I,QQ^{T}\neq I$ ，$QQ^TQQ^T = QQ^T$</li></ul><h4 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h4><h3 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h3><h3 id="奇异值和奇异向量"><a href="#奇异值和奇异向量" class="headerlink" title="奇异值和奇异向量"></a>奇异值和奇异向量</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2020 年 MIT 数学教授 Gilbert Strang 录制了一个关于线性代数的学习和教学的一个新的、启发性的课程，从矩阵 A 的列空间和组合这些列的乘法 Ax 开始，包括了线性代数的概览、正交向量、特征值和特征向量、以及奇异值和奇异向量等方面的内容。以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="http://blog.zhuangzhihao.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>微分学重点</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BE%AE%E5%88%86%E5%AD%A6%E9%87%8D%E7%82%B9/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BE%AE%E5%88%86%E5%AD%A6%E9%87%8D%E7%82%B9/</id>
    <published>2021-09-04T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微分学重点的十二章关于导数的课程深入挖掘了微积分的子领域，“微分”。 与微积分重点的课程一样，MIT 数学教授 Gilbert Strang 解释了每个主题如何应用于现实生活中，是对微积分重点的补充，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。</p></blockquote><a id="more"></a><h3 id="极限和连续"><a href="#极限和连续" class="headerlink" title="极限和连续"></a>极限和连续</h3><ul><li><p> 极限定义：当 $n\rightarrow \infty$ 时，$a_{n}\rightarrow A$</p></li><li><p>洛必达法则：假设 $f(x)$ 和 $g(x)$ 都收敛于 0</p><ul><li> $\dfrac{f\left( x\right) }{g\left( x\right) }=\dfrac{\dfrac{\Delta f}{\Delta x}}{\dfrac{\Delta g}{\Delta x}}\rightarrow \dfrac{s}{t}$</li></ul></li><li><p> 可导必然连续，连续不一定可导</p></li><li><p> 连续定义：对任取 $\varepsilon$，都能找到 $\delta$，满足如果 $\left| x-a\right| &lt;\delta$，则 $\left| f\left( x\right) -f\left( a\right) \right| &lt;\varepsilon$</p></li></ul><h3 id="sinx-和-cosx-的导数"><a href="#sinx-和-cosx-的导数" class="headerlink" title="$sinx$ 和 $cosx$ 的导数"></a>$sinx$ 和 $cosx$ 的导数</h3><ul><li><p>用 $sin$ 和 $cos$ 表示勾股定理</p><ul><li><p>$a^2+b^2=c^2$ $\rightarrow$ $\dfrac{a^{2}}{c^{2}}+\dfrac{b^{2}}{c^{2}}=1$ </p></li><li><p>$\left( \cos \theta \right) ^{2}+\left( \sin \theta \right) ^{2}=1$</p></li></ul></li><li><p>$\dfrac{d}{dx}\sin x=\dfrac{\Delta \left( \sin x\right) }{\Delta x}=\dfrac{\sin \left( x+\Delta x\right) -\sin x}{\Delta x}$</p><ul><li><p>因为 $\sin \left( x+\Delta x\right) =\sin x\cos \Delta x+\cos x\sin \Delta x$</p></li><li><p>所以原式 = $\dfrac{sinx\left( \cos \Delta x-1\right) }{\Delta x}+\dfrac{\cos x\sin \Delta x}{\Delta x}$</p></li><li><p>又因为 $\dfrac{\cos \left( \Delta x-1\right) }{\Delta x}\rightarrow 0$ 且 $\dfrac{\sin \Delta x}{\Delta x}\rightarrow 1$</p></li><li><p>所以 $\dfrac{d}{dx}\sin x=\cos x$</p></li></ul></li><li><p>$\dfrac{d}{dx}\cos x=\dfrac{\Delta \left( \cos x\right) }{\Delta x}=\dfrac{\cos \left( x+\Delta x\right) -\cos x}{\Delta x}$</p><ul><li><p>因为 $\cos \left( x+\Delta x\right) =\cos x\cos \Delta x-\sin x\sin \Delta x$</p></li><li><p>所以原式 = $\dfrac{cos\left( \cos \Delta x-1\right) }{\Delta x}-\dfrac{\sin x\sin \Delta x}{\Delta x}$</p></li><li><p>所以 $\dfrac{d}{dx}\cos x=-\sin x$</p></li></ul></li><li><p>$sinx$ 和 $cosx$ 的导数</p><ul><li><p>$\dfrac{d}{dx}\sin x=\cos x$</p></li><li><p>$\dfrac{d}{dx}\cos x=-\sin x$</p></li></ul></li></ul><h3 id="乘法法则和除法法则"><a href="#乘法法则和除法法则" class="headerlink" title="乘法法则和除法法则"></a>乘法法则和除法法则</h3><ul><li><p>$p(x)=f(x)g(x)$</p><ul><li><p>$\dfrac{\Delta p}{\Delta x}=\dfrac{f\Delta g}{\Delta x}+\dfrac{g\Delta f}{\Delta x}+\dfrac{\Delta f{\Delta }g}{\Delta x}$</p></li><li><p>乘法法则：$\dfrac{dp}{dx}=f\left( x\right) \dfrac{dg}{dx}+g\left( x\right) \dfrac{df}{dx}$</p></li><li><p>$\dfrac{d}{dx}x^{n}=nx^{n-1}$</p></li><li><p>$y=x^2sinx$：$\dfrac{dy}{dx}=x^{2}\cos x+2xsinx$</p></li></ul></li><li><p>$q(x)=\dfrac{f(x)}{g(x)}$</p><ul><li><p>$f(x)=g(x)q(x)$</p></li><li><p>$\dfrac{df}{dx}=g\left( x\right) \dfrac{dq}{dx}+q\left( x\right) \dfrac{dg}{dx}=g\left( x\right) \dfrac{dq}{dx}+\dfrac{f\left( x\right) }{g\left( x\right) }\dfrac{dg}{dx}$</p></li><li><p>$g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}=g(x)^{2}\dfrac{dq}{dx}$</p></li><li><p>除法法则：$\dfrac{dq}{dx}=\dfrac{g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}}{g\left( x\right) ^{2}}$</p></li></ul></li></ul><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><ul><li><p>函数链（复合函数）：$y=g(x)$，$z=f(y)$</p><ul><li>求导：$\dfrac{dz}{dx}=\dfrac{dz}{dy}\dfrac{dy}{dx}$</li></ul></li><li><p>$sin(3x)$ 的导数：$3cos(3x)$</p></li><li><p>$\dfrac{1}{\sqrt{1-x^{2}}}$ 的导数：$\left( -\dfrac{1}{2}\left( 1-x^{2}\right) ^{-3}\right) -2x=x\left( 1-x^{2}\right) ^{-\dfrac{3}{2}}$</p></li><li><p>$e^{-\dfrac{x^{2}}{2}}$ 的导数：$-x\cdot e^{-\dfrac{x^{2}}{2}}$</p><ul><li>二阶导数：$\left( -x\right) \left( -xe^{-\dfrac{x^{2}}{2}}\right) +\left( e^{-\dfrac{x^{2}}{2}}\right) \left( -1\right)=(x^2-1)\cdot e^{-\dfrac{x^{2}}{2}}$</li></ul></li></ul><h3 id="反函数-f-1-left-y-right-与对数函数-x-lny"><a href="#反函数-f-1-left-y-right-与对数函数-x-lny" class="headerlink" title="反函数 $f^{-1}\left( y\right)$ 与对数函数 $x=lny$"></a>反函数 $f^{-1}\left( y\right)$ 与对数函数 $x=lny$</h3><ul><li><p>$y=f(x)$ 的反函数：$x=f^{-1}(y)$，原函数和反函数关于 $y=x$ 对称</p></li><li><p>$y=e^{x}$ 的反函数：$x=lny$</p></li><li><p>对数函数的性质</p><ul><li><p>$\ln(xy) =\ln x+\ln y$</p></li><li><p>$ln(y^n)=nlny$</p></li></ul></li><li><p>$\dfrac{d}{dy}\left( \ln y\right) =\dfrac{1}{y}$</p></li></ul><h3 id="对数函数-lny-和反三角函数-sin-1-y-的导数"><a href="#对数函数-lny-和反三角函数-sin-1-y-的导数" class="headerlink" title="对数函数 $lny$ 和反三角函数 $sin^{-1}(y)$ 的导数"></a>对数函数 $lny$ 和反三角函数 $sin^{-1}(y)$ 的导数</h3><ul><li><p>令 $y=e^x$</p><ul><li><p>$\ln \left( e^{x}\right) =x$ 两边求导 $\dfrac{d}{dy}\left( \ln y\right) e^{x}=1$</p></li><li><p>$\dfrac{d}{dy}\left( \ln y\right) =\dfrac{1}{e^{x}}=\dfrac{1}{y}$</p></li></ul></li><li><p>$x=\sin ^{-1}y=\arcsin y$</p><ul><li><p>$y=\sin \left( \sin ^{-1}y\right)$ 两边求导 $1=\cos \left( \sin ^{-1}y\right) \dfrac{d\sin ^{-1}y}{dy}$</p></li><li><p>$1=\sqrt{1-y^{2}}\dfrac{d}{dy}\sin ^{-1}y$</p></li><li><p>$\dfrac{d}{dy}\sin ^{-1}y=\dfrac{1}{\sqrt{1-y^{2}}}$</p></li></ul></li><li><p>同理：$\dfrac{d}{dy}\cos ^{-1}y=\dfrac{-1}{\sqrt{1-y^{2}}}$，$\dfrac{d}{dy}\tan ^{-1}\left( y\right) =\dfrac{1}{1+y^{2}}$</p></li></ul><h3 id="增长率和对数图"><a href="#增长率和对数图" class="headerlink" title="增长率和对数图"></a>增长率和对数图</h3><ul><li><p>线性增长：$cx,x^{2},x^{3},\ldots$</p></li><li><p>指数增长：$2^{x},e^{x},10^{x},\ldots$</p></li><li><p>阶乘：$2^{x},e^{x},10^{x},\ldots$</p></li><li><p>对数图</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/微积分重点04.png" style="zoom: 50%;"></li></ul></li><li><p>线性拟合</p><ul><li><p>$y=Ax^{n}\rightarrow \log y=\log A+n\log x$</p></li><li><p>$y=B\cdot 10^{cx}\rightarrow \log y=\log B+cx$</p></li></ul></li></ul><h3 id="线性近似和牛顿法"><a href="#线性近似和牛顿法" class="headerlink" title="线性近似和牛顿法"></a>线性近似和牛顿法</h3><ul><li><p>取 $x=a$，已知 $\dfrac{df}{dx}=f’\left( a\right) =\lim _{x\rightarrow a}\dfrac{f\left( x\right) -f\left( a\right) }{x-a}$，求 $f(x)$</p></li><li><p>线性近似：函数在 a 点一阶泰勒展开</p><ul><li><p>$f’\left( a\right) \approx \dfrac{f\left( x\right) -f\left( a\right) }{x-a}$</p></li><li><p>$f\left( x\right) \approx f\left( a\right) +\left( x-a\right) f’\left( a\right)$</p></li></ul></li><li><p>牛顿法</p><ul><li><p>令 $F(x)=0$</p></li><li><p>$x-a\approx \dfrac{-F\left( a\right) }{F’\left( a\right) }$</p></li></ul></li><li><p>近似法求 $\sqrt{9.06}$</p><ul><li><p>$f\left( x\right) =\sqrt{x}=x^{\dfrac{1}{2}}$</p></li><li><p>$f’\left( x\right) =\dfrac{1}{2}x^{-\dfrac{1}{2}}=\dfrac{1}{\sqrt[2] {x}}$</p></li><li><p>取 $a=9$，$f(a)=\sqrt9=3$，$f’(a)=\dfrac{1}{6}$</p></li><li><p>$\sqrt{9.06}\approx 3+\left( 9.06-9\right) \dfrac{1}{6}=3.01$</p></li></ul></li><li><p>近似法求 $e^{0.01}$</p><ul><li><p>$f\left( x\right) =e^{x}$（$x=0.01$）</p></li><li><p>取 $a=0$，$f(a)=e^0=1$，$f’(a)=e^0=1$</p></li><li><p>$e^{x}=e^{0=01}=1+\left( 0.d-0\right) \cdot 1=1.01=1+x$</p></li></ul></li><li><p>牛顿法求 $\sqrt{9.06}$</p><ul><li><p>$F\left( x\right) =x^{2}-9.06=0$</p></li><li><p>取 $a=3$，$F(a)=9-9.06=-0.06$，$F’(a)=2a=6$</p></li><li><p>$x-3\approx \dfrac{0.06}{6}=0.01$</p></li></ul></li></ul><h3 id="幂级数和欧拉公式"><a href="#幂级数和欧拉公式" class="headerlink" title="幂级数和欧拉公式"></a>幂级数和欧拉公式</h3><ul><li><p>泰勒级数：$f\left( x\right) =f\left( 0\right) +f’\left( 0\right) \dfrac{x}{1}+f’’\left( 0\right) \dfrac{x^{2}}{2}+\ldots +f^{\left( n\right) }\left( 0\right) \dfrac{x^{n}}{n!}$</p><ul><li>$x^n$ 的 n 阶导：$n!$</li></ul></li><li><p>使用泰勒级数展开的幂级数</p><ul><li><p>$e^{x}=1+x+\dfrac{1}{2}x^{2}+\dfrac{1}{6}x^{3}+\ldots +\dfrac{1}{n!}x^{n}$</p></li><li><p>$\sin x=x-\dfrac{x^{3}}{3!}+\dfrac{x^{5}}{5!}\ldots$ 奇级数</p></li><li><p>$\cos x=1-\dfrac{x^{2}}{2!}+\dfrac{x^{4}}{4!}\ldots$ 偶级数</p></li></ul></li><li><p>欧拉公式：将 $e^x$ 级数中的 $x$ 考虑为虚数 $i$</p><ul><li><p>$e^{ix}=1+ix+\dfrac{1}{2!}\left( ix\right) ^{2}+\dfrac{1}{3!}\left( ix\right) ^{3}+\ldots$</p></li><li><p>实数、虚数分离：$e^{ix}=\left( 1-\dfrac{1}{2!}x^{2}+\ldots \right) +i\left( x-\dfrac{1}{3!}x^{3}+\ldots \right)$</p></li><li><p>因此：$e^{ix}=\cos x+i\sin x$</p></li><li><p>同理：$e^{-ix}=\cos x-i\sin x$</p></li></ul></li><li><p>几何级数：$\dfrac{1}{1-x}=1+x+x^{2}+x^{3}+\ldots ( \left| x\right| &lt; 1)$</p></li><li><p>将几何级数逐项积分：$-ln \left( 1-x\right) =x+\dfrac{x^{2}}{2}+\dfrac{x^{3}}{3}+\dfrac{x^{4}}{4}+\ldots ( \left| x\right| &lt; 1)$</p></li></ul><h3 id="关于运动的微分方程"><a href="#关于运动的微分方程" class="headerlink" title="关于运动的微分方程"></a>关于运动的微分方程</h3><ul><li><p>微分方程就是函数的导数和函数本身之间存在的关系</p></li><li><p>常系数二阶线性微分方程：$m\dfrac{d^{2}y}{dt^{2}}+2r\dfrac{dy}{dt}+ky=0$</p><ul><li><p>$m=0$ 时，$\dfrac{dy}{dt}=ay\rightarrow y=ce^{at}$</p></li><li><p>$r=0$ 时，$\dfrac{d^{2}y}{dt^{2}}=-\omega ^{2}y$ （$\omega ^{2}= \dfrac{k}{m}$）$\rightarrow y=C\cos \omega t+D\sin \omega t$</p></li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B905.png" style="zoom: 50%;"></li></ul></li><li><p>令 $y=e^{\lambda t}$ 满足方程 $m\lambda ^{2}e^{\lambda t}+2r\lambda e^{\lambda t}+ke^{\lambda t}=0$</p><ul><li><p>$m\lambda ^{2}+2r\lambda +k=0$</p></li><li><p>$\lambda =\dfrac{-r\pm \sqrt{r^{2}-km}}{m}$</p></li><li><p>$y=Ce^{\lambda _{1}t}+De^{\lambda _{2}t}$</p></li><li><p>若 $\lambda _{1}=\lambda _{2}$，$y=Ce^{\lambda t}+Dte^{\lambda t}$</p></li></ul></li><li><p>当 $m=1,r=3,k=10$ 时，$1y’’+6y’+10y=0$</p><ul><li><p>$\lambda ^{2}+6\lambda +10=0$</p></li><li><p>$\lambda =-3\pm i$</p></li><li><p>$y\left( t\right) =Ce^{\left( -3+i\right) t}+De^{\left( -3-i\right) t}$</p></li><li><p>由欧拉公式：$y\left( t\right) =Ae^{-3t}\cos t+Be^{-3t}\sin t$</p></li></ul></li></ul><h3 id="关于增长的微分方程"><a href="#关于增长的微分方程" class="headerlink" title="关于增长的微分方程"></a>关于增长的微分方程</h3><ul><li><p>微分方程 $\dfrac{dy}{dt}=cy$，对于任意 A 有解 $y\left( t\right) =Ae^{ct}$</p><ul><li>$y\left( t\right) =y\left( 0\right) e^{ct}$</li></ul></li><li><p>增加初始常数：$\dfrac{dy}{dt}=cy+s$</p><ul><li><p>$\dfrac{d}{dt}\left( y+\dfrac{s}{c}\right) =c\left( y+\dfrac{s}{c}\right)$</p></li><li><p>$y\left( t\right) =-\dfrac{s}{c}+\left( y\left( 0\right) +\dfrac{s}{c}\right) e^{ct}$</p></li></ul></li><li><p>人口增长方程：$\dfrac{dP}{dt}=cP-sP^{2}$，$c$ 为增长率而 $s$ 为竞争因素</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B906.png" style="zoom: 50%;"></li><li><p>令 $y=\dfrac{1}{P}$，$\dfrac{dy}{dt}=-\dfrac{\dfrac{dP}{dt}}{P^{2}}=\dfrac{\left( cP+sP^{2}\right) }{P^{2}}=s-cP=s-cy$</p></li><li><p>$y\left( t\right) =\dfrac{s}{c}+Ae^{-ct}=\dfrac{s}{c}+\left( y\left( 0\right) -\dfrac{s}{c}\right) e^{-ct}$</p></li><li><p>$\dfrac{1}{p\left( t\right) }-\dfrac{s}{c}=\left( \dfrac{1}{p(0)}-\dfrac{s}{c}\right) e^{-ct}$</p></li></ul></li><li><p>人口增长方程二阶导数：$\dfrac{d^{2}P}{dt^{2}}=\dfrac{d}{dt}\left( cP-sP^{2}\right) =\left( c-2sP\right) \dfrac{dP}{dt}$</p><ul><li>$p=\dfrac{c}{2s}$ 时，$\dfrac{d^{2}P}{dt^{2}}=0$（拐点，增长率开始放缓）</li></ul></li></ul><h3 id="微分学总结"><a href="#微分学总结" class="headerlink" title="微分学总结"></a>微分学总结</h3><h4 id="六函数"><a href="#六函数" class="headerlink" title="六函数"></a>六函数</h4><table><thead><tr><th align="center">积分</th><th align="center"></th><th align="center">导数</th></tr></thead><tbody><tr><td align="center">$\dfrac{x^{n+1}}{\left( n+1\right) },n\neq -1$</td><td align="center">$x^n$</td><td align="center">$nx^{n-1}$</td></tr><tr><td align="center">$-cosx$</td><td align="center">$sinx$</td><td align="center">$cosx$</td></tr><tr><td align="center">$sinx$</td><td align="center">$cosx$</td><td align="center">$-sinx$</td></tr><tr><td align="center">$\dfrac{e^{cx}}{c}$</td><td align="center">$e^{cx}$</td><td align="center">$ce^{cx}$</td></tr><tr><td align="center">$x\ln x-x$</td><td align="center">$lnx$</td><td align="center">$\dfrac{1}{x}$</td></tr><tr><td align="center">斜坡函数</td><td align="center">分段函数</td><td align="center">$\delta$ 函数</td></tr></tbody></table><h4 id="六法则"><a href="#六法则" class="headerlink" title="六法则"></a>六法则</h4><ul><li><p>加法法则：和的导数等于导数的和</p><ul><li>$af\left( x\right) +bg\left( x\right) \rightarrow a\dfrac{df}{dx}+b\dfrac{dg}{dx}$</li></ul></li><li><p>乘法法则：上乘下导加下乘上导</p><ul><li>$f\left( x\right) g\left( x\right) \rightarrow f\left( x\right) \dfrac{dg}{dx}+g\left( x\right) \dfrac{df}{dx}$</li></ul></li><li><p>除法法则：下平方分之下乘上导减上乘下导</p><ul><li>$\dfrac{f\left( x\right) }{g\left( x\right) }\rightarrow  \dfrac{g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}}{g\left( x\right) ^{2}}$</li></ul></li><li><p>链式法则</p><ul><li>$f\left( g\left( x\right) \right) \rightarrow \dfrac{df}{dy}\dfrac{dy}{dx}$</li></ul></li><li><p>反函数的导数等于原函数的导数分之一</p><ul><li>$x=f^{-1}\left( y\right) \rightarrow \dfrac{dx}{dy}=\dfrac{1}{\dfrac{dy}{dx}}$</li></ul></li><li><p>洛必达法则：$\dfrac{0}{0}$ 或 $\dfrac{\infty }{\infty }$</p><ul><li>$\dfrac{f\left( x\right) }{g\left( x\right) }\rightarrow \dfrac{\dfrac{dt}{dx}}{\dfrac{dg}{dx}}$</li></ul></li></ul><h4 id="六定理"><a href="#六定理" class="headerlink" title="六定理"></a>六定理</h4><ul><li><p>微积分基本定理</p><ul><li><p>如果函数 $f(x)=\int _{a}^{x}s\left( t\right) dt$，那么函数的导数为 $\dfrac{df}{dx}=s\left( x\right) $</p></li><li><p>如果函数的导数为 $\dfrac{df}{dx}=s\left( x\right) $，那么导数的积分（原函数）为 $\int _{a}^{b}s\left( x\right) dx=f\left( b\right) -f\left( a\right) $</p></li></ul></li><li><p>介值定理（全值定理）</p><ul><li><p>对于 $a\leq x\leq b$ 区间上的连续函数</p></li><li><p>一定能取到最大值 $M$ 和最小值 $m$，使得 $[M,m]$ 中的任意值都存在函数上的点与之对应</p></li><li><p>连续函数的一个区间内的函数值肯定介于最大值 $M$ 和最小值 $m$之间</p></li></ul></li><li><p>中值定理</p><ul><li>如果函数 $f(x)$ 在闭区间 $[a,b]$ 上连续，在开区间 $(a,b)$ 内可导，那么在 $(a,b)$ 内至少有一点 $\varepsilon $，使 $f\left( b\right) -f\left( a\right) =f\left( \varepsilon \right) \left( b-a\right) $ 成立</li></ul></li><li><p>泰勒级数</p><ul><li><p>$f\left( x\right) =f\left( a\right) +f’\left( a\right) \left( x-a\right) +\dfrac{1}{2}f’’\left( a\right) \left( x-a\right) ^{2}+\ldots =\sum ^{\infty }_{n=0}\dfrac{1}{n!}f^{\left( n\right) }\left( a\right) \left( x-a\right) ^{n}$</p></li><li><p>若级数截断于 $\left( x-a\right) ^{n}$ 项，余项为：$\dfrac{1}{\left( n+1\right) !}f^{\left( n+1\right) }\left( c\right) \left( x-a\right) ^{\left( n+1\right) }$</p></li><li><p>当 $a=0$ 时，$f\left( x\right)=\sum ^{\infty }_{n=0}\dfrac{1}{n!}f^{\left( n\right) }\left( 0\right) \left( x\right) ^{n}$</p></li></ul></li><li><p>二项式定理</p><ul><li><p>帕斯卡三角：<img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B907.png" style="zoom:80%;"></p></li><li><p>$(1+x)^p=1+px+\dfrac{P\left( p-1\right) }{\left( 2\right) \left( 1\right) }x^{2}+\dfrac{p\left( p-1\right) \left( p-2\right) }{\left( 3\right) \left( 2\right) \left( 1\right) }x^{3}+\ldots $</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;微分学重点的十二章关于导数的课程深入挖掘了微积分的子领域，“微分”。 与微积分重点的课程一样，MIT 数学教授 Gilbert Strang 解释了每个主题如何应用于现实生活中，是对微积分重点的补充，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="http://blog.zhuangzhihao.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>微积分重点</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B9/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B9/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微积分重点（Highlights of Calculus）是 MIT 数学教授 Gilbert Strang 对于微积分中的精华和重点出的一个生动、简短的课程，帮助我们重新审视微积分，课程主要涉及单变量微积分的总览，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。</p></blockquote><a id="more"></a><h3 id="微积分总览"><a href="#微积分总览" class="headerlink" title="微积分总览"></a>微积分总览</h3><ul><li><p>微积分是函数（1）和函数（2）之间的桥梁</p><ul><li><p>距离 $f\left( t\right)$ 、速度 $\dfrac{df}{dt}$</p></li><li><p>高度 $y\left( x\right)$ 、斜率 $\dfrac{dy}{dx}$</p></li></ul></li><li><p>匀速情况下，$速度=\dfrac{距离}{时间}$，即 $斜率=\dfrac{垂直}{水平}$，即 $s=\dfrac{f}{t}$</p><ul><li>若要求中间一段时间或距离的速度，$s=\dfrac{\Delta f}{\Delta t}$</li></ul></li><li><p>匀变速情况下，函数图像均为曲线</p><ul><li><p>微分学就是已知 $距离-时间$ 函数求 $速度-时间$ 函数</p></li><li><p>积分学就是已知 $速度-时间$ 函数求 $距离-时间$ 函数</p></li><li><p> $速度-时间$ 函数 $s=at$ 下面积 $\dfrac{1}{2}t\left( at\right)$ 就是 $距离-时间$ 函数 $\dfrac{1}{2}at^{2}$</p></li><li><p>速度 $s=\dfrac{df}{dt}$ 就是 $f=\int s\left( t\right) dt$ 的导数</p></li></ul></li></ul><h3 id="导数总览"><a href="#导数总览" class="headerlink" title="导数总览"></a>导数总览</h3><ul><li><p>已知距离 $f\left( t\right)$  如何求速度 $\dfrac{df}{dt}$，即已知高度 $y\left( x\right)$  如何求斜率 $\dfrac{dy}{dx}$</p></li><li><p>三个重要函数的斜率</p><ul><li><p>幂函数 $y=x^{n}$ ：$\dfrac{dy}{dx}=nx^{n-1}$</p></li><li><p>三角函数 $y=\sin x$ ：$\dfrac{dy}{dx}=\cos x$</p></li><li><p>指数函数 $y=e^{x}$ ：$\dfrac{dy}{dx}=e^{x}$</p></li></ul></li><li><p>$y=x^2$ 斜率的含义</p><ul><li><p>$平均斜率\dfrac{\left( \Delta x\right) ^{2}}{\Delta x}$，即 $\dfrac{\Delta y}{\Delta x}$ $\rightarrow$ $瞬时斜率\dfrac{dy}{dx}$</p></li><li><p>$\dfrac{\Delta y}{\Delta x}=\dfrac{\left( x+\Delta x\right) ^{2}}{\Delta x}\dfrac{-x^{2}}{}=\dfrac{2xax+\left( \Delta x\right) ^{2}}{\Delta x}=2x+\Delta x$</p></li><li><p>求导：$\dfrac{dy}{dx}=\lim\dfrac{\Delta y}{\Delta x}=2x$</p></li></ul></li><li><p>任意 $x$ 处，$y=\sin x 的斜率\rightarrow \dfrac{dy}{dx}=\cos x$</p></li></ul><h3 id="极值及二阶导数"><a href="#极值及二阶导数" class="headerlink" title="极值及二阶导数"></a>极值及二阶导数</h3><ul><li><p>二阶导数：导数的导数</p><ul><li>一阶导数用于确认极值点，二阶导数表明曲线弯曲方向</li></ul></li><li><p>二阶导数的例子：加速度</p><ul><li><p>距离 $f\left( t\right)$ 、速度 $\dfrac{df}{dt}$、加速度 $\dfrac{d^{2}f}{dt^{2}}$</p></li><li><p>高度 $y=x^2$ 、斜率 $\dfrac{dy}{dx}=2x$、弯曲性 $\dfrac{d^{2}f}{dt^{2}}=2$</p></li><li><p>$sinx$ 的二阶导数为 $-sinx$</p></li></ul></li><li><p>凸函数和凹函数：$f’’ &gt;0$ 为凸，表示向上弯曲，相对的凹为 $f’’ &lt;0$</p></li><li><p>拐点：二阶导数为 0 的点，表示弯曲方向改变</p></li><li><p>对于函数 $y=x^{3}-x^{2}$ $\rightarrow$ $y’=3x^{2}-2x$，$y’’=6x-2$</p><ul><li><p>求极值点：令 $y’=3x^{2}-2x=0$，$x= 0或x=\dfrac{2}{3}$</p></li><li><p>$x=0$ 处，二阶导数为负，取局部最大值（极大值）</p></li><li><p>$x=\dfrac{2}{3}$ 处，二阶导数为正，取局部最小值（极小值）</p></li></ul></li><li><p>应用：上班的最短时间</p><ul><li><p>设高速总长 $b$，家垂直上高速距离为 $a$，没走的高速距离为 $x$</p></li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B901.png" style="zoom: 33%;"></li><li><p>$时间t=\dfrac{b-x}{60}+\dfrac{\sqrt{a^{2}+x^{2}}}{30}$</p></li><li><p>取时间方程的导数，然后令导数为 0 来求最小值</p></li><li><p>$f’=-\dfrac{1}{60}+\dfrac{1}{30}\cdot \dfrac{1}{2}\cdot \dfrac{2x}{\sqrt{a^{2}+x^{2}}}=0$ $\rightarrow$ $x=\dfrac{a}{\sqrt{3}}$</p></li></ul></li><li><p>最值的一般求法：比较所有驻点（$f’=0$）处及边界点函数值，得到最大或最小值即函数最值</p></li><li><p>$f’’$ 的符号可通过 $f’$ 的单调性求出：$x&gt;0$ 时，$f’(x)&gt;f’(0)$ ，斜率变化率为正，$f’’&gt;0$</p></li></ul><h3 id="指数函数-e-x"><a href="#指数函数-e-x" class="headerlink" title="指数函数 $e^x$"></a>指数函数 $e^x$</h3><ul><li><p>最简单的微分方程：$y=\dfrac{dy}{dx}$</p></li><li><p>指数函数：通过微积分构造的函数</p><ul><li><p>重要性质一：指数函数的导数就是其自身</p></li><li><p>函数初始点：$y=e^{0}=1$</p></li><li><p>$\dfrac{x^{n}}{n!}$ 斜率的导数为 $\dfrac{x^{n-1}}{\left( n-1\right) !}$</p></li><li><p>指数级数：$e^{x}=1+x+\dfrac{x^{2}}{2!}+\dfrac{x^{3}}{3!}+\ldots +\dfrac{x^{n}}{n!}+\ldots$</p></li><li><p>重要性质二：$e^{x}\cdot e^{X}=e^{x+X}$</p></li><li><p>$e$ 等于 $x=1$ 时指数级数的值：$e=1+1+\dfrac{1}{2}+\dfrac{1}{6}+\ldots \dfrac{1}{n!}+\ldots\approx 2.71828\ldots$</p></li></ul></li><li><p>指数函数的图像</p><ul><li><p>由重要性质二可得：$e^{-x}=\dfrac{1}{e^{x}}$</p></li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B902.png" style="zoom:50%;"></li></ul></li><li><p>应用：计算存款复利</p><ul><li><p>假设利率为 100%，1 美元存一年得到 2 美元或更多</p></li><li><p>将一年分为 n 份付利息，得到 $\left( 1+\dfrac{1}{n}\right) ^{n}$，$n\rightarrow \infty$ 时最终趋近于 $e$</p></li><li><p>解常微分方程：$\dfrac{dy}{dx}=cy$ $\rightarrow$ $y\left( x\right) =e^{cx}$</p></li></ul></li></ul><h3 id="积分总览"><a href="#积分总览" class="headerlink" title="积分总览"></a>积分总览</h3><ul><li><p>函数二 $\dfrac{dy}{dx}=nx^{n-1}$ 是函数一 $y=x^{n}$ 的导数</p></li><li><p>函数一 $y=\dfrac{x^{n+1}}{n+1}$ 是函数二 $\dfrac{dy}{dx}=x^{n}$ 的积分</p></li><li><p>求原函数：$y\left( x\right) =\int s\left( x\right) dx$</p></li><li><p>求积分方法A：反过来看什么函数的导数能得到要积分的函数</p></li><li><p>例：通过代数方法求函数一</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B903.png" style="zoom:67%;"></li><li><p>相加求和：$\sum \Delta y=y_{终}-y_{始}$</p></li></ul></li><li><p>例：通过微积分方法求函数一</p><ul><li><p>同时乘除 $\Delta x$：$\sum \left( \dfrac{\Delta y}{\Delta x}\right) \Delta x=y_{终}-y_{始}$</p></li><li><p>在 $\Delta x\rightarrow 0$ 的极限情况下，求和转化为积分：$\int \dfrac{dy}{dx}dx$</p></li></ul></li><li><p>求积分方法B：$积分=函数一=函数二图像下的面积$</p><ul><li>斜率为 $s=2-2x$，对应的高度 $y=2x-x^2$</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;微积分重点（Highlights of Calculus）是 MIT 数学教授 Gilbert Strang 对于微积分中的精华和重点出的一个生动、简短的课程，帮助我们重新审视微积分，课程主要涉及单变量微积分的总览，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="http://blog.zhuangzhihao.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>考研政治小抄</title>
    <link href="http://blog.zhuangzhihao.top/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%B0%8F%E6%8A%84/"/>
    <id>http://blog.zhuangzhihao.top/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%B0%8F%E6%8A%84/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.845Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“思想政治理论”是研究生招生考试必考科目之一（为什么！┗|｀O′|┛），分为马原、毛中特、史纲、思修和时政5个大类。政治内容众多且杂，如果对基础概念和知识进行具体总结，篇幅非常长，本篇笔记只是以一个“Cheat-sheet”的形式尽可能包含所有考试重点，至于系统的归纳梳理则以肖精讲精练为准。</p></blockquote><a id="more"></a><h3 id="马克思主义基本原理概论"><a href="#马克思主义基本原理概论" class="headerlink" title="马克思主义基本原理概论"></a>马克思主义基本原理概论</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>马克思主义哲学（科学方法）<ul><li>哲学的基本问题哲学的基本问题，不同的哲学流派</li><li>马哲</li><li>唯物论——世界的本源是什么</li><li>辩证法——世界是怎样的</li><li>认识论——如何认知世界</li><li>唯物史观——人类历史发展规律</li></ul></li><li>马克思主义政治经济学（主体）<ul><li>简单商品经济时期（资本主义以前的商品经济就叫简单经济时期）</li><li>发达商品经济时期</li><li>自由竞争资本主义（考试重点）</li><li>垄断竞争资本主义</li></ul></li><li>科学社会主义理论（目的和归宿）<ul><li>社会主义：从空想到实</li><li>共产主义：社会的终极形态</li></ul></li><li>恩格斯的《反杜林论》把马原分为哲学、政经、科社</li></ul><h4 id="唯物论"><a href="#唯物论" class="headerlink" title="唯物论"></a>唯物论</h4><ul><li>世界的本原<ul><li>主观唯心：世界的本原在我心里（王阳明心学）</li><li>客观唯心：世界的本原是脱离物质世界、不依赖于个人意识而独立存在的精神（佛教中的“缘”、道教中的“道”）</li><li>马克思主义哲学认为世界的本原是一切客观实在</li><li>客观实在：不以人的意志为转移</li></ul></li><li>物质决定意识，物质派生出意识</li></ul><h4 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h4><ul><li>物质世界是联系和发展的</li><li>辩证法的两大总特征：联系、发展<ul><li>联系：世界上的万事万物都与其他事物发生某种关联、产生某种联系，这个世界是联系的统一体，不存在完全孤立的事物</li><li>发展：任何事物都有它的过去、现在与将来，要立足于过去，展望将来</li></ul></li><li>事物是一对一对联系的<ul><li>一个事物与另一个事物发生联系，而另一个事物又与另一个事物发生联系，如此循环往复</li><li>世界就是靠一对一对相互交织的联系，构建出一张普遍交织的大网，这就是联系的普遍性</li></ul></li><li>辩证法的三大规律：对立统一、量变质变、否定之否定<ul><li>对立统一：是世间万事万物发展的原因和动力</li><li>量变质变：不断地进行星的积累，最终实现质的突破，不断地积累与突破</li><li>否定之否定：波浪式地上升、螺旋式的前进，是事物发展的方向与归宿</li></ul></li></ul><h4 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h4><ul><li>认识的本质是人类头脑对外部世界的能动反映</li><li>实践是认识的来源</li><li>没有人类的实践，就不会有人类的认识<ul><li>感性认识（浅显）：外部世界直接作用于感官而形成的认识</li><li>理性认识（深刻）：基于感性素材，对其概括、抽象、提炼、加工、思考，获得理性认识</li></ul></li><li>真理：脑子里面的东西与外部世界相致</li><li>谬误：脑子里面的东西与外部世界不一致</li><li>真理的绝对性与相对性：任何一个真理既是绝对的,又是相对的（从不同角度来看）<ul><li>真理的绝对性（通俗）：我既然是真理，我肯定是对的</li><li>真理的相对性（通俗）：我虽然是对的，但我未来有可能不对</li></ul></li></ul><h4 id="唯物史观"><a href="#唯物史观" class="headerlink" title="唯物史观"></a>唯物史观</h4><ul><li>历史进程中的决定性力量<ul><li>唯心史观:由精神力量所决定</li><li>唯物史观:由物质力量所决定（社会生产劳动及其生产力水平的提高决定历史发展）</li></ul></li><li>历史是什么人创造的<ul><li>唯心史观：历史是由英雄人物创造</li><li>唯物史观：历史是由人民群众创造</li></ul></li><li>历史向前发展是统一性和多样性的统一<ul><li>自然界：不以人的意志为转移的客观规律</li><li>人类社会：历史发展规律（取决定性作用）+ 人的主观能动性（对其选择）</li><li>规律使得人类社会的发展具有统一性，能动使得人类社会的发展具有多样性</li></ul></li></ul><h4 id="马克思主义政治经济学"><a href="#马克思主义政治经济学" class="headerlink" title="马克思主义政治经济学"></a>马克思主义政治经济学</h4><ul><li>商品价值的本质是劳动者通过劳动创造的价值</li><li>商品的价值：隐藏在商品里面、用作交换的、人的劳动</li><li>资本主社会以前：劳动的过程以及劳动的成果都归劳动者本人所有</li><li>资本主义社会以后：劳动的过程以及劳动的成果都归资本家所有</li><li>为什么资本主义社会存在剥削<ul><li>劳动创造价值，其中一部分价值通过工资的形式给了劳动者，多出来的部分（剩余价值）被资本家无偿占有</li></ul></li></ul><h4 id="科学社会主义发展进程"><a href="#科学社会主义发展进程" class="headerlink" title="科学社会主义发展进程"></a>科学社会主义发展进程</h4><ul><li>社会主义的发展进程<ul><li>空想 -&gt; 科学</li><li>理论 -&gt; 实践</li></ul></li><li>共产主义的基本特征<ul><li>物质财富极大丰富（产品）</li><li>精神境界极大提高</li><li>每个人自由而全面的发展</li></ul></li></ul><h3 id="思想道德修养与法律基础"><a href="#思想道德修养与法律基础" class="headerlink" title="思想道德修养与法律基础"></a>思想道德修养与法律基础</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>思想修养<ul><li>人生观：如何树立正确的人生观</li><li>理想信念：如何树立远大的理想，理想和现实是怎样的关系</li><li>中国精神：什么是中国精神，如何去弘扬中国精神</li><li>社会主义核心价值观：当代中国人的思想标准</li></ul></li><li>道德修养<ul><li>道德的基本问题：概念、本质、特征、功能、历史发展脉络</li><li>两个维度<ul><li>不同时期的道德：古代的道德、近代的道德、今天的道德</li><li>不同领域的道德：社会工作中的道德提倡、职场工作中的道德提倡、自身修养的道德报倡、家庭生活中的道德提倡</li></ul></li></ul></li><li>法律基础：基础常识</li></ul><h4 id="思想修养"><a href="#思想修养" class="headerlink" title="思想修养"></a>思想修养</h4><ul><li>人生价值<ul><li>人生观：指我们对自己的人生的整体看法和整体观点</li><li>人生观属于世界观，世界观包含人生观</li><li>人生目的：在人生观中居于核心地位</li><li>人生目的是人生观的核心，可以决定人生态度和人生价值</li></ul></li><li>理想信念<ul><li>理想通过实践实现现实</li><li>实践是理想变成现实的根本途径</li><li>理想 -&gt; 信念 -&gt; 信仰 -&gt; 科学/非科学的信仰</li><li>信仰一般不会改变,但是不是不能改变</li><li>个人理想服从于社会理想，社会理想为个人理想提供保障</li></ul></li><li>中国精神<ul><li>以爱国主义为核心的民族精神</li><li>以改革创新为核心的时代精神</li></ul></li><li>社会主义核心价值观</li></ul><h4 id="道德修养"><a href="#道德修养" class="headerlink" title="道德修养"></a>道德修养</h4><ul><li>道德是上层建筑，由经济基础决定<ul><li>社会主义国家的经济基础：公有制（集体利益大于个人利益）</li><li>资本主义国家的经济基础：私有制（个人利益至上）</li></ul></li><li>道德的功能<ul><li>行为前：认识功能</li><li>行为中：规范功能</li><li>行为后：调节功能</li></ul></li><li>不同时期的道德<ul><li>古代的道德：传统美德</li><li>近代的道德：革命道德</li><li>现代的的道德：社会主义道德</li></ul></li><li>不同领域的道德<ul><li>社会公德</li><li>职业道德</li><li>家庭美德</li><li>个人品德</li></ul></li></ul><h4 id="法律基础"><a href="#法律基础" class="headerlink" title="法律基础"></a>法律基础</h4><ul><li>法律的基本问题<ul><li>法律的概念、功能、历史发展的脉络</li><li>法律是统治阶级的整体意志的体现，是统治阶级进行阶级统治的工具</li></ul></li><li>法律的运行：立法 -&gt; 执法 -&gt; 司法 -&gt; 守法</li><li>法律体系<ul><li>实体法律部门：宪法、民法等</li><li>程序法律部门：诉讼法、非诉讼法等</li></ul></li><li>法治体系：法律体系、法律实施体系、法律监督体系</li><li>法治思维：坚持法治思维，就要批判人治思维</li><li>法律权威：外在（强制性）和内在（合理性）</li><li>法律权利和义务</li></ul><h3 id="中国近代史纲要"><a href="#中国近代史纲要" class="headerlink" title="中国近代史纲要"></a>中国近代史纲要</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul><li>不考历史的细节，而考历史背后的政治逻辑</li><li>1840年鸦片战争：中国近代史开端</li><li>1911年辛亥革命：清朝政府结束，北洋政府开始</li><li>1919年五四运动：新旧民主主义革命分界线</li><li>1928年东北易帜：北洋政府结束，国民政府开始</li><li>1949年新中国成立：中国现代史开端</li></ul><h4 id="国情（从实际出发）"><a href="#国情（从实际出发）" class="headerlink" title="国情（从实际出发）"></a>国情（从实际出发）</h4><ul><li>国情是一切历史理论研究的起点</li><li>近代中国的国情：半殖民地半封建社会（1840年—1949年）</li></ul><h4 id="二、矛盾"><a href="#二、矛盾" class="headerlink" title="二、矛盾"></a>二、矛盾</h4><ul><li>近代中国主要矛盾<ul><li>半殖民：帝国主义与中华民族之间的矛盾</li><li>半封建：封建主义与人民大众之间的矛盾</li></ul></li></ul><h4 id="任务和对象"><a href="#任务和对象" class="headerlink" title="任务和对象"></a>任务和对象</h4><ul><li>近中国的任务<ul><li>帝国主义与中华民族之间的矛盾的任务：反帝</li><li>封建主义与人民大众之间的矛盾的任务：反封建</li></ul></li></ul><h4 id="中国革命的性质"><a href="#中国革命的性质" class="headerlink" title="中国革命的性质"></a>中国革命的性质</h4><ul><li>中国的革命是一场以反帝反封建为任务为对象的革命</li><li>革命的性质：资产阶级民族革命</li><li>新民主义革命是由无产阶级领导，但性质却是资产阶级革命<ul><li>决定革命性肤的不是革命的领导者，而是革命的任务和对象</li></ul></li><li>革命：推翻旧制度、确立新制度、确立新的生产关系的行为</li><li>奴隶社会：封建地主推翻奴隶主，奴隶主居于统治地位，奴隶处于被统治地位</li><li>封建社会：资产阶级推翻封建地主，封建地主居于统治地位，农民处于被统治地位</li><li>资本主义社会：无产阶级推翻资产阶级，资本主义居于统治地位，无产阶级处于被统治地位</li><li>因为中国革命的任务是反帝反封建，所以中国革命的性质就是资产阶级革命，无论谁来<br>做</li></ul><h4 id="史纲总结"><a href="#史纲总结" class="headerlink" title="史纲总结"></a>史纲总结</h4><ul><li>近代中国我们要做反帝反封建的任务，这件事情理应由资产阶级去做，是资产阶级的历<br>史使命</li><li>但是因为资产阶级的软弱本身没有实力去完成反帝反封建的历史使命，于是就由中国的无产阶级替资产阶级去完成本该由资产阶级完成的反帝反封建的历史使命</li><li>中国的革命也因此变成了由无产阶级领导的、资产阶级性质的、反帝反封建的、新式的<br>民主主义革命</li></ul><h3 id="毛泽东思想和中国特色社会主义理论体系概论"><a href="#毛泽东思想和中国特色社会主义理论体系概论" class="headerlink" title="毛泽东思想和中国特色社会主义理论体系概论"></a>毛泽东思想和中国特色社会主义理论体系概论</h3><h4 id="毛泽东思想"><a href="#毛泽东思想" class="headerlink" title="毛泽东思想"></a>毛泽东思想</h4><ul><li>理论的形成</li><li>理论内容<ul><li>新民主主义革命理论：1949年之前</li><li>社会主义改造理论：1949—1956年</li><li>社会主义建设道路的初步探索：1956—1976年</li></ul></li></ul><h4 id="中国特色主义理论体系"><a href="#中国特色主义理论体系" class="headerlink" title="中国特色主义理论体系"></a>中国特色主义理论体系</h4><ul><li>社会主义应该具有先进的、发达的生产力</li><li>怎样建设社会主义<ul><li>解放生产力，发展生产力</li><li>消灭剥削，消灭两极分化</li><li>最终达到共同富裕</li></ul></li><li>邓小平理论</li><li>“三个代表”重要思想<ul><li>建设什么样的党？怎样建设党？</li><li>要始终代表先进生产力的发展方向</li><li>要始终代表先进文化的发展方向</li><li>要始终代表广大人民的根本利益</li></ul></li><li>科学发展观<ul><li>实现什么样的发展？怎样发展？</li></ul></li><li>习近平新时代中国特色社会主义思想<ul><li>新时代、新思想</li><li>全面小康社会</li><li>建党一百年全面脱贫</li><li>2035年基本实现社会主义现代化</li><li>21世界中叶，建成社会主义现代化强国，实现中华民族伟大复兴</li><li>总任务：实现社会主义现代化，中华民族伟大复兴</li><li>布局理论：五位一体总体布局、四个全面战略布局</li><li>内外条件：国防军队建设、中国的外交问题、党的建设</li></ul></li></ul><h4 id="马克思主义中国化"><a href="#马克思主义中国化" class="headerlink" title="马克思主义中国化"></a>马克思主义中国化</h4><ul><li>新文化运动：学习西方资产阶级民族思想，来改造中国人的思想文化</li><li>十月革命：给中国送来了马克思列宁主义</li><li>五四运动：马克思列宁主义得到广泛传播</li><li>中共一大：以无产阶级革命推翻资产阶级，应联合资产阶级一起反帝反封建</li><li>六届六中全会：首次提出“马克思主义中国话”的命题</li><li>中共七大：实现了第一次飞跃，成果即为毛泽东思想</li><li>1956年《论十大关系》：第二次马克思主义中国化开始</li><li>改革开放：实现了马克思主义中国化的第二次飞跃，成果即为中国特色社会主义理论体系</li></ul><h4 id="新民主主义理论"><a href="#新民主主义理论" class="headerlink" title="新民主主义理论"></a>新民主主义理论</h4><ul><li>革命路线：无产阶级领导的人民大众的反帝反封建反官资的革命</li><li>革命纲领<ul><li>政治上：各革命阶级联合专政</li><li>经济上：没收地主、官资，保护民资</li><li>文化上：民族的、科学的、大众的</li></ul></li><li>革命道路：农村包围城市，武装夺取政权</li><li>革命经验（三大法宝）：统战线、武装斗争、党的建设</li></ul><h4 id="社会主义建设初步探索理论"><a href="#社会主义建设初步探索理论" class="headerlink" title="社会主义建设初步探索理论"></a>社会主义建设初步探索理论</h4><ul><li>《论十大关系》<ul><li>第二次马克思主义中国化开始</li><li>方针：调动一切积极因素为社会主义建设服务</li><li>指导思想：独立自主的符合中国特点的社会主义建设道路</li></ul></li><li>《关于正确处理人民内部矛盾的问题》<ul><li>基本矛盾：生产力和生产关系、经济基础和上层建筑</li><li>主要矛盾：作为一个落后的农业国与先进的工业国需求之间存在的矛盾、人民日益增长的物质文化需要同当前的发展不满足人民需要状况之间的矛盾</li><li>两类矛盾：敌我矛盾、人民内部矛盾</li></ul></li><li>中国工业化道路：农轻重</li></ul><h3 id="当代世界经济与政治"><a href="#当代世界经济与政治" class="headerlink" title="当代世界经济与政治"></a>当代世界经济与政治</h3><h4 id="当代世界政治与经济"><a href="#当代世界政治与经济" class="headerlink" title="当代世界政治与经济"></a>当代世界政治与经济</h4><ul><li>当今世界形势：百年未有之大变局，机遇与挑战并存</li><li>国际行为体：大国、欧盟</li><li>地区热点问题：朝韩问题，伊朗问题，叙利亚问题等</li><li>中国对外战略：和平发展道路、合作共赢的新型国际关系、人类命运共同体、一带一路</li></ul><h4 id="时事政治"><a href="#时事政治" class="headerlink" title="时事政治"></a>时事政治</h4><ul><li>重大会议：国际、国内（两会）</li><li>重大改革举措：雄安新区、深圳、粤港澳大湾区</li><li>科技创新：神舟、天宫、嫦娥</li><li>中国对外战略：事件、人物、政策</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“思想政治理论”是研究生招生考试必考科目之一（为什么！┗|｀O′|┛），分为马原、毛中特、史纲、思修和时政5个大类。政治内容众多且杂，如果对基础概念和知识进行具体总结，篇幅非常长，本篇笔记只是以一个“Cheat-sheet”的形式尽可能包含所有考试重点，至于系统的归纳梳理则以肖精讲精练为准。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="学习生活" scheme="http://blog.zhuangzhihao.top/categories/%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>基于Python和OpenCV实现人脸识别</title>
    <link href="http://blog.zhuangzhihao.top/Python-OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <id>http://blog.zhuangzhihao.top/Python-OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</id>
    <published>2021-08-02T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.842Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Open Source Computer Vision Library（OpenCV）是一个跨平台的计算机视觉库，可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV 用 C++ 语言编写，但本次实战项目使用的是 <code>python-opencv</code> 库实现的，主要是为了初步了解人脸识别的步骤和算法后面的原理。以下为项目笔记，源代码保存在 <a href="https://github.com/Bezhuang/Learn-CS/tree/main/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/Python-OpenCV">Github 仓库</a>中，可供参考。</p></blockquote><a id="more"></a><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><h4 id="人脸识别介绍"><a href="#人脸识别介绍" class="headerlink" title="人脸识别介绍"></a>人脸识别介绍</h4><ul><li>对人类来说，人脸识别很容易：我们的大脑有专门的神经细胞针对不同的场景或运动特征作出反应，视觉皮层再以某种方式把不同的信息来源转化成可用的模型</li><li>自动人脸识别就是研究如何从一幅图像中提取有意义的特征，形成可用的模型，然后对他们进行一些分类，因此基于几何特征的人脸的人脸识别可能是最直观的识别人脸的方法</li><li>但即使是使用最先进的算法，标记点的确定也是很复杂的，单靠几何特征不能提供足够的信息用于人脸识别</li><li>特征脸方法：把面部图像看作是一个点，从高维图像空间找到它在低维空间的表示，使用主元分析（Principal Component Analysis，PCA）可以找拥有最大方差的轴，但轴的最大方差不一定包含任何有鉴别性的信息</li><li>使用线性鉴别（Linear Discriminant Analysis，LDA）的特定类投影方法：使类内方差最小的同时，使类外方差最大</li><li>仅仅使用的局部特征描述图像的方法避免输入的图像的高维数据：提取的特征对于局部遮挡、光照变化、小样本等情况更强健<ul><li>盖伯小波：Gabor Waelets</li><li>离散傅立叶变换：Discrete Cosinus Transform（DCT）</li><li>局部二值模式：Local Binary Patterns（LBP）</li></ul></li></ul><h4 id="OpenCV-介绍"><a href="#OpenCV-介绍" class="headerlink" title="OpenCV 介绍"></a>OpenCV 介绍</h4><ul><li>从 OpenCV 2.4 开始，加入了新的类 FaceRecognizer，可以使用它便捷地进行人脸识别实验</li><li>FaceRecognizer 类目前包含三种人脸识别方法<ul><li>基于 PCA 变换的人脸识别：EigenFaceRecognizer</li><li>基于 Fisher 变换的人脸识别：FisherFaceRecognizer</li><li>基于局部二值模式的人脸识别：LBPHFaceRecognizer</li></ul></li><li>特征脸（Eigenfaces）：图像表示的问题是他的高维问题，如果数据有任何差异，可以通过寻找主元来知道主要信息，把一些可能相关的变量转换成一个更小的不相关的子集<ul><li>一个高维数据集经常被相关变量表示，因此只有一些的维上数据才是有意义的（包含最多的信息）</li><li>PCA 方法寻找数据中拥有最大方差的方向（主成分）</li><li>计算特征值和对应的特征向量，对特征值进行递减排序，特征向量和它顺序一致</li><li>k 个主成分也就是 k 个最大的特征值对应的特征向量</li><li>把所有的训练数据投影到 PCA 子空间 -&gt; 把待识别图像投影到 PCA 子空间 -&gt; 找到训练数据投影后的向量和待识别图像投影后的向量最近的那个</li></ul></li><li>FisherFaces：基于线性判别分析（Linear Discriminant Analysis，LDA）理论，在降维的同时考虑类别信息，基于特征脸的方法，找到使数据中最大方差的特征线性组合<ul><li>在低维表示下，相同的类应该紧紧的聚在一起，而不同的类别尽量距离越远</li></ul></li><li>局部二值模式直方图（Local Binary Patterns Histograms）：不把整个图像看成一个高维向量，仅用局部特征来描述一个物体，通过这种方式提取特征，获得一个低维隐式<ul><li>对图像的像素和它局部周围像素进行对比后的结果进行求和，把这个像素作为中心，对相邻像素进行阈值比较</li><li>如果中心像素的亮度大于等于他的相邻像素，标记为 1，否则标记为 0（用二进制数字来表示每个像素）</li></ul></li></ul><h3 id="OpenCV-的基本使用"><a href="#OpenCV-的基本使用" class="headerlink" title="OpenCV 的基本使用"></a>OpenCV 的基本使用</h3><h4 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h4><pre><code class="python">#导入模块import cv2 as cv#读取图片img=cv.imread(&#39;lena.jpg&#39;)    #加载图片路径中不能有中文#显示图片cv.imshow(&#39;read_img&#39;,img)#等待键盘输入 单位毫秒  传入0 则就是无限等待cv.waitKey(3000)#释放内存  由于OpenCV底层是C++编写的cv.destroyAllWindows()</code></pre><h4 id="图片灰度转换"><a href="#图片灰度转换" class="headerlink" title="图片灰度转换"></a>图片灰度转换</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)cv.imshow(&#39;BGR_img&#39;,img)#将图片灰度转换gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY)cv.imshow(&#39;gray_img&#39;,gray_img)#保存图片cv.imwrite(&#39;gray_lena.jpg&#39;,gray_img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="修改图片尺寸"><a href="#修改图片尺寸" class="headerlink" title="修改图片尺寸"></a>修改图片尺寸</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)cv.imshow(&#39;img&#39;,img)print(&#39;原来图片的形状&#39;,img.shape)# 修改图片尺寸resize_img=cv.resize(img,dsize=(600,560))print(&#39;修改后图片的形状：&#39;,resize_img.shape)cv.imshow(&#39;resize_img&#39;,resize_img) #输入q时退出while True:    if ord(&#39;q&#39;)==cv.waitKey(0):        breakcv.destroyAllWindows()</code></pre><h4 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)#绘制矩形，左上角坐标(x,y) 矩形的宽度和高度(w,h)x,y,w,h=100,100,100,100cv.rectangle(img,(x,y,x+w,y+h),color=(0,255,255),thickness=3) #BGR#绘制圆形，圆点的坐标center，半径radiusx,y,r=200,200,100cv.circle(img,center=(x,y),radius=r,color=(0,0,255),thickness=2)#显示图片cv.imshow(&#39;rectangle_img&#39;,img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h3 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h3><h4 id="Haarcascades"><a href="#Haarcascades" class="headerlink" title="Haarcascades"></a>Haarcascades</h4><ul><li>提取出图像的细节对产生稳定分类结果和跟踪结果很有用，这些提取的结果被称为特征</li><li>虽然任意像素都可以能影响多个特征，但特征应该比像素少得多，两个图像的相似程度可以通过它们对应特征的欧氏距离来度量</li><li>Haar 特征是一种用于实现实时人脸跟踪的特征，每一个 Haar 特征都描述了相邻图像区域的对比模式，如边、顶点和细线都能生成具有判别性的特征</li></ul><h4 id="官方-demo"><a href="#官方-demo" class="headerlink" title="官方 demo"></a>官方 demo</h4><ul><li><p>下载：<a href="https://sourceforge.net/projects/opencvlibrary/files/4.5.3/opencv-4.5.3-vc14_vc15.exe/download">https://sourceforge.net/projects/opencvlibrary/files/4.5.3/opencv-4.5.3-vc14_vc15.exe/download</a></p></li><li><p>build 中是 OpenCV 使用时要用到的一些库文件</p></li><li><p>sources 中是 OpenCV 官方提供的 demo 示例源码</p></li><li><p>sources/data/haarcascades 文件夹包含了所有 OpenCV 的人脸检测的 XML 文件，可用于检测静止图像、视频和摄像头所得到图像中的人脸</p></li></ul><h4 id="静态人脸检测"><a href="#静态人脸检测" class="headerlink" title="静态人脸检测"></a>静态人脸检测</h4><pre><code class="python">import cv2 as cvdef face_detect_demo():    #将图片转换为灰度图片    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector=cv.CascadeClassifier(&#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces=face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,255,0),thickness=2)    cv.imshow(&#39;result&#39;,img)#加载图片img=cv.imread(&#39;lena.jpg&#39;)face_detect_demo()cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="检测多张人脸"><a href="#检测多张人脸" class="headerlink" title="检测多张人脸"></a>检测多张人脸</h4><pre><code class="python">import cv2 as cvdef face_detect_demo():    #将图片灰度    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector = cv.CascadeClassifier(        &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces = face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        print(x,y,w,h)        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2)        cv.circle(img,center=(x+w//2,y+h//2),radius=w//2,color=(0,255,0),thickness=2)    #显示图片    cv.imshow(&#39;result&#39;,img)#加载图片img=cv.imread(&#39;face3.jpg&#39;)#调用人脸检测方法face_detect_demo()cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="检测视频中的人脸"><a href="#检测视频中的人脸" class="headerlink" title="检测视频中的人脸"></a>检测视频中的人脸</h4><pre><code class="python">import cv2 as cvdef face_detect_demo(img):    #将图片灰度    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector = cv.CascadeClassifier(&#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces = face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2)        cv.circle(img,center=(x+w//2,y+h//2),radius=(w//2),color=(0,255,0),thickness=2)    cv.imshow(&#39;result&#39;,img)#读取视频cap=cv.VideoCapture(&#39;video.mp4&#39;)while True:    flag,frame=cap.read()    print(&#39;flag:&#39;,flag,&#39;frame.shape:&#39;,frame.shape)    if not flag:        break    face_detect_demo(frame)    if ord(&#39;q&#39;) == cv.waitKey(10):        breakcv.destroyAllWindows()cap.release()</code></pre><h3 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h3><ul><li>用一系列分好类的图像来训练程序，并基于这些图像来进行识别</li><li>每个识别都具有转置信（confidence）评分，因此可在实际应用中通过对其设置阈值来进行筛选</li></ul><h4 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h4><ul><li><code>train()</code> 函数中有两个参数：图像数组和标签数组，这些标签表示进行识别时候某人人脸的ID</li><li>需要安装 <code>opencv-contrib-python</code> 模块</li></ul><pre><code class="python">import osimport cv2 as cvimport sysfrom PIL import Imageimport numpy as npdef getImageAndLabels(path):    facesSamples=[]    ids=[]    imagePaths=[os.path.join(path,f) for f in os.listdir(path)]    #检测人脸    face_detector = cv.CascadeClassifier(        &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    #遍历列表中的图片    for imagePath in imagePaths:        #打开图片        PIL_img=Image.open(imagePath).convert(&#39;L&#39;)        #将图像转换为数组        img_numpy=np.array(PIL_img,&#39;uint8&#39;)        faces = face_detector.detectMultiScale(img_numpy)        #获取每张图片的id        id=int(os.path.split(imagePath)[1].split(&#39;.&#39;)[0])        for x,y,w,h in faces:            facesSamples.append(img_numpy[y:y+h,x:x+w])            ids.append(id)    return facesSamples,idsif __name__ == &#39;__main__&#39;:    #图片路径    path=&#39;./data/jm/&#39;    #获取图像数组和id标签数组    faces,ids = getImageAndLabels(path)    #获取训练对象    recognizer = cv.face.LBPHFaceRecognizer_create()    recognizer.train(faces,np.array(ids))    #保存文件    recognizer.write(&#39;trainer/trainer.yml&#39;)</code></pre><h4 id="基于-LBPH-的人脸识别"><a href="#基于-LBPH-的人脸识别" class="headerlink" title="基于 LBPH 的人脸识别"></a>基于 LBPH 的人脸识别</h4><ul><li>LBPH（Local Binary Pattern Histogram）将检测到的人脸分为小单元，并将其与模型中的对应单元进行比较，对每个区域的匹配值产生一个直方图</li><li>由于这种方法的灵活性，LBPH 是唯一允许模型样本人脸和检测到的人脸在形状、大小上可以不同的人脸识别算法</li><li>调整后的区域中调用 <code>predict()</code>函数，该函数返回两个元素的数组：第一个元素是所识别<br>个体的标签，第二个是置信度评分</li><li>所有的算法都有一个置信度评分阈值，置信度评分用来衡量所识别人脸与原模型的差距，0 表示完全匹配</li><li>可能有时不想保留所有的识别结果，则需要进一步处理，因此可用自己的算法来估算识别的置信度评分</li><li>一个好的 LBPH 识别参考值要低于50，任何高于80的参考值都会被认为是低的置信度评分</li></ul><pre><code class="python">import cv2 as cvimport numpy as npimport os# 加载训练数据集文件recognizer = cv.face.LBPHFaceRecognizer_create()recognizer.read(&#39;trainer/trainer.yml&#39;)# 准备识别的图片faceCascade = cv.CascadeClassifier(    &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)font = cv.FONT_HERSHEY_SIMPLEXid = 0img = cv.imread(&#39;19.pgm&#39;)gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY)faces = faceCascade.detectMultiScale(gray_img)for x, y, w, h in faces:    cv.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)    # 人脸识别    id, confidence = recognizer.predict(gray_img[y:y + h, x:x + w])    print(&#39;标签id:&#39;, id, &#39;置信评分：&#39;, confidence)cv.imshow(&#39;result&#39;, img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h3 id="摄像头人脸识别"><a href="#摄像头人脸识别" class="headerlink" title="摄像头人脸识别"></a>摄像头人脸识别</h3><h4 id="摄像头调试"><a href="#摄像头调试" class="headerlink" title="摄像头调试"></a>摄像头调试</h4><pre><code class="python">#导入opencv模块import cv2#捕捉帧，笔记本摄像头设置为0即可capture = cv2.VideoCapture(0)#循环显示帧while(True):    ret, frame = capture.read()    #显示窗口第一个参数是窗口名，第二个参数是内容    cv2.imshow(&#39;frame&#39;, frame)    if cv2.waitKey(1) == ord(&#39;q&#39;):      #按q退出        break</code></pre><h4 id="摄像头人脸识别-1"><a href="#摄像头人脸识别-1" class="headerlink" title="摄像头人脸识别"></a>摄像头人脸识别</h4><pre><code class="python">import cv2import numpy as npface_cascade = cv2.CascadeClassifier(    &quot;opencv\sources\data\haarcascades\haarcascade_frontalface_default.xml&quot;)eye_cascade = cv2.CascadeClassifier(&quot;opencv\sources\data\haarcascades\haarcascade_eye.xml&quot;)cap = cv2.VideoCapture(0)while True:    ret, img = cap.read()    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    faces = face_cascade.detectMultiScale(gray, 1.1, 5)    if len(faces) &gt; 0:        for faceRect in faces:            x, y, w, h = faceRect            cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)            roi_gray = gray[y:y + h // 2, x:x + w]            roi_color = img[y:y + h // 2, x:x + w]            eyes = eye_cascade.detectMultiScale(roi_gray, 1.1, 1, cv2.CASCADE_SCALE_IMAGE, (2, 2))            for (ex, ey, ew, eh) in eyes:                cv2.rectangle(roi_color, (ex, ey), (ex + ew, ey + eh), (0, 255, 0), 2)    cv2.imshow(&quot;img&quot;, img)    if cv2.waitKey(1) &amp; 0xFF == ord(&#39;q&#39;):        break</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Open Source Computer Vision Library（OpenCV）是一个跨平台的计算机视觉库，可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV 用 C++ 语言编写，但本次实战项目使用的是 &lt;code&gt;python-opencv&lt;/code&gt; 库实现的，主要是为了初步了解人脸识别的步骤和算法后面的原理。以下为项目笔记，源代码保存在 &lt;a href=&quot;https://github.com/Bezhuang/Learn-CS/tree/main/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/Python-OpenCV&quot;&gt;Github 仓库&lt;/a&gt;中，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://blog.zhuangzhihao.top/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Python" scheme="http://blog.zhuangzhihao.top/tags/Python/"/>
    
    <category term="OpenCV" scheme="http://blog.zhuangzhihao.top/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://blog.zhuangzhihao.top/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.zhuangzhihao.top/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-04T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>偶然刷到一篇名为<a href="https://www.cnblogs.com/techflow/p/13998832.html">《一半人写不出冒泡排序，你的同龄人都躺下了》</a>的文章，其中提到轮子哥毕业去参加面试的时候，第一轮笔试考察冒泡排序，结果现场的一半学生都没写出来。自己回想了一下，也有一些遗忘。冒泡排序（Bubble Sort）作为最简单直观的排序算法是需要要求做到条件反射般熟练的，故作此笔记记录以防止哪天再次遇到。</p></blockquote><a id="more"></a><h3 id="冒泡排序的思想"><a href="#冒泡排序的思想" class="headerlink" title="冒泡排序的思想"></a>冒泡排序的思想</h3><ul><li>从头开始两两比较，把较大的元素与较小的元素进行交换</li><li>每轮把当前最大的一个元素存入到数组当前的末尾</li></ul><h3 id="冒泡排序的实现步骤"><a href="#冒泡排序的实现步骤" class="headerlink" title="冒泡排序的实现步骤"></a>冒泡排序的实现步骤</h3><ul><li>定义一个外部循环控制冒泡的轮数（<code>数组.length-1</code>）</li><li>定义一个内部循环控制每轮依次往后比较几个位置（<code>数组.length-i-1</code>）</li><li>如果当前位置的元素值 <code>&gt;</code> 后一个位置的元素值，两者交换</li></ul><h3 id="Java-版代码"><a href="#Java-版代码" class="headerlink" title="Java 版代码"></a>Java 版代码</h3><pre><code class="java">public class BubbleSort &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;5, 2, 3, 1&#125;;        for (int i = 1; i &lt;= arr.length - 1; i++) &#123;            for (int j = 0; j &lt; arr.length - i; j++) &#123;                if (arr[j] &gt; arr[j + 1]) &#123;                    int temp = arr[j + 1];                    arr[j + 1] = arr[j];                    arr[j] = temp;                &#125;            &#125;        &#125;        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.println(arr[i]);        &#125;    &#125;&#125;</code></pre><h3 id="Python-版代码"><a href="#Python-版代码" class="headerlink" title="Python 版代码"></a>Python 版代码</h3><pre><code class="python">def bubbleSort(arr):    for i in range(1, len(arr)):        for j in range(0, len(arr) - i):            if arr[j] &gt; arr[j + 1]:                arr[j], arr[j + 1] = arr[j + 1], arr[j]    return arr</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;偶然刷到一篇名为&lt;a href=&quot;https://www.cnblogs.com/techflow/p/13998832.html&quot;&gt;《一半人写不出冒泡排序，你的同龄人都躺下了》&lt;/a&gt;的文章，其中提到轮子哥毕业去参加面试的时候，第一轮笔试考察冒泡排序，结果现场的一半学生都没写出来。自己回想了一下，也有一些遗忘。冒泡排序（Bubble Sort）作为最简单直观的排序算法是需要要求做到条件反射般熟练的，故作此笔记记录以防止哪天再次遇到。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法与数据结构" scheme="http://blog.zhuangzhihao.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
    <category term="Python" scheme="http://blog.zhuangzhihao.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>双色球系统</title>
    <link href="http://blog.zhuangzhihao.top/%E5%8F%8C%E8%89%B2%E7%90%83/"/>
    <id>http://blog.zhuangzhihao.top/%E5%8F%8C%E8%89%B2%E7%90%83/</id>
    <published>2021-06-30T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>双色球是最常见的一种彩票。双色球投注区分为红球号码区和蓝球号码区，红球号码范围为01～33，蓝球号码范围为01～16。双色球每期从33个红球中开出6个号码，从16个蓝球中开出1个号码作为中奖号码，双色球玩法即是竞猜开奖号码的6个红球号码和1个蓝球号码，顺序不限。以下为双色球的业务分析和代码实现笔记。</p></blockquote><a id="more"></a><h3 id="随机一组中奖号码"><a href="#随机一组中奖号码" class="headerlink" title="随机一组中奖号码"></a>随机一组中奖号码</h3><ul><li>中奖号码由6个红球和1个蓝球组成</li><li>定义方法用于返回一组中奖号码（7个数据），返回的形式是一个整型数组</li><li>随机的6个中奖的红球号码不能重复<ul><li>每次随机一个红球号码后去数组中判断是否存在</li><li>如果存在则需要重新随机一个数字直到不重复为止</li></ul></li></ul><h3 id="用户输入一组双色球号码"><a href="#用户输入一组双色球号码" class="headerlink" title="用户输入一组双色球号码"></a>用户输入一组双色球号码</h3><ul><li>定义一个方法录入用户输入的6个红球和1个蓝球号码</li><li>该方法最终需要返回一个数组，数组中就是用户录入的号码（7位）</li></ul><h3 id="中奖情况判断"><a href="#中奖情况判断" class="headerlink" title="中奖情况判断"></a>中奖情况判断</h3><ul><li>定义一个方法接收中奖号码的数组，用户选号的数组</li><li>根据命中红球数和篮球数判断最终的中奖情况并输出详情和中奖金额</li><li>统计红球的命中数量<ul><li>遍历用户的每个选号，然后遍历中奖号码的数组</li><li>看当前选号是否在中奖号码中存在，存在则命中数量加1</li></ul></li></ul><h3 id="Java-版代码实现"><a href="#Java-版代码实现" class="headerlink" title="Java 版代码实现"></a>Java 版代码实现</h3><pre><code class="java">public class DoubleChromosphere &#123;    public static void main(String[] args) &#123;        // 随机6个红球号码（1-33，不能重复），随机一个蓝球号码（1-16），用数组装起来作为中奖号码        int[] luckNumbers = createLuckNumber();        // printArray(luckNumbers);        // 录入用户选中的号码        int[] userNumbers = userInputNumbers();        // 判断中奖情况        judge(luckNumbers, userNumbers);    &#125;    public static void judge(int[] luckNumbers, int[] userNumbers )&#123;        // 判断是否中奖              // 定义2个变量分别存储红球命中的个数，以及蓝球命中的个数        int redHitNumbers = 0;        int blueHitNumbers = 0;        // 判断红球命中了几个，开始统计        for (int i = 0; i &lt; userNumbers.length - 1; i++) &#123;            for (int j = 0; j &lt; luckNumbers.length - 1; j++) &#123;                // 每次找到了相等了，意味着当前号码命中了                if(userNumbers[i] == luckNumbers[j])&#123;                    redHitNumbers ++ ;                    break;                &#125;            &#125;        &#125;        // 蓝球号码是否命中        blueHitNumbers = luckNumbers[6] == userNumbers[6] ? 1 : 0;        System.out.println(&quot;中奖号码是：&quot;  );        printArray(luckNumbers);        System.out.println(&quot;您投注号码是：&quot;  );        printArray(userNumbers);        System.out.println(&quot;您命中了几个红球：&quot; + redHitNumbers);        System.out.println(&quot;您是否命中蓝球：&quot; + ( blueHitNumbers == 1 ? &quot;是&quot;: &quot;否&quot; ) );        // 判断中奖情况        if(blueHitNumbers == 1 &amp;&amp; redHitNumbers &lt; 3)&#123;            System.out.println(&quot;恭喜您，中了5元小奖！&quot;);        &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 3                || blueHitNumbers == 0 &amp;&amp; redHitNumbers == 4)&#123;            System.out.println(&quot;恭喜您，中了10元小奖！&quot;);        &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 4                || blueHitNumbers == 0 &amp;&amp; redHitNumbers == 5)&#123;            System.out.println(&quot;恭喜您，中了200元！&quot;);        &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 5)&#123;            System.out.println(&quot;恭喜您，中了3000元大奖！&quot;);        &#125;else if(blueHitNumbers == 0 &amp;&amp; redHitNumbers == 6)&#123;            System.out.println(&quot;恭喜您，中了500万超级大奖！&quot;);        &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 6)&#123;            System.out.println(&quot;恭喜您，中了1000万巨奖！可以开始享受人生，诗和远方！！&quot;);        &#125;else &#123;            System.out.println(&quot;感谢您为福利事业做出的突出贡献！！&quot;);        &#125;    &#125;    public static int[] userInputNumbers()&#123;        // 动态初始化一个数组，长度为7        int[] numbers = new int[7];        Scanner sc = new Scanner(System.in);        for (int i = 0; i &lt; numbers.length - 1; i++) &#123;            System.out.println(&quot;请您输入第&quot;+(i + 1)+&quot;个红球号码（1-33、不重复）：&quot;);            int data = sc.nextInt();            numbers[i] = data;        &#125;        // 录入一个蓝球号码        System.out.println(&quot;请您输入一个蓝球号码（1-16）：&quot;);        int data = sc.nextInt();        numbers[numbers.length - 1] = data;        return numbers;    &#125;    public static void printArray(int[] arr)&#123;        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.print(arr[i] + &quot; &quot;);        &#125;        System.out.println();    &#125;    public static int[] createLuckNumber()&#123;        // 定义一个动态初始化的数组，存储7个数字        int[] numbers = new int[7];          // 遍历数组，为每个位置生成对应的号码。(注意：遍历前6个位置，生成6个不重复的红球号码，范围是1-33)        Random r = new Random();        for (int i = 0; i &lt; numbers.length - 1; i++) &#123;            // 为当前位置找出一个不重复的1-33之间的数字            while (true) &#123;                int data = r.nextInt(33) + 1;                 // 注意：必须判断当前随机的这个号码之前是否出现过，出现过要重新随机一个，直到不重复为止，才可以存入数组中去                // 定义一个flag变量，默认认为data是没有重复的                boolean flag = true;                for (int j = 0; j &lt; i; j++) &#123;                    if(numbers[j] == data) &#123;                        // data当前这个数据之前出现过，不能用                        flag = false;                        break;                    &#125;                &#125;                if(flag) &#123;                    // data这个数据之前没有出现过，可以使用了                    numbers[i] = data;                    break;                &#125;            &#125;        &#125;        // 为第7个位置生成一个1-16的号码作为蓝球号码        numbers[numbers.length - 1] = r.nextInt(16) + 1;        return numbers;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;双色球是最常见的一种彩票。双色球投注区分为红球号码区和蓝球号码区，红球号码范围为01～33，蓝球号码范围为01～16。双色球每期从33个红球中开出6个号码，从16个蓝球中开出1个号码作为中奖号码，双色球玩法即是竞猜开奖号码的6个红球号码和1个蓝球号码，顺序不限。以下为双色球的业务分析和代码实现笔记。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础编程总结</title>
    <link href="http://blog.zhuangzhihao.top/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.zhuangzhihao.top/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-06-19T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.841Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java 语言是 SUN (Stanford University Network) 公司于1995年推出的一门高级编程语言，舍弃了 C 语言中容易引起错误的指针（以引用取代）、运算符重载（operator overloading）、多重继承 （以接口取代）等特性，增加了垃圾回收器等功能，具有面向对象、健壮性、跨平台性等特性。我选择的 Java课程为<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚学堂 Java 零基础入门教程</a>，但由于我个人不是零基础入门，所以这篇笔记不含编程入门和语言概述，仅包含 Java 基础编程知识的总结。</p></blockquote><a id="more"></a><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><h4 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h4><ul><li>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器</li><li>对于不同的平台，有不同的虚拟机，只有某平台提供了对应的 Java 虚拟机，Java 程序才可在此平台运行</li><li>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li></ul><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul><li>Java 语言消除了程序员回收无用内存空间的责任：提供一种系统级线程跟踪存储空间的分配情况，并在 JVM 空闲时，检查并释放那些可被释放的存储空间</li><li>垃圾回收在 Java 程序运行过程中自动进行，程序员无法精确控制和干预</li></ul><h4 id="JRE-与-JDK"><a href="#JRE-与-JDK" class="headerlink" title="JRE 与 JDK"></a>JRE 与 JDK</h4><ul><li>Java Development Kit 是提供给 Java 开发人员使用的 Java 开发工具包，其中包含了 Java 的开发工具，也包括了 JRE</li><li>Java Runtime Environment 包括 Java 虚拟机（Java Virtual Machine）和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可</li><li>JDK = JRE + 开发工具集（例如 Javac 编译工具等），JRE = JVM + Java SE 标准类库</li></ul><h4 id="通过-javac-命令编译-Java-文件"><a href="#通过-javac-命令编译-Java-文件" class="headerlink" title="通过 javac 命令编译 Java 文件"></a>通过 javac 命令编译 Java 文件</h4><ul><li><p>通过编译器将 Java 源文件编译成 JVM 可以识别的字节码文件</p><pre><code class="java">javac Test.java  //此时有了可执行的 java 程序</code></pre></li><li><p>通过 java 命令运行生成的 class 文件</p><pre><code class="java">java Test  //通过运行工具 java.exe 对字节码文件进行执行</code></pre></li><li><p>一个源文件可以声明多个 class，但最多只能有一个 public 类，而且 public 类名必须与文件名相同</p></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>被注释的文字不会被 JVM 解释执行，多行注释里面不允许有多行注释嵌套</p><pre><code class="java">//单行注释/* 多行注释/*</code></pre></li><li><p>文档注释</p><pre><code class="java">/** * @author  java程序的作者** * @version  源文件的版本** */</code></pre></li><li><p>注释内容可以被 JDK 提供的 javadoc 所解析，生成该程序的说明文档</p></li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>标识符（Identifier）不可以数字开头，不能包含空格，严格区分大小写，长度无限制</li><li>包名：所有字母都小写</li><li>类名、接口名：所有单词的首字母大写</li><li>变量名、方法名：第一个单词首字母小写，第二个单词开始每个单词首字母大写</li><li>常量名：所有字母都大写，每个单词用下划线连接</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量是程序中最基本的存储单元，包含变量类型、变量名和存储的值</li><li>先声明，后使用：<code>&lt;数据类型&gt; &lt;变量名称&gt;</code></li><li>赋值：<code>&lt;变量名称&gt; = &lt;值&gt;</code>，<code>&lt;数据类型&gt;&lt;变量名&gt;= &lt;初始化值&gt;</code></li><li>成员变量：在类体内，方法体外声明的变量<ul><li>以 static 修饰的是类变量，不以 static 修饰的是实例变量</li></ul></li><li>局部变量：在方法体内部声明的变量<ul><li>方法、构造器中定义的变量成为实参</li><li>局部变量除形参外，都需显式初始化</li></ul></li><li>基本数据类型<ul><li>整型：byte \ short \ int \ long（整型常量默认为 int 型，声明 long 型常量须后加 l 或 L）</li><li>浮点型：float \ double（浮点型常量默认为双精度，声明 float 型常量须后加 f 或 F）</li><li>字符型：char（使用 Unicode 编码，<code>‘\uXXXX’</code>）</li><li>布尔型：boolean（true 用1表示，false 用0表示）</li></ul></li><li>引用数据类型<ul><li>类：class</li><li>接口：interface</li><li>字符串：String（<code>“aaaa”</code>）</li><li>数组：array</li></ul></li><li>数据类型转换<ul><li>byte、short、char之间不会相互转换，在计算时首先转换为 int 类型</li><li>boolean 类型不能与其它数据类型运算，不可以转换为其它的数据类型</li><li>任何基本数据类型的值和 String 进行连接运算时，基本数据类型的值将自动转化为 String 类型</li><li>强制转换符：<code>(byte)(a+b)</code></li><li>通过基本类型对应的包装类则可以实现把字符串转换成基本类型：<code>String a = “43”; inti= Integer.parseInt(a);</code></li></ul></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>算术运算符</li><li>赋值运算符<ul><li>当 <code>=</code> 两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理</li><li>支持连续赋值</li><li>扩展赋值运算符：<code>+=, -=, *=, /=, %=</code></li></ul></li><li>比较运算符（关系运算符）<ul><li>比较运算符的结果都是 boolean 型</li></ul></li><li>逻辑运算符<ul><li><code>&amp;</code>：逻辑与，<code>|</code>：逻辑或，<code>！</code>：逻辑非</li><li><code>&amp;&amp;</code> ：短路与，<code>||</code>：短路或，<code>^</code> ：逻辑异或</li><li>单<code>&amp;</code>时，左边无论真假右边都进行运算；双<code>&amp;</code>时，如果左边为假，那么右边不参与运算</li><li><code>||</code>时：当左边为真，右边不参与运算</li></ul></li><li>位运算符<ul><li>位运算符操作的都是整型的数据变量</li><li><code>&lt;&lt;</code> : 在一定范围内，每向左移一位，相当于 <code>\* 2</code></li><li> <code>&gt;&gt;</code> : 在一定范围内，每向右移一位，相当于 <code>/ 2</code></li><li><code>&gt;&gt;&gt;</code>：无符号右移</li><li><code>&amp;</code>：与运算，<code>|</code>：或运算，<code>^</code> ：异或运算，<code>~</code>：取反运算</li></ul></li><li>三元运算符<ul><li><code>(条件)？a : b</code></li><li>条件表达式的结果为 boolean 类型</li><li>三元运算符是可以嵌套的</li></ul></li><li>只有单目运算符、三元运算符、赋值运算符是从右向左运算的</li></ul><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><ul><li><p><code>if-else</code> 条件表达式</p><ul><li>必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量</li></ul><pre><code class="java">if(条件表达式)&#123;执行表达式1&#125;else if&#123;执行表达式2&#125;else if(条件表达式)&#123;执行表达式3&#125;...else&#123;执行表达式n&#125;</code></pre></li><li><p>输入语句</p><ol><li>导包：<code>import java.util.Scanner;</code> </li><li>Scanner 的实例化</li><li>调用 Scanner 类的相关方法来获取指定的变量</li></ol><pre><code class="java">import java.util.Scanner;class ScannerTest&#123;    public static void main(String[] args)&#123;        Scanner scan = new Scanner(System.in);        //声明一个Scanner        int num = scan.nextInt();      //获取变量        System.out.println(num);    &#125;&#125;</code></pre></li><li><p><code>switch-case</code> 结构</p><ul><li>switch 结构中的表达式只能是如下的六种数据类型：<code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>枚举类型</code> （JDK5.0）、<code>String类型</code>（JDK7.0）</li><li>case 之后只能声明常量，不能声明范围</li></ul><pre><code class="java">switch(表达式)&#123;case 常量1:    执行语句1;    //break;     //break关键字是可选的case 常量2:    执行语句2;...default:    执行语句n:&#125;</code></pre></li></ul><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul><li><p>for 循环</p><ul><li>初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</li><li>可以有多个变量更新，用逗号分隔</li></ul><pre><code class="java">for(初始化; 循环条件; 迭代)｛    循环体;｝</code></pre></li><li><p>while 循环</p><ul><li>for 循环和 while 循环可以相互转换</li></ul><pre><code class="java">初始化while(循环条件)｛    循环体;    迭代;&#125;</code></pre></li><li><p>do-while 循环</p><ul><li>至少执行一次循环体</li></ul><pre><code class="java">初始化do&#123;    循环体;    迭代;&#125;while(循环条件);</code></pre></li><li><p><code>for</code>、<code>while</code>、<code>do…while</code> 均可以作为外层循环或内层循环</p></li><li><p><code>break</code> 用于终止某个语句块的执行，<code>continue</code> 用于跳过其所在循环语句块的一次执行，继续下一次循环</p><ul><li><code>break</code> 只能用于 <code>switch</code> 语句和循环语句中，<code>continue</code> 只能用于循环语句中</li><li><code>continue</code> 出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</li></ul></li><li><p>与 <code>break</code> 和 <code>continue</code> 不同的是，<code>return</code> 直接结束整个方法</p></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p>数组属于引用类型的变量，数组的元素既可以是基本数据类型，也可以是引用数据类型</p></li><li><p>创建数组对象会在内存中开辟一整块连续的空间，数组的长度一旦确定就不能修改</p></li><li><p>数组是有序排列的</p><pre><code class="java">//静态初始化：数组的初始化和数组元素的赋值操作同时进行ids = new int[]&#123;1001,1002,1003,1004&#125;;    //动态初始化：数组的初始化和数组元素的赋值操作分开进行String[] names = new String[5]; //通过角标的方式调用数组指定位置的元素names[0] = &quot;张学良&quot;;    //如果数组超过角标会通过编译，运行失败//获取数组的长度Syst遍历数组em.out.println(names.length);//遍历数组for(int i = 0;i &lt; names.length;i++)&#123;            System.out.println(names[i]);        &#125;</code></pre></li></ul><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><ul><li><p>从数组底层的运行机制来看，其实没有多维数组，可以看作 array1 作为 array2 的元素而存在</p><pre><code class="java">//静态初始化int[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;//动态初始化String[][] arr2 = new String[3][];//调用数组的指定位置的元素System.out.println(arr1[0][1]);//获取数组的长度System.out.println(arr4.length);System.out.println(arr4[0].length);//遍历二维数组for(int i = 0;i &lt; arr4.length;i++)&#123;  for(int j = 0;j &lt; arr4[i].length;j++)&#123;    System.out.print(arr4[i][j] + &quot; &quot;);  &#125;  System.out.println();&#125;</code></pre></li></ul><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="类与对象的创建"><a href="#类与对象的创建" class="headerlink" title="类与对象的创建"></a>类与对象的创建</h4><ul><li><p>属性：类中的成员变量，行为：类中的成员方法</p></li><li><p>Field = 属性 = 成员变量 = 域、字段，Method = 成员方法 = 函数</p></li><li><p>创建类 = 类的实例化 = 实例化类</p></li><li><p>如果创建类一个类的多个对象，则每个对象都独立的拥有一套非 static 的类的属性</p></li><li><p>所有的对象实例以及数组都要在堆（Heap）上分配：此内存区域的唯一目的就是存放对象实例</p></li><li><p>虚拟机栈（Stack）用于存储局部变量：局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，是对象在堆内存的首地址），方法执行完，自动释放</p></li><li><p>方法区（MethodArea）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p><pre><code class="java">//类的正文要用&#123; &#125;括起来修饰符 class 类名&#123;        //修饰符为 public：类可以被任意访问         属性声明;         方法()声明;&#125;        //调用属性对象.属性;//调用方法对象.方法();</code></pre></li></ul><h4 id="类中属性的使用"><a href="#类中属性的使用" class="headerlink" title="类中属性的使用"></a>类中属性的使用</h4><ul><li>属性（成员变量）和局部变量<ul><li>属性直接定义在类的一对 <code>&#123;&#125;</code> 内 。局部变量声明在方法内、方法形参、构造器形参、构造器内部</li><li>在声明属性时可以使用权限修饰符指明其权限（private、public、缺省、protected），局部变量不可以使用权限修饰符</li><li>类的属性都有默认初始化值，局部变量没有默认初始化值，在调用局部变量之前，一定要显式赋值（形参在调用时，赋值即可）</li><li>属性加载到堆空间中（非 static），局部变量加载到栈空间</li></ul></li></ul><h4 id="类中方法的使用"><a href="#类中方法的使用" class="headerlink" title="类中方法的使用"></a>类中方法的使用</h4><ul><li><p>Math类：<code>sqrt()、random()</code></p></li><li><p>Scanner类：<code>nextXxx()</code></p></li><li><p>Arrays类：<code>sort()、binarySearch()、toString()、equals()</code></p><pre><code class="java">//方法的声明权限修饰符 返回值类型 方法名(形参列表)&#123;    方法体&#125;</code></pre></li><li><p>如果方法有返回值，则必须在方法声明时指定返回值的类型，在方法中使用 return 关键字来返回指定类型的变量或常量</p></li></ul><h4 id="匿名对象的使用"><a href="#匿名对象的使用" class="headerlink" title="匿名对象的使用"></a>匿名对象的使用</h4><ul><li>创建对象时，没有显式的赋值给一个变量名，即为匿名对象</li><li>匿名对象只能调用一次，换行直接销毁匿名对象</li></ul><h4 id="方法重载（overload）"><a href="#方法重载（overload）" class="headerlink" title="方法重载（overload）"></a>方法重载（overload）</h4><ul><li><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可</p></li><li><p>判断是否重载与方法的返回值类型、权限修饰符、形参变量名、方法体都无关</p><pre><code class="java">//与 void show(int a,char b,double c)&#123;&#125; 构成重载int show(int a,double c,char b)&#123;&#125;void show(int a,double c,char b)&#123;&#125;//void show(int a,double c,char b)&#123;&#125; 不与上方构成重载，因为参数类型相同</code></pre></li></ul><h4 id="可变个数的形参"><a href="#可变个数的形参" class="headerlink" title="可变个数的形参"></a>可变个数的形参</h4><ul><li><p>JavaSE 5.0 中提供了 Varargs (variable number of arguments) 机制，允许直接定义能和多个实参相匹配的形参，从而可以用一种更简单的方式来传递个数可变的实参</p></li><li><p>可变个数形参的格式：<code>数据类型 ... 变量名</code></p></li><li><p>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。</p></li><li><p>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载（二者不可共存）</p></li><li><p>可变个数形参在方法中的形参中，必须声明在末尾</p></li><li><p>可变个数形参在方法中的形参中，最多只能声明一个可变形参</p><pre><code class="java">public void show(String... strs) &#123;    for (int i = 0; i &lt; strs.length; i++) &#123;        System.out.println(strs[i]);    &#125;&#125;//public void show(String[] strs)&#123;&#125; 与上一方法不可共存</code></pre></li></ul><h4 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h4><ul><li><p>如果变量是基本数据类型，此时实参赋值给形参的是实参真是存储的数据值</p></li><li><p>如果变量是引用数据类型，此时实参赋值给形参的是实参存储数据的地址值</p><pre><code class="java">public class ArrayPrint &#123;    public static void main(String[] args) &#123;        int[] arr = new int[]&#123;1,2,3&#125;;  //传进去的是一个Object的对象        System.out.println(arr);    //地址值                char[] arr1 = new char[]&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;  //传进去的是一个数组，里面遍历数据了       System.out.println(arr1);    //abc    &#125;&#125;</code></pre></li></ul><h4 id="递归（recursion）方法"><a href="#递归（recursion）方法" class="headerlink" title="递归（recursion）方法"></a>递归（recursion）方法</h4><ul><li><p>一个方法体内调用它自身</p></li><li><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制</p></li><li><p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环</p></li></ul><h4 id="属性赋值的过程"><a href="#属性赋值的过程" class="headerlink" title="属性赋值的过程"></a>属性赋值的过程</h4><ol><li>默认初始化值</li><li>显式初始化</li><li>构造器中赋值</li><li>通过 <code>对象.方法</code> 或 <code>对象.属性</code> 的方式赋值</li></ol><h3 id="封装与隐藏"><a href="#封装与隐藏" class="headerlink" title="封装与隐藏"></a>封装与隐藏</h3><ul><li><p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</p></li><li><p>低耦合：仅对外暴露少量的方法用于使用</p></li><li><p>将类的属性私有化（private），同时提供 public 方法来 get 和 set</p><pre><code class="java">public class AnimalTest &#123;    public static void main(String[] args) &#123;        Animal a = new Animal();        a.name = &quot;大黄&quot;;        a.show();        a.setLegs(-6);        a.show();        System.out.println(a.name);        System.out.println(a.getLegs());    &#125;&#125;//类的设置class Animal&#123;    String name;    private int age;    private int legs;//对于属性的设置public void setLegs(int l)&#123;  if(l &gt;= 0 &amp;&amp; l % 2 == 0)&#123;    legs = l;  &#125;else&#123;    legs = 0;  &#125;&#125;//对于属性的获取public int getLegs()&#123;  return legs;&#125;    public void eat()&#123;    System.out.println(&quot;动物进食&quot;);&#125;    public void show()&#123;    System.out.println(&quot;name = &quot; + name + &quot;,age = &quot; + age + &quot;,legs = &quot; + legs);&#125;    //提供关于属性 age 的 get 和 set 方法public int getAge()&#123;    return age;&#125;public void setAge(int a)&#123;    age = a;    &#125;&#125;</code></pre></li><li><p>权限修饰符 <code>public、protected、default（缺省）、private</code>  置于类的成员定义前，用来限定对象对该类成员的访问权限</p><ul><li>对于 class 的权限修饰只可以用 public 和 default</li><li>public 类可以在任意地方被访问，default 类只可以被同一个包内部的类访问</li></ul></li></ul><h3 id="构造器（constructor）"><a href="#构造器（constructor）" class="headerlink" title="构造器（constructor）"></a>构造器（constructor）</h3><ul><li><p>构造器的作用：初始化类的对象（属性），并返回对象的地址</p></li><li><p>如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器</p></li><li><p>无参数构造器：初始化的对象时，成员变量的数据均采用默认值</p></li><li><p>有参数构造器：在初始化对象的时候，同时可以为对象进行赋值</p><ul><li>一旦定义了有参数构造器，无参数构造器就没有了，此时就需要自己写无参数构造器了</li></ul></li><li><p>一个类中至少会有一个构造器，一个类中若定义多个构造器，则彼此构成重载</p><pre><code class="java">权限修饰符  类名(形参列表) &#123; &#125;//创建类的对象：new + 构造器</code></pre></li></ul><h4 id="JavaBean-的使用"><a href="#JavaBean-的使用" class="headerlink" title="JavaBean 的使用"></a>JavaBean 的使用</h4><ul><li><p>JavaBean 是一种 Java 语言写成的可重用组件</p></li><li><p>JavaBean 符合如下标准：类是公共的、有一个无参的公共的构造器 、有属性，且有对应的 get、set 方法</p><pre><code class="java">public class Customer &#123;        private int id;    private String name;    public Customer()&#123;            &#125;        public void setId(int i)&#123;        id = i;    &#125;        public int getId()&#123;        return id;    &#125;        public void setName(String n)&#123;        name = n;    &#125;        public String getName()&#123;        return name;    &#125;&#125;</code></pre></li></ul><h4 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h4><p><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/UML%E7%B1%BB%E5%9B%BE.png"></p><ul><li><code>+</code> 表示 public 类型，<code>-</code> 表示 private 类型，<code>#</code> 表示 protected 类型</li></ul><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><ul><li>this 用来修饰和调用属性、方法、构造器</li><li>在类的方法中，可以使用 <code>this.属性</code> 或 <code>this.方法</code> 调用当前对象属性和方法（通常情况下选择省略），特殊情况下，如果方法的形参和类的属性同名必须显式使用 <code>this.变量</code> ，表明此变量是属性而非形参</li><li>在类的构造器中，可以使用 <code>this.属性</code> 或 <code>this.方法</code> 调用当前对象属性和方法（通常情况下选择省略），特殊情况下，如果构造器的形参和类的属性同名必须显式使用 <code>this.变量</code> ，表明此变量是属性而非形参</li><li>this 调用构造器<ul><li>可以在类的构造器中，显式使用 <code>this(形参列表)</code> 调用本类中重载的其他的构造器</li><li>   构造器中不能通过 <code>this(形参列表)</code> 的方式调用自己。</li><li>   如果一个类中声明了 n 个构造器，则最多有 n -1 个构造器中使用了<code>this(形参列表)</code></li><li>   <code>this(形参列表)</code> 必须声明在类的构造器的首行</li><li>   在类的一个构造器中，最多只能声明一个 <code>this(形参列表)&quot;</code></li></ul></li></ul><h3 id="package-关键字"><a href="#package-关键字" class="headerlink" title="package 关键字"></a>package 关键字</h3><ul><li><p>为了更好的实现项目中类的管理，提供包的概念</p></li><li><p>使用 package 声明类或接口所属的包，声明在源文件的首行</p></li><li><p>每 <code>“.”</code> 一次就代表一层文件目录。</p></li><li><p>同一个包下，不能命名同名接口或同名类；不同包下，可以命名同名的接口、类</p><pre><code class="java">java.lang  //包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能java.net  //包含执行与网络相关的操作的类和接口java.io  //包含能提供多种输入/输出功能的类java.util  //包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数java.text  //包含了一些 java 格式化相关的类java.sql  //包含了 java 进行 JDBC 数据库编程的相关类/接口java.awt  //包含了构成抽象窗口工具集（abstractwindowtoolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。B/S  C/S</code></pre></li></ul><h4 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h4><ul><li><p>MVC 是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，数据模型层</p></li><li><p>这种将程序输入输出、数据处理以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性</p></li><li><p>模型层 model 主要处理数据</p><ul><li>数据对象封装 model bean/domain</li><li>数据库操作类 model.dao</li><li>数据库 model. db</li></ul></li><li><p>控制层 controller 处理业务逻辑</p><ul><li>应用界面相关 controller.activity</li><li>存放 fragment/controller.fragment</li><li>显示列表的适配器 controller.adapter</li><li>服务相关的 controller.service</li><li>抽取的基类 controller.base</li></ul></li><li><p>视图层 vieW 显示数据</p><ul><li>相关工具类 view.utils</li><li>自定义 vIew/view.ul</li></ul></li></ul><h4 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h4><ul><li>在源文件中显式的使用 import 结构导入指定包下的类、接口，声明在包的声明和类的声明之间</li><li>如果导入的类或接口是 <code>java.lang</code> 包下的，或者是当前包下的，则可以省略此 import 语句</li><li>如果在代码中使用不同包下的同名的类，需要使用类的全类名的方式指明调用的是哪个类</li><li>已经导入 <code>java.a</code> 包下的类时，如果需要使用 a 包的子包下的类的话，仍然需要导</li><li>import static：调用指定类或接口下的静态的属性或方法</li></ul><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><ul><li><p>一旦子类 A 继承父类以后，子类 A 中就获取了父类 B 中声明的结构（属性、方法）</p></li><li><p>如果父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只有因为封装性的影响，使得子类不能直接调用父类的结构而已</p></li><li><p>子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的拓展</p></li><li><p>子类和父类的关系不同于子集与集合的关系</p><pre><code class="java">class A extends B&#123;&#125;//A：子类、派生类、subclass//B：父类、超类、基类、superclass</code></pre></li><li><p>Java 中关于继承性的规定</p><ul><li>一个类可以被多个类继承</li><li>类的单继承性：一个类只能有一个父类</li><li>子父类是相对的概念。</li><li>子类直接继承的父类，称为直接父类。间接继承的父类，称为间接父类。</li><li>子类继承父类后，就获取了直接父类以及所有间接父类中声明的属性和方法</li><li>如果没有显式的声明一个类的父类的话，则此类继承于 <code>java.lang.Object</code> 类</li><li>所有的 java 类具有 <code>java.lang.Object</code> 类声明的功能（直接或间接继承）</li></ul></li></ul><h3 id="方法的重写（override-overwrite）"><a href="#方法的重写（override-overwrite）" class="headerlink" title="方法的重写（override/overwrite）"></a>方法的重写（override/overwrite）</h3><ul><li><p>重写：子类继承父类以后，可以对父类中的方法进行覆盖操作</p></li><li><p>重写以后，当创建子类对象以后，通过子类对象去调用子父类中同名同参数方法时，执行的是子类重写父类的方法（即在程序执行时，子类的方法将覆盖父类的方法）</p><pre><code class="java">权限修饰符 返回值类型 方法名(形参列表)&#123;        //方法体&#125;</code></pre></li><li><p>类重写的方法的方法名和形参列表必须和父类被重写的方法的方法名、形参列表相同</p></li><li><p>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</p></li><li><p>子类不能重写父类中声明为 private 权限的方法</p></li><li><p>子类方法抛出的异常不能大于父类被重写的方法抛出的异常</p></li><li><p>子类与父类中同名同参数的方法必须同时声明为非 static 的（即为重写），或者同时声明为 static 的（不是重写），因为 static 方法是属于类的，子类无法覆盖父类的方法</p></li><li><p>方法的重载与重写</p><ul><li>   方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现</li><li>   重写 Overriding 是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现</li><li>   如果在子类中定义某方法与其父类有相同的名称和参数，该方法被重写 Overriding</li><li>   子类的对象使用这个方法时，将调用子类中的定义，对它而言父类中的定义被屏蔽了</li><li>   如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载 Overloading</li></ul></li><li><p>返回值类型</p></li><li><p>   父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型只能是 void</p></li><li><p>   父类被重写的方法的返回值类型是 A 类型，则子类重写的方法的返回值类型可以是 A 类或 A 类的子类</p></li><li><p>   父类被重写的方法的返回值类型如果是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型</p></li></ul><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><ul><li>super：父类的，可以用来调用属性、方法、构造器 </li><li>可以在子类的方法或构造器中，通过 <code>super.属性</code> 或 <code>super.方法</code> 显式的调用父类中声明的属性或方法（通常情况下省略这个）</li><li>当子类和父类中定义了同名的属性时，要想在子类中调用父类中声明的属性，则必须显式的使用 <code>super.属性</code>  表明调用的是父类中声明的属性</li><li>当子类重写了父类中的方法后，想在子类的方法中调用父类中被重写的方法时，必须显式的使用 <code>super.方法</code>  表明调用的是父类中被重写的方法</li><li>super 调用构造器<ul><li>可以在子类的构造器中显式的使用 <code>super(形参列表)</code> 调用父类中声明的指定的构造器</li><li><code>super(形参列表)</code> 的使用必须声明在子类构造器的首行</li><li>在类的构造器中，针对于 <code>this(形参列表)</code> 或 <code>super(形参列表)</code> 只能二选一，不能同时出现</li><li>在构造器的首行，既没有显式的声明 <code>this(形参列表)</code> 或 <code>super(形参列表)</code> 则默认的调用的是父类中的空参构造器 <code>super()</code></li><li>在类的多个构造器中，至少有一个类的构造器使用了 <code>super(形参列表)</code> 调用父类中的构造器</li></ul></li></ul><h3 id="子类对象实例化过程"><a href="#子类对象实例化过程" class="headerlink" title="子类对象实例化过程"></a>子类对象实例化过程</h3><ul><li>从结果上看<ul><li>   子类继承父类以后，就获取了父类中声明的属性或方法</li><li>   创建子类的对象中，在堆空间中，就会加载所有父类中声明的属性</li></ul></li><li>从过程上看</li><li>   通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类构造器， 直到调用了 <code>java.lang.Object</code> 类中空参的构造器为止</li><li>正因为加载过所有的父类结构，所以才可以看到内存中有父类中的结构，子类对象可以考虑进行调用</li><li>   虽然创建子类对象时调用了父类的构造器，但自始至终就创建过一个对象，即为 <code>new</code> 的子类对象</li></ul><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><ul><li>父类的引用指向子类的对象（或子类的对象赋值给父类的引用）</li><li>多态的使用：当调用子父类同名同参数方法时，实际调用的是子类重写父类的方法（虚拟方法调用）</li><li>有了对象多态性以后，在编译期，只能调用父类声明的方法，但在执行期实际执行的是子类重写父类的方法<ul><li>编译时，看左边，看的是父类的引用（父类中不具备子类特有的方法）</li><li>运行时，看右边，看的是子类的对象（实际运行的是子类重写父类的方法）</li></ul></li><li>多态性的使用前提：类的继承关系、方法的重写<ul><li>对象的多态性只适用于方法，不适用于属性（编译和运行都看左边）</li></ul></li><li>多态是运行时行为</li></ul><h4 id="虚拟方法"><a href="#虚拟方法" class="headerlink" title="虚拟方法"></a>虚拟方法</h4><ul><li><p>重载是指允许存在多个同名方法，而这些方法的参数不同，编译器根据方法不同的参数表，对同名方法的名称做修饰</p></li><li><p>对于编译器而言，这些同名方法就成了不同的方法，它们的调用地址在编译期就绑定了</p></li><li><p>Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为早绑定或静态绑定</p></li><li><p>而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为晚绑定或动态绑定</p><blockquote><p>不要犯傻，如果它不是晚绑定，它就不是多态。—— Bruce Eckel</p></blockquote></li></ul><h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><ul><li><p>使用强制类型转换符调用子类所特有的属性和方法</p></li><li><p>可能出现 ClassCastException 异常</p></li><li><p>进行向下转型之前，先进行 <code>instanceof</code> 的判断，返回 true 就进行向下转型，返回 false 不进行向下转型</p><pre><code class="java">if (p2 instanceof Man) &#123;    Man m2 = (Man) p2;    m2.earnMoney();    System.out.println(&quot;Man&quot;);&#125;</code></pre></li></ul><h3 id="Object-类的使用"><a href="#Object-类的使用" class="headerlink" title="Object 类的使用"></a>Object 类的使用</h3><ul><li><p>Object 类是所有 Java 类的根父类</p></li><li><p>如果在类的声明中未使用 extends 关键字指明其父类，则默认父类为 <code>java.lang.Object</code>  类</p></li><li><p>Object 类中的功能（属性、方法）具有通用性</p><ul><li>方法：<code>equals()、toString()、getClass()、hashCode()、clone()、finalize()、wait() 、notify()、notifyAll()</code></li></ul></li><li><p>Object类只声明了一个空参的构造器</p></li></ul><h4 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h4><ul><li>被 final 修饰符（关键字）修饰的类，不能再派生出新的子类，不能作为父类而被子类继承<ul><li>一个类不能既被 abstract 声明，又被 final 声明</li><li>将变量或方法声明为 final，可以保证他们在使用的过程中不被修改</li><li>被声明为 final 的变量必须在声明时给出变量的初始值，而在以后的引用中只能读取</li><li>被 final 声明的方法也同样只能使用，即不能被子类重写</li><li>final 修饰局部变量（尤其是使用 final 修饰形参）时，表明此形参是一个常量，当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值</li><li>static final 用来修饰全局常量</li></ul></li><li>finally 是在异常处理时提供 finally 块来执行任何清除操作，不管有没有异常被抛出、捕获，finally块都会被执行<ul><li>try 块中的内容是在无异常时执行到结束</li><li>catch 块中的内容是在 try 块内容发生 catch 所声明的异常时跳转到 catch 块中执行</li><li>finally 块则是无论异常是否发生都会执行 finally 块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在 finally 块中</li></ul></li><li>Java技术允许使用 <code>finalize()</code> 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作<ul><li>这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的</li><li>它是在 object 类中定义的，因此所有的类都继承了它，子类覆盖 <code>finalize()</code> 方法以整理系统资源或者被执行其他清理工作</li><li><code>finalize()</code> 方法是在垃圾收集器删除对象之前对这个对象调用的</li></ul></li></ul><h4 id="操作符与-equals-方法"><a href="#操作符与-equals-方法" class="headerlink" title="== 操作符与 equals 方法"></a>== 操作符与 equals 方法</h4><ul><li><p>== 运算符可以使用在基本数据类型变量和引用数据类型变量中</p><ul><li>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等（类型不一定要相同）</li><li>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同（两个引用是否指向同一个对象实体）</li></ul></li><li><p><code>equals()</code> 是一个方法，而非运算符，只能适用于引用数据类型</p><pre><code class="java">public boolean equals(Object obj)&#123;  return (this == obj);&#125;        //Object 类中 equals() 的定义，和 == 的作用相同</code></pre></li><li><p>重写 equals() 方法</p><ul><li>对称性、自反性、传递性、一致性</li></ul><pre><code class="java">@Override    public boolean equals(Object obj) &#123;        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Customer other = (Customer) obj;        if (age != other.age)            return false;        if (name == null) &#123;            if (other.name != null)                return false;        &#125; else if (!name.equals(other.name))            return false;        return true;    &#125;        //重写原则，比较两个对象的实体内容（name和age）是否相同</code></pre></li></ul><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><ul><li><p>输出一个引用对象时，实际上就是调用当前对象的 <code>toString()</code></p></li><li><p>自定义类如果重写 <code>toString()</code> 方法：当调用此方法时，返回对象的实体内容</p><pre><code class="java">public String toString() &#123;    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;</code></pre></li></ul><h3 id="包装类（Wrapper）"><a href="#包装类（Wrapper）" class="headerlink" title="包装类（Wrapper）"></a>包装类（Wrapper）</h3><h4 id="JUnit-单元测试"><a href="#JUnit-单元测试" class="headerlink" title="JUnit 单元测试"></a>JUnit 单元测试</h4><ul><li>选中当前项目工程 -&gt; 右键 build path-&gt; add libraries-&gt;  JUnit 4</li><li>创建一个 Java 类进行单元测试。</li><li>此时的Java类要求：此类是公共的、此类提供一个公共的无参构造器、此类中声明单元测试方法</li><li>此时的单元测试方法：方法的权限是 public，没有返回值，没有形参</li><li>此单元测试方法上需要声明注解：<code>@Test</code> 并在单元测试类中调用：<code>import org.junit.Test;</code></li><li>声明好单元测试方法以后，就可以在方法体内测试代码</li><li>写好代码后 -&gt; 双击单元测试方法名 -&gt; 右键 run as -&gt; JUnit Test</li><li>如果执行结果无错误，则显示是一个绿色进度条，反之，错误即为红色进度条</li></ul><h4 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h4><ul><li>Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征</li><li>byte -&gt; Byte，short -&gt; Short，int -&gt; Integer，long -&gt; Long，float -&gt; Float，double -&gt; Double，boolean -&gt; Boolean，char -&gt; Character</li><li>其中 Byte、Short、Integer、Long、Float、Double 的父类是 Number</li></ul><h4 id="包装类与基本数据类型相互转换"><a href="#包装类与基本数据类型相互转换" class="headerlink" title="包装类与基本数据类型相互转换"></a>包装类与基本数据类型相互转换</h4><ul><li>基本数据类型 -&gt; 包装类（装箱）<ul><li>通过构造器：<code>Integer t = new Integer(11);</code></li><li>通过字符串参数：<code>Float f = new float(&quot;32.1F&quot;);</code></li><li>自动装箱</li></ul></li><li>包装类 -&gt; 基本数据类型（拆箱）<ul><li>调用包装类的方法：<code>xxxValue()</code></li><li>自动拆箱</li></ul></li><li>String 类 -&gt; 基本数据类型<ul><li>调用相应的包装类的 <code>parseXxx(String)</code> 静态方法</li><li>通过包装类构造器: <code>boolean b = new Boolean (&quot;true&quot;);</code></li></ul></li><li>基本数据类型 -&gt; String 类<ul><li>String 类的 <code>valueof (3.4f)</code> 方法 2.23.4+””</li></ul></li><li>包装类 -&gt; String 类<ul><li>包装类对象的 <code>toString()</code> 方法</li><li>调用包装类的 <code>toString(形参)</code> 方法</li></ul></li><li>String 类 -&gt; 包装类：装箱</li></ul><h3 id="Static-关键字"><a href="#Static-关键字" class="headerlink" title="Static 关键字"></a>Static 关键字</h3><h4 id="static-的使用"><a href="#static-的使用" class="headerlink" title="static 的使用"></a>static 的使用</h4><ul><li><p>使用 static 修饰属性：静态变量（类变量）</p><ul><li>实例变量：创建类的多个对象，每个对象都独立的拥有了一套类中的非静态属性，当修改其中一个非静态属性时，不会导致其他对象中同样的属性值的修饰</li><li>静态变量：创建类的多个对象，多个对象共享同一个静态变量，当通过静态变量去修改某一个变量时，会导致其他对象调用此静态变量时，是修改过的</li></ul></li><li><p>静态变量随着类的加载而加载，可以通过 <code>类.静态变量</code> 的方式进行调用</p></li><li><p>静态变量的加载要早于对象的创建，由于类只会加载一次，则静态变量在内存中也只会存在一次，存在方法区的静态域中</p><pre><code class="java">System.out.Math.PI;</code></pre></li></ul><h4 id="static-修饰方法"><a href="#static-修饰方法" class="headerlink" title="static 修饰方法"></a>static 修饰方法</h4><ul><li>使用 static 修饰方法：静态方法</li><li>静态方法中，只能调用静态的方法或属性，非静态的方法中，可以调用所有的方法或属性</li><li>在静态的方法内，不能使用 this 关键字、super 关键字</li><li>操作静态属性的方法，通常设置为 static ，工具类中的方法，习惯上声明为 static （Math、Arrays、Collections）</li></ul><h4 id="单例（Singleton）设计模式"><a href="#单例（Singleton）设计模式" class="headerlink" title="单例（Singleton）设计模式"></a>单例（Singleton）设计模式</h4><ul><li>取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</li><li>饿汉式：对象加载时间过长，但线程安全的</li><li>懒汉式：延迟对象的创建</li><li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</li><li>Singleton 设计模式的应用场景<ul><li>网站的计数器</li><li>应用程序的日志应用，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加</li><li>数据库连接池，因为数据库连接是一种数据库资源。</li><li>项目中读取配置文件的类，一般也只有一个对象，没有必要每次使用配置文件数据，都生成一个对象去读取</li><li>Application、Windows 的 Task Manager、Recycle Bin</li></ul></li></ul><h3 id="代码块（初始化块）"><a href="#代码块（初始化块）" class="headerlink" title="代码块（初始化块）"></a>代码块（初始化块）</h3><ul><li>用来初始化类、对象</li><li>代码块如果有修饰的话，只能使用 static</li><li>静态代码块：初始化类的信息<ul><li>内部可以有输出语句</li><li>随着类的加载而执行，而且只执行一次</li><li>如果一个类中，定义了多个静态代码块，则按照声明的先后顺序执行</li><li>静态代码块的执行，优先于非静态代码块的执行</li><li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li></ul></li><li>非静态代码块：可以在创建对象时，对对象的属性等进行初始化<ul><li>内部可以有输出语句</li><li>随着对象的创建而执行</li><li>每创建一个对象，就执行一次非静态代码块</li><li>如果一个类中，定义了多个非静态代码块，则按照声明的先后顺序执行</li><li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li></ul></li><li>对属性可以赋值的位置<ul><li>默认初始化、显式初始化、构造器中初始化</li><li>有了对象以后，可以通过 <code>对象.属性</code> 或 <code>对象.方法</code> 的方式进行赋值</li><li> 在代码块中赋值</li></ul></li></ul><h3 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h3><ul><li>Java 允许类设计者指定超类声明一个方法但不提供实现，该方法的实现由子类提供</li><li>这样的方法称为抽象方法，有一个或更多抽象方法的类称为抽象类</li></ul><h4 id="abstract-关键字的使用"><a href="#abstract-关键字的使用" class="headerlink" title="abstract 关键字的使用"></a>abstract 关键字的使用</h4><ul><li>abstract 修饰抽象类<ul><li>此类不能实例化</li><li>抽象类中一定有构造器，便于子类实例化时调用</li><li>开发中都会提供抽象类的子类，让子类对象实例化，实现相关的操作</li></ul></li><li>abstract 修饰抽象方法<ul><li>抽象方法：只有方法的声明，没有方法体</li><li>包含抽象方法的类，一定是一个抽象类，但抽象类中可以没有抽象方法</li></ul></li><li>abstract 不能用来修饰变量、代码块、构造器</li><li>abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类</li></ul><h4 id="模板方法设计模式（TemplateMethod）"><a href="#模板方法设计模式（TemplateMethod）" class="headerlink" title="模板方法设计模式（TemplateMethod）"></a>模板方法设计模式（TemplateMethod）</h4><ul><li>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式</li><li>模板模式：在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了，但是某些部分易变，易变部分可以抽象出来，供不同子类实现</li><li>常见的模板方法设计模式<ul><li>数据库访问的封装</li><li>Junit 单元测试</li><li>JavaWeb 的 Servlet 中关于 doGet/doPost 方法调用</li><li>Hibernate 中模板程序</li><li>Spring 中 JDBCTemlate、HibernateTemplate 等</li></ul></li></ul><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><ul><li>接口是抽象方法和常量值定义的集合，用 interface 来定义</li><li>接口中的所有成员变量都默认是由 <code>public static final</code> 修饰的，接口中的所有抽象方法都默认是由 <code>public abstract</code> 修饰的</li><li>接口中没有构造器，意味着接口不可以实例化</li><li>JDK8 后除了全局常量和抽象方法之外，还可以定义静态方法、默认方法</li><li>接口和类是并列的两个结构</li><li>接口通过让类去实现 implements 使用，如果实现类覆盖了接口中的所有方法，则此实现类就可以实例化，如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</li><li>Java 类可以实现多个接口 ，弥补了 Java 单继承性的局限性，接口与接口之间是继承,而且可以多继承</li><li>接口的具体使用，体现多态性 ，主要用途就是被实现类实现，实际可以看作是一种规范</li></ul><h4 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h4><ul><li>代理设计就是为其他对象提供一种代理以控制对这个对象的访问</li><li>分类<ul><li>静态代理（静态定义代理类）</li><li>动态代理（动态生成代理类）：JDK 自带的动态代理</li></ul></li><li>应用场景<ul><li>安全代理：屏蔽对真实角色的直接访问。</li><li>远程代理：通过代理类处理远程方法调用（RMI）</li><li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li></ul></li></ul><h4 id="接口和抽象类之间的对比"><a href="#接口和抽象类之间的对比" class="headerlink" title="接口和抽象类之间的对比"></a>接口和抽象类之间的对比</h4><table><thead><tr><th>区别点</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>定义</td><td>包含抽象方法的类</td><td>主要是抽象方法和全局常量的集合</td></tr><tr><td>组成</td><td>构造方法、抽象方法、普通方法、常量、变量</td><td>常量、抽象方法、默认方法、静态方法</td></tr><tr><td>使用</td><td>子类继承抽象类（extends）</td><td>子类实现接口（implements）</td></tr><tr><td>关系</td><td>抽象类可以实现多个接口</td><td>接口不能继承抽象类，但允许继承多个接口</td></tr><tr><td>常见设计模式</td><td>模板方法</td><td>简单工厂、工厂方法、代理模式</td></tr><tr><td>对象</td><td>都通过对象的多态性产生实例化对象</td><td></td></tr><tr><td>局限</td><td>抽象类有单继承的局限</td><td>接口没有此局限</td></tr><tr><td>实际</td><td>作为一个模板</td><td>是作为一个标准或是表示一种能力</td></tr><tr><td>选择</td><td>如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限</td><td></td></tr></tbody></table><h4 id="Java-8-中关于接口的改进"><a href="#Java-8-中关于接口的改进" class="headerlink" title="Java 8 中关于接口的改进"></a>Java 8 中关于接口的改进</h4><ul><li>静态方法<ul><li>使用 static 关键字修饰，可以通过接口直接调用静态方法，并执行其方法体</li><li>经常在相互一起使用的类中使用静态方法，可以在标准库中找到像 Collection/Collections 或者 Path/Paths 这样成对的接口和类</li></ul></li><li>默认方法<ul><li>默认方法使用 default 关键字修饰，可以通过实现类对象来调用</li><li>在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性，如：java 8 API 中对 Collection、List、Comparator 等接口提供了丰富的默认方法</li></ul></li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li>Java 中允许将一个类 A 声明在另一个类 B 中，则类 A 就是内部类，类 B 就是外部类</li><li>成员内部类<ul><li><pre><code>作为外部类的成员，调用外部类的结构，可以被static修饰，可以被4种不同的权限修饰</code></pre></li><li><pre><code>作为一个类，类内可以定义属性、方法、构造器等，可以被 final 修饰，表示此类不能被继承。言外之意，不使用 final，就可以被继承，可以 abstract 修饰</code></pre></li></ul></li></ul><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul><li><p>匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例</p></li><li><p>一个匿名内部类一定是在 new 的后面，用其隐含实现一个接口或实现一个类</p></li><li><p>匿名内部类必须继承父类或实现接口 ，=只能有一个对象，匿名内部类对象只能使用多态形式引用</p><pre><code class="java">new 父类构造器（实参列表）|实现接口()&#123;         //匿名内部类的类体部分&#125;</code></pre></li></ul><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul><li>方法内、代码块内、构造器内</li><li>局部内部类的方法中（如：show）如果调用局部内部类所声明的方法（如：method）中的局部变量（如：num）的话，要求此局部变量声明为 final 的</li><li>jdk 8及之后的版本可以省略 final 的声明</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li>将程序执行中发生的不正常情况称为异常，开发过程中的语法错误和逻辑错误不是异常</li><li>Error：Java 虚拟机无法解决的严重问题，如：JVM系统内部错误、资源耗尽等严重情况<ul><li>StackOverflowError 和 OutOfMemoryError：一般不编写针对性的代码进行处理</li></ul></li><li>Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理<ul><li>空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界</li></ul></li><li>解决方法：遇到错误就终止程序的运行，或在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理</li><li>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生，如：除数为0，数组下标越界等</li></ul><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><ul><li>运行时异常<ul><li>编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常</li><li><code>java.lang.RuntimeException</code> 类及它的子类都是运行时异常</li><li>对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</li></ul></li><li>编译时异常<ul><li>编译器要求必须处置的异常，即程序在运行时由于外界因素造成的一般性异常</li><li>编译器要求 Java 程序必须捕获或声明所有编译时异常</li><li>对于这类异常，如果程序不处理，可能会带来意想不到的后果</li></ul></li></ul><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><ul><li><p>try</p><ul><li>用 try{…} 语句块选定捕获异常的范围，将可能出现异常的代码放在 try 语句块中</li></ul></li><li><p>catch(Exceptiontypee)</p><ul><li>在 catch 语句块中是对异常对象进行处理的代码，每个 try 语句块可以伴随一个或多个 catch 语句，用于处理可能产生的不同类型的异常对象</li><li>捕获异常的有关信息与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法</li><li>getMessage() 获取异常信息，返回字符串</li><li>printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置，返回值 void</li></ul></li><li><p>finally</p><ul><li>通过 finally 语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理</li><li>不论在 try 代码块中是否发生了异常事件、catch 语句是否执行、catch语 句是否有异常、catch 语句中是否有 return，finally 块中的语句都会被执行</li><li>像数据库连接、输入输出流、网络编程 Socket 等资源，JVM 是不能自动的回收的，我们需要自己手动的进行资源的释放，此时的资源释放，就需要声明在 finally 中</li><li>finally 语句和 catch 语句是任选的</li></ul><pre><code class="java"> try&#123;         //可能出现异常的代码 &#125;catch(异常类型1 变量名1)&#123;         //处理异常的方式1 &#125;catch(异常类型2 变量名2)&#123;      //处理异常的方式2 &#125; ... finally&#123;         //一定会执行的代码 &#125;</code></pre></li></ul><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><ul><li>声明抛出异常是 Java 中处理异常的第二种方式<ul><li>如果一个方法中的语句执行时可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理</li><li>在方法声明中用 throws 语句可以声明抛出异常的列表，throws 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li></ul></li><li><code>throws + 异常类型</code> 写在方法的声明处，指明此方法执行时，可能会抛出的异常类型</li></ul><h4 id="用户自定义异常类"><a href="#用户自定义异常类" class="headerlink" title="用户自定义异常类"></a>用户自定义异常类</h4><ul><li>一般用户自定义异常类都是 <code>RuntimeException</code> 的子类</li><li>自定义异常类通常需要编写几个重载的构造器，需要提供 serialVersionUID</li><li>自定义的异常通过throw抛出</li><li>如何自定义异常类<ol><li>继承于现有的异常结构：RuntimeException 、Exception</li><li>提供全局常量：serialVersionUID</li><li>提供重载的构造器</li></ol></li></ul><h3 id="课程代码"><a href="#课程代码" class="headerlink" title="课程代码"></a>课程代码</h3><ul><li>课程代码已上传 <a href="https://github.com/Bezhuang/LearnCS/tree/main/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B">Github 仓库</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java 语言是 SUN (Stanford University Network) 公司于1995年推出的一门高级编程语言，舍弃了 C 语言中容易引起错误的指针（以引用取代）、运算符重载（operator overloading）、多重继承 （以接口取代）等特性，增加了垃圾回收器等功能，具有面向对象、健壮性、跨平台性等特性。我选择的 Java课程为&lt;a href=&quot;https://www.bilibili.com/video/BV1Kb411W75N&quot;&gt;尚学堂 Java 零基础入门教程&lt;/a&gt;，但由于我个人不是零基础入门，所以这篇笔记不含编程入门和语言概述，仅包含 Java 基础编程知识的总结。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Data Science Methodology</title>
    <link href="http://blog.zhuangzhihao.top/Data-Science-Methodology/"/>
    <id>http://blog.zhuangzhihao.top/Data-Science-Methodology/</id>
    <published>2021-05-29T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.840Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Despite the recent increase in computing power and access to data over the last couple of decades, our ability to use the data within the decision making process is either lost or not maximized at all too often, we don’t have a solid understanding of the questions being asked and how to apply the data correctly to the problem at hand. This course provided by IBM shares a methodology that can be used within data science, to ensure that the data used in problem solving is relevant and properly manipulated to address the question at hand. The following are the notes I took during this course.</p></blockquote><a id="more"></a><div class="row">    <embed src="/pdf/Data-Science-Methodology.pdf" width="100%" height="550" type="application/pdf"></div><div class="row">    <embed src="/pdf/Introduction-to-DS.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Data-Science-Methodologies"><a href="#Data-Science-Methodologies" class="headerlink" title="Data Science Methodologies"></a>Data Science Methodologies</h3><ul><li>Methodology: a system of methods used in a particular area of study.</li><li>CRISP-DM: the Cross Industry Process for Data Mining methodology.<ul><li>The CRISP-DM methodology is a process aimed at increasing the use of data mining over a wide variety of business applications and industries. </li><li>The intent is to take case specific scenarios and general behaviors to make them domain neutral. </li><li>CRISP-DM is comprised of six steps with an entity that has to implement in order to have a reasonable chance of success.</li><li>Business Understanding、Data Understanding、Data Preparation、Modeling、Evaluation、Deployment</li><li>CRISP-DM is a highly flexible and cyclical model. Flexibility is required at each step along with communication to keep the project on track. </li><li>At any of the six stages, it may be necessary to revisit an earlier stage and make changes. The key point of this process is that it’s cyclical.</li></ul></li></ul><h3 id="From-Problem-to-Approach"><a href="#From-Problem-to-Approach" class="headerlink" title="From Problem to Approach"></a>From Problem to Approach</h3><ul><li>Business Understanding<ul><li>Establishing a clearly defined question starts with understanding the goal of the person asking the question</li><li>Seek clarification (where is the goal) -&gt; Support the goal -&gt; Get stakeholder “buy-in” and support</li><li>Case Study: Apply concepts, Define Goals and objectives, Pilot project kickoff, Identify the business requirements</li></ul></li><li>Analytic Approach<ul><li>Once a strong understanding of the question is established, the analytic approach can be selected. This means identifying what type of patterns will be needed to address the question most effectively</li><li>The correct approach depends on business requirements for the model</li><li>If the question is to determine probabilities of an action, Use a predictive model </li><li>If the question is to show relationships, Use a descriptive model</li><li>if the question requires a yes/no answer, Use a classification model</li><li>It is only when the problem to be addressed is defined, that the appropriate analytic approach for the problem can be selected in the context of the business requirements</li><li>Case Study: Decision tree classification (Predictive model)</li></ul></li></ul><h3 id="From-Requirements-to-Collection"><a href="#From-Requirements-to-Collection" class="headerlink" title="From Requirements to Collection"></a>From Requirements to Collection</h3><ul><li>Data Requirements<ul><li>The Data Requirements stage of the data science methodology involves identifying the necessary data content, formats and sources for initial data collection.</li><li>Prior to undertaking the data collection and data preparation stages of the methodology, it’s vital to define the data requirements for decision-tree classification. This includes identifying the necessary data content, formats and sources for initial data collection</li><li>Case Study: Select the cohort, Define the data</li></ul></li><li>Data Collection<ul><li>Once the data ingredients are collected, then in the data collection stage, the data scientist will have a good understanding of what they will be working with</li><li>Techniques such as descriptive statistics and visualization can be applied to the data set, to assess the content, quality, and initial insights about the data. Gaps in data will be identified and plans to either fill or make substitutions will have to be made</li><li>When collecting data, it is alright to defer decisions about unavailable data, and attempt to acquire it at a later stage</li><li>Case Study: Gather available data, Merge data</li></ul></li></ul><h3 id="From-Understanding-to-Preparation"><a href="#From-Understanding-to-Preparation" class="headerlink" title="From Understanding to Preparation"></a>From Understanding to Preparation</h3><ul><li>Data Understanding<ul><li>Descriptive statistics: Univariate statistics, Pairwise correlations, Histogram</li><li>Data quality: Missing value, Invalid or misleading values</li><li>Iterative data collection and understanding: Refined definition of “CHF admission”</li><li>Data understanding is iterative; you learn more about your data the more you study it</li><li>Sorting data is not part of the Data Understanding stage</li></ul></li><li>Data Preparation<ul><li>Cleansing data</li><li>Transforming data</li><li>Feature engineering is the process of using domain knowledge of the data to create features that make the machine learning algorithms work</li><li>Feature engineering is critical when machine learning tools are being applied to analyze the data</li><li>The Data Preparation stage is in fact the most time-consuming phase of a data science project</li><li>Using training sets</li></ul></li></ul><h3 id="From-Modeling-to-Evaluation"><a href="#From-Modeling-to-Evaluation" class="headerlink" title="From Modeling to Evaluation"></a>From Modeling to Evaluation</h3><ul><li>Modeling<ul><li>Descriptive Analytics</li><li>Predictive Analytics</li><li>A training set is used to build a predictive model</li><li>Understand the question at hand -&gt; Select an analytic approach or method to solve the problem -&gt; Obtain, understand, prepare and model the data</li></ul></li><li>Evaluation<ul><li>Diagnostic measures: Predictive model, Descriptive model, Statistical significance</li><li>Diagnostic tool for classification model evaluation<ul><li>Classification model performance </li><li>True-Positive Rate <code>vs</code> False-Positive Rate</li><li>Optimal model at maximum separation</li></ul></li><li>Model evaluation can have two main phases: a diagnostic measures phase and statistical significance testing</li></ul></li><li>The purpose of statistical significance tests: Modeling and evaluation are iterative processes</li></ul><h3 id="From-Deployment-to-Feedback"><a href="#From-Deployment-to-Feedback" class="headerlink" title="From Deployment to Feedback"></a>From Deployment to Feedback</h3><ul><li>Deployment<ul><li>Understand the results</li><li>Gather application requirements</li><li>After the model is evaluated and the data scientist is confident it will work, it is deployed and put to the ultimate test</li><li>The refined model must be redeployed</li><li>This process should be repeated as often as necessary</li></ul></li><li>Feedback<ul><li>Assessing model performance</li><li>Refine model: Review and refine intervention actions</li><li>Redeployment: Continue modeling, deployment, feedback and refinement throughout the life of the Intervention program</li><li>The data science methodology is highly iterative, ensuring the refinement at each stage in the game</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Despite the recent increase in computing power and access to data over the last couple of decades, our ability to use the data within the decision making process is either lost or not maximized at all too often, we don’t have a solid understanding of the questions being asked and how to apply the data correctly to the problem at hand. This course provided by IBM shares a methodology that can be used within data science, to ensure that the data used in problem solving is relevant and properly manipulated to address the question at hand. The following are the notes I took during this course.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="人工智能与大数据" scheme="http://blog.zhuangzhihao.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA 的配置与使用总结</title>
    <link href="http://blog.zhuangzhihao.top/IDEA%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.zhuangzhihao.top/IDEA%E9%85%8D%E7%BD%AE/</id>
    <published>2021-05-19T16:00:00.000Z</published>
    <updated>2022-03-05T09:02:25.841Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IntelliJ IDEA 被公认为是最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、创新的GUI 设计等方面的功能可以说是超常的。相较于 Eclipse 而言，IDEA 增加了强大的整合能力、好用的快捷键和代码模板以及精准搜索，一些新的特性非常有必要学习熟悉。我目前使用的是 IDEA Ultimate 2021.2 版本，本篇笔记也是对最新版 IDEA 项目的创建、模板的使用、断点调试、数据库的关联、插件的下载、Maven及版本控制工具的配置等内容的一些总结。</p></blockquote><a id="more"></a><h3 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h3><ul><li><code>bin</code>：容器，执行文件和启动参数等<ul><li><code>idea.exe.vmoptions</code>：VM 配置文件</li><li><code>idea.properties</code>：IDEA 属性配置文件</li></ul></li><li><code>help</code>：快捷键文档和其他帮助文档</li><li><code>jre64</code>：64 位 java 运行环境 </li><li><code>lib</code>：IDEA 依赖的类库 </li><li><code>license</code>：各个插件许可 </li><li><code>plugin</code>：插件</li></ul><h3 id="设置目录"><a href="#设置目录" class="headerlink" title="设置目录"></a>设置目录</h3><h4 id="config-目录"><a href="#config-目录" class="headerlink" title="config 目录"></a>config 目录</h4><ul><li>IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等个性化配置</li></ul><h4 id="system-目录"><a href="#system-目录" class="headerlink" title="system 目录"></a>system 目录</h4><ul><li>缓存、索引、容器文件输出等</li></ul><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><ul><li>IntelliJ IDEA 没有类似 Eclipse 的工作空间的概念（ Workspaces），最大单元就是 Project</li><li>Eclipse 中 Workspace 相当于 IDEA 中的 Project</li><li>Project 下的 <code>src</code> 类似于 Eclipse 下的 <code>src</code> 目录，用于存放代码</li><li>Project 下的 <code>.idea</code> 和 <code>projectname.iml</code> 文件都是 IDEA 工程特有的，类似于 Eclipse 工程下的 <code>.settings</code>、<code>.classpath</code>、<code>.project</code> 等</li></ul><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul><li>Eclipse 中 Project 相当于 IDEA 中的 Module</li><li>在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module</li><li>一个 Project 可以有多个 Module。目前主流的大型项目都是分布式部署的， 结构都是类似这种多 Module 结构</li></ul><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><ul><li><p>Editor -&gt; General</p><ul><li>Change font size with <code>Ctrl</code> + Mouse Wheel</li></ul></li><li><p>Editor -&gt; General -&gt; Auto Import</p><ul><li><p>Add unambiguous imports on the fly</p></li><li><p>Optimize imports on the fly</p></li></ul></li><li><p>Editor -&gt; General -&gt; Appearance</p><ul><li>Show line numbers</li><li>Show method separators</li></ul></li><li><p>Editor -&gt; General -&gt; Code Completion</p><ul><li>取消 Match Case</li></ul></li><li><p>Editor -&gt; General -&gt; Editor Tabs</p><ul><li>取消 Show tabs in one row </li></ul></li><li><p>Editor -&gt; File and Code Templates -&gt; Includes</p><pre><code class="java">/** @author Bezhuang@create $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;TIME&#125; */ </code></pre></li><li><p>Editor -&gt; File Encodings</p><ul><li>Global / Project / Default encoding: <code>UTF-8</code></li><li>Transparent native-to-ascii conversion</li></ul></li><li><p>Build, Execution, Deployment -&gt; Compiler</p><ul><li>Build project automatically（如果电脑带不动取消）</li><li>Compile independent modules in parallel</li></ul></li></ul><h3 id="Keymap"><a href="#Keymap" class="headerlink" title="Keymap"></a>Keymap</h3><table><thead><tr><th>快捷键</th><th>实现效果</th></tr></thead><tbody><tr><td>Ctrl + X</td><td>删除当前行</td></tr><tr><td>Ctrl +D</td><td>复制当前行</td></tr><tr><td>Alt+Insert（右键Generate）</td><td>get、set方法，构造函数等</td></tr><tr><td>Ctrl+Alt+T</td><td><code>try catch</code>（Alt+enter选择）</td></tr><tr><td>CTRL+ALT+T</td><td>把选中的代码放在 <code>TRY&#123;&#125;</code> <code>IF&#123;&#125;</code> <code>ELSE&#123;&#125;</code> 里</td></tr><tr><td>Ctr+shift+U</td><td>大小写之间转化</td></tr><tr><td>ALT+回车</td><td>导入包，自动修正</td></tr><tr><td>CTRL+ALT+L</td><td>格式化代码</td></tr><tr><td>CTRL+ALT+I</td><td>自动缩进</td></tr><tr><td>CTRL+E</td><td>最近更改的代码</td></tr><tr><td>Alt + 左右键</td><td>多窗口</td></tr><tr><td>Ctrl + 鼠标点击</td><td>快速找到成员变量的出处</td></tr><tr><td>Shift+F6</td><td>重构/重命名 (包、类、方法、变量、甚至注释等)</td></tr><tr><td>CTRL+Q</td><td>查看当前方法的声明</td></tr><tr><td>Ctrl+Alt+V</td><td><code>new 对象();</code>（自动创建变量）</td></tr><tr><td>Ctrl+O</td><td>重写方法</td></tr><tr><td>Ctrl+I</td><td>实现方法</td></tr><tr><td>ALT+/</td><td>代码提示</td></tr><tr><td>Ctrl+Shift+R</td><td>在当前项目中替换指定内容</td></tr><tr><td>Ctrl+E</td><td>最近编辑的文件列表</td></tr><tr><td>Ctrl+P</td><td>显示方法参数信息</td></tr><tr><td>Ctrl+Shift+Insert</td><td>查看历史复制记录</td></tr></tbody></table><h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><ul><li><p>Live Templates 可以自定义，而 Postfix Completion 不可以</p></li><li><p>psvm -&gt; <code>public static void main(String[] args)</code></p></li><li><p>sout -&gt; <code>System.out.println()</code> </p><ul><li>soutp -&gt; <code>System.out.println(&quot;方法形参名 = &quot; + 形参名);</code></li><li>soutv -&gt; <code>System.out.println(&quot;变量名 = &quot; + 变量);</code></li><li>soutm -&gt; <code>System.out.println(&quot;当前类名.当前方法&quot;);</code></li><li>“abc”.sout -&gt; <code>System.out.println(&quot;abc&quot;);</code></li></ul></li><li><p>fori -&gt; for 循环</p><ul><li>iter -&gt; 增强 for 循环</li><li>itar -&gt; 普通 for 循环</li></ul></li><li><p>list -&gt; <code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><ul><li>list.for -&gt; <code>for(String s:list)&#123;&#125;</code></li></ul></li></ul><ul><li><p>list.fori -&gt; 正序遍历</p></li><li><p>list.forr -&gt; 倒序遍历</p></li><li><p>ifn -&gt; <code>if(xxx = null)</code></p><ul><li>inn -&gt; <code>if(xxx != null)</code></li><li>xxx.nn</li><li>xxx.null</li></ul></li><li><p>prsf -&gt; <code>private static final</code></p><ul><li>psf -&gt; <code>public static final</code></li><li>psfi -&gt; <code>public static final int</code></li><li>psfs -&gt; <code>public static final String</code></li></ul></li></ul><h3 id="创建-Java-Web"><a href="#创建-Java-Web" class="headerlink" title="创建 Java Web"></a>创建 Java Web</h3><ul><li>Module 右键 -&gt; add Framework Support</li><li>配置本地 Tomcat 环境变量<ul><li>系统环境变量中新建 <code>CATALINA_HOME</code> 环境变量</li><li>修改 <code>Path</code> ： <code>%CATALINA_HOME%\lib</code>、<code>%CATALINA_HOME%\bin</code>、<code>%CATALINA_HOME%\lib\servlet-api.jar</code></li><li>Tomcat 文件夹下打开 Terminal：<code>catalina run</code> 启动 Tomcat</li></ul></li></ul><h3 id="关联数据库"><a href="#关联数据库" class="headerlink" title="关联数据库"></a>关联数据库</h3><ul><li>IDEA 的 Database 对于常使用的 ORM 框架，如 Hibernate、 Mybatis有很好的支持，比如配置好了 Database 之后，IDEA 会自动识别 domain 对象与数据表的关系，也可以通过 Database 的数据表直接生成 domain 对象等</li></ul><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ul><li>IntelliJ IDEA 对版本控制的支持是以插件化的方式来实现的</li><li>IntelliJ IDEA 自带了 Github 插件，方便 Checkout 和管理 Github 项目</li><li>File -&gt; Setting -&gt; VCS (version control system)</li><li>VCS -&gt; Get from Version Control</li></ul><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><h4 id="Debug-的设置"><a href="#Debug-的设置" class="headerlink" title="Debug 的设置"></a>Debug 的设置</h4><ul><li>File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Debugger<ul><li>Java -&gt; Transport: Shared memory</li></ul></li></ul><h4 id="断点调试快捷键"><a href="#断点调试快捷键" class="headerlink" title="断点调试快捷键"></a>断点调试快捷键</h4><ul><li>step over：进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</li><li>step into：进入下一步，如果当前行断点是一个方法，则进入当前方法体内</li><li>force step into：进入下一步，如果当前行断点是一个方法，则进入当前方法体内</li><li>step out：跳出</li><li>resume program：恢复程序运行，但如果该断点下面代码还有断点则停在下一个断点上</li><li>stop：停止</li><li>mute breakpoints：点中，使得所有的断点失效</li><li>view breakpoints：查看所有断点</li></ul><h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><ul><li>调试的时候，在循环里增加条件判断，可以极大的提高效率</li><li>在断点处右击调出条件断点，可以在满足某个条件下，实施断点</li><li>选择行后 CTRL + u，可以在查看框中输入编写代码时的其他方法</li></ul><h3 id="配置-Maven"><a href="#配置-Maven" class="headerlink" title="配置 Maven"></a>配置 Maven</h3><ul><li>自动化构建工具：Make -&gt; Ant -&gt; Maven -&gt; Gradle </li><li>Maven 使用了一个标准的目录结构和一个默认的构建生命周期，用于自动化构建和依赖管理</li><li>构建环节<ul><li>清理：表示在编译代码前将之前生成的内容删除</li><li>编译：将源代码编译为字节码</li><li>测试：运行单元测试用例程序</li><li>报告：测试程序的结果</li><li>打包：将 java 项目打成 jar 包，或将 Web 项目打成 war 包</li><li>安装：将 jar 或 war 生成到 Maven 仓库中</li><li>部署：将 jar 或 war 从 Maven 仓库中部署到 Web 服务器上运行</li></ul></li><li>File -&gt; Settings -&gt; Maven：选择自己Maven 的目录和 settings 文件，然后配置自己的本地仓库 repository</li><li>Maven 目录下有对应的生命周期，其中常用的是：clean、compile、package、install</li></ul><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><ul><li>生成 javadoc<ul><li>Tools -&gt; Generate JavaDoc</li><li>Locale（输入语言类型）：zh_CN </li><li>Other command line arguments: <code>-encoding UTF-8 -charset UTF-8</code></li></ul></li><li>缓存和索引的清理<ul><li>IntelliJ IDEA 首次加载项目的时候，都会创建索引，而创建索引的时间跟项目的文件多少成正比</li><li>IntelliJ IDEA 的缓存和索引主要是用来加快文件查询，从而加快各种查找、代码提示等操作的速度</li><li>某些特殊条件下，IntelliJ IDEA 的缓存和索引文件也是会损坏的，可以清理缓存和索引</li><li>File -&gt; Invalidate Caches / Restart</li></ul></li><li>插件<ul><li>File -&gt; Settings -&gt; Plugins</li><li><a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com/</a> </li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;IntelliJ IDEA 被公认为是最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、创新的GUI 设计等方面的功能可以说是超常的。相较于 Eclipse 而言，IDEA 增加了强大的整合能力、好用的快捷键和代码模板以及精准搜索，一些新的特性非常有必要学习熟悉。我目前使用的是 IDEA Ultimate 2021.2 版本，本篇笔记也是对最新版 IDEA 项目的创建、模板的使用、断点调试、数据库的关联、插件的下载、Maven及版本控制工具的配置等内容的一些总结。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
    <category term="IDEA" scheme="http://blog.zhuangzhihao.top/tags/IDEA/"/>
    
  </entry>
  
</feed>
