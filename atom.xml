<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bezhuang&#39;s Blog</title>
  
  
  <link href="http://blog.zhuangzhihao.top/atom.xml" rel="self"/>
  
  <link href="http://blog.zhuangzhihao.top/"/>
  <updated>2022-05-31T06:25:39.860Z</updated>
  <id>http://blog.zhuangzhihao.top/</id>
  
  <author>
    <name>Bezhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过构建资产负债表了解有关 CSS 伪选择器的更多信息</title>
    <link href="http://blog.zhuangzhihao.top/CSS%E6%9E%84%E5%BB%BA%E8%B5%84%E4%BA%A7%E8%B4%9F%E5%80%BA%E8%A1%A8/"/>
    <id>http://blog.zhuangzhihao.top/CSS%E6%9E%84%E5%BB%BA%E8%B5%84%E4%BA%A7%E8%B4%9F%E5%80%BA%E8%A1%A8/</id>
    <published>2022-05-30T16:00:00.000Z</published>
    <updated>2022-05-31T06:25:39.860Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>freeCodeCamp 响应式网页设计的认证课程第九章。可以使用 CSS 伪选择器来更改特定的 HTML 元素。在通过构建资产负债表了解有关 CSS 伪选择器的更多信息的课程中，使用伪选择器构建资产负债表，学习如何在将鼠标悬停在元素上时更改其样式，并触发网页上的其他事件。</p></blockquote><a id="more"></a><h3 id="一、重点-HTML-代码"><a href="#一、重点-HTML-代码" class="headerlink" title="一、重点 HTML 代码"></a>一、重点 HTML 代码</h3><p>flex class：</p><pre><code class="html">&lt;h1&gt;  &lt;span class=&quot;flex&quot;&gt;    &lt;span&gt;AcmeWidgetCorp&lt;/span&gt;    &lt;span&gt;Balance Sheet&lt;/span&gt;  &lt;/span&gt;&lt;/h1&gt;</code></pre><p>aria-hidden 属性：</p><pre><code class="html">&lt;div id=&quot;years&quot; aria-hidden=&quot;true&quot;&gt;  &lt;span class=&quot;year&quot;&gt;2019&lt;/span&gt;  &lt;span class=&quot;year&quot;&gt;2020&lt;/span&gt;  &lt;span class=&quot;year&quot;&gt;2021&lt;/span&gt;&lt;/div&gt;</code></pre><p>HTML table 标签:</p><pre><code class="html">&lt;div class=&quot;table-wrap&quot;&gt;  &lt;table&gt;    &lt;caption&gt;Assets&lt;/caption&gt;    &lt;thead&gt;      &lt;tr&gt;        &lt;td&gt;&lt;/td&gt;        &lt;th&gt;&lt;span class=&quot;sr-only year&quot;&gt;2019&lt;/span&gt;&lt;/th&gt;        &lt;th&gt;&lt;span class=&quot;sr-only year&quot;&gt;2020&lt;/span&gt;&lt;/th&gt;        &lt;th class=&quot;current&quot;&gt;&lt;span class=&quot;sr-only year&quot;&gt;2021&lt;/span&gt;&lt;/th&gt;      &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;      &lt;tr class=&quot;data&quot;&gt;        &lt;th&gt;Cash &lt;span class=&quot;description&quot;&gt;This is the cash we currently have on hand.&lt;/span&gt;&lt;/th&gt;        &lt;td&gt;$25&lt;/td&gt;        &lt;td&gt;$30&lt;/td&gt;        &lt;td class=&quot;current&quot;&gt;$28&lt;/td&gt;      &lt;/tr&gt;      &lt;tr class=&quot;data&quot;&gt;        &lt;th&gt;Checking &lt;span class=&quot;description&quot;&gt;Our primary transactional account.&lt;/span&gt;&lt;/th&gt;        &lt;td&gt;$54&lt;/td&gt;        &lt;td&gt;$56&lt;/td&gt;        &lt;td class=&quot;current&quot;&gt;$53&lt;/td&gt;      &lt;/tr&gt;      &lt;tr class=&quot;data&quot;&gt;        &lt;th&gt;Savings &lt;span class=&quot;description&quot;&gt;Funds set aside for emergencies.&lt;/span&gt;&lt;/th&gt;        &lt;td&gt;$500&lt;/td&gt;        &lt;td&gt;$650&lt;/td&gt;        &lt;td class=&quot;current&quot;&gt;$728&lt;/td&gt;      &lt;/tr&gt;      &lt;tr class=&quot;total&quot;&gt;        &lt;th&gt;Total &lt;span class=&quot;sr-only&quot;&gt;Assets&lt;/span&gt;&lt;/th&gt;        &lt;td&gt;$579&lt;/td&gt;        &lt;td&gt;$736&lt;/td&gt;        &lt;td class=&quot;current&quot;&gt;$809&lt;/td&gt;      &lt;/tr&gt;    &lt;/tbody&gt;  &lt;/table&gt;  &lt;!--同理多个&lt;table&gt;&lt;/table&gt;--&gt;&lt;/div&gt;</code></pre><h3 id="二、重点-CSS-代码"><a href="#二、重点-CSS-代码" class="headerlink" title="二、重点 CSS 代码"></a>二、重点 CSS 代码</h3><p>box-sizing 属性：</p><pre><code class="CSS">html &#123;  box-sizing: border-box;&#125;body &#123;  font-family: sans-serif;  color: #0a0a23;&#125;</code></pre><p>The <code>span[class~=&quot;sr-only&quot;]</code> selector will select any <code>span</code> element whose <code>class</code> <em>includes</em> <code>sr-only</code>：</p><pre><code class="css">span[class~=&quot;sr-only&quot;] &#123;  border: 0 !important;  clip: rect(1px, 1px, 1px, 1px) !important;  clip-path: inset(50%) !important;  -webkit-clip-path: inset(50%) !important;  height: 1px !important ;  width: 1px !important;  position: absolute !important;  overflow: hidden !important;  white-space: nowrap !important;  padding: 0 !important;  margin: -1px !important;&#125;/*The CSS clip property is used to define the visible portions of an element.The clip-path property determines the shape the clip property should take.use the !important keyword to ensure these properties are always applied, regardless of order or specificity.*/</code></pre><p>flex-direction 属性：</p><pre><code class="CSS">h1 &#123;  max-width: 37.25rem;  margin: 0 auto;  padding: 1.5rem 1.25rem;&#125;h1 .flex &#123;  display: flex;  flex-direction: column-reverse;  gap: 1rem;&#125;</code></pre><p>The <code>:first-of-type</code> pseudo-selector is used to target the first element that matches the selector：</p><pre><code class="CSS">h1 .flex span:first-of-type &#123;  font-size: 0.7em;&#125;/* The :last-of-type pseudo-selector does the exact opposite - it targets the last element that matches the selector. */h1 .flex span:last-of-type &#123;  font-size: 1.2em;&#125;</code></pre><p>section、.table-wrap selector：</p><pre><code class="CSS">section &#123;  max-width: 40rem;  margin: 0 auto;  border: 2px solid #d0d0d5;&#125;.table-wrap &#123;  padding: 0 0.75rem 1.5rem 0.75rem;&#125;</code></pre><p>The <code>calc()</code> function is a CSS function that allows you to calculate a value based on other values：</p><pre><code class="CSS">#years &#123;  display: flex;  justify-content: flex-end;  position: sticky;  top: 0;  background: #0a0a23;  color: #fff;  z-index: 999;  margin: 0 -2px;  padding: 0.5rem calc(1.25rem + 2px) 0.5rem 0;&#125;</code></pre><p>The <code>span[class]</code> syntax will target any <code>span</code>element that has a <code>class</code> attribute set, regardless of the attribute’s value：</p><pre><code class="CSS">#years span[class] &#123;  font-weight: bold;  width: 4.5rem;  text-align: right;&#125;</code></pre><p>The <code>:not()</code> pseudo-selector is used to target all elements that do not match the selector：</p><pre><code class="CSS">span:not(.sr-only) &#123;  font-weight: normal;&#125;</code></pre><p>table selector：</p><pre><code class="CSS">table &#123;  border-collapse: collapse; /* allow cell borders to collapse into a single border */  border: 0;  width: 100%;  position: relative;  margin-top: 3rem;&#125;</code></pre><p>caption selector：</p><pre><code class="CSS">table caption &#123;  color: #356eaf;  font-size: 1.3em;  font-weight: normal;  position: absolute;  top: -2.25rem;  left: 0.5rem;&#125;</code></pre><p>tbody selector：</p><pre><code class="CSS">tbody td &#123;  width: 100vw; /* fill the viewport */  min-width: 4rem;  max-width: 4rem;&#125;tbody th &#123;  width: calc(100% - 12rem);&#125;</code></pre><p>The <code>[attribute=&quot;value&quot;]</code> selector targets any element that has an attribute with a specific value：</p><pre><code class="CSS">tr[class=&quot;total&quot;] th &#123;  text-align: left;  padding: 0.5rem 0 0.25rem 0.5rem;&#125;</code></pre><p>The key difference between <code>tr[class=&quot;total&quot;]</code> and <code>tr.total</code> is that the first will select <code>tr</code> elements where the <em>only</em> class is <code>total</code>. The second will select <code>tr</code> elements where the class <em>includes</em> total：</p><pre><code class="CSS">tr.total td &#123;  text-align: right;  padding: 0 0.25rem;&#125;</code></pre><p>The <code>:nth-of-type()</code> pseudo-selector is used to target specific elements based on their order among siblings of the same type：</p><pre><code class="CSS">tr.total td:nth-of-type(3) &#123;  padding-right: 0.5rem;&#125;</code></pre><p>其他 table 行/列属性：</p><pre><code class="CSS">tr.total:hover &#123;  background-color: #99c9ff;&#125;td.current &#123;  font-style: italic;&#125;tr.data &#123;  background-image: linear-gradient(to bottom, #dfdfe2 1.845rem, white 1.845rem);&#125;tr.data th &#123;  text-align: left;  padding-top: 0.3rem;  padding-left: 0.5rem;&#125;</code></pre><p><code>tr.data th .description</code> selector target the elements with the <code>class</code> set to <code>description</code> that are within your <code>th</code> elements in your <code>.data</code> table rows：</p><pre><code class="CSS">tr.total:hover &#123;  background-color: #99c9ff;&#125;</code></pre><p>block display：</p><pre><code class="CSS">tr.data th .description &#123;  display: block;  font-weight: normal;  font-style: italic;  padding: 1rem 0 0.75rem;  margin-right: -13.5rem;&#125;</code></pre><p>Vertically align the text to the top, horizontally align the text to the right：</p><pre><code class="CSS">tr.data td &#123;  vertical-align: top;  padding: 0.3rem 0.25rem 0;  text-align: right;&#125;tr.data td:last-of-type &#123;  padding-right: 0.5rem;&#125;</code></pre><h3 id="三、页面展示"><a href="#三、页面展示" class="headerlink" title="三、页面展示"></a>三、页面展示</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://free-code-camp-demo.vercel.app/通过构建资产负债表了解有关CSS伪选择器的更多信息/index.html" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;freeCodeCamp 响应式网页设计的认证课程第九章。可以使用 CSS 伪选择器来更改特定的 HTML 元素。在通过构建资产负债表了解有关 CSS 伪选择器的更多信息的课程中，使用伪选择器构建资产负债表，学习如何在将鼠标悬停在元素上时更改其样式，并触发网页上的其他事件。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Web前端" scheme="http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://blog.zhuangzhihao.top/tags/CSS/"/>
    
    <category term="HTML" scheme="http://blog.zhuangzhihao.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>通过编写小测验学习无障碍</title>
    <link href="http://blog.zhuangzhihao.top/%E7%BC%96%E5%86%99%E5%B0%8F%E6%B5%8B%E9%AA%8C%E5%AD%A6%E4%B9%A0%E6%97%A0%E9%9A%9C%E7%A2%8D/"/>
    <id>http://blog.zhuangzhihao.top/%E7%BC%96%E5%86%99%E5%B0%8F%E6%B5%8B%E9%AA%8C%E5%AD%A6%E4%B9%A0%E6%97%A0%E9%9A%9C%E7%A2%8D/</id>
    <published>2022-05-25T16:00:00.000Z</published>
    <updated>2022-05-26T06:53:39.674Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>freeCodeCamp 响应式网页设计的认证课程第八章。无障碍环境使你的网页便于所有人使用，甚至是残疾人。在通过编写小测验学习无障碍的课程中，建立一个测验网页，学习诸如键盘快捷键、ARIA 属性和设计最佳实践等无障碍工具。</p></blockquote><a id="more"></a><h3 id="一、重点-HTML-代码"><a href="#一、重点-HTML-代码" class="headerlink" title="一、重点 HTML 代码"></a>一、重点 HTML 代码</h3><p>head：</p><pre><code class="html">&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot; /&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;  &lt;meta name=&quot;description&quot; content=&quot;freeCodeCamp Accessibility Quiz practice project&quot; /&gt;  &lt;title&gt;Accessibility Quiz&lt;/title&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; /&gt;&lt;/head&gt;</code></pre><p>header：</p><pre><code class="html">&lt;header&gt;  &lt;img id=&quot;logo&quot; src=&quot;https://cdn.freecodecamp.org/platform/universal/fcc_primary.svg&quot;&gt;  &lt;h1&gt;HTML/CSS Quiz&lt;/h1&gt;  &lt;nav&gt;    &lt;ul&gt;      &lt;li&gt;&lt;a href=&quot;#student-info&quot; accesskey=&quot;i&quot;&gt;INFO&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href=&quot;#html-questions&quot; accesskey=&quot;h&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href=&quot;#css-questions&quot; accesskey=&quot;c&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/nav&gt;&lt;/header&gt;</code></pre><p>student-info:</p><pre><code class="html">&lt;section role=&quot;region&quot; aria-labelledby=&quot;student-info&quot;&gt;  &lt;h2 id=&quot;student-info&quot;&gt;Student Info&lt;/h2&gt;  &lt;div class=&quot;info&quot;&gt;    &lt;label for=&quot;student-name&quot;&gt;Name:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;student-name&quot; id=&quot;student-name&quot; /&gt;  &lt;/div&gt;  &lt;div class=&quot;info&quot;&gt;    &lt;label for=&quot;student-email&quot;&gt;Email:&lt;/label&gt;    &lt;input type=&quot;email&quot; name=&quot;student-email&quot; id=&quot;student-email&quot; /&gt;  &lt;/div&gt;  &lt;div class=&quot;info&quot;&gt;    &lt;label for=&quot;birth-date&quot;&gt;D.O.B.&lt;span class=&quot;sr-only&quot;&gt;(Date of Birth)&lt;/span&gt;&lt;/label&gt;    &lt;input type=&quot;date&quot; name=&quot;birth-date&quot; id=&quot;birth-date&quot; /&gt;  &lt;/div&gt;&lt;/section&gt;</code></pre><p>html-questions：</p><pre><code class="html">&lt;section role=&quot;region&quot; aria-labelledby=&quot;html-questions&quot;&gt;  &lt;h2 id=&quot;html-questions&quot;&gt;HTML&lt;/h2&gt;  &lt;div class=&quot;question-block&quot;&gt;    &lt;p&gt;1&lt;/p&gt;    &lt;fieldset class=&quot;question&quot; name=&quot;html-question-one&quot;&gt;      &lt;legend&gt;        The legend element represents a caption for the content of its        parent fieldset element      &lt;/legend&gt;      &lt;ul class=&quot;answers-list&quot;&gt;        &lt;li&gt;          &lt;label for=&quot;q1-a1&quot;&gt;            &lt;input type=&quot;radio&quot; id=&quot;q1-a1&quot; name=&quot;q1&quot; value=&quot;true&quot; /&gt;            True          &lt;/label&gt;        &lt;/li&gt;        &lt;li&gt;          &lt;label for=&quot;q1-a2&quot;&gt;            &lt;input type=&quot;radio&quot; id=&quot;q1-a2&quot; name=&quot;q1&quot; value=&quot;false&quot; /&gt;            False          &lt;/label&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/fieldset&gt;  &lt;/div&gt;  &lt;div class=&quot;question-block&quot;&gt;    &lt;p&gt;2&lt;/p&gt;    &lt;fieldset class=&quot;question&quot; name=&quot;html-question-two&quot;&gt;      &lt;legend&gt;        A label element nesting an input element is required to have a        for attribute with the same value as the input&#39;s id      &lt;/legend&gt;      &lt;ul class=&quot;answers-list&quot;&gt;        &lt;li&gt;          &lt;label for=&quot;q2-a1&quot;&gt;            &lt;input type=&quot;radio&quot; id=&quot;q2-a1&quot; name=&quot;q2&quot; value=&quot;true&quot; /&gt;            True          &lt;/label&gt;        &lt;/li&gt;        &lt;li&gt;          &lt;label for=&quot;q2-a2&quot;&gt;            &lt;input type=&quot;radio&quot; id=&quot;q2-a2&quot; name=&quot;q2&quot; value=&quot;false&quot; /&gt;            False          &lt;/label&gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/fieldset&gt;  &lt;/div&gt;&lt;/section&gt;</code></pre><p>css-questions：</p><pre><code class="html">&lt;section role=&quot;region&quot; aria-labelledby=&quot;css-questions&quot;&gt;  &lt;h2 id=&quot;css-questions&quot;&gt;CSS&lt;/h2&gt;  &lt;div class=&quot;formrow&quot;&gt;    &lt;div class=&quot;question-block&quot;&gt;      &lt;label for=&quot;customer&quot;&gt;Are you a frontend developer?&lt;/label&gt;    &lt;/div&gt;    &lt;div class=&quot;answer&quot;&gt;      &lt;select name=&quot;customer&quot; id=&quot;customer&quot; required&gt;        &lt;option value=&quot;&quot;&gt;Select an option&lt;/option&gt;        &lt;option value=&quot;yes&quot;&gt;Yes&lt;/option&gt;        &lt;option value=&quot;no&quot;&gt;No&lt;/option&gt;      &lt;/select&gt;    &lt;/div&gt;    &lt;div class=&quot;question-block&quot;&gt;      &lt;label for=&quot;css-questions&quot;&gt;Do you have any questions:&lt;/label&gt;    &lt;/div&gt;    &lt;div class=&quot;answer&quot;&gt;      &lt;textarea id=&quot;css-questions&quot; name=&quot;css-questions&quot; rows=&quot;5&quot; cols=&quot;24&quot;                placeholder=&quot;Who is flexbox...&quot;&gt;&lt;/textarea&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/section&gt;</code></pre><p>footer：</p><pre><code class="html">&lt;footer&gt;  &lt;address&gt;    &lt;a href=&quot;https://freecodecamp.org&quot;&gt;freeCodeCamp&lt;/a&gt;&lt;br /&gt;    San Francisco&lt;br /&gt;    California&lt;br /&gt;    USA  &lt;/address&gt;&lt;/footer&gt;</code></pre><h3 id="二、重点-CSS-代码"><a href="#二、重点-CSS-代码" class="headerlink" title="二、重点 CSS 代码"></a>二、重点 CSS 代码</h3><p>@media 属性：</p><pre><code class="CSS">@media (prefers-reduced-motion: no-preference) &#123;    * &#123;        scroll-behavior: smooth;    &#125;&#125;</code></pre><p>body，header：</p><pre><code class="css">body &#123;    background: #f5f6f7;    color: #1b1b32;    font-family: Helvetica;    margin: 0;&#125;header &#123;    width: 100%;    height: 50px;    background-color: #1b1b32;    display: flex;    justify-content: space-between;    align-items: center;    position: fixed;    top: 0;&#125;</code></pre><p>logo，nav：</p><pre><code class="CSS">#logo &#123;    width: max(100px, 18vw);    background-color: #0a0a23;    aspect-ratio: 35 / 4;    padding: 0.4rem;&#125;h1 &#123;    color: #f1be32;    font-size: min(5vw, 1.2em);    text-align: center;&#125;nav &#123;    width: 50%;    max-width: 300px;    height: 50px;&#125;nav&gt;ul &#123;    display: flex;    justify-content: space-evenly;    flex-wrap: wrap;    align-items: center;    padding-inline-start: 0;    margin-block: 0;    height: 100%;&#125;nav&gt;ul&gt;li &#123;    color: #dfdfe2;    margin: 0 0.2rem;    padding: 0.2rem;    display: block;&#125;nav&gt;ul&gt;li:hover &#123;    background-color: #dfdfe2;    color: #1b1b32;    cursor: pointer;&#125;li&gt;a &#123;    color: inherit;    text-decoration: none;&#125;</code></pre><p>表单 1：</p><pre><code class="CSS">main &#123;    padding-top: 50px;&#125;section &#123;    width: 80%;    margin: 0 auto 10px auto;    max-width: 600px;&#125;h1,h2 &#123;    font-family: Verdana, Tahoma;&#125;h2 &#123;    border-bottom: 4px solid #dfdfe2;    margin-top: 0px;    padding-top: 60px;&#125;.info &#123;    padding: 10px 0 0 5px;&#125;.formrow &#123;    margin-top: 30px;    padding: 0px 15px;&#125;input &#123;    font-size: 16px;&#125;.info label,.info input &#123;    display: inline-block;    text-align: right;&#125;.info input &#123;    width: 50%;    text-align: left;&#125;.info label &#123;    width: 10%;    min-width: 55px;&#125;</code></pre><p>表单 2、3：</p><pre><code class="CSS">.question-block &#123;    text-align: left;    display: block;    width: 100%;    margin-top: 20px;    padding-top: 5px;&#125;p &#123;    margin-top: 5px;    padding-left: 15px;    font-size: 20px;&#125;p::before &#123;    content: &quot;Question #&quot;;&#125;.question &#123;    border: none;    padding-bottom: 0;&#125;.answers-list &#123;    list-style: none;    padding: 0;&#125;button &#123;    display: block;    margin: 40px auto;    width: 40%;    padding: 15px;    font-size: 23px;    background: #d0d0d5;    border: 3px solid #3b3b4f;&#125;</code></pre><p>.sr-only selector：</p><pre><code class="CSS">.sr-only &#123;    position: absolute;    width: 1px;    height: 1px;    padding: 0;    margin: -1px;    overflow: hidden;    clip: rect(0, 0, 0, 0);    white-space: nowrap;    border: 0;&#125;</code></pre><h3 id="三、页面展示"><a href="#三、页面展示" class="headerlink" title="三、页面展示"></a>三、页面展示</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://free-code-camp-demo.vercel.app/通过编写小测验学习无障碍/index.html" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;freeCodeCamp 响应式网页设计的认证课程第八章。无障碍环境使你的网页便于所有人使用，甚至是残疾人。在通过编写小测验学习无障碍的课程中，建立一个测验网页，学习诸如键盘快捷键、ARIA 属性和设计最佳实践等无障碍工具。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Web前端" scheme="http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://blog.zhuangzhihao.top/tags/CSS/"/>
    
    <category term="HTML" scheme="http://blog.zhuangzhihao.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>通过建立营养标签来学习排版</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BB%BA%E7%AB%8B%E8%90%A5%E5%85%BB%E6%A0%87%E7%AD%BE%E6%9D%A5%E5%AD%A6%E4%B9%A0%E6%8E%92%E7%89%88/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BB%BA%E7%AB%8B%E8%90%A5%E5%85%BB%E6%A0%87%E7%AD%BE%E6%9D%A5%E5%AD%A6%E4%B9%A0%E6%8E%92%E7%89%88/</id>
    <published>2022-05-24T16:00:00.000Z</published>
    <updated>2022-05-26T06:53:53.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>freeCodeCamp 响应式网页设计的认证课程第七章。排版是将文本样式设置为易于阅读并适合其目的的艺术。在通过建立营养标签来学习排版的课程中，你将使用排版来构建营养标签网页。你将学习如何使用 CSS 设置文本样式、调整行高和定位文本。</p></blockquote><a id="more"></a><h3 id="一、重点-HTML-代码"><a href="#一、重点-HTML-代码" class="headerlink" title="一、重点 HTML 代码"></a>一、重点 HTML 代码</h3><p>head：</p><pre><code class="html">&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Nutrition Label&lt;/title&gt;    &lt;link href=&quot;https://fonts.googleapis.com/css?family=Open+Sans:400,700,800&quot; rel=&quot;stylesheet&quot;&gt;    &lt;link href=&quot;styles.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;</code></pre><p>body：</p><pre><code class="html">&lt;body&gt;    &lt;div class=&quot;label&quot;&gt;        &lt;header&gt;            &lt;h1 class=&quot;bold&quot;&gt;Nutrition Facts&lt;/h1&gt;            &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt;            &lt;p&gt;8 servings per container&lt;/p&gt;            &lt;p class=&quot;bold&quot;&gt;Serving size &lt;span class=&quot;right&quot;&gt;2/3 cup (55g)&lt;/span&gt;&lt;/p&gt;        &lt;/header&gt;        &lt;div class=&quot;divider lg&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;calories-info&quot;&gt;            &lt;p class=&quot;bold sm-text&quot;&gt;Amount per serving&lt;/p&gt;            &lt;h1&gt;Calories &lt;span class=&quot;right&quot;&gt;230&lt;/span&gt;&lt;/h1&gt;        &lt;/div&gt;        &lt;div class=&quot;divider md&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;daily-value sm-text&quot;&gt;            &lt;p class=&quot;right bold no-divider&quot;&gt;% Daily Value *&lt;/p&gt;            &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt;            &lt;p&gt;&lt;span class=&quot;bold&quot;&gt;Total Fat&lt;/span&gt; 8g &lt;span class=&quot;bold right&quot;&gt;10%&lt;/span&gt;&lt;/p&gt;            &lt;p class=&quot;indent no-divider&quot;&gt;Saturated Fat 1g &lt;span class=&quot;bold right&quot;&gt;5%&lt;/span&gt;&lt;/p&gt;            &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt;            &lt;p class=&quot;indent no-divider&quot;&gt;&lt;i&gt;Trans&lt;/i&gt; Fat 0g&lt;/p&gt;            &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt;            &lt;p&gt;&lt;span class=&quot;bold&quot;&gt;Cholesterol&lt;/span&gt; 0mg &lt;span class=&quot;right bold&quot;&gt;0%&lt;/span&gt;&lt;/p&gt;            &lt;p&gt;&lt;span class=&quot;bold&quot;&gt;Sodium&lt;/span&gt; 160mg &lt;span class=&quot;right bold&quot;&gt;7%&lt;/span&gt;&lt;/p&gt;            &lt;p&gt;&lt;span class=&quot;bold&quot;&gt;Total Carbohydrate&lt;/span&gt; 37g &lt;span class=&quot;right bold&quot;&gt;13%&lt;/span&gt;&lt;/p&gt;            &lt;p class=&quot;indent no-divider&quot;&gt;Dietary Fiber 4g&lt;/p&gt;            &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt;            &lt;p class=&quot;indent no-divider&quot;&gt;Total Sugars 12g&lt;/p&gt;            &lt;div class=&quot;divider dbl-indent&quot;&gt;&lt;/div&gt;            &lt;p class=&quot;dbl-indent no-divider&quot;&gt;Includes 10g Added Sugars &lt;span class=&quot;right bold&quot;&gt;20%&lt;/span&gt;            &lt;div class=&quot;divider&quot;&gt;&lt;/div&gt;            &lt;p class=&quot;no-divider&quot;&gt;&lt;span class=&quot;bold&quot;&gt;Protein&lt;/span&gt; 3g&lt;/p&gt;            &lt;div class=&quot;divider lg&quot;&gt;&lt;/div&gt;            &lt;p&gt;Vitamin D 2mcg &lt;span class=&quot;right&quot;&gt;10%&lt;/span&gt;&lt;/p&gt;            &lt;p&gt;Calcium 260mg &lt;span class=&quot;right&quot;&gt;20%&lt;/span&gt;&lt;/p&gt;            &lt;p&gt;Iron 8mg &lt;span class=&quot;right&quot;&gt;45%&lt;/span&gt;&lt;/p&gt;            &lt;p class=&quot;no-divider&quot;&gt;Potassium 235mg &lt;span class=&quot;right&quot;&gt;6%&lt;/span&gt;&lt;/p&gt;        &lt;/div&gt;        &lt;div class=&quot;divider md&quot;&gt;&lt;/div&gt;        &lt;p class=&quot;note&quot;&gt;* The % Daily Value (DV) tells you how much a nutrient in a serving of food contributes to a            daily diet. 2,000 calories a day is used for general nutrition advice.&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="二、重点-CSS-代码"><a href="#二、重点-CSS-代码" class="headerlink" title="二、重点 CSS 代码"></a>二、重点 CSS 代码</h3><p>box-sizing 属性：</p><pre><code class="CSS">* &#123;    box-sizing: border-box;&#125;html &#123;    font-size: 16px;&#125;body &#123;    font-family: &#39;Open Sans&#39;, sans-serif;&#125;</code></pre><p>letter-spacing 属性：</p><pre><code class="css">.label &#123;    border: 2px solid black;    width: 270px;    margin: 20px auto;    padding: 0 7px;&#125;header h1 &#123;    text-align: center;    margin: -4px 0;    letter-spacing: 0.15px&#125;p &#123;    margin: 0;&#125;</code></pre><p>divider 分隔栏：</p><pre><code class="CSS">.divider &#123;    border-bottom: 1px solid #888989;    margin: 2px 0;    clear: right;&#125;.bold &#123;    font-weight: 800;&#125;.right &#123;    float: right;&#125;.lg &#123;    height: 10px;&#125;.lg,.md &#123;    background-color: black;    border: 0;&#125;.md &#123;    height: 5px;&#125;</code></pre><p>calories-info：</p><pre><code class="CSS">.sm-text &#123;    font-size: 0.85rem;&#125;.calories-info h1 &#123;    margin: -5px -2px;    overflow: hidden;&#125;.calories-info span &#123;    font-size: 1.2em;    margin-top: -7px;&#125;</code></pre><p>indent 缩进：</p><pre><code class="CSS">.indent &#123;    margin-left: 1em;&#125;.dbl-indent &#123;    margin-left: 2em;&#125;.note &#123;    font-size: 0.6rem;    margin: 5px 0;    padding: 0 8px;    text-indent: -8px;&#125;</code></pre><p><code>:not</code> pseudo-selector：</p><pre><code class="CSS">.daily-value p:not(.no-divider) &#123;    border-bottom: 1px solid #888989;&#125;</code></pre><h3 id="三、页面展示"><a href="#三、页面展示" class="headerlink" title="三、页面展示"></a>三、页面展示</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://free-code-camp-demo.vercel.app/通过建立营养标签来学习排版/index.html" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;freeCodeCamp 响应式网页设计的认证课程第七章。排版是将文本样式设置为易于阅读并适合其目的的艺术。在通过建立营养标签来学习排版的课程中，你将使用排版来构建营养标签网页。你将学习如何使用 CSS 设置文本样式、调整行高和定位文本。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Web前端" scheme="http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://blog.zhuangzhihao.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>通过创建照片集来学习 CSS 弹性盒子</title>
    <link href="http://blog.zhuangzhihao.top/CSS%E5%88%9B%E5%BB%BA%E7%85%A7%E7%89%87%E9%9B%86/"/>
    <id>http://blog.zhuangzhihao.top/CSS%E5%88%9B%E5%BB%BA%E7%85%A7%E7%89%87%E9%9B%86/</id>
    <published>2022-05-23T16:00:00.000Z</published>
    <updated>2022-05-25T01:16:02.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>freeCodeCamp 响应式网页设计的认证课程第六章。通过弹性盒子你可以设计适应不同屏幕大小的网页。在通过创建照片集来学习 CSS 弹性盒子的课程中，使用弹性盒子创建一个响应式的照片集网页。</p></blockquote><a id="more"></a><h3 id="一、重点-CSS-代码"><a href="#一、重点-CSS-代码" class="headerlink" title="一、重点 CSS 代码"></a>一、重点 CSS 代码</h3><p><code>*</code> selector：</p><pre><code class="CSS">* &#123;    box-sizing: border-box;&#125;body &#123;    margin: 0;    font-family: Arial;    background: #EBE7E7;&#125;.header &#123;    text-align: center;    padding: 32px;    background: #E0DDDD;&#125;</code></pre><p>id selector：</p><pre><code class="css">#gallery img &#123;    width: 25%;    height: 300px;    object-fit: cover;    margin-top: 8px;    padding: 0 4px;    border-radius: 10px;&#125;</code></pre><p>CSS Flexbox：</p><pre><code class="CSS">#gallery &#123;    display: flex;    flex-direction: row;    flex-wrap: wrap;    justify-content: center;    align-items: center;    padding: 0 4px;&#125;</code></pre><p>media query：</p><pre><code class="CSS">@media (max-width: 800px) &#123;    #gallery img &#123;        width: 50%;    &#125;&#125;@media (max-width: 600px) &#123;    #gallery img &#123;        width: 100%;    &#125;&#125;</code></pre><h3 id="二、页面展示"><a href="#二、页面展示" class="headerlink" title="二、页面展示"></a>二、页面展示</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://free-code-camp-demo.vercel.app/通过创建照片集来学习CSS弹性盒子/index.html" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;freeCodeCamp 响应式网页设计的认证课程第六章。通过弹性盒子你可以设计适应不同屏幕大小的网页。在通过创建照片集来学习 CSS 弹性盒子的课程中，使用弹性盒子创建一个响应式的照片集网页。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Web前端" scheme="http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://blog.zhuangzhihao.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>通过创作罗斯科绘画学习 CSS 盒子模型</title>
    <link href="http://blog.zhuangzhihao.top/CSS%E5%88%9B%E4%BD%9C%E7%BD%97%E6%96%AF%E7%A7%91%E7%BB%98%E7%94%BB/"/>
    <id>http://blog.zhuangzhihao.top/CSS%E5%88%9B%E4%BD%9C%E7%BD%97%E6%96%AF%E7%A7%91%E7%BB%98%E7%94%BB/</id>
    <published>2022-05-22T16:00:00.000Z</published>
    <updated>2022-05-24T13:04:28.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>freeCodeCamp 响应式网页设计的认证课程第五章。每个 HTML 元素都是一个盒子，它拥有着自己的间距和边框，这叫作盒子模型。在通过创作罗斯科绘画学习 CSS 盒子模型的课程中，使用 CSS 和盒子模型，创作属于自己的罗斯科风格的矩形艺术作品。</p></blockquote><a id="more"></a><h3 id="一、CSS-box-model"><a href="#一、CSS-box-model" class="headerlink" title="一、CSS box model"></a>一、CSS box model</h3><p><img src="https://cdn.freecodecamp.org/curriculum/css-box-model/diagram-3.png" class="lazyload" data-srcset="https://cdn.freecodecamp.org/curriculum/css-box-model/diagram-3.png" srcset="data:image/png;base64,666"></p><h3 id="二、重点-CSS-代码"><a href="#二、重点-CSS-代码" class="headerlink" title="二、重点 CSS 代码"></a>二、重点 CSS 代码</h3><p>Use padding to adjust the spacing within an element：</p><pre><code class="CSS">.frame &#123;    border: 50px solid black;    width: 500px;    padding: 50px;    margin: 20px auto;&#125;</code></pre><p>Use margins to adjust the spacing outside of an element：</p><pre><code class="css">.one &#123;    width: 425px;    height: 150px;    background-color: #efb762;    margin: 20px auto;    box-shadow: 0 0 3px 3px #efb762;    border-radius: 9px;    transform: rotate(-0.6deg);&#125;</code></pre><p>overflow:hidden 溢出隐藏、清除浮动、解决外边距塌陷：</p><pre><code class="CSS">.canvas &#123;    width: 500px;    height: 600px;    background-color: #4d0f00;    overflow: hidden;    filter: blur(2px);&#125;</code></pre><p>filter 属性；box-shadow 属性；border-radius 属性；transform 属性：</p><pre><code class="CSS">.two &#123;    width: 475px;    height: 200px;    background-color: #8f0401;    margin: 0 auto 20px;    box-shadow: 0 0 3px 3px #8f0401;    border-radius: 8px 10px;    transform: rotate(0.4deg);&#125;.one,.two &#123;    filter: blur(1px);&#125;.three &#123;    width: 91%;    height: 28%;    background-color: #b20403;    margin: auto;    filter: blur(2px);    box-shadow: 0 0 5px 5px #b20403;    border-radius: 30px 25px 60px 12px;    transform: rotate(-0.2deg);&#125;</code></pre><h3 id="三、页面展示"><a href="#三、页面展示" class="headerlink" title="三、页面展示"></a>三、页面展示</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://free-code-camp-demo.vercel.app/通过创作罗斯科绘画学习CSS盒子模型/index.html" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;freeCodeCamp 响应式网页设计的认证课程第五章。每个 HTML 元素都是一个盒子，它拥有着自己的间距和边框，这叫作盒子模型。在通过创作罗斯科绘画学习 CSS 盒子模型的课程中，使用 CSS 和盒子模型，创作属于自己的罗斯科风格的矩形艺术作品。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Web前端" scheme="http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://blog.zhuangzhihao.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>通过编写注册表单学习 HTML 表单</title>
    <link href="http://blog.zhuangzhihao.top/HTML%E7%BC%96%E5%86%99%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%95/"/>
    <id>http://blog.zhuangzhihao.top/HTML%E7%BC%96%E5%86%99%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%95/</id>
    <published>2022-05-19T16:00:00.000Z</published>
    <updated>2022-05-23T10:38:15.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>freeCodeCamp 响应式网页设计的认证课程第四章。你可以使用 HTML 表单收集访问网页的用户的信息。在通过编写注册表单学习 HTML 表单的课程中，通过编写一个注册页学习 HTML 表单，学习如何控制人们在表单中可以输入的数据类型，以及使用一些新的 CSS 工具装饰你的页面。</p></blockquote><a id="more"></a><h3 id="一、重点-HTML-代码"><a href="#一、重点-HTML-代码" class="headerlink" title="一、重点 HTML 代码"></a>一、重点 HTML 代码</h3><p>表格页面格式：</p><pre><code class="HTML">&lt;body&gt;  &lt;h1&gt;Registration Form&lt;/h1&gt;  &lt;p&gt;Please fill out this form with the required information&lt;/p&gt;  &lt;form action=&#39;https://register-demo.freecodecamp.org&#39;&gt;    &lt;!--表格内容--&gt;  &lt;/form&gt;  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/body&gt;</code></pre><p>输入框：</p><pre><code class="html">&lt;fieldset&gt;    &lt;label&gt;Enter Your First Name: &lt;input type=&quot;text&quot; name=&quot;first-name&quot; required /&gt;&lt;/label&gt;    &lt;label&gt;Enter Your Last Name: &lt;input type=&quot;text&quot; name=&quot;last-name&quot; required /&gt;&lt;/label&gt;    &lt;label&gt;Enter Your Email: &lt;input type=&quot;email&quot; name=&quot;email&quot; required /&gt;&lt;/label&gt;    &lt;label&gt;Create a New Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; minlen=&quot;8&quot; pattern=&quot;[a-z0-5]&#123;8,&#125;&quot; required /&gt;&lt;/label&gt;&lt;/fieldset&gt;</code></pre><p>单选&amp;复选框：</p><pre><code class="html">&lt;fieldset&gt;  &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;account-type&quot; class=&quot;inline&quot; /&gt; Personal Account&lt;/label&gt;  &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;account-type&quot; class=&quot;inline&quot; /&gt; Business Account&lt;/label&gt;  &lt;label&gt;    &lt;input type=&quot;checkbox&quot; name=&quot;terms&quot; class=&quot;inline&quot; required /&gt; I accept the &lt;a href=&quot;https://www.freecodecamp.org/news/terms-of-service/&quot;&gt;terms and conditions&lt;/a&gt;  &lt;/label&gt;&lt;/fieldset&gt;</code></pre><p>文件、数字、下拉栏、文本框输入：</p><pre><code class="html">&lt;fieldset&gt;    &lt;label&gt;Upload a profile picture: &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;/label&gt;    &lt;label&gt;Input your age (years): &lt;input type=&quot;number&quot; name=&quot;age&quot; min=&quot;13&quot; max=&quot;120&quot; /&gt;&lt;/label&gt;    &lt;label&gt;How did you hear about us?        &lt;select name=&quot;referrer&quot;&gt;        &lt;option value=&quot;&quot;&gt;(select one)&lt;/option&gt;        &lt;option value=&quot;1&quot;&gt;freeCodeCamp News&lt;/option&gt;         &lt;option value=&quot;2&quot;&gt;freeCodeCamp YouTube Channel&lt;/option&gt;      &lt;option value=&quot;3&quot;&gt;freeCodeCamp Forum&lt;/option&gt;      &lt;option value=&quot;4&quot;&gt;Other&lt;/option&gt;       &lt;/select&gt;  &lt;/label&gt;  &lt;label&gt;Provide a bio:      &lt;textarea name=&quot;bio&quot; rows=&quot;3&quot; cols=&quot;30&quot; placeholder=&quot;I like coding on the beach...&quot;&gt;&lt;/textarea&gt;    &lt;/label&gt;&lt;/fieldset&gt;</code></pre><h3 id="二、重点-CSS-代码"><a href="#二、重点-CSS-代码" class="headerlink" title="二、重点 CSS 代码"></a>二、重点 CSS 代码</h3><p>pseudo-class（<code>:not(:last-of-type)</code>）：</p><pre><code class="CSS">fieldset &#123;  border: none;    padding: 2rem 0;&#125;fieldset:not(:last-of-type) &#123;  border-bottom: 3px solid #3b3b4f;&#125;</code></pre><p>unset 属性：</p><pre><code class="css">.inline &#123;  width: unset;  margin: 0 0.5em 0 0;  vertical-align: middle;&#125;</code></pre><p>CSS attribute selector：</p><pre><code class="CSS">input[type=&quot;submit&quot;] &#123;  display: block;  width: 60%;  margin: 1em auto;  height: 2em;  font-size: 1.1rem;  background-color: #3b3b4f;  border-color: white;  min-width: 300px;&#125;input[type=&quot;file&quot;] &#123;  padding: 1px 2px;&#125;</code></pre><p>其他表单设置：</p><pre><code class="css">body &#123;  width: 100%;  height: 100vh;  margin: 0;  background-color: #1b1b32;    color: #f5f6f7;  font-family: Tahoma;    font-size: 16px;&#125;h1, p &#123;  margin: 1em auto;  text-align: center;&#125;form &#123;  width: 60vw;    max-width: 500px;    min-width: 300px;    margin: 0 auto;  padding-bottom: 2em;&#125;label &#123;  display: block;    margin: 0.5rem 0;&#125;input,textarea,select &#123;  margin: 10px 0 0 0;    width: 100%;  min-height: 2em;&#125;input, textarea &#123;  background-color: #0a0a23;  border: 1px solid #0a0a23;  color: #ffffff;&#125;a&#123;  color: #dfdfe2;&#125;</code></pre><h3 id="三、页面展示"><a href="#三、页面展示" class="headerlink" title="三、页面展示"></a>三、页面展示</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://free-code-camp-demo.vercel.app/通过编写注册表单学习HTML表单/index.html" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;freeCodeCamp 响应式网页设计的认证课程第四章。你可以使用 HTML 表单收集访问网页的用户的信息。在通过编写注册表单学习 HTML 表单的课程中，通过编写一个注册页学习 HTML 表单，学习如何控制人们在表单中可以输入的数据类型，以及使用一些新的 CSS 工具装饰你的页面。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Web前端" scheme="http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="HTML" scheme="http://blog.zhuangzhihao.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>通过构建一组彩色标记来学习 CSS 颜色</title>
    <link href="http://blog.zhuangzhihao.top/CSS%E6%9E%84%E5%BB%BA%E4%B8%80%E7%BB%84%E5%BD%A9%E8%89%B2%E6%A0%87%E8%AE%B0/"/>
    <id>http://blog.zhuangzhihao.top/CSS%E6%9E%84%E5%BB%BA%E4%B8%80%E7%BB%84%E5%BD%A9%E8%89%B2%E6%A0%87%E8%AE%B0/</id>
    <published>2022-05-18T16:00:00.000Z</published>
    <updated>2022-05-23T10:38:23.142Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>freeCodeCamp 响应式网页设计的认证课程第三章。为你的网页选择正确的颜色可以大大提高对读者的审美吸引力。在通过构建一组彩色标记来学习 CSS 颜色的课程中，构建一组彩色标记，学习设置颜色值的不同方法以及如何将颜色相互配对。</p></blockquote><a id="more"></a><h3 id="一、重点-HTML-代码"><a href="#一、重点-HTML-代码" class="headerlink" title="一、重点 HTML 代码"></a>一、重点 HTML 代码</h3><p>head 标签：</p><pre><code class="html">&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Colored Markers&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;&lt;/head&gt;</code></pre><p>含多个 CSS class 的 div 标签：</p><pre><code class="html">&lt;body&gt;    &lt;h1&gt;CSS Color Markers&lt;/h1&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;marker red&quot;&gt;            &lt;div class=&quot;cap&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;sleeve&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;marker green&quot;&gt;            &lt;div class=&quot;cap&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;sleeve&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;marker blue&quot;&gt;            &lt;div class=&quot;cap&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;sleeve&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="二、重点-CSS-代码"><a href="#二、重点-CSS-代码" class="headerlink" title="二、重点 CSS 代码"></a>二、重点 CSS 代码</h3><p>padding 属性：</p><pre><code class="CSS">.container &#123;    background-color: rgb(255, 255, 255);    padding: 10px 0;&#125;.marker &#123;    width: 200px;    height: 25px;    margin: 10px auto;&#125;</code></pre><p> opacity 属性：</p><pre><code class="CSS">.sleeve &#123;  opacity: 0.5;  width: 110px;  height: 25px;  background-color: white;&#125;</code></pre><p>border-left 属性：</p><pre><code class="CSS">.cap &#123;    width: 60px;    height: 25px;&#125;.sleeve &#123;    width: 110px;    height: 25px;    background-color: rgba(255, 255, 255, 0.5);    border-left: 10px double rgba(0, 0, 0, 0.75);&#125;</code></pre><p>多层 CSS class selector：</p><pre><code class="CSS">.cap,.sleeve &#123;    display: inline-block;&#125;</code></pre><p>linear-gradient 属性：</p><pre><code class="CSS">.red &#123;    background: linear-gradient(rgb(122, 74, 14), rgb(245, 62, 113), rgb(162, 27, 27));    box-shadow: 0 0 20px 0 rgba(83, 14, 14, 0.8);&#125;</code></pre><p>box-shadow 属性：</p><pre><code class="css">.green &#123;    background: linear-gradient(#55680D, #71F53E, #116C31);    box-shadow: 0 0 20px 0 #3B7E20CC;&#125;</code></pre><p>HSL color model：</p><pre><code class="CSS">.blue &#123;    background: linear-gradient(hsl(186, 76%, 16%), hsl(223, 90%, 60%), hsl(240, 56%, 42%));    box-shadow: 0 0 20px 0 hsla(223, 59%, 31%, 0.8);&#125;</code></pre><h3 id="三、页面展示"><a href="#三、页面展示" class="headerlink" title="三、页面展示"></a>三、页面展示</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://free-code-camp-demo.vercel.app/通过构建一组彩色标记学习CSS颜色/index.html" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;freeCodeCamp 响应式网页设计的认证课程第三章。为你的网页选择正确的颜色可以大大提高对读者的审美吸引力。在通过构建一组彩色标记来学习 CSS 颜色的课程中，构建一组彩色标记，学习设置颜色值的不同方法以及如何将颜色相互配对。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Web前端" scheme="http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://blog.zhuangzhihao.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>通过编写咖啡店菜单学习基础 CSS</title>
    <link href="http://blog.zhuangzhihao.top/CSS%E5%92%96%E5%95%A1%E5%BA%97%E8%8F%9C%E5%8D%95/"/>
    <id>http://blog.zhuangzhihao.top/CSS%E5%92%96%E5%95%A1%E5%BA%97%E8%8F%9C%E5%8D%95/</id>
    <published>2022-05-16T16:00:00.000Z</published>
    <updated>2022-05-23T10:38:37.523Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>freeCodeCamp 响应式网页设计的认证课程第二章。CSS 负责告诉浏览器如何展示你的网页。你可以使用 CSS 设置 HTML 元素的颜色、字体、大小等属性。在通过编写咖啡店菜单学习基础 CSS 课程中，通过为一个咖啡店网站设计菜单页来学习 CSS。</p></blockquote><a id="more"></a><h3 id="一、重点-HTML-代码"><a href="#一、重点-HTML-代码" class="headerlink" title="一、重点 HTML 代码"></a>一、重点 HTML 代码</h3><p>meta 标签（自闭和）：</p><pre><code class="HTML">&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;/head&gt;</code></pre><p>head 中 link CSS 文件 <code>styles.css</code>：</p><pre><code class="html">&lt;link href=&quot;styles.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code></pre><p>header 标签：</p><pre><code class="html">&lt;body&gt;  &lt;header&gt;        &lt;h1&gt;CAMPER CAFE&lt;/h1&gt;        &lt;p class=&quot;established&quot;&gt;Est. 2020&lt;/p&gt;    &lt;/header&gt;  &lt;hr&gt;&lt;/body&gt;</code></pre><p>div 标签：</p><pre><code class="html">&lt;div class=&quot;menu&quot;&gt;  &lt;!--header + main + footer--&gt;&lt;/div&gt;</code></pre><p>article 标签：</p><pre><code class="html">&lt;section&gt;    &lt;h2&gt;Coffee&lt;/h2&gt;    &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/css-cafe/coffee.jpg&quot; alt=&quot;coffee icon&quot;/&gt;    &lt;article class=&quot;item&quot;&gt;    &lt;p class=&quot;flavor&quot;&gt;French Vanilla&lt;/p&gt;&lt;p class=&quot;price&quot;&gt;3.00&lt;/p&gt;    &lt;/article&gt;&lt;section&gt;</code></pre><p>footer 标签：</p><pre><code class="html">&lt;hr class=&quot;bottom-line&quot;&gt;&lt;footer&gt;    &lt;p&gt;    &lt;a href=&quot;https://www.freecodecamp.org&quot; target=&quot;_blank&quot;&gt;Visit our website&lt;/a&gt;    &lt;/p&gt;    &lt;p class=&quot;address&quot;&gt;123 Free Code Camp Drive&lt;/p&gt;&lt;/footer&gt;</code></pre><p>CSS type selector：</p><pre><code class="html">&lt;head&gt;  &lt;style&gt;        h1, h2, p &#123;            text-align: center;        &#125;    &lt;/style&gt;&lt;/head&gt;</code></pre><h3 id="二、重点-CSS-代码"><a href="#二、重点-CSS-代码" class="headerlink" title="二、重点 CSS 代码"></a>二、重点 CSS 代码</h3><p>CSS 注释：</p><pre><code class="CSS">/* FOOTER */</code></pre><p>background-image 属性：</p><pre><code class="CSS">body &#123;    background-image: url(https://cdn.freecodecamp.org/curriculum/css-cafe/beans.jpg);    font-family: sans-serif;    padding: 20px;&#125;</code></pre><p>CSS class selector：</p><pre><code class="CSS">.menu &#123;    width: 80%;    background-color: burlywood;    margin-left: auto;    margin-right: auto;    padding: 20px;    max-width: 500px;&#125;</code></pre><p>多层 CSS style selector：</p><pre><code class="CSS">h1, h2, p &#123;    text-align: center;&#125;h1, h2 &#123;    font-family: Impact, serif;&#125;</code></pre><p>多层 CSS class selector：</p><pre><code class="CSS">.flavor, .dessert &#123;    text-align: left;    width: 75%;&#125;</code></pre><p>display 属性：</p><pre><code class="css">.item p &#123;    display: inline-block;    margin-top: 5px;    margin-bottom: 5px;    font-size: 18px;&#125;</code></pre><p>CSS pseudo-selector：</p><pre><code class="CSS">a &#123;    color: black;&#125;a:visited &#123;    color: black;&#125;a:hover &#123;    color: brown;&#125;a:active &#123;    color: brown;&#125;</code></pre><p>给 img 和 hr 设置属性：</p><pre><code class="CSS">img &#123;    margin: -25px;    display: block;    margin-left: auto;    margin-right: auto;&#125;hr &#123;    height: 2px;    background-color: brown;    border-color: brown;&#125;</code></pre><p>font-size 属性：</p><pre><code class="CSS">footer &#123;    font-size: 14px;&#125;</code></pre><h3 id="三、页面展示"><a href="#三、页面展示" class="headerlink" title="三、页面展示"></a>三、页面展示</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://free-code-camp-demo.vercel.app/通过编写咖啡店菜单学习基础CSS/index.html" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;freeCodeCamp 响应式网页设计的认证课程第二章。CSS 负责告诉浏览器如何展示你的网页。你可以使用 CSS 设置 HTML 元素的颜色、字体、大小等属性。在通过编写咖啡店菜单学习基础 CSS 课程中，通过为一个咖啡店网站设计菜单页来学习 CSS。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Web前端" scheme="http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://blog.zhuangzhihao.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>通过编写猫咪相册应用学习 HTML</title>
    <link href="http://blog.zhuangzhihao.top/HTML%E7%8C%AB%E5%92%AA%E7%9B%B8%E5%86%8C%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.zhuangzhihao.top/HTML%E7%8C%AB%E5%92%AA%E7%9B%B8%E5%86%8C%E5%BA%94%E7%94%A8/</id>
    <published>2022-05-14T16:00:00.000Z</published>
    <updated>2022-05-23T10:38:08.466Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>freeCodeCamp 响应式网页设计的认证课程第一章。HTML 标签赋予了网页结构。你可以使用 HTML 标签添加照片、按钮和其它元素到你的网页。在通过编写猫咪相册应用学习 HTML 的课程中，通过编写一个猫咪相册应用，学习最常见的 HTML 标签。</p></blockquote><a id="more"></a><h3 id="一、重点代码"><a href="#一、重点代码" class="headerlink" title="一、重点代码"></a>一、重点代码</h3><p>页面格式：</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;header&gt;&lt;title&gt;CatPhotoApp&lt;/title&gt;&lt;/header&gt;    &lt;body&gt;      &lt;main&gt;        &lt;section&gt;&lt;/section&gt;  &lt;!--多个分块--&gt;      &lt;/main&gt;      &lt;footer&gt;&lt;p&gt;Copyright&lt;/p&gt;&lt;/footer&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>figure 标签，用于规定独立的流内容（图像、图表、照片、代码等）：</p><pre><code class="html">&lt;figure&gt;    &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/lasagna.jpg&quot; alt=&quot;A slice of lasagna on a plate.&quot;&gt;   &lt;!--img 标签自闭和--&gt;    &lt;figcaption&gt;Cats &lt;em&gt;love&lt;/em&gt; lasagna.&lt;/figcaption&gt;&lt;/figure&gt;</code></pre><p>form 表单提交：</p><pre><code class="html">&lt;form action=&quot;https://freecatphotoapp.com/submit-cat-photo&quot;&gt;  &lt;input type=&quot;text&quot; name=&quot;catphotourl&quot; placeholder=&quot;cat photo URL&quot; required&gt;  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;</code></pre><p>用 fieldset 标签对表单进行分组，一个表单可以有多个 fieldset：</p><pre><code class="html">&lt;fieldset&gt;    &lt;legend&gt;Is your cat an indoor or outdoor cat?&lt;/legend&gt;    &lt;label&gt;&lt;input id=&quot;indoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;indoor&quot; checked&gt; Indoor&lt;/label&gt;    &lt;label&gt;&lt;input id=&quot;outdoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;outdoor&quot;&gt; Outdoor&lt;/label&gt;&lt;/fieldset&gt;&lt;fieldset&gt;    &lt;legend&gt;What&#39;s your cat&#39;s personality?&lt;/legend&gt;    &lt;input id=&quot;loving&quot; type=&quot;checkbox&quot; name=&quot;personality&quot; value=&quot;loving&quot; checked&gt; &lt;label for=&quot;loving&quot;&gt;Loving&lt;/label&gt;    &lt;input id=&quot;lazy&quot; type=&quot;checkbox&quot; name=&quot;personality&quot; value=&quot;lazy&quot;&gt; &lt;label for=&quot;lazy&quot;&gt;Lazy&lt;/label&gt;    &lt;input id=&quot;energetic&quot; type=&quot;checkbox&quot; name=&quot;personality&quot; value=&quot;energetic&quot;&gt; &lt;label for=&quot;energetic&quot;&gt;Energetic&lt;/label&gt;&lt;/fieldset&gt;</code></pre><h3 id="二、页面展示"><a href="#二、页面展示" class="headerlink" title="二、页面展示"></a>二、页面展示</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://free-code-camp-demo.vercel.app/通过编写猫咪相册应用学习HTML/index.html" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;freeCodeCamp 响应式网页设计的认证课程第一章。HTML 标签赋予了网页结构。你可以使用 HTML 标签添加照片、按钮和其它元素到你的网页。在通过编写猫咪相册应用学习 HTML 的课程中，通过编写一个猫咪相册应用，学习最常见的 HTML 标签。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Web前端" scheme="http://blog.zhuangzhihao.top/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="HTML" scheme="http://blog.zhuangzhihao.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 C 语言指针</title>
    <link href="http://blog.zhuangzhihao.top/%E6%B5%85%E8%B0%88%E6%8C%87%E9%92%88/"/>
    <id>http://blog.zhuangzhihao.top/%E6%B5%85%E8%B0%88%E6%8C%87%E9%92%88/</id>
    <published>2022-05-07T16:00:00.000Z</published>
    <updated>2022-05-30T08:04:36.265Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机内存区域中的每字节都对应一个编号，这个编号就是“地址”。如果在程序中定义了一个变量，那么在对程序进行编译时，系统就会给这个变量分配内存单元。如果我们在程序中需要将某个整型、浮点型或字符型数据变量的地址保存下来，需要用到 C 语言为我们提供的指针。在 C 语言中，指针变量是一种特殊的变量，它用来存放变量地址。掌握指针，对于学习操作系统、理解操作系统原理会有非常大的帮助。</p></blockquote><a id="more"></a><h3 id="一、取地址操作符和取值操作符"><a href="#一、取地址操作符和取值操作符" class="headerlink" title="一、取地址操作符和取值操作符"></a>一、取地址操作符和取值操作符</h3><p>取地址操作符为 <code>&amp;</code>，也称引用，通过该操作符我们可以获取一个变量的地址值；取值操作符为 <code>*</code>，也称解引用，通过该操作符我们可以得到一个地址对应的数据。取地址操作符和取值操作符优先级相同，按照自右向左的顺序相结合。</p><pre><code class="c">int main()&#123;  int i = 10;  int *p; //p就是一个指针变量，可以用来存储地址，类型是整型指针  p = &amp;i; //初始化赋值  printf(&quot;i = %d\n&quot;, i); //直接访问  printf(&quot;*p = %d\n&quot;, *p); //间接访问&#125;</code></pre><p>指针变量前面的表示该变量为指针型变量，例如 <code>float **pointer_1;</code> 的指针变量名是 <code>pointer_1</code>。在定义指针变量时必须指定其类型，只有整型变量的地址才能放到指向整型变量的指针变量中。</p><h3 id="二、指针的传递和偏移"><a href="#二、指针的传递和偏移" class="headerlink" title="二、指针的传递和偏移"></a>二、指针的传递和偏移</h3><p>C 语言中的函数调用均为值传递。指针的传递将变量 i 的地址传递给 change 函数时，实际效果是 <code>j=&amp;i</code>，这时 j 是一个指针变量，依然是值传递, 只是 j 内部存储的是变量 i 的地址，所以通过 <code>*j</code> 就间接访问到了与变量 i 相同的区域，通过 <code>*j=5</code> 就实现了对变量 i 的值的改变。</p><pre><code class="c">void change(int* j)&#123;  *j = 5; //间接访问得到变量 i&#125;int main() //指针的传递&#123;  int i = 10;    printf(&quot;before change i=%d\n&quot;, i);    change(&amp;i); //传递变量 i 的地址    printf(&quot;after change i=%d\n&quot;, i);&#125;</code></pre><p>我们把对指针的加减称为指针的偏移，加就是向后偏移，减就是向前偏移，但对指针进行乘除是没有意义的。</p><pre><code class="c">//指针的偏移int main()&#123;  int a[5]=&#123;1,2,3,4,5&#125;;  int *p;  int i;  p = a; //保证等号两边的数值类型一致  for(i=0; i&lt;5; i++) //正序输出  &#123;      printf(&quot;%3d&quot;, *(p+i));  &#125;  p = &amp;a[4]; //让 p 指向最后一个元素    for(i=0; i&lt;5; i++) //逆序输出    &#123;    printf(&quot;%3d&quot;,*(p-i));  &#125;&#125;</code></pre><h3 id="三、指针与一维数组"><a href="#三、指针与一维数组" class="headerlink" title="三、指针与一维数组"></a>三、指针与一维数组</h3><p>数组在传递时弱化为指针。这是由于一维数组名中存储的是数组的首地址，因此一维数组在函数调用进行传递时，它的长度子函数无法知道。定义一个指针变量时，指针变量的类型要和数组的数据类型保持一致，通过取值操作, 就可获取数组元素, 这种方法称为指针法。也可以通过取下标的方式来获取数组元素并进行修改，这种方法称为下标法。</p><pre><code class="c">void change(char *d)  //*d 为形参&#123;  *d = &#39;H&#39;; //指针法  d[1] = &#39;E&#39;; //下标法  *(d+2) = &#39;L&#39;; //指针的偏移&#125;int main()&#123;  char c[10] = &#39;hello&#39;;  change(c); //c 为实参  printf(&quot;%c\n&quot;, c);&#125;</code></pre><h3 id="四、指针与动态内存申请"><a href="#四、指针与动态内存申请" class="headerlink" title="四、指针与动态内存申请"></a>四、指针与动态内存申请</h3><p>C 语言的数组长度固定是因为其定义的整型、浮点型、字符型变量、数组变量都在栈空间中，而栈空间的大小在编译时是确定的。如果使用的空间大小不确定，那么就要使用堆空间申请动态内存申请。栈空间由系统自动管理，而堆空间的申请和释放需要自行管理，所以在具体例子中需要通过 free 函数释放堆空间。</p><p>栈是计算机系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈操作、出栈操作都有专门的指令执行，这就决定了栈的效率比较高；堆则是 C/C++ 函数库提供的数据结构，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能由于内存碎片太多）那么就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后返回。显然，堆的效率要比栈低得多。</p><pre><code class="c">int main()&#123;  int i;  char *p;  scanf(&quot;%d&quot;, &amp;i); //输入要申请的空间大小  p = (char*)malloc(i)；//使用 malloc 动态申请堆空间，(char *)是强制类型转换  strcpy(p, &quot;malloc success&quot;);  puts(p);  free(p)；//free 时必须使用 malloc 申请时返回的指针值，不能进行任何偏移  p = NULL; //消除野指针&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机内存区域中的每字节都对应一个编号，这个编号就是“地址”。如果在程序中定义了一个变量，那么在对程序进行编译时，系统就会给这个变量分配内存单元。如果我们在程序中需要将某个整型、浮点型或字符型数据变量的地址保存下来，需要用到 C 语言为我们提供的指针。在 C 语言中，指针变量是一种特殊的变量，它用来存放变量地址。掌握指针，对于学习操作系统、理解操作系统原理会有非常大的帮助。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://blog.zhuangzhihao.top/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>gets 函数与 puts 函数</title>
    <link href="http://blog.zhuangzhihao.top/gets%E5%87%BD%E6%95%B0%E4%B8%8Eputs%E5%87%BD%E6%95%B0/"/>
    <id>http://blog.zhuangzhihao.top/gets%E5%87%BD%E6%95%B0%E4%B8%8Eputs%E5%87%BD%E6%95%B0/</id>
    <published>2022-05-02T16:00:00.000Z</published>
    <updated>2022-05-24T08:55:53.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C 语言标准输入 scanf 在通过 <code>%s</code> 读取字符串时遇到空格就认为读取结束，这样没办法把一行带有空格的字符串存入到一个字符数组中。所以当需要输入的字符串中含有空格时，我们需要使用 gets 函数进行读取，使用 puts 函数进行输出。</p></blockquote><a id="more"></a><h3 id="一、字符数组"><a href="#一、字符数组" class="headerlink" title="一、字符数组"></a>一、字符数组</h3><p>字符数组的定义方法一维数组、二维数组类似，例如 <code>char c[10]=&quot;hello&quot;</code>。</p><p>因为 C 语言规定字符串的结束标志为 <code>\0</code>，而系统会对字符串常量自动加一个 <code>\0</code>，为了保证处理方法一致，一般会人为地在字符数组中添加 <code>\0</code>，所以字符数组存储的字符串长度必须比字符数组少 1 字节。例如 <code>char[10]</code> 最多存储 9 个字符，最后一个字符用来存储 <code>\0</code>。</p><p>字符数组的数组名里存的就是字符数组的起始地址，类型是字符指针。即编译器给字符数组 c 内部存了一个值，c 中存储的值的类型是字符指针。</p><h3 id="二、gets-函数和-puts-函数"><a href="#二、gets-函数和-puts-函数" class="headerlink" title="二、gets 函数和 puts 函数"></a>二、gets 函数和 puts 函数</h3><p>scanf 函数没办法把一行带有空格的字符串存入到一个字符数组中，所以当需要输入的字符串中含有空格时，我们需要使用 gets 函数进行读取：<code>char *gets(char *str)</code>。</p><p>gets 函数从 STDIN（标准输入）读取字符并把它们加载到 str（字符串）中，直到遇到换行符（\n）或到达 EOF。gets 遇到 <code>\n</code> 后, 不会存储 <code>\n</code>，而是将其翻译为空字符 <code>\0</code>。</p><p>puts 函数类似于 printf 函数，用于输出标准输出：<code>int puts(char *str);</code>。</p><p>函数 puts 把 str (字符串) 写人STDOU (标准输出)。puts 执行成功时返回非负值，执行失败时返回 EOF。相对于 printf 函数，puts 只能用于输出字符串，同时多打印一个换行符。</p><pre><code class="c">int main()&#123;    char c[20];    gets(c); //当一次读取一行时，使用gets    puts(c); //等价于printf(&quot;%s\n&quot;,c);    return 0;&#125;</code></pre><p>虽然用 <code>gets()</code> 时有空格也可以直接输入，但是 gets 不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界，所以编程时建议使用 <code>fgets()</code>。fgets 相对于 gets 去读取标准输入时，会把 <code>\n</code> 放到字符数组中。<code>char *fgets(char *s, int size, FILE *stream);</code>。</p><pre><code class="c">int main()&#123;    char c[20];    fgets(c, sizeof(c), stdin);    int len = strlen(c);  c[len -1] = &#39;\0&#39;;    puts(c);  return 0;&#125;</code></pre><h3 id="三、str-系列字符串操作函数"><a href="#三、str-系列字符串操作函数" class="headerlink" title="三、str 系列字符串操作函数"></a>三、str 系列字符串操作函数</h3><p>str 系列字符串操作函数主要包括 strlen、strcpy 、strcmp、strcat 等。strlen 函数用于统计字符串长度，strcpy 函数用于将某个字符串复制到字符数组中，strcmp 函数用于比较两个字符串的大小，strcat 函数用于将两个字符串连接到一起：</p><pre><code class="c">#include &lt;string.h&gt;size_t strlen(char *str);char *strcpy(char *to, const char *from); //有const修饰代表此处可以放字符串常量int strcmp(const char *str1, const char *str2);char *strcat(char *str1, const char *str2);</code></pre><p>对于传参类型 <code>char*</code>，直接放入字符数组的数组名即可。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;    char c[20] = &quot;zhuang&quot;;    puts(c); //zhuang    printf(&quot;数组c内字符串的长度=%d\n&quot;, strlen(c));    char d[20];    strcpy(d, c); // 将c的内容复制到d中    puts(d); //zhuang    strcpy(d, &quot;study&quot;); // 将字符串study复制到d中    //strcmp比较字符串对应字符位置的ascii码值    int ret = strcmp(&quot;hello&quot;, &quot;how&quot;);    printf(&quot;两个字符串比较结果=%d\n&quot;, ret);  //-1    //strcat拼接两个字符串    strcat(d, &quot;!&quot;); // 将字符串!拼接到d中    puts(d);  //study!    return 0;&#125;</code></pre><h3 id="四、判断回文数"><a href="#四、判断回文数" class="headerlink" title="四、判断回文数"></a>四、判断回文数</h3><p>读取一个字符串，字符串可能含有空格，将字符串逆转，原来的字符串与逆转后字符串相同，输出 0，原字符串小于逆转后字符串输出 -1，大于逆转后字符串输出 1。例如输入 hello，逆转后的字符串为 olleh，因为hello 小于 olleh，所以输出 -1。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;  char c[20], d[20];  gets(c);  int i, j;  for (i = strlen(c) - 1, j = 0; i &gt;= 0; i--, j++)  &#123;    d[j] = c[i];  &#125;  d[j] = &#39;\0&#39;;  int result = strcmp(c, d);  if (result &lt; 0)  &#123;    printf(&quot;%d\n&quot;, -1);  &#125;  else if (result &gt; 0)  &#123;    printf(&quot;%d\n&quot;, 1);  &#125;  else  &#123;    printf(&quot;%d\n&quot;, 0);  &#125;  return 0；&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C 语言标准输入 scanf 在通过 &lt;code&gt;%s&lt;/code&gt; 读取字符串时遇到空格就认为读取结束，这样没办法把一行带有空格的字符串存入到一个字符数组中。所以当需要输入的字符串中含有空格时，我们需要使用 gets 函数进行读取，使用 puts 函数进行输出。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://blog.zhuangzhihao.top/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>Request 和 Response 对象详解</title>
    <link href="http://blog.zhuangzhihao.top/Request&amp;Response/"/>
    <id>http://blog.zhuangzhihao.top/Request&amp;Response/</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-05-16T05:49:06.035Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java Web 核心第二章。在 Java Servlet 中，Request 对象是用来封装请求数据的对象，Response 对象是用来封装响应数据的对象。Web 服务器收到客户端的 HTTP 请求，会针对每一次请求分别创建一个用于代表请求的 Request 对象和代表响应的 Response 对象。</p></blockquote><a id="more"></a><h3 id="一、Request-和-Response-对象的使用"><a href="#一、Request-和-Response-对象的使用" class="headerlink" title="一、Request 和 Response 对象的使用"></a>一、Request 和 Response 对象的使用</h3><p>Request 和 Response 这两个参数的作用是什么?</p><p>Request：获取请求数据</p><ul><li>浏览器会发送 HTTP 请求到后台服务器（Tomcat）。</li><li>HTTP 的请求中会包含很多请求数据（请求行 + 请求头 + 请求体）。</li><li>后台服务器会对 HTTP 请求中的数据进行解析并把解析结果存入到一个对象中。</li><li>所存入的对象即为 Request 对象，所以我们可以从 Request 对象中获取请求的相关参数。</li><li>获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务。</li></ul><p>Response：设置响应数据</p><ul><li>业务处理完后，后台就需要给前端返回业务处理的结果，即响应数据。</li><li>把响应数据封装到 Response 对象中。</li><li>后台服务器（Tomcat）会解析 Response 对象，按照（响应行 + 响应头 + 响应体）格式拼接结果。</li><li>浏览器最终解析结果，把内容展示在浏览器给用户浏览。</li></ul><p>初步体验下 Request 和 Response 对象的使用案例。</p><pre><code class="java">@WebServlet(&quot;/demo3&quot;)public class ServletDemo3 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //使用request对象 获取请求数据        String name = request.getParameter(&quot;name&quot;);//url?name=zhangsan        //使用response对象 设置响应数据        response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);        response.getWriter().write(&quot;&lt;h1&gt;&quot;+name+&quot;,欢迎您！&lt;/h1&gt;&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;Post...&quot;);    &#125;&#125;</code></pre><h3 id="二、Request-对象"><a href="#二、Request-对象" class="headerlink" title="二、Request 对象"></a>二、Request 对象</h3><h4 id="Request-继承体系"><a href="#Request-继承体系" class="headerlink" title="Request 继承体系"></a>Request 继承体系</h4><p>当我们的 Servlet 类实现的是 Servlet 接口的时候，service 方法中的参数是 ServletRequest 和 ServletResponse，当我们的 Servlet 类继承的是 HttpServlet 类的时候，doGet 和 doPost 方法中的参数就变成 HttpServletRequest 和 HttpServletReponse。</p><p>Request 的继承体系：</p><pre><code class="mermaid">graph BTRequestFacade --&gt; HttpServletRequest --&gt; ServletRequest</code></pre><p>ServletRequest 和 HttpServletRequest 是继承关系，并且两个都是接口，接口是无法创建对象，需要用到 RequestFacade：该类实现了 HttpServletRequest 接口，也间接实现了ServletRequest接口。Servlet 类中的 service 方法、doGet 方法或者是 doPost 方法最终都是由 Web 服务器来调用的，所以 Tomcat 提供了方法参数接口的具体实现类，并完成了对象的创建。</p><p>要想了解 RequestFacade 中都提供了哪些方法，我们可以直接查看 JavaEE API 文档中关于 ServletRequest 和 HttpServletRequest 的接口文档，因为 RequestFacade 实现了其接口就需要重写接口中的方法。</p><pre><code class="java">@WebServlet(&quot;/demo2&quot;)public class ServletDemo2 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(request);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    &#125;&#125;</code></pre><h4 id="Request-获取请求数据"><a href="#Request-获取请求数据" class="headerlink" title="Request 获取请求数据"></a>Request 获取请求数据</h4><p>获取请求行数据：请求行包含三块内容，分别是 <code>请求方式</code>、<code>请求资源路径</code>、<code>HTTP协议及版本</code>。</p><pre><code class="java">@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // String getMethod()：获取请求方式： GET        String method = req.getMethod();        System.out.println(method);//GET        // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo        String contextPath = req.getContextPath();        System.out.println(contextPath);        // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1        StringBuffer url = req.getRequestURL();        System.out.println(url.toString());        // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1        String uri = req.getRequestURI();        System.out.println(uri);        // String getQueryString()：获取请求参数（GET方式）： username=zhangsan        String queryString = req.getQueryString();        System.out.println(queryString);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;&#125;</code></pre><p>获取请求头数据：请求头的数据格式为 <code>key: value</code>。</p><pre><code class="java">@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //获取请求头: user-agent: 浏览器的版本信息        String agent = req.getHeader(&quot;user-agent&quot;);        System.out.println(agent);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;&#125;</code></pre><p>获取请求体数据：浏览器在发送 GET 请求的时候是没有请求体的，所以需要把请求方式变更为 POST。</p><ol><li><p>  如果前端发送的是字节数据，比如传递的是文件数据，则使用 <code>getInputStream()</code> 方法获取字节输入流。</p></li><li><p>  如果前端发送的是纯文本数据，则使用 <code>getReader()</code> 方法获取字符输入流。</p></li></ol><pre><code class="java">@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;         //获取post 请求体：请求参数        //1. 获取字符输入流        BufferedReader br = req.getReader();        //2. 读取数据        String line = br.readLine();        System.out.println(line);    &#125;&#125;</code></pre><p>BufferedReader 流是通过 request 对象来获取的，当请求完成后 request 对象就会被销毁，request 对象被销毁后，BufferedReader 流就会自动关闭，所以此处就不需要手动关闭流了。</p><h4 id="获取请求参数的通用方式"><a href="#获取请求参数的通用方式" class="headerlink" title="获取请求参数的通用方式"></a>获取请求参数的通用方式</h4><p>请求参数是请求数据中的部分内容（如：用户名和密码），请求数据则是包含请求行、请求头和请求体的所有数据，如果是 GET 请求，请求参数在请求行中，如果是 POST 请求，请求参数一般在请求体中。</p><ol><li><p>  GET 方式获取请求参数：<code>String getQueryString()</code></p></li><li><p>  POST 方式获取请求参数：<code>BufferedReader getReader();</code></p></li></ol><pre><code class="java">@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;                //GET 方式获取请求参数        String result = req.getQueryString();        System.out.println(result);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // POST 方式获取请求参数          BufferedReader br = req.getReader();        String result = br.readLine();        System.out.println(result);    &#125;&#125;</code></pre><p>GET 请求方式和 POST 请求方式区别主要在于获取请求参数的方式不一样，为了统一获取请求参数，Request 对象为我们提供了如下方法：</p><ol><li><p>  获取所有参数Map集合：<code>Map&lt;String,String[]&gt; getParameterMap()</code></p></li><li><p>  根据名称获取参数值（数组）：<code>String[] getParameterValues(String name)</code></p></li><li><p>  根据名称获取参数值（单个值）：<code>String getParameter(String name)</code></p></li></ol><pre><code class="java">/** * request 通用方式获取请求参数 */@WebServlet(&quot;/req2&quot;)public class RequestDemo2 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //GET请求逻辑        System.out.println(&quot;get....&quot;);        //1. 获取所有参数的Map集合        Map&lt;String, String[]&gt; map = req.getParameterMap();        for (String key : map.keySet()) &#123;            // username:zhangsan lisi            System.out.print(key+&quot;:&quot;);            //获取值            String[] values = map.get(key);            for (String value : values) &#123;                System.out.print(value + &quot; &quot;);            &#125;            System.out.println();        &#125;        //2. 获取GET请求参数中的爱好，结果是数组值        System.out.println(&quot;------------&quot;);        String[] hobbies = req.getParameterValues(&quot;hobby&quot;);        for (String hobby : hobbies) &#123;            System.out.println(hobby);        &#125;          //3. 获取GET请求参数中的用户名和密码，结果是单个值        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);        System.out.println(username);        System.out.println(password);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;&#125;</code></pre><p><code>req.getParameter()</code> 方法使用的频率会比较高，以后我们再写代码的时候，就只需要按照如下格式来编写：</p><pre><code class="java">public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;       //采用request提供的获取请求参数的通用方式来获取请求参数       //编写其他的业务代码...    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        this.doGet(req,resp);    &#125;&#125;</code></pre><h4 id="请求参数中文乱码问题"><a href="#请求参数中文乱码问题" class="headerlink" title="请求参数中文乱码问题"></a>请求参数中文乱码问题</h4><p>POST 的请求参数是通过 request 的 <code>getReader()</code> 来获取流中的数据，Tomcat 在获取流的时候采用的编码是ISO-8859-1（不支持中文），需要通过 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code> 把 Tomcat 在获取流数据之前的编码设置为UTF-8。</p><pre><code class="java">@WebServlet(&quot;/req4&quot;)public class RequestDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 解决乱码: POST getReader()        //设置字符输入流的编码，设置的字符集要和页面保持一致        request.setCharacterEncoding(&quot;UTF-8&quot;);       //2. 获取username       String username = request.getParameter(&quot;username&quot;);       System.out.println(username);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>GET 请求获取请求参数的方式是 <code>request.getQueryString()</code>，并没有通过流的方式获取数据，所以 GET 请求不能用设置编码的方式来解决中文乱码问题。</p><p>GET 请求中文参数出现乱码的原因，是浏览器把中文参数按照  <code>UTF-8</code>  进行 URL 编码，而后台的 Tomcat 对获取到的内容进行 <code>ISO-8859-1</code> 的 URL 解码，我们可以按照 ISO-8859-1 编码获取乱码对应的字节数组，再按照 UTF-8 编码获取字节数组对应的字符串，在转换的过程中它们的编码一致，就可以解决中文乱码问题。</p><p>URL编码实现方式:</p><ul><li><p>编码：<code>URLEncoder.encode(str,&quot;UTF-8&quot;);</code></p></li><li><p>解码：<code>URLDecoder.decode(s,&quot;ISO-8859-1&quot;);</code></p></li></ul><pre><code class="java">public class URLDemo &#123;  public static void main(String[] args) throws UnsupportedEncodingException &#123;        String username = &quot;张三&quot;;        //1. URL编码        String encode = URLEncoder.encode(username, &quot;utf-8&quot;);        System.out.println(encode);        //2. URL解码        String decode = URLDecoder.decode(encode, &quot;ISO-8859-1&quot;);        System.out.println(decode); //此处打印的是对应的乱码数据        //3. 转换为字节数据,编码        byte[] bytes = decode.getBytes(&quot;ISO-8859-1&quot;);        for (byte b : bytes) &#123;            System.out.print(b + &quot; &quot;);        &#125;        //此处打印的是:-27 -68 -96 -28 -72 -119        //4. 将字节数组转为字符串，解码        String s = new String(bytes, &quot;utf-8&quot;);        System.out.println(s); //此处打印的是张三    &#125;&#125;</code></pre><p>通用中文乱码解决方案：先解码，再编码。</p><pre><code class="java">@WebServlet(&quot;/req4&quot;)public class RequestDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 解决乱码：POST，getReader()        //request.setCharacterEncoding(&quot;UTF-8&quot;);//设置字符输入流的编码        //2. 获取username        String username = request.getParameter(&quot;username&quot;);        System.out.println(&quot;解决乱码前：&quot;+username);        //3. GET,获取参数的方式：getQueryString        // 乱码原因：tomcat进行URL解码，默认的字符集ISO-8859-1       /* //3.1 先对乱码数据进行编码：转为字节数组        byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1);        //3.2 字节数组解码        username = new String(bytes, StandardCharsets.UTF_8);*/        username  = new String(username.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);        System.out.println(&quot;解决乱码后：&quot;+username);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>把 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code> 代码注释掉后，会发现 GET 请求参数乱码解决方案同时也可也把 POST 请求参数乱码的问题也解决了，只不过对于 POST 请求参数一般都会比较多，采用这种方式解决乱码起来比较麻烦，所以对于 POST 请求还是建议使用设置编码的方式进行。</p><p>Tomcat 8.0 之后的版本已将 GET 请求乱码问题解决，设置默认的解码方式为 UTF-8。</p><h4 id="Request-请求转发"><a href="#Request-请求转发" class="headerlink" title="Request 请求转发"></a>Request 请求转发</h4><p>请求转发（forward）是一种在服务器内部的资源跳转方式。</p><p>请求转发的实现方式：<code>req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);</code>。</p><pre><code class="java">@WebServlet(&quot;/req5&quot;)public class RequestDemo5 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;demo5...&quot;);        //请求转发        request.getRequestDispatcher(&quot;/req6&quot;).forward(request,response);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>请求转发资源间共享数据：使用 Request 对象。</p><ol><li><p>  存储数据到 request 域中：<code>void setAttribute(String name,Object o);</code></p></li><li><p>  根据 key 获取值：<code>Object getAttribute(String name);</code></p></li><li><p>  根据 key 删除该键值对：<code>void removeAttribute(String name);</code></p></li></ol><pre><code class="java">@WebServlet(&quot;/req5&quot;)public class RequestDemo5 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;demo5...&quot;);        //存储数据        request.setAttribute(&quot;msg&quot;,&quot;hello&quot;);        //请求转发        request.getRequestDispatcher(&quot;/req6&quot;).forward(request,response);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;@WebServlet(&quot;/req6&quot;)public class RequestDemo6 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;demo6...&quot;);        //获取数据        Object msg = request.getAttribute(&quot;msg&quot;);        System.out.println(msg);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>请求转发的特点：浏览器地址栏路径不发生变化，只能转发到当前服务器的内部资源，而不能从一个服务器通过转发访问另一台服务器。一次请求可以在转发资源间使用 request 共享数据。</p><h3 id="三、Response-对象"><a href="#三、Response-对象" class="headerlink" title="三、Response 对象"></a>三、Response 对象</h3><p>Reponse 的继承体系和 Request 的继承体系非常相似</p><p>Servlet -&gt; <code>service(request, response)</code></p><pre><code class="mermaid">graph BTReponseFacade --&gt; HttpServletReponse --&gt; ServletReponse</code></pre><h4 id="Response-设置响应数据"><a href="#Response-设置响应数据" class="headerlink" title="Response 设置响应数据"></a>Response 设置响应数据</h4><p>HTTP响应数据总共分为三部分内容，分别是响应行、响应头、响应体，对于这三部分内容的数据，respone 对象都提供了哪些方法来进行设置?</p><p>对于响应头，比较常用的就是设置响应状态码：<code>void setStatus(int sc);</code>。</p><p>设置响应头键值对：<code>void setHeader(String name,String value);</code>。</p><p>对于响应体，是通过字符、字节输出流的方式往浏览器写，获取字符输出流：<code>PrintWriter getWriter();</code>，或获取字节输出流：<code>ServletOutputStream getOutputStream();</code>。</p><p>介绍完这些方法后，后面我们会通过案例把这些方法都用一用，首先先来完成下重定向的功能开发。</p><h4 id="Respones-请求重定向"><a href="#Respones-请求重定向" class="headerlink" title="Respones 请求重定向"></a>Respones 请求重定向</h4><p>Response 重定向（redirect）是一种资源跳转方式。浏览器发送请求给服务器，服务器中对应的资源 A 接收到请求。当资源 A 现在无法处理该请求，就会给浏览器响应一个 302 的状态码 + location 的一个访问资源 B 的路径。浏览器接收到响应状态码为 302 就会重新发送请求到 location 对应的访问地址去访问资源 B。资源 B 接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向。</p><p>重定向的实现方式：</p><pre><code class="http">resp.setStatus(302);resp.setHeader(&quot;location&quot;,&quot;资源B的访问路径&quot;);</code></pre><ol><li>  具体使用，我们先创建 ResponseDemo1 类</li></ol><pre><code class="java">@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><ol start="2"><li>  创建 ResponseDemo2 类</li></ol><pre><code class="java">@WebServlet(&quot;/resp2&quot;)public class ResponseDemo2 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp2....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><ol start="3"><li>  在 ResponseDemo1 的 doGet 方法中给前端响应数据</li></ol><pre><code class="java">@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);        //重定向        //1.设置响应状态码 302        response.setStatus(302);        //2. 设置响应头 Location        response.setHeader(&quot;Location&quot;,&quot;/request-demo/resp2&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><ol start="4"><li>  虽然功能已经实现，但是从设置重定向的两行代码来看，会发现除了重定向的地址不一样，其他的内容都是一模一样，所以request对象给我们提供了简化的编写方式为：<code>resposne.sendRedirect(&quot;/request-demo/resp2&quot;)</code>。</li></ol><pre><code class="java">@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);        //重定向        resposne.sendRedirect(&quot;/request-demo/resp2&quot;)；    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>重定向的特点</p><ul><li><p>浏览器地址栏路径发送变化：当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化。</p></li><li><p>可以重定向到任何位置的资源(服务内容、外部均可)，因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。</p></li><li><p>两次请求，不能在多个资源使用 request 共享数据，因为浏览器发送了两次请求，是两个不同的 request 对象，就无法通过 request 对象进行共享数据</p></li></ul><h4 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h4><ol><li><p>转发的时候路径上没有加 <code>/request-demo</code> 而重定向加了，因为对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录。对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。</p></li><li><p>在重定向的代码中，<code>/request-demo</code> 是固定编码的，如果后期通过 Tomcat 插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，因此我们可以在代码中动态去获取项目访问的虚拟目录进行优化，具体可以借助 request 对象 <code>getContextPath() </code>方法，修改后的代码如下：</p></li></ol><pre><code class="java">@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);        //简化方式完成重定向        //动态获取虚拟目录        String contextPath = request.getContextPath();        response.sendRedirect(contextPath+&quot;/resp2&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>重新启动访问测试，功能依然能够实现，此时就可以动态获取项目访问的虚拟路径，从而降低代码的耦合度。</p><h4 id="Response-响应字符数据"><a href="#Response-响应字符数据" class="headerlink" title="Response 响应字符数据"></a>Response 响应字符数据</h4><p>要想将字符数据写回到浏览器，我们需要两个步骤：首先通过 Response 对象获取字符输出流（<code>PrintWriter writer = resp.getWriter();</code>），再通过字符输出流写数据（<code>writer.write(&quot;aaa&quot;);</code>）</p><ol><li>返回一个简单的字符串 <code>aaa</code>。</li></ol><pre><code class="java">/** * 响应字符数据：设置字符数据的响应体 */@WebServlet(&quot;/resp3&quot;)public class ResponseDemo3 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        //1. 获取字符输出流        PrintWriter writer = response.getWriter();         writer.write(&quot;aaa&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><ol start="2"><li>返回一串 html 字符串，并且能被浏览器解析。</li></ol><pre><code class="java">PrintWriter writer = response.getWriter();//content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签response.setHeader(&quot;content-type&quot;,&quot;text/html&quot;);writer.write(&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;);//一次请求响应结束后，response 对象就会被销毁掉，所以不要手动关闭流。</code></pre><ol start="3"><li>返回一个中文的字符串 <code>你好</code>，需要注意设置响应数据的编码为 <code>utf-8</code></li></ol><pre><code class="java">//设置响应的数据格式及数据的编码response.setContentType(&quot;text/html;charset=utf-8&quot;);writer.write(&quot;你好&quot;);</code></pre><h4 id="Response-响应字节数据"><a href="#Response-响应字节数据" class="headerlink" title="Response 响应字节数据"></a>Response 响应字节数据</h4><p>要想将字节数据写回到浏览器，我们需要两个步骤：首先通过Response对象获取字节输出流（<code>ServletOutputStream outputStream = resp.getOutputStream();</code>），再通过字节输出流写数据（<code>outputStream.write(字节数据);</code>）。</p><p>响应字符数据的实际应用：</p><ol><li>返回一个图片文件到浏览器</li></ol><pre><code class="java">/** * 响应字节数据：设置字节数据的响应体 */@WebServlet(&quot;/resp4&quot;)public class ResponseDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 读取文件        FileInputStream fis = new FileInputStream(&quot;d://a.jpg&quot;);        //2. 获取response字节输出流        ServletOutputStream os = response.getOutputStream();        //3. 完成流的copy        byte[] buff = new byte[1024];        int len = 0;        while ((len = fis.read(buff))!= -1)&#123;            os.write(buff,0,len);        &#125;        fis.close();    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>上述代码中，对于流的 copy 的代码还是比较复杂的，所以我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是：</p><ol><li>  pom.xml 添加依赖</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>  调用工具类方法</li></ol><pre><code class="java">//fis:输入流//os:输出流IOUtils.copy(fis,os);</code></pre><p>优化后的代码：</p><pre><code class="java">/** * 响应字节数据：设置字节数据的响应体 */@WebServlet(&quot;/resp4&quot;)public class ResponseDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 读取文件        FileInputStream fis = new FileInputStream(&quot;d://a.jpg&quot;);        //2. 获取response字节输出流        ServletOutputStream os = response.getOutputStream();        //3. 完成流的copy          IOUtils.copy(fis,os);        fis.close();    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java Web 核心第二章。在 Java Servlet 中，Request 对象是用来封装请求数据的对象，Response 对象是用来封装响应数据的对象。Web 服务器收到客户端的 HTTP 请求，会针对每一次请求分别创建一个用于代表请求的 Request 对象和代表响应的 Response 对象。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="Servlet" scheme="http://blog.zhuangzhihao.top/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议和 Servlet</title>
    <link href="http://blog.zhuangzhihao.top/HTTP&amp;Servlet/"/>
    <id>http://blog.zhuangzhihao.top/HTTP&amp;Servlet/</id>
    <published>2022-04-04T16:00:00.000Z</published>
    <updated>2022-05-16T05:49:21.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java Web 核心第一章。Java Web 是用 Java 技术来解决相关 web 互联网领域的技术栈，国内很多大型网站公司也是首选 Java 语言来解决 web 互联网相关的问题。要了解 Java Web 开发的技术栈，首先需要理解 HTTP 协议和 HTTP 请求与响应数据的格式，理解 Servlet 的执行流程和生命周期，掌握 Servlet 的使用和相关配置。</p></blockquote><a id="more"></a><h3 id="一、HTTP-协议"><a href="#一、HTTP-协议" class="headerlink" title="一、HTTP 协议"></a>一、HTTP 协议</h3><p>HyperText Transfer Protocol（超文本传输协议）规定了浏览器和服务器之间数据传输的规则。数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。</p><p>HTTP 协议是基于 TCP 的协议，TCP 是一种面向连接的（建立连接前是需经过三次握手）、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。</p><p>HTTP 同样也是基于请求—响应模型的，一次请求对应一次响应，请求和响应是一一对应关系。</p><p>HTTP 协议是无状态协议，对于事物处理没有记忆能力，每次请求—响应都是独立的。无状态指的是客户端发送 HTTP 请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点，缺点是多次请求间不能共享数据，但速度快。</p><p>请求之间无法共享数据会引发的问题，如电商网站加入购物车和去购物车结算是两次请求，加入购物车请求响应结束后，并未记录加入购物车是何商品，发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据，在 Java Web 中要使用会话技术（Cookie、Session）来解决这个问题。</p><h4 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a>请求数据格式</h4><p>HTTP 请求数据总共分为三部分内容，分别是请求行、请求头、请求体，请求方式有七种，最常用的是 GET 和 POST 方法。</p><p>请求行是 HTTP 请求中的第一行数据，请求行包含三块内容，分别是 <code>[请求方式] /[请求URL路径] / [HTTP协议及版本]</code>。</p><pre><code class="http">GET / HTTP/1.1</code></pre><p>请求头从第二行开始，格式均为 <code>key: value</code> 形式，请求头中会包含若干个属性。</p><pre><code class="HTTP">Host: 请求的主机名User-Agent: 浏览器版本, Mozilla/5.0 Chrome/79Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等</code></pre><p>服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，比如浏览器兼容问题。</p><p>请求体是 POST 请求的最后一部分，存储请求参数，请求体和请求头之间是有一个空行隔开。</p><pre><code class="http">username=bezhuang@password=1234</code></pre><p>GET 和 POST 两个请求的区别：GET 请求请求参数在请求行中，没有请求体，POST 请求请求参数在请求体中，GET 请求请求参数大小有限制，POST 没有。</p><h4 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h4><p>响应数据总共分为三部分内容，分别是响应行、响应头、响应体。</p><p>响应行是响应数据的第一行，响应行包含三块内容，分别是 <code>[HTTP协议及版本] [响应状态码] [状态码的描述]</code>。</p><pre><code class="http">HTTP/1.1 200 OK</code></pre><p>响应状态码</p><ul><li>200  ok 客户端请求成功</li><li>404  Not Found 请求资源不存在</li><li>500 Internal Server Error 服务端发生不可预期的错误</li></ul><p>响应头从第二行开始，格式也为 <code>key：value</code> 形式，响应头中会包含若干个属性。</p><pre><code class="http">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；Content-Length：表示该响应内容的长度（字节数）；Content-Encoding：表示该响应压缩算法，例如gzip；Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒</code></pre><p>响应体是最后一部分，存放响应数据，<code>&lt;html&gt;数据内容&lt;/html&gt;</code>。</p><h4 id="自定义服务器"><a href="#自定义服务器" class="headerlink" title="自定义服务器"></a>自定义服务器</h4><p>可以使用 Java 编写服务器，用来接受页面发送的请求和响应数据给前端浏览器，主要使用到的是 <code>ServerSocket</code> 和 <code>Socket</code>。</p><pre><code class="java">package com.itheima;import sun.misc.IOUtils;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.nio.charset.StandardCharsets;import java.nio.file.Files;public class Server &#123;    public static void main(String[] args) throws IOException &#123;        ServerSocket ss = new ServerSocket(8080); // 监听指定端口        System.out.println(&quot;server is running...&quot;);        while (true)&#123;            Socket sock = ss.accept();            System.out.println(&quot;connected from &quot; + sock.getRemoteSocketAddress());            Thread t = new Handler(sock);            t.start();        &#125;    &#125;&#125;class Handler extends Thread &#123;    Socket sock;    public Handler(Socket sock) &#123;        this.sock = sock;    &#125;    public void run() &#123;        try (InputStream input = this.sock.getInputStream()) &#123;            try (OutputStream output = this.sock.getOutputStream()) &#123;                handle(input, output);            &#125;        &#125; catch (Exception e) &#123;            try &#123;                this.sock.close();            &#125; catch (IOException ioe) &#123;            &#125;            System.out.println(&quot;client disconnected.&quot;);        &#125;    &#125;    private void handle(InputStream input, OutputStream output) throws IOException &#123;        BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));        // 读取HTTP请求:        boolean requestOk = false;        String first = reader.readLine();        if (first.startsWith(&quot;GET / HTTP/1.&quot;)) &#123;            requestOk = true;        &#125;        for (;;) &#123;            String header = reader.readLine();            if (header.isEmpty()) &#123; // 读取到空行时, HTTP Header读取完毕                break;            &#125;            System.out.println(header);        &#125;        System.out.println(requestOk ? &quot;Response OK&quot; : &quot;Response Error&quot;);        if (!requestOk) &#123;            // 发送错误响应:            writer.write(&quot;HTTP/1.0 404 Not Found\r\n&quot;);            writer.write(&quot;Content-Length: 0\r\n&quot;);            writer.write(&quot;\r\n&quot;);            writer.flush();        &#125; else &#123;            // 发送成功响应:            //读取html文件，转换为字符串            BufferedReader br = new BufferedReader(new FileReader(&quot;http/html/a.html&quot;));            StringBuilder data = new StringBuilder();            String line = null;            while ((line = br.readLine()) != null)&#123;                data.append(line);            &#125;            br.close();            int length = data.toString().getBytes(StandardCharsets.UTF_8).length;            writer.write(&quot;HTTP/1.1 200 OK\r\n&quot;);            writer.write(&quot;Connection: keep-alive\r\n&quot;);            writer.write(&quot;Content-Type: text/html\r\n&quot;);            writer.write(&quot;Content-Length: &quot; + length + &quot;\r\n&quot;);            writer.write(&quot;\r\n&quot;); // 空行标识Header和Body的分隔            writer.write(data.toString());            writer.flush();        &#125;    &#125;&#125;</code></pre><h3 id="二、Tomcat-服务器"><a href="#二、Tomcat-服务器" class="headerlink" title="二、Tomcat 服务器"></a>二、Tomcat 服务器</h3><p>Web 服务器是一个安装在服务器端的对 HTTP 协议的操作进行封装的应用程序，使得程序员不必直接对协议进行操作，让 Web 开发更加便捷，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><p>Tomcat 是 Apache 软件基金会一个核心项目，是一个开源免费的轻量级 Web 服务器，支持 Servlet/JSP 少量 JavaEE 规范。JavaEE 规范是指 Java 企业级开发的技术规范总和。因为 Tomcat 支持 Servlet/JSP 规范，所以 Tomcat 也被称为Web容器、Servlet容器。Servlet需要依赖 Tomcat 才能运行。</p><p>使用 Maven 工具能更加简单快捷的把 Web 项目给创建出来，创建方式有两种：使用骨架和不使用骨架。使用骨架，默认没有 java 和 resources 目录，需要手动完成创建补齐，不使用骨架要在 pom.xml 设置打包方式为 war、补齐 Maven Web 项目缺失 webapp 的目录结构和 WEB-INF/web.xml 的目录结构。</p><p>Maven Web 项目创建成功后，通过 Maven 的 package 命令可以将项目打包成 war 包，将 war 文件拷贝到 Tomcat 的 webapps 目录下，启动 Tomcat 就可以将项目部署成功，然后通过浏览器进行访问即可。</p><p>在 IDEA 中可以直接使用 Maven 中的 Tomcat 插件来部署项目，即在 pom.xml 中添加 Tomcat 插件，再使用 Maven Helper 插件快速启动项目。</p><pre><code class="xml">&lt;build&gt;    &lt;plugins&gt;        &lt;!--Tomcat插件 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;            &lt;configuration&gt;                &lt;port&gt;80&lt;/port&gt;&lt;!--访问端口号 --&gt;                &lt;!--项目访问路径                    未配置访问路径: http://localhost:80/tomcat-demo2/a.html                    配置/后访问路径: http://localhost:80/a.html                    如果配置成 /hello,访问路径会变成什么?                        答案: http://localhost:80/hello/a.html                --&gt;                &lt;path&gt;/&lt;/path&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><h3 id="三、Servlet"><a href="#三、Servlet" class="headerlink" title="三、Servlet"></a>三、Servlet</h3><p>Servlet 是 Java Web 最为核心的内容，它是 Java 提供的一门动态 web 资源开发技术。使用 Servlet 就可以实现根据不同的登录用户在页面上动态显示不同内容。Servlet 是 JavaEE 规范之一，其实就是一个接口，将来我们需要定义 Servlet 类实现 Servlet 接口，并由 web 服务器运行 Servlet。</p><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>编写一个 Servlet 类，并使用 IDEA 中 Tomcat 插件进行部署，最终通过浏览器访问所编写的 Servlet 程序。具体的实现步骤如下：</p><ol><li>创建 Web 项目 <code>web-demo</code>，导入 Servlet 依赖坐标。</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;!--      此处为什么需要添加该标签?      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错    --&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>创建：定义一个类，实现 Servlet 接口，并重写接口中所有方法，并在 service 方法中输入一句话。</li></ol><pre><code class="java">package com.itheima.web;import javax.servlet.*;import java.io.IOException;public class ServletDemo1 implements Servlet &#123;    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;        System.out.println(&quot;servlet hello world~&quot;);    &#125;    public void init(ServletConfig servletConfig) throws ServletException &#123;    &#125;    public ServletConfig getServletConfig() &#123;        return null;    &#125;    public String getServletInfo() &#123;        return null;    &#125;    public void destroy() &#123;    &#125;&#125;</code></pre><ol start="3"><li>配置：在类上使用 <code>@WebServlet</code> 注解，配置该 Servlet 的访问路径。</li></ol><pre><code class="java">@WebServlet(&quot;/demo1&quot;)</code></pre><ol start="4"><li>访问：启动 Tomcat，浏览器中输入 URL 地址访问该 Servlet。</li></ol><pre><code class="http">http://localhost:8080/web-demo/demo1</code></pre><ol start="5"><li>通过浏览器访问后，在控制台会打印 <code>servlet hello world~</code> ，说明 servlet 程序已经成功运行。</li></ol><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>Servlet 的执行流程：浏览器发出 <code>http://localhost:8080/web-demo/demo1</code> 请求，从请求中可以解析出三部分内容，分别是 <code>localhost:8080</code>、<code>web-demo</code>、<code>demo1</code>，根据 <code>localhost:8080</code> 可以找到要访问的 Tomcat Web 服务器，根据 <code>web-demo</code> 可以找到部署在 Tomcat 服务器上的 web-demo 项目，根据 <code>demo1</code> 可以找到要访问的是项目中的哪个 Servlet 类，根据 <code>@WebServlet</code> 后面的值进行匹配。</p><p>找到 ServletDemo1 这个类后，Tomcat Web 服务器就会为 ServletDemo1 这个类创建一个对象，然后调用对象中的 service 方法。</p><p>ServletDemo1 实现了 Servlet 接口，所以类中必然会重写 service 方法供 Tomcat Web 服务器进行调用，service 方法中 ServletRequest 和 ServletResponse 两个参数，ServletRequest 封装的是请求数据，ServletResponse 封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互。</p><p>Servlet 由 web 服务器创建，Servlet 方法由 web 服务器调用。</p><p>因为我们自定义的 Servlet 必须实现 Servlet 接口并复写其方法，而 Servlet 接口中有 service 方法，因此服务器知道 Servlet 中一定有 service 方法。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>对象的生命周期指一个对象从被创建到被销毁的整个过程。</p><p>Servlet 运行在 Servlet 容器（web 服务器）中，其生命周期由容器来管理，分为 4 个阶段：</p><ol><li>加载和实例化：默认情况下，当 Servlet 第一次被访问时，由容器创建 Servlet 对象，，但是如果创建 Servlet 比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们可以把 Servlet 的创建放到服务器启动的时候来创建。</li></ol><pre><code class="java">@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)/*loadOnstartup的取值有两类情况    （1）负整数:第一次访问时创建Servlet对象    （2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高*/</code></pre><ol start="2"><li>初始化：在 Servlet 实例化之后，容器将调用 Servlet 的 <code>init()</code> 方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次。</li><li>请求处理：每次请求 Servlet 时，Servlet 容器都会调用 Servlet 的 <code>service()</code> 方法对请求进行处理</li><li>服务终止：当需要释放内存或者容器关闭时，容器就会调用 Servlet 实例的 <code>destroy()</code> 方法完成资源的释放。在 <code>destroy()</code> 方法调用之后，容器会释放这个 Servlet 实例，该实例随后会被 Java 的垃圾收集器所回收。</li></ol><p>通过案例演示 Servlet 生命周期方法</p><pre><code class="java">package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/*** Servlet生命周期方法*/@WebServlet(urlPatterns = &quot;/demo2&quot;,loadOnStartup = 1)public class ServletDemo2 implements Servlet &#123;    /**     *  初始化方法     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用     *  2.调用次数: 1次     * @param config     * @throws ServletException     */    public void init(ServletConfig config) throws ServletException &#123;        System.out.println(&quot;init...&quot;);    &#125;    /**     * 提供服务     * 1.调用时机:每一次Servlet被访问时，调用     * 2.调用次数: 多次     * @param req     * @param res     * @throws ServletException     * @throws IOException     */    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        System.out.println(&quot;servlet hello world~&quot;);    &#125;    /**     * 销毁方法     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用     * 2.调用次数: 1次     */    public void destroy() &#123;        System.out.println(&quot;destroy...&quot;);    &#125;    public ServletConfig getServletConfig() &#123;        return null;    &#125;    public String getServletInfo() &#123;        return null;    &#125;&#125;</code></pre><p>Servlet 对象默认是第一次访问的时候被创建，可以使用 <code>@WebServlet(urlPatterns = &quot;/demo2&quot;,loadOnStartup = 1)</code> 的 loadOnStartup 修改成在服务器启动的时候创建。</p><p>Servlet 生命周期中涉及到三个方法，分别是 <code>init()</code>、<code>service()</code>、<code>destroy()</code>，<code>init</code> 方法在 Servlet 对象被创建的时候执行，只执行 1 次，service 方法在 Servlet 被访问的时候调用，每访问 1 次就调用 1 次，destroy 方法在 Servlet 对象被销毁的时候调用，只执行 1 次。</p><h4 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h4><p>Servlet 中总共有5个方法，我们已经介绍过其中的三个，剩下的两个方法为 <code>getServletInfo()</code> 和 <code>getServletConfig() </code>。</p><ol><li>初始化方法，在 Servlet 被创建时执行，只执行一次。</li></ol><pre><code class="java">void init(ServletConfig config) </code></pre><ol start="2"><li>提供服务方法， 每次 Servlet 被访问，都会调用该方法。</li></ol><pre><code class="java">void service(ServletRequest req, ServletResponse res)</code></pre><ol start="3"><li>销毁方法，当 Servlet 被销毁时，调用该方法。在内存释放或服务器关闭时销毁 Servlet。</li></ol><pre><code class="java">void destroy() </code></pre><ol start="4"><li>获取 Servlet 信息方法</li></ol><pre><code class="java">String getServletInfo() //该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可public String getServletInfo() &#123;    return &quot;&quot;;&#125;</code></pre><ol start="5"><li>获取 ServletConfig 对象方法</li></ol><pre><code class="java">ServletConfig getServletConfig()</code></pre><p>ServletConfig 对象在 init 方法的参数中有，而 Tomcat Web 服务器在创建 Servlet 对象的时候会调用 init 方法，必定会传入一个  ServletConfig 对象，我们只需要将服务器传过来的 ServletConfig 进行返回即可。</p><pre><code class="java">package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/** * Servlet方法介绍 */@WebServlet(urlPatterns = &quot;/demo3&quot;,loadOnStartup = 1)public class ServletDemo3 implements Servlet &#123;    private ServletConfig servletConfig;    /**     *  初始化方法     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用     *  2.调用次数: 1次     * @param config     * @throws ServletException     */    public void init(ServletConfig config) throws ServletException &#123;        this.servletConfig = config;        System.out.println(&quot;init...&quot;);    &#125;    public ServletConfig getServletConfig() &#123;        return servletConfig;    &#125;    /**     * 提供服务     * 1.调用时机:每一次Servlet被访问时，调用     * 2.调用次数: 多次     * @param req     * @param res     * @throws ServletException     * @throws IOException     */    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        System.out.println(&quot;servlet hello world~&quot;);    &#125;    /**     * 销毁方法     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用     * 2.调用次数: 1次     */    public void destroy() &#123;        System.out.println(&quot;destroy...&quot;);    &#125;        public String getServletInfo() &#123;        return &quot;&quot;;    &#125;&#125;</code></pre><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>B/S 架构的 web 项目都是针对 HTTP 协议，所以我们自定义 Servlet，会通过继承 HttpServlet，具体的编写格式如下:</p><pre><code class="java">@WebServlet(&quot;/demo4&quot;)public class ServletDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //TODO GET 请求方式处理逻辑        System.out.println(&quot;get...&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //TODO Post 请求方式处理逻辑        System.out.println(&quot;post...&quot;);    &#125;&#125;</code></pre><p>要想发送一个 GET 请求，请求该 Servlet，只需要通过浏览器发送 <code>http://localhost:8080/web-demo/demo4</code>，就能看到 doGet 方法被执行了。</p><p>要想发送一个 POST 请求，请求该 Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个 form 表单来发送请求，在 webapp 下创建一个 <code>a.html</code> 页面，启动测试，即可看到 doPost 方法被执行了。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/web-demo/demo4&quot; method=&quot;post&quot;&gt;        &lt;input name=&quot;username&quot;/&gt;&lt;input type=&quot;submit&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>因为前端发送 GET 和 POST 请求的时候，参数的位置不一致，GET 请求参数在请求行中，POST 请求参数在请求体中，为了能处理不同的请求方式，我们得在 service 方法中进行判断，然后写不同的业务处理。</p><pre><code class="java">package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/demo5&quot;)public class ServletDemo5 implements Servlet &#123;    public void init(ServletConfig config) throws ServletException &#123;    &#125;    public ServletConfig getServletConfig() &#123;        return null;    &#125;    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        //如何调用?        //获取请求方式，根据不同的请求方式进行不同的业务处理        HttpServletRequest request = (HttpServletRequest)req;       //1. 获取请求方式        String method = request.getMethod();        //2. 判断        if(&quot;GET&quot;.equals(method))&#123;            // get方式的处理逻辑        &#125;else if(&quot;POST&quot;.equals(method))&#123;            // post方式的处理逻辑        &#125;    &#125;    public String getServletInfo() &#123;        return null;    &#125;    public void destroy() &#123;    &#125;&#125;</code></pre><p>这样能实现，但是每个 Servlet 类中都将有相似的代码，针对这个问题，我们可以对 Servlet 接口进行继承封装，来简化代码开发。</p><pre><code class="java">package com.itheima.web;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class MyHttpServlet implements Servlet &#123;    public void init(ServletConfig config) throws ServletException &#123;    &#125;    public ServletConfig getServletConfig() &#123;        return null;    &#125;    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        HttpServletRequest request = (HttpServletRequest)req;        //1. 获取请求方式        String method = request.getMethod();        //2. 判断        if(&quot;GET&quot;.equals(method))&#123;            // get方式的处理逻辑            doGet(req,res);        &#125;else if(&quot;POST&quot;.equals(method))&#123;            // post方式的处理逻辑            doPost(req,res);        &#125;    &#125;    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;    protected void doGet(ServletRequest req, ServletResponse res) &#123;    &#125;    public String getServletInfo() &#123;        return null;    &#125;    public void destroy() &#123;    &#125;&#125;</code></pre><p>有了 MyHttpServlet 这个类，以后我们再编写 Servlet 类的时候，只需要继承 MyHttpServlet，重写父类中的 doGet 和 doPost 方法，就可以用来处理 GET 和 POST 请求的业务逻辑。</p><pre><code class="java">@WebServlet(&quot;/demo5&quot;)public class ServletDemo5 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;post...&quot;);    &#125;&#125;</code></pre><p>将来页面发送的是 GET 请求，则会进入到 doGet 方法中进行执行，如果是 POST 请求，则进入到 doPost 方法。这样代码在编写的时候就相对来说更加简单快捷。</p><p>类似 MyHttpServlet 这样的类 Servlet 中已经为我们提供好了，就是 HttpServlet。</p><pre><code class="java">protected void service(HttpServletRequest req, HttpServletResponse resp)        throws ServletException, IOException    &#123;        String method = req.getMethod();        if (method.equals(METHOD_GET)) &#123;            long lastModified = getLastModified(req);            if (lastModified == -1) &#123;                // servlet doesn&#39;t support if-modified-since, no reason                // to go through further expensive logic                doGet(req, resp);            &#125; else &#123;                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);                if (ifModifiedSince &lt; lastModified) &#123;                    // If the servlet mod time is later, call doGet()                    // Round down to the nearest second for a proper compare                    // A ifModifiedSince of -1 will always be less                    maybeSetLastModified(resp, lastModified);                    doGet(req, resp);                &#125; else &#123;                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);                &#125;            &#125;        &#125; else if (method.equals(METHOD_HEAD)) &#123;            long lastModified = getLastModified(req);            maybeSetLastModified(resp, lastModified);            doHead(req, resp);        &#125; else if (method.equals(METHOD_POST)) &#123;            doPost(req, resp);        &#125; else if (method.equals(METHOD_PUT)) &#123;            doPut(req, resp);        &#125; else if (method.equals(METHOD_DELETE)) &#123;            doDelete(req, resp);        &#125; else if (method.equals(METHOD_OPTIONS)) &#123;            doOptions(req,resp);        &#125; else if (method.equals(METHOD_TRACE)) &#123;            doTrace(req,resp);               &#125; else &#123;            //            // Note that this means NO servlet supports whatever            // method was requested, anywhere on this server.            //            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);            Object[] errArgs = new Object[1];            errArgs[0] = method;            errMsg = MessageFormat.format(errMsg, errArgs);            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);        &#125;    &#125;</code></pre><p>HttpServlet 的使用步骤是先继承 HttpServlet，再重写 doGet、doPost 或其他方法。HttpServlet 的原理就是获取请求方式，并根据不同的请求方式，调用不同的 doXxx 方法。</p><h4 id="urlPattern-配置"><a href="#urlPattern-配置" class="headerlink" title="urlPattern 配置"></a>urlPattern 配置</h4><p>Servlet 类编写好后，要想被访问到，就需要配置其访问路径（urlPattern），一个 Servlet，可以配置多个 urlPattern。</p><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/*** urlPattern: 一个 Servlet 可以配置多个访问路径*/@WebServlet(urlPatterns = &#123;&quot;/demo7&quot;,&quot;/demo8&quot;&#125;)public class ServletDemo7 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo7 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125;// 在浏览器上输入 http://localhost:8080/web-demo/demo7, http://localhost:8080/web-demo/demo8 这两个地址都能访问到 ServletDemo7 的 doGet 方法</code></pre><p>urlPattern 总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配，配置的优先级为 精确匹配 &gt; 目录匹配 &gt; 扩展名匹配 &gt; <code>/*</code> &gt; <code>/</code> 。</p><ol><li>精确匹配</li></ol><pre><code class="java">@WebServlet(urlPatterns = &quot;/user/select&quot;)public class ServletDemo8 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo8 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125; //访问路径：http://localhost:8080/web-demo/user/select</code></pre><ol start="2"><li>目录匹配：<code>/*</code></li></ol><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;/user/*&quot;)public class ServletDemo9 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo9 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125; //访问路径：http://localhost:8080/web-demo/user/任意</code></pre><ol start="3"><li>扩展名匹配：<code>*.do</code></li></ol><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;*.do&quot;)public class ServletDemo10 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo10 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125;  //访问路径：http://localhost:8080/web-demo/任意.do</code></pre><ol start="4"><li>任意匹配：<code>/</code> 或 <code>/*</code></li></ol><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;/&quot;)public class ServletDemo11 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo11 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125; //访问路径：http://localhost:8080/demo-web/任意</code></pre><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;/*&quot;)public class ServletDemo12 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo12 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125; // 访问路径：http://localhost:8080/demo-web/任意</code></pre><p>当我们的项目中的 Servlet 配置了 <code>/</code>，会覆盖掉 tomcat 中的 DefaultServlet，当其他的 url-pattern 都匹配不上时都会走这个 Servlet。当我们的项目中配置了 <code>/*</code>，意味着匹配任意访问路径。</p><p>DefaultServlet 是用来处理静态资源，如果配置了 <code>/</code> 会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的 Servlet 类，最终导致静态资源不能被访问。</p><h4 id="XML-配置"><a href="#XML-配置" class="headerlink" title="XML 配置"></a>XML 配置</h4><p>一般情况下 Servlet 使用的是注解配置 <code>@WebServlet</code>，但 3.0 版本前只支持 XML 配置文件的配置方法。对于 XML 的配置步骤有两步：</p><ol><li>编写Servlet类。</li></ol><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;public class ServletDemo13 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo13 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125;</code></pre><ol start="2"><li>在 web.xml 中配置该 Servlet。</li></ol><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--         Servlet 全类名    --&gt;    &lt;servlet&gt;        &lt;!-- servlet的名称，名字任意--&gt;        &lt;servlet-name&gt;demo13&lt;/servlet-name&gt;        &lt;!--servlet的类全名--&gt;        &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;!--         Servlet 访问路径    --&gt;    &lt;servlet-mapping&gt;        &lt;!-- servlet的名称，要和上面的名称一致--&gt;        &lt;servlet-name&gt;demo13&lt;/servlet-name&gt;        &lt;!-- servlet的访问路径--&gt;        &lt;url-pattern&gt;/demo13&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java Web 核心第一章。Java Web 是用 Java 技术来解决相关 web 互联网领域的技术栈，国内很多大型网站公司也是首选 Java 语言来解决 web 互联网相关的问题。要了解 Java Web 开发的技术栈，首先需要理解 HTTP 协议和 HTTP 请求与响应数据的格式，理解 Servlet 的执行流程和生命周期，掌握 Servlet 的使用和相关配置。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="HTTP" scheme="http://blog.zhuangzhihao.top/tags/HTTP/"/>
    
    <category term="Servlet" scheme="http://blog.zhuangzhihao.top/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 基础知识总结</title>
    <link href="http://blog.zhuangzhihao.top/MyBatis%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.zhuangzhihao.top/MyBatis%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-18T16:00:00.000Z</published>
    <updated>2022-05-05T11:47:00.363Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><a id="more"></a><h3 id="一、Mybatis-概述"><a href="#一、Mybatis-概述" class="headerlink" title="一、Mybatis 概述"></a>一、Mybatis 概述</h3><p>MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发。</p><p>MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。</p><p>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a> 。</p><p>持久层：负责将数据到保存到数据库的那一层代码。以后开发我们会将操作数据库的 Java 代码作为持久层。而 Mybatis 就是对 jdbc 代码进行了封装。</p><p>JavaEE三层架构：表现层、业务层、持久层。</p><p>框架：框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。在框架的基础之上构建软件编写更加高效、规范、通用、可扩展。</p><h4 id="JDBC-缺点"><a href="#JDBC-缺点" class="headerlink" title="JDBC 缺点"></a>JDBC 缺点</h4><p>硬编码：注册驱动、获取连接代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要换成其他的关系型数据库的话，要修改源代码。如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。</p><p>操作繁琐：手动设置参数。手动封装结果集。</p><p>使用Mybatis 优化：硬编码可以配置到配置文件，操作繁琐的地方 MyBatis 都自动完成。</p><h4 id="MyBatis-快速入门"><a href="#MyBatis-快速入门" class="headerlink" title="MyBatis 快速入门"></a>MyBatis 快速入门</h4><p>需求：查询 user 表中所有的数据。</p><p>创建 user 表，添加数据。</p><pre><code class="sql">create database mybatis;use mybatis;drop table if exists tb_user;create table tb_user(    id int primary key auto_increment,    username varchar(20),    password varchar(20),    gender char(1),    addr varchar(30));INSERT INTO tb_user VALUES (1, &#39;zhangsan&#39;, &#39;123&#39;, &#39;男&#39;, &#39;北京&#39;);INSERT INTO tb_user VALUES (2, &#39;李四&#39;, &#39;234&#39;, &#39;女&#39;, &#39;天津&#39;);INSERT INTO tb_user VALUES (3, &#39;王五&#39;, &#39;11&#39;, &#39;男&#39;, &#39;西安&#39;);</code></pre><p>创建模块，导入坐标：需要在项目的 resources 目录下创建 logback 的配置文件。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;!--        CONSOLE ：表示当前的日志信息是可以输出到控制台的。    --&gt;    &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;[%level] %blue(%d&#123;HH:mm:ss.SSS&#125;) %cyan([%thread]) %boldGreen(%logger&#123;15&#125;) - %msg %n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;logger name=&quot;com.itheima&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;Console&quot;/&gt;    &lt;/logger&gt;    &lt;!--      level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF     ， 默认debug      &lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个输出位置将会被本日志级别控制。      --&gt;    &lt;root level=&quot;DEBUG&quot;&gt;        &lt;appender-ref ref=&quot;Console&quot;/&gt;    &lt;/root&gt;&lt;/configuration&gt;</code></pre><p>在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标。</p><pre><code class="xml">&lt;dependencies&gt;    &lt;!--mybatis 依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--mysql 驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.46&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--junit 单元测试--&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.13&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- 添加slf4j日志api --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;        &lt;version&gt;1.7.20&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 添加logback-classic依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;        &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 添加logback-core依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;        &lt;artifactId&gt;logback-core&lt;/artifactId&gt;        &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>编写 MyBatis 核心配置文件 – &gt; 替换连接信息 解决硬编码问题。</p><ul><li>  在模块下的 resources 目录下创建 MyBatis 的配置文件 <code>mybatis-config.xml</code>，内容如下：</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.itheima.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--    environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment    --&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!--数据库连接信息--&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;        &lt;environment id=&quot;test&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!--数据库连接信息--&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;       &lt;!--加载sql映射文件--&gt;       &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>编写 SQL 映射文件：统一管理sql语句，解决硬编码问题。</p><ul><li>  在模块的 <code>resources</code> 目录下创建映射配置文件 <code>UserMapper.xml</code>，内容如下：</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt;        select * from tb_user;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>编码</p><ul><li>  在 <code>com.itheima.pojo</code> 包下创建 User类。</li></ul><pre><code class="java">public class User &#123;    private int id;    private String username;    private String password;    private String gender;    private String addr;    //添加 setter 和 getter&#125;</code></pre><ul><li>  在 <code>com.itheima</code> 包下编写 MybatisDemo 测试类。</li></ul><pre><code class="java">public class MyBatisDemo &#123;    public static void main(String[] args) throws IOException &#123;        //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //2. 获取SqlSession对象，用它来执行sql        SqlSession sqlSession = sqlSessionFactory.openSession();        //3. 执行sql        List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;); //参数是一个字符串，该字符串必须是映射配置文件的namespace.id        System.out.println(users);        //4. 释放资源        sqlSession.close();    &#125;&#125;</code></pre><h3 id="二、Mapper-代理开发"><a href="#二、Mapper-代理开发" class="headerlink" title="二、Mapper 代理开发"></a>二、Mapper 代理开发</h3><p>Mapper 代理方式的目的：解决原生方式中的硬编码，简化后期执行SQL。</p><h4 id="使用-Mapper-代理要求"><a href="#使用-Mapper-代理要求" class="headerlink" title="使用 Mapper 代理要求"></a>使用 Mapper 代理要求</h4><ul><li><p>定义与 SQL 映射文件同名的 Mapper 接口，并且将 Mapper 接口和 SQL 映射文件放置在同一目录下。</p></li><li><p>设置 SQL 映射文件的 namespace 属性为 Mapper 接口全限定名。</p></li><li><p>在 Mapper 接口中定义方法，方法名就是 SQL 映射文件中 sql 语句的 id，并保持参数类型和返回值类型一致。</p></li></ul><h4 id="Mapper-代理代码实现"><a href="#Mapper-代理代码实现" class="headerlink" title="Mapper 代理代码实现"></a>Mapper 代理代码实现</h4><p>在 <code>com.itheima.mapper</code> 包下创建 UserMapper接口，代码如下：</p><pre><code class="java">public interface UserMapper &#123;    List&lt;User&gt; selectAll();    User selectById(int id);&#125;</code></pre><p>在 <code>resources</code> 下创建 <code>com/itheima/mapper</code> 目录，并在该目录下创建 UserMapper.xml 映射配置文件：</p><pre><code class="xml">&lt;!--    namespace:名称空间。必须是对应接口的全限定名--&gt;&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt;        select * from tb_user;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>在 <code>com.itheima</code> 包下创建 MybatisDemo2 测试类，代码如下：</p><pre><code class="java">/** * Mybatis 代理开发 */public class MyBatisDemo2 &#123;    public static void main(String[] args) throws IOException &#123;        //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //2. 获取SqlSession对象，用它来执行sql        SqlSession sqlSession = sqlSessionFactory.openSession();        //3. 执行sql        //3.1 获取UserMapper接口的代理对象        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        List&lt;User&gt; users = userMapper.selectAll();        System.out.println(users);        //4. 释放资源        sqlSession.close();    &#125;&#125;</code></pre><p>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。</p><p>也就是将核心配置文件的加载映射配置文件的配置修改为：</p><pre><code class="xml">&lt;mappers&gt;    &lt;!--加载sql映射文件--&gt;    &lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt;    &lt;!--Mapper代理方式--&gt;    &lt;package name=&quot;com.itheima.mapper&quot;/&gt;&lt;/mappers&gt;</code></pre><h3 id="三、MyBatis-核心配置文件"><a href="#三、MyBatis-核心配置文件" class="headerlink" title="三、MyBatis 核心配置文件"></a>三、MyBatis 核心配置文件</h3><h4 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h4><p>在核心配置文件的 <code>environments</code> 标签中其实是可以配置多个 <code>environment</code> ，使用 <code>id</code> 给每段环境起名，在 <code>environments</code> 中使用 <code>default=&#39;环境id&#39;</code> 来指定使用哪儿段配置。一般就配置一个 <code>environment</code> 即可。</p><pre><code class="xml">&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;/&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;!--数据库连接信息--&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;    &lt;environment id=&quot;test&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;/&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;!--数据库连接信息--&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;=</code></pre><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>在映射配置文件中的 <code>resultType</code> 属性需要配置数据封装的类型（类的全限定名）。</p><p>Mybatis 提供了 <code>类型别名</code>(typeAliases) 可以简化这部分的书写。</p><p>首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。</p><pre><code class="xml">&lt;typeAliases&gt;    &lt;!--name属性的值是实体类所在包--&gt;    &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt;</code></pre><p>通过上述的配置，我们就可以简化映射配置文件中 <code>resultType</code> 属性值的编写。</p><pre><code class="xml">&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt;        select * from tb_user;    &lt;/select&gt;&lt;/mapper&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="MyBatis" scheme="http://blog.zhuangzhihao.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Maven 项目管理知识总结</title>
    <link href="http://blog.zhuangzhihao.top/Maven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.zhuangzhihao.top/Maven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-13T16:00:00.000Z</published>
    <updated>2022-05-23T09:47:21.043Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Maven 是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理，也可被用于构建和管理其他语言编写的各种项目，例如 C#，Ruby，Scala。</p></blockquote><a id="more"></a><h3 id="一、Maven-概述"><a href="#一、Maven-概述" class="headerlink" title="一、Maven 概述"></a>一、Maven 概述</h3><p>Maven 是专门用于管理和构建 Java 项目的工具，它提供了一套标准化的项目结构，提供了一套标准化的构建流程（编译，测试，打包，发布……），提供了一套依赖管理机制。</p><p>标准化的项目结构：每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。在 Eclipse 中创建的目录，无法在 IDEA 中进行使用，这就造成了很大的不方便，而 Maven 提供了一套标准化的项目结构，所有的 IDE 使用 Maven 构建的项目完全一样，所以 IDE 创建的 Maven 项目可以通用。</p><p>标准化的构建流程：开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而 Maven 提供了一套简单的命令来完成项目构建。</p><p>依赖管理：管理你项目所依赖的第三方资源（jar包、插件），而 Maven 使用标准的坐标配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。</p><p>Maven 模型：</p><ol><li>  项目对象模型（Project Object Model）：将我们自己抽象成一个对象模型，有自己专属的坐标。</li></ol><pre><code class="xml">&lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;artifactId&gt;maven&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code></pre><ol start="2"><li>  依赖管理模型（Dependency）：使用坐标来描述当前项目依赖哪儿些第三方jar包。</li></ol><pre><code class="xml">&lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.32&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>Maven 仓库</p><ul><li>本地仓库：自己计算机上的一个目录。</li><li>中央仓库：由 Maven 团队维护的全球唯一的仓库： <a href="https://repo1.maven.org/maven2/%E3%80%82">https://repo1.maven.org/maven2/。</a></li><li>远程仓库(私服)：一般由公司团队搭建的私有仓库。</li><li>当项目中使用坐标引入对应依赖 jar 包后，首先会查找本地仓库中是否有对应的 jar 包，如果有，则在项目直接引用；如果没有，则去中央仓库中下载对应的jar包到本地仓库。</li><li>如果还可以搭建远程仓库，将来jar包的查找顺序则变为：本地仓库 –&gt; 远程仓库–&gt; 中央仓库。</li></ul><p>Maven 安装配置</p><ul><li>IDEA 自带 Maven 且 Mac 无需配置环境变量。</li><li>安装 Maven Helper 插件。</li></ul><h3 id="二、Maven-基本使用"><a href="#二、Maven-基本使用" class="headerlink" title="二、Maven 基本使用"></a>二、Maven 基本使用</h3><h4 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h4><p><code>mvn compile</code> ：编译，在项目下会生成一个 <code>target</code> 目录。</p><p><code>mvn clean</code>：清理，删除项目下的 <code>target</code> 目录。</p><p><code>mvn test</code>：测试，执行所有的测试代码。</p><p><code>mvn package</code>：打包，将当前项目打成的 jar 包。</p><p><code>mvn install</code>：安装，将当前项目打成jar包，并安装到本地仓库。</p><h4 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h4><p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件。</p><p>Maven 对项目构建的生命周期划分为3套：</p><ul><li><p>clean ：清理工作。</p></li><li><p>default ：核心工作，例如编译，测试，打包，安装等。</p></li><li><p>site ： 产生报告，发布站点等。这套声明周期一般不会使用。</p></li></ul><p>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。当我们执行 <code>install</code>（安装）命令时，它会先执行 <code>compile</code>命令，再执行 <code>test </code> 命令，再执行 <code>package</code> 命令，最后执行 <code>install</code> 命令；当我们执行 <code>package</code> （打包）命令时，它会先执行 <code>compile</code> 命令，再执行 <code>test</code> 命令，最后执行 <code>package</code> 命令。</p><h4 id="Maven-坐标详解"><a href="#Maven-坐标详解" class="headerlink" title="Maven 坐标详解"></a>Maven 坐标详解</h4><p>Maven 中的坐标是资源的唯一标识，资源可以是插件、依赖、当前项目。</p><p>使用坐标来定义项目或引入项目中需要的依赖。</p><p>Maven 坐标主要组成：</p><ul><li><p>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）。</p></li><li><p>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）。</p></li><li><p>version：定义当前项目版本号。</p></li></ul><p>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</p><h3 id="三、Maven-依赖管理"><a href="#三、Maven-依赖管理" class="headerlink" title="三、Maven 依赖管理"></a>三、Maven 依赖管理</h3><h4 id="使用坐标引入-jar-包"><a href="#使用坐标引入-jar-包" class="headerlink" title="使用坐标引入 jar 包"></a>使用坐标引入 jar 包</h4><p>在项目的 pom.xml 中编写<code> &lt;dependencies&gt;</code> 标签。</p><p>在 <code>&lt;dependencies&gt; </code>标签中 使用 <code>&lt;dependency&gt;</code> 引入坐标。</p><p>定义坐标的 <code> groupId</code>，<code>artifactId</code>，<code>version</code>。</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.32&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h4><p>通过设置坐标的依赖范围（scope），可以设置对应 jar 包的作用范围：编译环境、测试环境、运行环境。</p><p>通过 <code>scope</code> 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p><pre><code class="xml">&lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.32&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p><code>scope</code> 的取值：</p><table><thead><tr><th><strong>依赖范围</strong></th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td><strong>compile</strong></td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td><strong>test</strong></td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td><strong>provided</strong></td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td><strong>runtime</strong></td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td><strong>system</strong></td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table><p>compile：作用于编译环境、测试环境、运行环境。</p><p>test：作用于测试环境。典型的就是 Junit 坐标，以后使用 Junit 时，都会将 scope 指定为该值。</p><p>provided：作用于编译环境、测试环境。我们后面会学习 <code>servlet-api</code> ，在使用它时，必须将 <code>scope</code> 设置为该值，不然运行时就会报错。</p><p>runtime： 作用于测试环境、运行环境。jdbc驱动一般将 <code>scope</code> 设置为该值，当然不设置也没有任何问题 。</p><p>如果引入坐标不指定 <code>scope</code> 标签时，默认就是 compile  值，大部分 jar 包都是使用默认值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Maven 是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理，也可被用于构建和管理其他语言编写的各种项目，例如 C#，Ruby，Scala。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="Maven" scheme="http://blog.zhuangzhihao.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>数据操作和数据预处理</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86/</id>
    <published>2022-03-12T16:00:00.000Z</published>
    <updated>2022-05-05T12:26:18.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>要学习深度学习，首先需要先掌握一些基本技能。 所有机器学习方法都涉及从数据中提取信息。 因此，动手学深度学习 v2 课程在第二章的一开始先教授了一些关于数据的实用技能，包括存储、操作和预处理数据，作为预备知识的内容。以下为学习 Dive to Deep Learning（d2l） 课程第二章数据操作 + 数据预处理所记笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><ul><li>为了能够完成各种数据操作，我们需要某种方法来存储和操作数据</li><li>通常，我们需要做两件重要的事：获取数据和将数据读入计算机后对其进行处理</li><li>如果没有某种方法来存储数据，那么获取数据是没有意义的</li></ul><h4 id="n-维数组"><a href="#n-维数组" class="headerlink" title="n 维数组"></a>n 维数组</h4><ul><li><p>深度学习存储和操作数据的主要接口是张量（n维数组）。它提供了各种功能，包括基本数学运算、广播、索引、切片、内存节省和转换其他Python对象</p></li><li><p>n 维数组，也称为张量（tensor）</p></li><li><p>深度学习框架的张量类（在MXNet中为<code>ndarray</code>， 在PyTorch和TensorFlow中为<code>Tensor</code>）与Numpy的<code>ndarray</code>类似</p></li><li><p>但深度学习框架又比Numpy的<code>ndarray</code>多一些重要功能： 首先，GPU 很好地支持加速计算，而 NumPy 仅支持CPU计算； 其次，张量类支持自动微分。 这些功能使得张量类更适合深度学习</p></li><li><p>张量表示由一个数值组成的数组，这个数组可能有多个维度。 具有一个轴的张量对应数学上的向量（vector）； 具有两个轴的张量对应数学上的矩阵（matrix）</p></li><li><p>可以使用<code>arange</code>创建一个行向量<code>x</code>。 这个行向量包含从0开始的前12个整数，它们被默认创建为浮点数。 张量中的每个值都称为张量的元素（element）</p><pre><code class="python">import torchx = torch.arange(12)x # tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</code></pre></li><li><p>可以通过张量的<code>shape</code>属性来访问张量（沿每个轴的长度）的形状</p><pre><code class="python">x.shape  # torch.Size([12])</code></pre></li><li><p>如果只想知道张量中元素的总数，即形状的所有元素乘积，可以检查它的大小（size）</p><pre><code class="python">x.numel() # 12</code></pre></li><li><p>要想改变一个张量的形状而不改变元素数量和元素值，可以调用<code>reshape</code>函数</p><pre><code class="python">X = x.reshape(3, 4)  # 张量x从形状为（12,）的行向量转换为形状为（3,4）的矩阵X # tensor([[ 0,  1,  2,  3],  #       [ 4,  5,  6,  7],  #       [ 8,  9, 10, 11]])</code></pre><ul><li>我们可以通过<code>-1</code>来调用此自动计算出维度的功能。 即我们可以用<code>x.reshape(-1,4)</code>或<code>x.reshape(3,-1)</code>来取代<code>x.reshape(3,4)</code></li></ul></li><li><p>使用全0、全1、其他常量，或者从特定分布中随机采样的数字来初始化矩阵</p><pre><code class="python">torch.zeros((2, 3, 4))  # tensor([[[0., 0., 0., 0.],                        #               [0., 0., 0., 0.],                                        #                  [0., 0., 0., 0.]],                                        #                 [[0., 0., 0., 0.],                                         #                  [0., 0., 0., 0.],                                         #                 [0., 0., 0., 0.]]])torch.ones((2, 3, 4))  # 一个形状为(2,3,4)的张量，其中所有元素都设置为1torch.randn(3, 4)  # 一个形状为（3,4）的张量。 其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样</code></pre></li><li><p>通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值。 在这里，最外层的列表对应于轴0，内层的列表对应于轴1</p><pre><code class="python">torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])  </code></pre></li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><p>在这些数据上执行数学运算，其中最简单且最有用的操作是按元素（elementwise）运算。 它们将标准标量运算符应用于数组的每个元素。</p></li><li><p>对于将两个数组作为输入的函数，按元素运算将二元运算符应用于两个数组中的每对位置对应的元素。 我们可以基于任何从标量到标量的函数来创建按元素函数</p></li><li><p>对于任意具有相同形状的张量，常见的标准算术运算符（<code>+</code>、<code>-</code>、<code>\*</code>、<code>/</code>和<code>**</code>）都可以被升级为按元素运算。 我们可以在同一形状的任意两个张量上调用按元素操作</p><pre><code class="python">x = torch.tensor([1.0, 2, 4, 8])y = torch.tensor([2, 2, 2, 2])x + y, x - y, x * y, x / y, x ** y  # **运算符是求幂运算</code></pre></li><li><p>按元素方式可以应用更多的计算，包括像求幂这样的一元运算符</p><pre><code class="python">torch.exp(x)</code></pre></li><li><p>除了按元素计算外，我们还可以执行线性代数运算，包括向量点积和矩阵乘法。</p></li><li><p>也可以把多个张量连结（concatenate）在一起， 把它们端对端地叠起来形成一个更大的张量。 我们只需要提供张量列表，并给出沿哪个轴连结</p><pre><code class="python">X = torch.arange(12, dtype=torch.float32).reshape((3,4))Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])torch.cat((X, Y), dim=0) # 沿行（轴-0，形状的第一个元素）连结两个矩阵torch.cat((X, Y), dim=1) # 按列（轴-1，形状的第二个元素）连结两个矩阵</code></pre><ul><li><p>第一个输出张量的轴 -0 长度（6）是两个输入张量轴 -0 长度的总和（3+3）； 第二个输出张量的轴 -1 长度（8）是两个输入张量轴 -1 长度的总和（4+4）</p></li><li><p>通过逻辑运算符构建二元张量： 对于每个位置，如果<code>X</code>和<code>Y</code>在该位置相等，则新张量中相应项的值为1。 这意味着逻辑语句<code>X == Y</code>在该位置处为真，否则该位置为0</p><pre><code class="python">X == Y # tensor([[False,  True, False,  True],       #                 [False, False, False, False],       #                 [False, False, False, False]])</code></pre></li><li><p>对张量中的所有元素进行求和，会产生一个单元素张量</p><pre><code class="python">X.sum() # tensor(66.)</code></pre></li></ul></li></ul><h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><ul><li><p>即使形状不同，我们仍然可以通过调用广播机制（broadcasting mechanism）来执行按元素操作</p></li><li><p>首先，通过适当复制元素来扩展一个或两个数组， 以便在转换之后，两个张量具有相同的形状。 其次，对生成的数组执行按元素操作。在大多数情况下，我们将沿着数组中长度为1的轴进行广播</p><pre><code class="python">a = torch.arange(3).reshape((3, 1))b = torch.arange(2).reshape((1, 2))a, b # (tensor([[0],     #                [1],     #                [2]]),     #  tensor([[0, 1]]))</code></pre></li><li><p>由于<code>a</code>和<code>b</code>分别是3×1和1×2矩阵，如果让它们相加，它们的形状不匹配。 我们将两个矩阵广播为一个更大的3×2矩阵，如下所示：矩阵<code>a</code>将复制列， 矩阵<code>b</code>将复制行，然后再按元素相加</p><pre><code class="python">a + b # tensor([[0, 1],      #              [1, 2],      #              [2, 3]])</code></pre></li></ul><h4 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h4><ul><li><p>就像在任何其他Python数组中一样，张量中的元素可以通过索引访问。</p></li><li><p>与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1； 可以指定范围以包含第一个元素和最后一个之前的元素</p><pre><code class="python">X[-1], X[1:3] # (tensor([ 8.,  9., 10., 11.]),              # tensor([[ 4.,  5.,  6.,  7.],              #         [ 8.,  9., 10., 11.]]))</code></pre></li><li><p>除读取外，我们还可以通过指定索引来将元素写入矩阵</p><pre><code class="python">X[1, 2] = 9 # 将第二行第三列元素改为 9</code></pre></li><li><p>为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值，例如，<code>[0:2, :]</code>访问第1行和第2行，其中 “:” 代表沿轴1（列）的所有元素</p><pre><code class="python">X[0:2, :] = 12 # tensor([[12., 12., 12., 12.],               #         [12., 12., 12., 12.],               #         [ 8.,  9., 10., 11.]])</code></pre></li></ul><h4 id="节省内存"><a href="#节省内存" class="headerlink" title="节省内存"></a>节省内存</h4><ul><li><p>运行一些操作可能会导致为新结果分配内存。 例如，如果我们用<code>Y = X + Y</code>，我们将取消引用<code>Y</code>指向的张量，而是指向新分配的内存处的张量</p><pre><code class="python">before = id(Y)Y = Y + Xid(Y) == before  # False</code></pre></li><li><p>执行原地操作非常简单。 我们可以使用切片表示法将操作的结果分配给先前分配的数组，例如<code>Y[:] = &lt;expression&gt;</code></p><pre><code class="python">Z = torch.zeros_like(Y) # 创建一个新的矩阵Z，其形状与另一个Y相同， 使用zeros_like来分配一个全 0 的块print(&#39;id(Z):&#39;, id(Z))Z[:] = X + Yprint(&#39;id(Z):&#39;, id(Z))  # id一样</code></pre><ul><li>如果在后续计算中没有重复使用<code>X</code>， 我们也可以使用<code>X[:] = X + Y</code>或<code>X += Y</code>来减少操作的内存开销</li></ul></li></ul><h4 id="转换为其他Python对象"><a href="#转换为其他Python对象" class="headerlink" title="转换为其他Python对象"></a>转换为其他Python对象</h4><ul><li><p>将深度学习框架定义的张量[转换为NumPy张量（<code>ndarray</code>）很容易，反之也同样容易</p></li><li><p>torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量</p><pre><code class="python">A = X.numpy()B = torch.tensor(A)type(A), type(B) # (numpy.ndarray, torch.Tensor)</code></pre></li><li><p>要(将大小为1的张量转换为Python标量，我们可以调用<code>item</code>函数或Python的内置函数</p><pre><code class="python">a = torch.tensor([3.5])a, a.item(), float(a), int(a)# (tensor([3.5000]), 3.5, 3.5, 3)</code></pre></li></ul><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><ul><li>为了能用深度学习来解决现实世界的问题，我们经常从预处理原始数据开始， 而不是从那些准备好的张量格式数据开始</li><li>在Python中常用的数据分析工具中，我们通常使用<code>pandas</code>软件包。 像庞大的Python生态系统中的许多其他扩展包一样，<code>pandas</code>可以与张量兼容</li></ul><h4 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h4><ul><li><p>首先创建一个人工数据集，并存储在CSV（逗号分隔值文件) <code>../data/house_tiny.csv</code>中。 以其他格式存储的数据也可以通过类似的方式进行处理</p><pre><code class="python">import osos.makedirs(os.path.join(&#39;..&#39;, &#39;data&#39;), exist_ok=True)data_file = os.path.join(&#39;..&#39;, &#39;data&#39;, &#39;house_tiny.csv&#39;)with open(data_file, &#39;w&#39;) as f:    f.write(&#39;NumRooms,Alley,Price\n&#39;)  # 列名    f.write(&#39;NA,Pave,127500\n&#39;)  # 每行表示一个数据样本    f.write(&#39;2,NA,106000\n&#39;)    f.write(&#39;4,NA,178100\n&#39;)    f.write(&#39;NA,NA,140000\n&#39;)</code></pre></li><li><p>要从创建的CSV文件中加载原始数据集，我们导入<code>pandas</code>包并调用<code>read_csv</code>函数</p><pre><code class="python">import pandas as pddata = pd.read_csv(data_file)print(data)</code></pre><ul><li>该数据集有四行三列。其中每行描述了房间数量（“NumRooms”）、巷子类型（“Alley”）和房屋价格（“Price”）</li></ul></li></ul><h4 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h4><ul><li><p>“NaN”项代表缺失值</p></li><li><p>为了处理缺失的数据，典型的方法包括插值法和删除法，其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值</p></li><li><p>插值法：通过位置索引<code>iloc</code>，将<code>data</code>分成<code>inputs</code>和<code>outputs</code>， 其中前者为<code>data</code>的前两列，而后者为<code>data</code>的最后一列</p><ul><li>对于<code>inputs</code>中缺少的数值，我们用同一列的均值替换“NaN”项</li></ul><pre><code class="python">inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]inputs = inputs.fillna(inputs.mean())print(inputs)</code></pre></li><li><p>对于<code>inputs</code>中的类别值或离散值，我们将“NaN”视为一个类别</p><pre><code class="python">inputs = pd.get_dummies(inputs, dummy_na=True)print(inputs)</code></pre></li></ul><h4 id="转换为张量格式"><a href="#转换为张量格式" class="headerlink" title="转换为张量格式"></a>转换为张量格式</h4><ul><li><p>现在<code>inputs</code>和<code>outputs</code>中的所有条目都是数值类型，它们可以转换为张量格式</p></li><li><p>当数据采用张量格式后，可以通过张量函数来进一步操作</p><pre><code class="python">import torchX, y = torch.tensor(inputs.values), torch.tensor(outputs.values)X, y</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;要学习深度学习，首先需要先掌握一些基本技能。 所有机器学习方法都涉及从数据中提取信息。 因此，动手学深度学习 v2 课程在第二章的一开始先教授了一些关于数据的实用技能，包括存储、操作和预处理数据，作为预备知识的内容。以下为学习 Dive to Deep Learning（d2l） 课程第二章数据操作 + 数据预处理所记笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://blog.zhuangzhihao.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PyTorch" scheme="http://blog.zhuangzhihao.top/tags/PyTorch/"/>
    
    <category term="pandas" scheme="http://blog.zhuangzhihao.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>Java 数据库基础知识总结</title>
    <link href="http://blog.zhuangzhihao.top/JDBC%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.zhuangzhihao.top/JDBC%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-11T16:00:00.000Z</published>
    <updated>2022-05-16T06:02:28.659Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java 数据库连接，JDBC（Java Database Connectivity），是 Java 语言编程中与数据库连接的 API，封装了各种数据库访问的 API 和基础类库，支持多种数据库连接，也是 Java Web 技术核心的第一部分，我把整个学习过程分为 MySQL 基础、MySQL 高级、JDBC 和数据连接池四个部分，便于理解。</p></blockquote><a id="more"></a><h3 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h3><h4 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h4><ul><li>英文：Structured Query Language，简称 SQL</li><li>结构化查询语言，一门操作关系型数据库的编程语言</li><li>定义操作所有关系型数据库的统一标准</li><li>对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方</li></ul><h4 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h4><ul><li><p>SQL 语句可以单行或多行书写，以分号结尾。</p></li><li><p>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</p></li><li><p>注释</p><ul><li><p>单行注释: <code>-- 注释内容</code> 或 <code>#注释内容</code></p></li><li><p>多行注释: <code>/* 注释 */</code></p></li></ul></li></ul><h4 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h4><ul><li><p>DDL (Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等</p></li><li><p>DML (Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改</p></li><li><p>DQL (Data Query Language) 数据查询语言，用来查询数据库中表的记录（数据）</p></li><li><p>DCL (Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户</p></li></ul><h4 id="DDL：操作数据库"><a href="#DDL：操作数据库" class="headerlink" title="DDL：操作数据库"></a>DDL：操作数据库</h4><ul><li> 查询所有的数据库</li></ul><pre><code class="sql">SHOW DATABASES;</code></pre><ul><li>创建数据库（先判断，如果不存在则创建）</li></ul><pre><code class="sql">CREATE DATABASE IF NOT EXISTS 数据库名称;</code></pre><ul><li>删除数据库（先判断，如果存在则删除）</li></ul><pre><code class="sql">DROP DATABASE IF EXISTS 数据库名称;</code></pre><ul><li>使用数据库</li></ul><pre><code class="sql">USE 数据库名称;</code></pre><ul><li>查看当前使用的数据库</li></ul><pre><code class="sql">SELECT DATABASE();</code></pre><h4 id="DDL：操作表"><a href="#DDL：操作表" class="headerlink" title="DDL：操作表"></a>DDL：操作表</h4><ul><li>查询当前数据库下所有表名称</li></ul><pre><code class="sql">SHOW TABLES;</code></pre><ul><li>查询表结构</li></ul><pre><code class="sql">DESC 表名称;</code></pre><ul><li>创建表</li></ul><pre><code class="sql">create table tb_user (    id int,    username varchar(20),    password varchar(32)  -- 最后一行末尾，不能加逗号);</code></pre><ul><li>删除表（先判断表是否存在）</li></ul><pre><code class="sql">DROP TABLE IF EXISTS 表名;</code></pre><ul><li>修改表名</li></ul><pre><code class="sql">ALTER TABLE 表名 RENAME TO 新的表名;</code></pre><ul><li>添加一列</li></ul><pre><code class="sql">ALTER TABLE 表名 ADD 列名 数据类型;-- 给stu表添加一列address，该字段类型是varchar(50)alter table stu add address varchar(50);</code></pre><ul><li>修改数据类型</li></ul><pre><code class="sql">ALTER TABLE 表名 MODIFY 列名 新数据类型;-- 将stu表中的address字段的类型改为 char(50)alter table stu modify address char(50);</code></pre><ul><li>修改列名和数据类型</li></ul><pre><code class="sql">ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;-- 将stu表中的address字段名改为 addr，类型改为varchar(50)alter table stu change address addr varchar(50);</code></pre><ul><li>删除列</li></ul><pre><code class="sql">ALTER TABLE 表名 DROP 列名;</code></pre><h4 id="SQL-的数据类型"><a href="#SQL-的数据类型" class="headerlink" title="SQL 的数据类型"></a>SQL 的数据类型</h4><ul><li><p>数值</p><pre><code class="sql">tinyint : 小整数型，占一个字节int    ： 大整数类型，占四个字节    eg ： age intdouble ： 浮点类型    使用格式： 字段名 double(总长度,小数点后保留的位数)    eg ： score double(5,2)   </code></pre></li><li><p>日期</p><pre><code class="sql">date ： 日期值。只包含年月日    eg ：birthday date ： datetime ： 混合日期和时间值。包含年月日时分秒</code></pre></li><li><p>字符串</p><pre><code class="sql">char ： 定长字符串。    优点：存储性能高    缺点：浪费空间    eg ： name char(10)  如果存储的数据字符个数不足10个，也会占10个的空间varchar ： 变长字符串。    优点：节约空间    缺点：存储性能底    eg ： name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间    </code></pre></li></ul><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><ul><li>查询所有数据</li></ul><pre><code class="sql">SELECT * FROM 表名;</code></pre><ul><li>给指定列添加数据</li></ul><pre><code class="sql">INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…);</code></pre><ul><li>给全部列添加数据</li></ul><pre><code class="sql">INSERT INTO 表名 VALUES(值1,值2,…);</code></pre><ul><li>批量添加数据</li></ul><pre><code class="sql">INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;</code></pre><ul><li>修改表数据</li></ul><pre><code class="sql">UPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ;-- 修改语句中如果不加条件，则将所有数据都修改！</code></pre><ul><li>删除数据</li></ul><pre><code class="sql">DELETE FROM 表名 [WHERE 条件] ;</code></pre><ul><li>删除表中所有的数据</li></ul><pre><code class="sql">DELETE FROM 表名;</code></pre><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><ul><li>查询多个字段</li></ul><pre><code class="sql">SELECT 字段列表 FROM 表名;SELECT * FROM 表名; -- 查询所有数据</code></pre><ul><li>去除重复记录</li></ul><pre><code class="sql">SELECT DISTINCT 字段列表 FROM 表名;</code></pre><ul><li>起别名</li></ul><pre><code class="sql">SELECT 字段列表 AS: 别名 FROM 表名; -- AS 也可以省略</code></pre><ul><li>条件查询</li></ul><pre><code class="sql">SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></pre><ul><li>模糊查询<ul><li>使用 <code>LIKE</code> 关键字，可以使用通配符进行占位</li><li><code>_</code> ：代表单个任意字符</li><li><code>%</code> ：代表任意个数字符</li></ul></li></ul><pre><code class="sql">select * from stu where name like &#39;马%&#39;;  -- 查询姓&#39;马&#39;的学员信息select * from stu where name like &#39;_花%&#39;;  -- 查询第二个字是&#39;花&#39;的学员信息 select * from stu where name like &#39;%德%&#39;;  -- 查询名字中包含 &#39;德&#39; 的学员信息</code></pre><ul><li>排序查询</li></ul><pre><code class="sql">SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;/*排序方式有两种，分别是：ASC ： 升序排列（默认值）DESC ： 降序排列如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序*/</code></pre><ul><li>聚合函数<ul><li>将一列数据作为一个整体，进行纵向计算</li></ul></li></ul><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td><code>count(列名)</code></td><td>统计数量（一般选用不为null的列）</td></tr><tr><td><code>max(列名)</code></td><td>最大值</td></tr><tr><td><code>min(列名)</code></td><td>最小值</td></tr><tr><td><code>sum(列名)</code></td><td>求和</td></tr><tr><td><code>avg(列名)</code></td><td>平均值</td></tr></tbody></table><pre><code class="sql">SELECT 聚合函数名(列名) FROM 表;-- null 值不参与所有聚合函数运算</code></pre><ul><li>分组查询</li></ul><pre><code class="sql">SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];-- 分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</code></pre><ul><li><p>where 和 having 区别：</p><ul><li>执行时机不一样：<code>where</code> 是分组之前进行限定，不满足 <code>where</code> 条件，则不参与分组，而 <code>having</code> 是分组之后对结果进行过滤。</li></ul></li></ul><ul><li>可判断的条件不一样：<code>where</code> 不能对聚合函数进行判断，<code>having</code> 可以</li></ul><ul><li>分页查询</li></ul><pre><code class="sql">SELECT 字段列表 FROM 表名 LIMIT  起始索引 , 查询条目数;-- 起始索引是从0开始</code></pre><ul><li>起始索引计算公式：</li></ul><pre><code class="sql">起始索引 = (当前页码 - 1) * 每页显示的条数</code></pre><h3 id="MySQL-进阶"><a href="#MySQL-进阶" class="headerlink" title="MySQL 进阶"></a>MySQL 进阶</h3><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><ul><li><p>约束是作用于表中列上的规则，用于限制加入表的数据</p></li><li><p>约束的存在保证了数据库中数据的正确性、有效性和完整性</p></li><li><p>约束的分类</p><ul><li>非空约束：关键字是 <code>NOT NULL</code>，保证列中所有的数据不能有null值。</li></ul></li></ul><ul><li>唯一约束：关键字是 <code>UNIQUE</code>，保证列中所有数据各不相同</li></ul><ul><li>主键约束： 关键字是 <code>PRIMARY KEY</code>，主键是一行数据的唯一标识，要求非空且唯一</li></ul><ul><li>检查约束： 关键字是 <code>CHECK</code>，保证列中的值满足某一条件（MySQL不支持检查约束）</li></ul><ul><li>默认约束： 关键字是  <code>DEFAULT</code>，保存数据时，未指定值则采用默认值</li><li>外键约束： 关键字是 <code>FOREIGN KEY</code>，外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</li></ul><ul><li><p>非空约束</p><ul><li><p>用于保证列中所有数据不能有NULL值</p></li><li><p>添加约束</p><pre><code class="sql">-- 创建表时添加非空约束CREATE TABLE 表名(   列名 数据类型 NOT NULL,   …); </code></pre><pre><code class="sql">-- 建完表后添加非空约束ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL;</code></pre></li></ul></li></ul><pre><code>* 删除约束  ```sql  ALTER TABLE 表名 MODIFY 字段名 数据类型;  ```</code></pre><ul><li><p>唯一约束</p><ul><li>用于保证列中所有数据各不相同</li></ul></li></ul><pre><code>* 添加约束  ```sql  -- 创建表时添加唯一约束  CREATE TABLE 表名(     列名 数据类型 UNIQUE [AUTO_INCREMENT],     -- AUTO_INCREMENT: 当不指定值时自动增长     …  );   CREATE TABLE 表名(     列名 数据类型,     …     [CONSTRAINT] [约束名称] UNIQUE(列名)  );   ```  ```sql  -- 建完表后添加唯一约束  ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE;  ```* 删除约束  ```sql  ALTER TABLE 表名 DROP INDEX 字段名;  ```</code></pre><ul><li><p>主键约束</p><ul><li>主键是一行数据的唯一标识，要求非空且唯一</li><li>一张表只能有一个主键</li></ul><ul><li><p>添加约束</p><pre><code class="sql">-- 创建表时添加主键约束CREATE TABLE 表名(   列名 数据类型 PRIMARY KEY [AUTO_INCREMENT],   …); CREATE TABLE 表名(   列名 数据类型,   [CONSTRAINT] [约束名称] PRIMARY KEY(列名)); </code></pre><pre><code class="sql">-- 建完表后添加主键约束ALTER TABLE 表名 ADD PRIMARY KEY(字段名);</code></pre></li></ul></li></ul><ul><li><p>删除约束</p><pre><code class="sql">ALTER TABLE 表名 DROP PRIMARY KEY;</code></pre></li></ul><ul><li><p>默认约束</p><ul><li><p>保存数据时，未指定值则采用默认值</p></li><li><p>添加约束</p><pre><code class="sql">-- 创建表时添加默认约束CREATE TABLE 表名(   列名 数据类型 DEFAULT 默认值,   …); </code></pre><pre><code class="sql">-- 建完表后添加默认约束ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值;</code></pre></li><li><p>删除约束</p><pre><code class="sql">ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;</code></pre></li></ul></li></ul><ul><li>默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值</li></ul><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><ul><li>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</li></ul><ul><li>添加外键约束</li></ul><pre><code class="sql">-- 创建表时添加外键约束CREATE TABLE 表名(   列名 数据类型,   …   [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) ); </code></pre><pre><code class="sql">-- 建完表后添加外键约束ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</code></pre><ul><li>删除外键约束</li></ul><pre><code class="sql">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></pre><ul><li>添加数据</li></ul><pre><code class="sql">-- 添加 2 个部门insert into dept(dep_name,addr) values(&#39;研发部&#39;,&#39;广州&#39;),(&#39;销售部&#39;, &#39;深圳&#39;);-- 添加员工,dep_id 表示员工所在的部门INSERT INTO emp (NAME, age, dep_id) VALUES (&#39;张三&#39;, 20, 1),(&#39;李四&#39;, 20, 1),(&#39;王五&#39;, 20, 1),</code></pre><p>删除外键</p><pre><code class="sql">alter table emp drop FOREIGN key fk_emp_dept;</code></pre><p>重新添加外键</p><pre><code class="sql">alter table emp add CONSTRAINT fk_emp_dept FOREIGN key(dep_id) REFERENCES dept(id);</code></pre><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><ul><li><p>数据库设计概念</p><ul><li>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型</li><li>建立数据库中的表结构以及表与表之间的关联关系的过程</li><li>有哪些表？表里有哪些字段？表和表之间有什么关系？</li></ul></li><li><p>数据库设计的步骤</p><ul><li><p>需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么）</p></li><li><p>逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）</p></li><li><p>物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）</p></li><li><p>维护设计（1.对新的需求进行建表；2.表优化）</p></li></ul></li><li><p>表关系</p><ul><li><p>一对一（如：用户 和 用户详情）：一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</p></li><li><p>一对多（如：部门 和 员工）：一个部门对应多个员工，一个员工对应一个部门</p></li><li><p>多对多（如：商品 和 订单）：一个商品对应多个订单，一个订单包含多个商品</p></li></ul></li></ul><ul><li><p>表关系（一对多）</p><ul><li>实现方式：在多的一方建立外键，指向一的一方的主键</li></ul></li></ul><ul><li>以 <code>员工表</code> 和 <code>部门表</code> 举例：在员工表中添加一列（dep_id），指向于部门表的主键（id）</li></ul><pre><code class="sql">-- 删除表DROP TABLE IF EXISTS tb_emp;DROP TABLE IF EXISTS tb_dept;-- 部门表CREATE TABLE tb_dept(    id int primary key auto_increment,    dep_name varchar(20),    addr varchar(20));-- 员工表 CREATE TABLE tb_emp(    id int primary key auto_increment,    name varchar(20),    age int,    dep_id int,    -- 添加外键 dep_id,关联 dept 表的id主键    CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES tb_dept(id)    );</code></pre><ul><li><p>表关系（多对多）</p><ul><li>建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul><ul><li>以 <code>订单表</code> 和 <code>商品表</code> 举例：订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键：</li></ul><pre><code class="sql">  -- 删除表  DROP TABLE IF EXISTS tb_order_goods;  DROP TABLE IF EXISTS tb_order;  DROP TABLE IF EXISTS tb_goods;  -- 订单表  CREATE TABLE tb_order(  id int primary key auto_increment,  payment double(10,2),  payment_type TINYINT,  status TINYINT  );  -- 商品表  CREATE TABLE tb_goods(  id int primary key auto_increment,  title varchar(100),  price double(10,2)  );  -- 订单商品中间表  CREATE TABLE tb_order_goods(  id int primary key auto_increment,  order_id int,  goods_id int,  count int  );  -- 建完表后，添加外键  alter table tb_order_goods add CONSTRAINT fk_order_id FOREIGN key(order_id) REFERENCES tb_order(id);  alter table tb_order_goods add CONSTRAINT fk_goods_id FOREIGN key(goods_id) REFERENCES tb_goods(id);</code></pre></li><li><p>表关系（一对一）</p><ul><li>在任意一方加入外键，关联另一方主键，并且设置外键为唯一（<code>UNIQUE</code>）</li></ul></li></ul><ul><li>以 <code>用户表</code> 举例：在真正使用过程中发现 id、photo、nickname、age、gender 字段比较常用，此时就可以将这张表查分成两张表</li></ul><pre><code class="sql">create table tb_user_desc (    id int primary key auto_increment,    city varchar(20),    edu varchar(10),    income int,    status char(2),    des varchar(100));create table tb_user (    id int primary key auto_increment,    photo varchar(100),    nickname varchar(50),    age int,    gender char(1),    desc_id int unique,    -- 添加外键    CONSTRAINT fk_user_desc FOREIGN KEY(desc_id) REFERENCES tb_user_desc(id)    );</code></pre><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><ul><li>多表查询顾名思义就是从多张表中一次性的查询出我们想要的数据</li></ul><pre><code class="sql">DROP TABLE IF EXISTS emp;DROP TABLE IF EXISTS dept;# 创建部门表    CREATE TABLE dept(        did INT PRIMARY KEY AUTO_INCREMENT,        dname VARCHAR(20)    );    # 创建员工表    CREATE TABLE emp (        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(10),        gender CHAR(1), -- 性别        salary DOUBLE, -- 工资        join_date DATE, -- 入职日期        dep_id INT,        FOREIGN KEY (dep_id) REFERENCES dept(did) -- 外键，关联部门表(部门表的主键)    );    -- 添加部门数据    INSERT INTO dept (dNAME) VALUES (&#39;研发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;),(&#39;销售部&#39;);    -- 添加员工数据    INSERT INTO emp(NAME,gender,salary,join_date,dep_id) VALUES    (&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1),    (&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2),    (&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2),    (&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3),    (&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1),    (&#39;小白龙&#39;,&#39;男&#39;,2500,&#39;2011-02-14&#39;,null);    </code></pre><ul><li>执行下面的多表查询语句</li></ul><pre><code class="sql">select * from emp , dept;  -- 从emp和dept表中查询所有的字段数据</code></pre><ul><li>通过限制员工表中的 <code>dep_id</code> 字段的值和部门表 <code>did</code> 字段的值相等来消除无效的数据，</li></ul><pre><code class="sql">select * from emp , dept where emp.dep_id = dept.did;</code></pre><ul><li><p>连接查询 </p><ul><li>内连接查询 ：相当于查询AB交集数据</li><li>外连接查询<ul><li>左外连接查询 ：相当于查询A表所有数据和交集部门数据</li><li>右外连接查询 ： 相当于查询B表所有数据和交集部分数据</li></ul></li><li>子查询</li></ul></li></ul><ul><li>内连接查询</li></ul><pre><code class="sql">-- 隐式内连接SELECT 字段列表 FROM 表1,表2… WHERE 条件;-- 显示内连接SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件;</code></pre><ul><li>隐式内连接</li></ul><pre><code class="sql">SELECT * FROM emp, dept WHERE emp.dep_id = dept.did;</code></pre><ul><li>查询 emp 的 name， gender，dept 表的 dname</li></ul><pre><code class="sql">SELECT    t1. NAME,    t1.gender,    t2.dnameFROM    emp t1,    dept t2WHERE    t1.dep_id = t2.did;</code></pre><ul><li>显式内连接</li></ul><pre><code class="sql">select * from emp inner join dept on emp.dep_id = dept.did;-- 上面语句中的inner可以省略，可以书写为如下语句select * from emp  join dept on emp.dep_id = dept.did;</code></pre><ul><li>外连接查询</li></ul><pre><code class="sql">-- 左外连接：相当于查询A表所有数据和交集部分数据SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;-- 右外连接：相当于查询B表所有数据和交集部分数据SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;</code></pre><ul><li>查询emp表所有数据和对应的部门信息（左外连接）</li></ul><pre><code class="sql">select * from emp left join dept on emp.dep_id = dept.did;-- 结果显示查询到了左表（emp）中所有的数据及两张表能关联的数据</code></pre><ul><li>查询dept表所有数据和对应的员工信息（右外连接）</li></ul><pre><code class="sql">select * from emp right join dept on emp.dep_id = dept.did;-- 结果显示查询到了右表（dept）中所有的数据及两张表能关联的数据</code></pre><p>。要查询出部门表中所有的数据，也可以通过左外连接实现，只需要将两个表的位置进行互换：</p><pre><code class="sql">select * from dept left join emp on emp.dep_id = dept.did;</code></pre><ul><li><p>子查询</p><ul><li>查询中嵌套查询，称嵌套查询为子查询</li></ul></li></ul><ul><li>子查询根据查询结果不同，作用不同</li><li>子查询语句结果是单行单列，子查询语句作为条件值，使用 =  !=  &gt;  &lt;  等进行条件判断</li><li>子查询语句结果是多行单列，子查询语句作为条件值，使用 in 等关键字进行条件判断</li><li>子查询语句结果是多行多列，子查询语句作为虚拟表</li><li>查询 ‘财务部’ 和 ‘市场部’ 所有的员工信息</li></ul><pre><code class="sql">-- 查询 &#39;财务部&#39; 或者 &#39;市场部&#39; 所有的员工的部门didselect did from dept where dname = &#39;财务部&#39; or dname = &#39;市场部&#39;;select * from emp where dep_id in (select did from dept where dname = &#39;财务部&#39; or dname = &#39;市场部&#39;);</code></pre><ul><li>查询入职日期是 ‘2011-11-11’ 之后的员工信息和部门信息</li></ul><pre><code class="sql">-- 查询入职日期是 &#39;2011-11-11&#39; 之后的员工信息select * from emp where join_date &gt; &#39;2011-11-11&#39; ;-- 将上面语句的结果作为虚拟表和dept表进行内连接查询select * from (select * from emp where join_date &gt; &#39;2011-11-11&#39; ) t1, dept where t1.dep_id = dept.did;</code></pre><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul><li><p>概述</p><ul><li><p>数据库的事务（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令</p></li><li><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败</p></li><li><p>事务是一个不可分割的工作逻辑单元</p></li></ul></li></ul><ul><li><p>语法</p><ul><li>开启事务</li></ul><pre><code class="sql">START TRANSACTION;或者  BEGIN;</code></pre></li></ul><ul><li><p>提交事务</p><pre><code class="sql">commit;</code></pre></li></ul><ul><li><p>回滚事务</p><pre><code class="sql">rollback;</code></pre></li></ul><ul><li><p>代码验证</p><ul><li>环境准备</li></ul><pre><code class="sql">DROP TABLE IF EXISTS account;-- 创建账户表CREATE TABLE account(    id int PRIMARY KEY auto_increment,    name varchar(10),    money double(10,2));-- 添加数据INSERT INTO account(name,money) values(&#39;张三&#39;,1000),(&#39;李四&#39;,1000);</code></pre></li></ul><ul><li><p>不加事务演示问题</p><pre><code class="sql">-- 转账操作-- 1. 查询李四账户金额是否大于500-- 2. 李四账户 -500UPDATE account set money = money - 500 where name = &#39;李四&#39;;出现异常了...  -- 此处不是注释，在整体执行时会出问题，后面的sql则不执行-- 3. 张三账户 +500UPDATE account set money = money + 500 where name = &#39;张三&#39;;</code></pre></li></ul><ul><li><p>添加事务 sql</p><pre><code class="sql">-- 开启事务BEGIN;-- 转账操作-- 1. 查询李四账户金额是否大于500-- 2. 李四账户 -500UPDATE account set money = money - 500 where name = &#39;李四&#39;;出现异常了...  -- 此处不是注释，在整体执行时会出问题，后面的sql则不执行-- 3. 张三账户 +500UPDATE account set money = money + 500 where name = &#39;张三&#39;;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;</code></pre><ul><li>上面sql中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句，以后我们肯定不可能这样操作，而是在java中进行操作，在java中可以抓取异常，没出现异常提交事务，出现异常回滚事务</li></ul></li></ul><ul><li><p>事务的四大特征</p><ul><li>原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li>一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation） :多个事务之间，操作的可见性</li><li>持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li><li>MySQL 中事务是自动提交的，也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务<ul><li>可以通过下面语句查询默认提交方式：</li></ul></li></ul><pre><code class="java">SELECT @@autocommit;</code></pre></li><li><p> 查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式</p></li></ul><pre><code class="sql">set @@autocommit = 0;</code></pre><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><h4 id="JDBC-简介"><a href="#JDBC-简介" class="headerlink" title="JDBC 简介"></a>JDBC 简介</h4><ul><li><p>JDBC 概念</p><ul><li><p>JDBC 就是使用Java语言操作关系型数据库的一套API</p></li><li><p>JDBC 全称：( Java DataBase Connectivity ) Java 数据库连接</p></li><li><p>sun公司指定了一套标准接口（JDBC），JDBC中定义了所有操作关系型数据库的规则，众所周知接口是无法直接使用的，我们需要使用接口的实现类，而这套实现类（称之为：驱动）就由各自的数据库厂商给出</p></li></ul></li><li><p>JDBC本质</p><ul><li><p>官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口</p></li><li><p>各个数据库厂商去实现这套接口，提供数据库驱动jar包</p></li><li><p>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</p></li></ul></li></ul><ul><li><p>JDBC好处</p><ul><li><p>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发</p></li><li><p>可随时替换底层数据库，访问数据库的Java代码基本不变</p></li><li><p>以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包</p></li></ul></li></ul><h4 id="JDBC快速入门"><a href="#JDBC快速入门" class="headerlink" title="JDBC快速入门"></a>JDBC快速入门</h4><ul><li><p>通过Java操作数据库的流程</p><ul><li>第一步：编写Java代码</li></ul></li></ul><pre><code>- 第二步：Java代码将SQL发送到MySQL服务端- 第三步：MySQL服务端接收到SQL语句并执行该SQL语句- 第四步：将SQL语句执行的结果返回给Java代码</code></pre><ul><li><p>编写代码步骤</p><ul><li>创建工程，导入驱动 jar 包（mysql-connector-java-5.1.48.jar）</li></ul></li></ul><ul><li><p>注册驱动</p><pre><code class="sql">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></pre></li></ul><ul><li><p>获取连接</p><pre><code class="sql">Connection conn = DriverManager.getConnection(url, username, password);</code></pre><ul><li>Java代码需要发送SQL给MySQL服务端，就需要先建立连接</li></ul></li></ul><ul><li><p>定义SQL语句</p><pre><code class="sql">String sql =  &quot;select * from table;&quot; ;</code></pre></li></ul><ul><li><p>获取执行SQL对象</p><ul><li>执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象</li></ul><pre><code class="sql">Statement stmt = conn.createStatement();</code></pre></li><li><p>执行SQL</p><pre><code class="sql">stmt.executeUpdate(sql);  </code></pre></li></ul><ul><li>处理返回结果</li><li>释放资源</li><li>IDEA 中编写代码</li></ul><pre><code class="java">/** * JDBC快速入门 */public class JDBCDemo &#123;    public static void main(String[] args) throws Exception &#123;        //1. 注册驱动        //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //2. 获取连接        String url = &quot;jdbc:mysql://127.0.0.1:3306/db1?useSSL=false&quot;;        String username = &quot;root&quot;;        String password = &quot;1234&quot;;        Connection conn = DriverManager.getConnection(url, username, password);        //3. 定义sql        String sql = &quot;update account set money = 2000 where id = 1&quot;;        //4. 获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //5. 执行sql        int count = stmt.executeUpdate(sql);//受影响的行数        //6. 处理结果        System.out.println(count);        //7. 释放资源        stmt.close();        conn.close();    &#125;&#125;</code></pre><h4 id="JDBC-API-详解"><a href="#JDBC-API-详解" class="headerlink" title="JDBC API 详解"></a>JDBC API 详解</h4><ul><li><p>DriverManager（驱动管理类）</p><ul><li><p>注册驱动：<code>registerDriver</code> 方法是用于注册驱动的，但是我们之前做的入门案例并不是这样写的。而是如下实现</p><pre><code class="sql">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></pre></li><li><p>在该类中的静态代码块中已经执行了 <code>DriverManager</code> 对象的 <code>registerDriver()</code> 方法进行驱动的注册了，那么我们只需要加载 <code>Driver</code> 类，该静态代码块就会执行，而 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code> 就可以加载 <code>Driver</code> 类</p></li></ul></li></ul><pre><code>* 获取数据库连接  ```sql  Connection conn = DriverManager.getConnection(url, username, password);  ```  * url ： `jdbc:mysql://ip地址(域名):端口号/数据库名称?参数键值对1&amp;参数键值对2…`    * 配置 `useSSL=false` 参数，禁用安全连接方式，解决警告提示  * user ：用户名  * poassword ：密码</code></pre><ul><li><p>Connection（数据库连接对象）</p><ul><li><p>获取执行 SQL 的对象</p><ul><li>普通执行SQL对象</li></ul><pre><code class="sql">Statement createStatement()  -- 通过该方法获取执行对象Statement stmt = conn.createStatement();int count = stmt.executeUpdate(sql);</code></pre><ul><li>预编译SQL的执行SQL对象：防止SQL注入</li></ul><pre><code class="sql">PreparedStatement  prepareStatement(sql)</code></pre><ul><li><p>通过这种方式获取的 <code>PreparedStatement</code> SQL语句执行对象可以防止SQL注入</p></li><li><p>执行存储过程的对象</p><pre><code class="sql">CallableStatement prepareCall(sql)</code></pre></li><li><p>通过这种方式获取的 <code>CallableStatement</code> 执行对象是用来执行存储过程的，但存储过程在MySQL中不常用</p></li></ul></li></ul></li></ul><pre><code>- 事务管理  - MySQL事务管理的操作（MySQL默认是自动提交事务）    * 开启事务 ： `BEGIN;` 或者 `START TRANSACTION;`    * 提交事务 ： `COMMIT;`    * 回滚事务 ： `ROLLBACK;`  - JDBC事务管理的方法    - Connection几个接口中定义了3个对应的方法：      * 开启事务        ```sql        setAutoCommit(boolean autoCommit)        ```      * 参与 `autoCommit` 表示是否自动提交事务，true表示自动提交事务，false表示手动提交事务，而开启事务需要将该参数设为为 false      * 提交事务        ```sql        commit()        ```      * 回滚事务        ```sql        rollback;        ```</code></pre><ul><li><p>Statement（声明执行对象）</p><ul><li>Statement对象的作用就是用来执行SQL语句，而针对不同类型的SQL语句使用的方法也不一样</li></ul></li></ul><pre><code>* 执行DDL、DML语句  ```sql  int excuteUpdate(sql)  ```  * 返回值：DML语句影响的行数，DDL语句执行成功后可能返回0* 执行DQL语句  ```sql  ResultSet excuteQuery(sql)  ```  - 返回值： `ResultSet` 结果集对象</code></pre><ul><li><p>ResultSet（结果集对象）</p><ul><li>封装了SQL查询语句的结果，执行DQL语句后就会返回该对象<ul><li><code>ResultSet  executeQuery(sql)</code>：执行DQL 语句，返回 <code>ResultSet</code> 对象</li></ul></li></ul><ul><li><p><code>ResultSet</code> 对象提供了获取查询结果数据的方法</p><ul><li><p><code>boolean  next()</code>：将光标从当前位置向前移动一行，判断当前行是否为有效行</p></li><li><p>方法返回值：true （ 有效行，当前行有数据），false（无效行，当前行没有数据）</p></li><li><p><code>xxx  getXxx(参数)</code>：获取数据</p></li><li><p>xxx : 数据类型；如： <code>nt getInt(参数)</code> ；<code>String getString(参数)</code></p></li><li><p>int 类型的参数：列的编号，从1开始</p></li><li><p>String 类型的参数： 列的名称 </p></li></ul></li></ul></li></ul><ul><li><p>一开始光标指定于第一行前，当我们调用了 <code>next()</code> 方法后，光标就下移到第一行数据，并且方法返回 true，此时就可以通过 <code>getInt(&quot;id&quot;)</code> 获取当前行id字段的值，也可以通过 <code>getString(&quot;name&quot;)</code> 获取当前行name字段的值。如果想获取下一行的数据，继续调用 <code>next()</code>  方法，以此类推。</p></li><li><p>PreparedStatement</p><ul><li><p>预编译SQL语句并执行：预防SQL注入问题</p></li><li><p>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p></li><li><p>代码模拟SQL注入问题</p></li></ul><pre><code class="java">@Testpublic void testLogin() throws  Exception &#123;    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写    String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;    String username = &quot;root&quot;;    String password = &quot;1234&quot;;    Connection conn = DriverManager.getConnection(url, username, password);    // 接收用户输入 用户名和密码    String name = &quot;sjdljfld&quot;;    String pwd = &quot;&#39; or &#39;1&#39; = &#39;1&quot;;    String sql = &quot;select * from tb_user where username = &#39;&quot;+name+&quot;&#39; and password = &#39;&quot;+pwd+&quot;&#39;&quot;;    // 获取stmt对象    Statement stmt = conn.createStatement();    // 执行sql    ResultSet rs = stmt.executeQuery(sql);    // 判断登录是否成功    if(rs.next())&#123;        System.out.println(&quot;登录成功~&quot;);    &#125;else&#123;        System.out.println(&quot;登录失败~&quot;);    &#125;    //7. 释放资源    rs.close();    stmt.close();    conn.close();&#125;</code></pre><ul><li>上面代码是将用户名和密码拼接到sql语句中，拼接后的sql语句如下</li></ul><pre><code class="sql">select * from tb_user where username = &#39;sjdljfld&#39; and password = &#39;&#39;or &#39;1&#39; = &#39;1&#39;</code></pre><ul><li>获取 PreparedStatement 对象</li></ul></li></ul><pre><code class="java">// SQL语句中的参数值，使用？占位符替代String sql = &quot;select * from user where username = ? and password = ?&quot;;// 通过Connection对象获取，并传入对应的sql语句PreparedStatement pstmt = conn.prepareStatement(sql);</code></pre><ul><li><p>设置参数值：PreparedStatement 的sql语句中参数使用 ? 进行占位，在之前之前肯定要设置这些 ?  的值</p></li><li><p>PreparedStatement对象：<code>setXxx(参数1，参数2)</code>：给 ? 赋值</p></li><li><p>Xxx：数据类型 ； 如 setInt (参数1，参数2)</p></li><li><p>参数：</p></li><li><p>参数1： ？的位置编号，从1 开始</p><ul><li>参数2： ？的值</li></ul></li></ul><ul><li><p>执行SQL语句</p><ul><li><code>executeUpdate()</code>;  执行DDL语句和DML语句</li><li><code>executeQuery()</code>;  执行DQL语句</li><li>调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了</li></ul></li></ul><ul><li><p>使用PreparedStatement改进</p><pre><code class="java">@Testpublic void testPreparedStatement() throws  Exception &#123;  //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写  String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;  String username = &quot;root&quot;;  String password = &quot;1234&quot;;  Connection conn = DriverManager.getConnection(url, username, password);  // 接收用户输入 用户名和密码  String name = &quot;zhangsan&quot;;  String pwd = &quot;&#39; or &#39;1&#39; = &#39;1&quot;;  // 定义sql  String sql = &quot;select * from tb_user where username = ? and password = ?&quot;;  // 获取pstmt对象  PreparedStatement pstmt = conn.prepareStatement(sql);  // 设置？的值  pstmt.setString(1,name);  pstmt.setString(2,pwd);  // 执行sql  ResultSet rs = pstmt.executeQuery();  // 判断登录是否成功  if(rs.next())&#123;      System.out.println(&quot;登录成功~&quot;);  &#125;else&#123;      System.out.println(&quot;登录失败~&quot;);  &#125;  //7. 释放资源  rs.close();  pstmt.close();  conn.close();&#125;</code></pre></li><li><p>PreparedStatement 实际上是将特殊字符进行了转义，转义的SQL如下：</p><pre><code class="sql">select * from tb_user where username = &#39;sjdljfld&#39; and password = &#39;\&#39;or \&#39;1\&#39; = \&#39;1&#39;</code></pre></li><li><p>PreparedStatement原理</p><ul><li>预编译SQL，性能更高</li><li>防止SQL注入：将敏感字符进行转义</li></ul><ul><li>将sql语句发送到MySQL服务器端</li></ul></li></ul><pre><code>* MySQL服务端会对sql语句进行如下操作  * 检查SQL语句的语法是否正确。  * 编译SQL语句。将SQL语句编译成可执行的函数。  * 检查SQL和编译SQL花费的时间比执行SQL的时间还要长。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行。这样就提高了性能。  * 执行SQL语句</code></pre><ul><li><p>开启预编译功能：<code>useServerPrepStmts=true</code></p><pre><code class="sql">String url = &quot;jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true&quot;;</code></pre></li><li><p>配置MySQL执行日志（重启mysql服务后生效）</p><ul><li>在mysql配置文件（my.ini）中添加如下配置</li></ul><pre><code class="ini">log-output=FILEgeneral-log=1general_log_file=&quot;D:\mysql.log&quot;slow-query-log=1slow_query_log_file=&quot;D:\mysql_slow.log&quot;long_query_time=2</code></pre></li></ul><ul><li>PreparedStatement 小结<ul><li>在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li><li>执行时就不用再进行这些步骤了，速度更快</li><li>如果sql模板一样，则只需要进行一次检查、编译</li></ul></li></ul><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h4 id="数据库连接池简介"><a href="#数据库连接池简介" class="headerlink" title="数据库连接池简介"></a>数据库连接池简介</h4><ul><li>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</li><li>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</li><li>好处<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li><li>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的</li><li>而数据库使用了数据库连接池后，就能达到Connection对象的复用</li><li>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度</li></ul><h4 id="数据库连接池实现"><a href="#数据库连接池实现" class="headerlink" title="数据库连接池实现"></a>数据库连接池实现</h4><ul><li><p>标准接口：DataSource</p></li><li><p>官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能：</p><pre><code class="java">Connection getConnection()</code></pre></li></ul><ul><li>那么以后就不需要通过 <code>DriverManager</code> 对象获取 <code>Connection</code> 对象，而是通过连接池（DataSource）获取 <code>Connection</code> 对象。</li></ul><ul><li><p>常见的数据库连接池</p><ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul><p>我们现在使用更多的是Druid，它的性能比其他两个会好一些。</p></li><li><p>Druid（德鲁伊）</p><ul><li><p>Druid连接池是阿里巴巴开源的数据库连接池项目 </p></li><li><p>功能强大，性能优秀，是Java语言最好的数据库连接池之一</p></li></ul></li></ul><h4 id="Driud-使用"><a href="#Driud-使用" class="headerlink" title="Driud 使用"></a>Driud 使用</h4><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件：src 目录下新建 <code>druid.properties</code></li></ul><pre><code class="properties">driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=trueusername=rootpassword=1234# 初始化连接数量initialSize=5# 最大连接数maxActive=10# 最大等待时间maxWait=3000</code></pre><ul><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ul><pre><code class="java">/** * Druid数据库连接池演示 */public class DruidDemo &#123;    public static void main(String[] args) throws Exception &#123;        // 加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(&quot;jdbc-demo/src/druid.properties&quot;));        // 获取连接池对象        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);        // 获取数据库连接 Connection        Connection connection = dataSource.getConnection();        System.out.println(connection); //获取到了连接后就可以继续做其他操作了        //System.out.println(System.getProperty(&quot;user.dir&quot;));    &#125;&#125;</code></pre><ul><li>druid 配置详解</li></ul><table><thead><tr><th align="center">属性</th><th align="center">说明</th><th align="center">建议值</th></tr></thead><tbody><tr><td align="center">url</td><td align="center">数据库的jdbc连接地址。一般为连接oracle/mysql。示例如下：</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">mysql : jdbc:mysql://ip:port/dbname?option1&amp;option2&amp;…</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">oracle : jdbc:oracle:thin:@ip:port:oracle_sid</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">username</td><td align="center">登录数据库的用户名</td><td align="center"></td></tr><tr><td align="center">password</td><td align="center">登录数据库的用户密码</td><td align="center"></td></tr><tr><td align="center">initialSize</td><td align="center">启动程序时，在连接池中初始化多少个连接</td><td align="center">10-50已足够</td></tr><tr><td align="center">maxActive</td><td align="center">连接池中最多支持多少个活动会话</td><td align="center"></td></tr><tr><td align="center">maxWait</td><td align="center">程序向连接池中请求连接时,超过maxWait的值后，认为本次请求失败，即连接池</td><td align="center">100</td></tr><tr><td align="center"></td><td align="center">没有可用连接，单位毫秒，设置-1时表示无限等待</td><td align="center"></td></tr><tr><td align="center">minEvictableIdleTimeMillis</td><td align="center">池中某个连接的空闲时长达到 N 毫秒后, 连接池在下次检查空闲连接时，将</td><td align="center">见说明部分</td></tr><tr><td align="center"></td><td align="center">回收该连接,要小于防火墙超时设置</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">net.netfilter.nf_conntrack_tcp_timeout_established的设置</td><td align="center"></td></tr><tr><td align="center">timeBetweenEvictionRunsMillis</td><td align="center">检查空闲连接的频率，单位毫秒, 非正整数时表示不进行检查</td><td align="center"></td></tr><tr><td align="center">keepAlive</td><td align="center">程序没有close连接且空闲时长超过 minEvictableIdleTimeMillis,则会执</td><td align="center">true</td></tr><tr><td align="center"></td><td align="center">行validationQuery指定的SQL,以保证该程序连接不会池kill掉,其范围不超</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">过minIdle指定的连接个数。</td><td align="center"></td></tr><tr><td align="center">minIdle</td><td align="center">回收空闲连接时，将保证至少有minIdle个连接.</td><td align="center">与initialSize相同</td></tr><tr><td align="center">removeAbandoned</td><td align="center">要求程序从池中get到连接后, N 秒后必须close,否则druid 会强制回收该</td><td align="center">false,当发现程序有未</td></tr><tr><td align="center"></td><td align="center">连接,不管该连接中是活动还是空闲, 以防止进程不会进行close而霸占连接。</td><td align="center">正常close连接时设置为true</td></tr><tr><td align="center">removeAbandonedTimeout</td><td align="center">设置druid 强制回收连接的时限，当程序从池中get到连接开始算起，超过此</td><td align="center">应大于业务运行最长时间</td></tr><tr><td align="center"></td><td align="center">值后，druid将强制回收该连接，单位秒。</td><td align="center"></td></tr><tr><td align="center">logAbandoned</td><td align="center">当druid强制回收连接后，是否将stack trace 记录到日志中</td><td align="center">true</td></tr><tr><td align="center">testWhileIdle</td><td align="center">当程序请求连接，池在分配连接时，是否先检查该连接是否有效。(高效)</td><td align="center">true</td></tr><tr><td align="center">validationQuery</td><td align="center">检查池中的连接是否仍可用的 SQL 语句,drui会连接到数据库执行该SQL, 如果</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">正常返回，则表示连接可用，否则表示连接不可用</td><td align="center"></td></tr><tr><td align="center">testOnBorrow</td><td align="center">程序 <strong>申请</strong> 连接时,进行连接有效性检查（低效，影响性能）</td><td align="center">false</td></tr><tr><td align="center">testOnReturn</td><td align="center">程序 <strong>返还</strong> 连接时,进行连接有效性检查（低效，影响性能）</td><td align="center">false</td></tr><tr><td align="center">poolPreparedStatements</td><td align="center">缓存通过以下两个方法发起的SQL:</td><td align="center">true</td></tr><tr><td align="center"></td><td align="center">public PreparedStatement prepareStatement(String sql)</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">public PreparedStatement prepareStatement(String sql,</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">int resultSetType, int resultSetConcurrency)</td><td align="center"></td></tr><tr><td align="center">maxPoolPrepareStatementPerConnectionSize</td><td align="center">每个连接最多缓存多少个SQL</td><td align="center">20</td></tr><tr><td align="center">filters</td><td align="center">这里配置的是插件,常用的插件有:</td><td align="center">stat,wall,slf4j</td></tr><tr><td align="center"></td><td align="center">监控统计: filter:stat</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">日志监控: filter:log4j 或者 slf4j</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">防御SQL注入: filter:wall</td><td align="center"></td></tr><tr><td align="center">connectProperties</td><td align="center">连接属性。比如设置一些连接池统计方面的配置。</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">比如设置一些数据库连接属性:</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java 数据库连接，JDBC（Java Database Connectivity），是 Java 语言编程中与数据库连接的 API，封装了各种数据库访问的 API 和基础类库，支持多种数据库连接，也是 Java Web 技术核心的第一部分，我把整个学习过程分为 MySQL 基础、MySQL 高级、JDBC 和数据连接池四个部分，便于理解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="MySQL" scheme="http://blog.zhuangzhihao.top/tags/MySQL/"/>
    
    <category term="JDBC" scheme="http://blog.zhuangzhihao.top/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>机器学习和深度学习介绍及入门</title>
    <link href="http://blog.zhuangzhihao.top/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.zhuangzhihao.top/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-07T16:00:00.000Z</published>
    <updated>2022-05-05T12:33:23.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习（machine learning，ML）是一类强大的可以从经验中学习的技术。 通常采用观测数据或与环境交互的形式，机器学习算法会积累更多的经验，其性能也会逐步提高就在过去的五年里，深度学习给世界带来了惊喜，推动了计算机视觉、自然语言处理、自动语音识别、强化学习和统计建模等领域的快速发展。我选择动手学深度学习 v2 课程来开启机器学习之旅，并特别关注深度学习（deep learning，DL）的基础知识深度学习。</p></blockquote><a id="more"></a><h3 id="日常生活中的机器学习"><a href="#日常生活中的机器学习" class="headerlink" title="日常生活中的机器学习"></a>日常生活中的机器学习</h3><ul><li>Hey, Siri：收集一个包含音频样本的巨大的数据集（dataset），并对包含和不包含唤醒词的样本进行标记</li><li>通过机器学习算法，我们不需要设计一个“明确地”识别唤醒词的系统。 相反，我们定义一个灵活的程序算法，其输出由许多参数（parameter）决定。 然后我们使用数据集来确定当下的“最佳参数集”，这些参数通过某种性能度量来获取完成任务的最佳性能</li><li>把参数看作是旋钮，我们可以转动旋钮来调整程序的行为。 任一调整参数后的程序，我们称为模型（model）</li><li>通过操作参数而生成的所有不同程序（输入-输出映射）的集合称为“模型族”</li><li>使用数据集来选择参数的元程序被称为学习算法（learning algorithm）</li><li>在我们开始用机器学习算法解决问题之前，我们必须精确地定义问题，确定输入（input）和输出（output）的性质，并选择合适的模型族</li><li>在机器学习中，学习（learning）是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据训练（train）我们的模型</li><li>训练过程通常包含如下步骤：<ol><li>从一个随机初始化参数的模型开始，这个模型基本毫不“智能”</li><li>获取一些数据样本（例如，音频片段以及对应的{是,否}{是,否}标签）</li><li>调整参数，使模型在这些样本中表现得更好</li><li>重复第2步和第3步，直到模型在任务中的表现令你满意</li></ol></li></ul><h3 id="机器学习的关键组件"><a href="#机器学习的关键组件" class="headerlink" title="机器学习的关键组件"></a>机器学习的关键组件</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul><li>每个数据集由一个个样本（example, sample）组成，大多时候，它们遵循独立同分布（independently and identically distributed, i.i.d.）</li><li> 样本有时也叫做数据点（data point）或者数据实例（data instance），通常每个样本由一组称为特征（features，或<em>协变量</em>（covariates））的属性组成，机器学习模型会根据这些属性进行预测</li><li>在监督学习问题中，要预测的是一个特殊的属性，它被称为标签（label，或目标（target））</li><li>当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的维数（dimensionality）。 固定长度的特征向量是一个方便的属性，它有助于我们量化学习大量样本</li><li>然而，并不是所有的数据都可以用“固定长度”的向量表示，例如文本数据。与传统机器学习方法相比，深度学习的一个主要优势是可以处理不同长度的数据</li><li>一般来说，我们拥有的数据越多，通常可以训练出更强大的模型，从而减少对预先设想假设的依赖。 数据集的由小变大为现代深度学习的成功奠定基础。 在没有大数据集的情况下，许多令人兴奋的深度学习模型黯然失色。 就算一些深度学习模型在小数据集上能够工作，但其效能并不比传统方法高</li><li>仅仅拥有海量的数据是不够的，我们还需要正确的数据。 如果数据中充满了错误，或者如果数据的特征不能预测任务目标，那么模型很可能无效</li><li>此外，糟糕的预测性能甚至会加倍放大事态的严重性。 在一些敏感应用中，如预测性监管、简历筛选和用于贷款的风险模型，我们必须特别警惕垃圾数据带来的后果。一种常见的问题来自不均衡的数据集，比如在一个有关医疗的训练数据集中，某些人群没有样本表示</li><li>当数据不具有充分代表性，甚至包含了一些社会偏见时，模型就很有可能有偏见</li></ul><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><ul><li>大多数机器学习会涉及到数据的转换。 比如，建立一个“摄取照片并预测笑脸”的系统</li><li>深度学习与经典方法的区别主要在于：前者关注的功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换，因此被称为深度学习（deep learning）</li></ul><h4 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h4><ul><li>在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，我们称之为目标函数（objective function）</li><li>我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为损失函数（loss function，或cost function）。 但这只是一个惯例，你也可以取一个新的函数，优化到它的最高点。 这两个函数本质上是相同的，只是翻转一下符号</li><li>当任务在试图预测数值时，最常见的损失函数是平方误差（squared error），即预测值与实际值之差的平方</li><li>当试图解决分类问题时，最常见的目标函数是最小化错误率，即预测与实际情况不符的样本比例</li><li>有些目标函数（如平方误差）很容易被优化，有些目标（如错误率）由于不可微性或其他复杂性难以直接优化。 在这些情况下，通常会优化替代目标</li><li>通常，损失函数是根据模型参数定义的，并取决于数据集。 在一个数据集上，我们通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称为训练数据集（training dataset，或称为训练集（training set））</li><li>然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的效能，这里的“新数据集”通常称为测试数据集（test dataset，或称为测试集（test set））</li><li>综上所述，我们通常将可用数据集分成两部分：训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。 然后我们观察模型在这两部分数据集的效能</li><li>换言之，测试性能可能会显著偏离训练性能。 当一个模型在训练集上表现良好，但不能推广到测试集时，我们说这个模型是“过拟合”（overfitting）的</li></ul><h4 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h4><ul><li>一旦我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，我们接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数</li><li>深度学习中，大多流行的优化算法通常基于一种基本方法——梯度下降（gradient descent）。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果你仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数</li></ul><h3 id="各种机器学习问题"><a href="#各种机器学习问题" class="headerlink" title="各种机器学习问题"></a>各种机器学习问题</h3><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><ul><li>监督学习（supervised learning）擅长在“给定输入特征”的情况下预测标签。 每个“特征-标签”对都称为一个样本（example）。 有时，即使标签是未知的，样本也可以指代输入特征。 我们的目标是生成一个模型，能够将任何输入特征映射到标签，即预测</li><li>监督学习之所以发挥作用，是因为在训练参数时，我们为模型提供了一个数据集，其中每个样本都有真实的标签。 用概率论术语来说，我们希望预测“估计给定输入特征的标签”的条件概率</li><li>虽然监督学习只是几大类机器学习问题之一，但是在工业中，大部分机器学习的成功应用都是监督学习。 这是因为在一定程度上，许多重要的任务可以清晰地描述为：在给定一组特定的可用数据的情况下，估计未知事物的概率</li><li>监督学习的学习过程：<ol><li>首先，从已知大量数据样本中随机选取一个子集，为每个样本获取基本的真实标签</li><li>有时，这些样本已有标签（例如，患者是否在下一年内康复？）； 有时，我们可能需要人工标记数据（例如，将图像分类）。这些输入和相应的标签一起构成了训练数据集</li><li>随后，我们选择有监督的学习算法，它将训练数据集作为输入，并输出一个“完成学习模型”</li><li>最后，我们将之前没见过的样本特征放到这个“完成学习模型”中，使用模型的输出作为相应标签的预测</li></ol></li><li>即使使用简单的描述“给定输入特征的预测标签”，监督学习也可以采取多种形式的模型，并且需要大量不同的建模决策，这取决于输入和输出的类型、大小和数量</li><li>回归<ul><li>回归（regression）是最简单的监督学习任务之一</li><li>回归问题本质上是输出决定的。 假设你在市场上寻找新房子，你可能需要估计一栋房子的公平市场价值。 销售价格，即标签，是一个数值。 当标签取任意数值时，我们称之为回归问题。 我们的目标是生成一个模型，它的预测非常接近实际标签值</li></ul></li><li>分类<ul><li>虽然回归模型可以很好地解决“有多少？”的问题，但是解决不了“哪一个？”的问题，这种问题叫做分类（classification）问题</li><li>在分类问题中，我们希望模型能够预测样本属于哪个类别（category，正式称为类（class））</li><li>最简单的分类问题是只有两类，我们称之为“二元分类”</li><li>在回归中，我们训练一个回归函数来输出一个数值； 而在分类中，我们训练一个分类器，它的输出即为预测的类别</li><li>可以试着用概率语言来理解模型。 给定一个样本特征，我们的模型为每个可能的类分配一个概率，比如，猫狗分类器可能会输出图像是猫的概率为0.9，即分类器90%确定图像描绘的是一只猫。 预测类别的概率的大小传达了一种模型的不确定性</li><li>当我们有两个以上的类别时，我们把这个问题称为多元分类（multiclass classification）问题，常见的例子包括手写字符识别 </li><li>与解决回归问题不同，分类问题的常见损失函数被称为交叉熵（cross-entropy）</li><li>最常见的类别不一定是你将用于决策的类别，或许不确定风险的影响远远大于收益。 因此，我们需要将“预期风险”作为损失函数。 也就是说，我们需要将结果的概率乘以与之相关的收益（或伤害）</li><li>有一些分类任务的变体可以用于寻找层次结构，层次结构假定在许多类之间存在某种关系。 因此，并不是所有的错误都是均等的。 我们宁愿错误地分入一个相关的类别，也不愿错误地分入一个遥远的类别，这通常被称为层次分类（hierarchical classification）</li></ul></li><li>标记问题<ul><li>学习预测不相互排斥的类别的问题称为多标签分类（multi-label classification）</li><li>举个例子，人们在技术博客上贴的标签，比如“机器学习”、“技术”、“小工具”、“编程语言”、“Linux”、“云计算”、“AWS”。 一篇典型的文章可能会用5-10个标签，因为这些概念是相互关联的。 关于“云计算”的帖子可能会提到“AWS”，而关于“机器学习”的帖子也可能涉及“编程语言”</li></ul></li><li>搜索<ul><li>有时，我们不仅仅希望输出为一个类别或一个实值。 在信息检索领域，我们希望对一组项目进行排序</li><li>以网络搜索为例，我们的目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。 搜索结果的排序也十分重要，我们的学习算法需要输出有序的元素子集</li><li>该问题的一种可能的解决方案：首先为集合中的每个元素分配相应的相关性分数，然后检索评级最高的元素。PageRank，谷歌搜索引擎背后最初的秘密武器就是这种评分系统的早期例子</li><li>如今，搜索引擎使用机器学习和用户行为模型来获取网页相关性得分，很多学术会议也致力于这一主题</li></ul></li><li>推荐系统<ul><li>另一类与搜索和排名相关的问题是推荐系统（recommender system），它的目标是向特定用户进行“个性化”推荐</li><li>简单来说，推荐系统会为“给定用户和物品”的匹配性打分，这个“分数”可能是估计的评级或购买的概率。 由此，对于任何给定的用户，推荐系统都可以检索得分最高的对象集，然后将其推荐给用户。工业生产的推荐系统还要先进得多，它会将详细的用户活动和项目特征考虑在内</li><li>尽管推荐系统具有巨大的应用价值，但单纯用它作为预测模型仍存在一些缺陷。首先，用户更倾向于给他们感觉强烈的事物打分，此外，推荐系统有可能形成反馈循环</li></ul></li><li>序列学习<ul><li>以上大多数问题都具有固定大小的输入和产生固定大小的输出，在这些情况下，模型只会将输入作为生成输出的“原料”，而不会“记住”输入的具体内容</li><li>但是如果输入是连续的，我们的模型可能就需要拥有“记忆”功能。 比如，处理视频片段时，每个视频片段可能由不同数量的帧组成，通过前一帧的图像，我们可能对后一帧中发生的事情更有把握。 语言也是如此，机器翻译的输入和输出都为文字序列</li><li>序列学习的实例，是机器学习最令人兴奋的应用之一。 序列学习需要摄取输入序列或预测输出序列，或两者兼而有之。 具体来说，输入和输出都是可变长度的序列，例如机器翻译和从语音中转录文本</li><li>标记和解析：这涉及到用属性注释文本序列。 换句话说，输入和输出的数量基本上是相同的。 例如，我们可能想知道动词和主语在哪里，或者，我们可能想知道哪些单词是命名实体。 通常，目标是基于结构和语法假设对文本进行分解和注释，以获得一些注释</li><li>自动语音识别：在语音识别中，输入序列是说话人的录音，输出序列是说话人所说内容的文本记录。 它的挑战在于，与文本相比，音频帧多得多，也就是说，音频和文本之间没有1:1的对应关系，因为数千个样本可能对应于一个单独的单词。 这也是“序列到序列”的学习问题，其中输出比输入短得多</li><li>文本到语音：这与自动语音识别相反。 换句话说，输入是文本，输出是音频文件。 在这种情况下，输出比输入长得多。 虽然人类很容易识判断发音别扭的音频文件，但这对计算机来说并不是那么简单</li><li>机器翻译：在语音识别中，输入和输出的出现顺序基本相同。 而在机器翻译中，颠倒输入和输出的顺序非常重要。 换句话说，虽然我们仍将一个序列转换成另一个序列，但是输入和输出的数量以及相应序列的顺序大都不会相同</li></ul></li></ul><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><ul><li>监督学习向模型提供巨大数据集，每个样本包含特征和相应标签值，准确地告诉模型在每种情况下应该做什么，直到模型学会从情况到行动的映射</li><li>如果没有十分具体的目标，就需要“自发”地去学习了，我们称这类数据中不含有“目标”的机器学习问题为无监督学习（unsupervised learning）</li><li>无监督学习可以回答什么样的问题<ul><li>聚类（clustering）问题：没有标签的情况下，我们是否能给数据分类。比如，给定一组照片，把它们分成风景照片、狗、婴儿、猫和山峰的照片</li><li>主成分分析（principal component analysis）问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性。比如，一个球的运动轨迹可以用球的速度、直径和质量来描述</li><li>因果关系（causality）和概率图模型（probabilistic graphical models）问题：我们能否描述观察到的许多数据的根本原因。例如，如果我们有关于房价、污染、犯罪、地理位置、教育和工资的人口统计数据，我们能否简单地根据经验数据发现它们之间的关系</li><li>生成对抗性网络（generative adversarial networks）：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的非结构化数据。潜在的统计机制是检查真实和虚假数据是否相同的测试，它是无监督学习的另一个重要而令人兴奋的领域</li></ul></li></ul><h4 id="与环境互动"><a href="#与环境互动" class="headerlink" title="与环境互动"></a>与环境互动</h4><ul><li>不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。 这里所有学习都是在算法与环境断开后进行的，被称为离线学习（offline learning）</li><li>离线学习可以孤立地进行模式识别，而不必分心于其他问题，但缺点是，解决的问题相当有限</li><li>你可能会期望人工智能不仅能够做出预测，而且能够与真实环境互动。 与预测不同，“与真实环境互动”实际上会影响环境。 这里的人工智能是“智能代理”，而不仅是“预测模型”。 因此，我们必须考虑到它的行为可能会影响未来的观察结果</li><li>考虑“与真实环境互动”将打开一整套新的建模问题<ul><li>环境还记得我们以前做过什么吗？</li><li>环境是否有助于我们建模？例如，用户将文本读入语音识别器。</li><li>环境是否想要打败模型？例如，一个对抗性的设置，如垃圾邮件过滤或玩游戏？</li><li>环境是否重要？</li><li>当训练和测试数据不同时，环境是否变化？这是分布偏移（distribution shift）的问题。例如，未来的数据是否总是与过去相似，还是随着时间的推移会发生变化？是自然变化还是响应我们的自动化工具而发生变化？</li></ul></li></ul><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><ul><li>如果你对使用机器学习开发与环境交互并采取行动感兴趣，那么你最终可能会专注于强化学习（reinforcement learning）。 这可能包括应用到机器人、对话系统，甚至开发视频游戏的人工智能（AI）</li><li>深度强化学习（deep reinforcement learning）将深度学习应用于强化学习的问题，是非常热门的研究领域</li><li>我们可以将任何监督学习问题转化为强化学习问题。 假设我们有一个分类问题，我们可以创建一个强化学习agent，每个分类对应一个“动作”。 然后，我们可以创建一个环境，该环境给予agent的奖励。 这个奖励与原始监督学习问题的损失函数是一致的</li><li>在监督学习中，我们总是希望输入与正确的标签相关联。 但在强化学习中，我们并不假设环境告诉agent每个观测的最优动作。 一般来说，agent只是得到一些奖励。</li><li>环境甚至可能不会告诉我们是哪些行为导致了奖励，因此，强化学习者必须处理学分分配（credit assignment）问题：决定哪些行为是值得奖励的，哪些行为是需要惩罚的</li><li>强化学习可能还必须处理部分可观测性问题。 也就是说，当前的观察结果可能无法阐述有关当前状态的所有信息</li><li>最后，在任何时间点上，强化学习agent可能知道一个好的策略，但可能有许多更好的策略从未尝试过的。 强化学习agent必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识）</li><li>环境可以是完整观察到的，也可以是部分观察到的，解释所有这些复杂性可能会对研究人员要求太高。 此外，并不是每个实际问题都表现出所有这些复杂性。 因此，学者们研究了一些特殊情况下的强化学习问题</li><li>当环境可被完全观察到时，我们将强化学习问题称为马尔可夫决策过程（markov decision process）。 当状态不依赖于之前的操作时，我们称该问题为上下文赌博机（contextual bandit problem）。 当没有状态，只有一组最初未知回报的可用动作时，这个问题就是经典的多臂赌博机（multi-armed bandit problem）</li></ul><h3 id="深度学习的发展"><a href="#深度学习的发展" class="headerlink" title="深度学习的发展"></a>深度学习的发展</h3><ul><li>为了解决各种各样的机器学习问题，深度学习提供了强大的工具。 虽然许多深度学习方法都是最近的才有重大突破，但使用数据和神经网络编程的核心思想已经研究了几个世纪</li><li>伯努利分布是以雅各布•伯努利（1654–1705）命名的。 而高斯分布是由卡尔•弗里德里希•高斯（1777—1855）发现的， 他发明了最小均方算法，至今仍用于解决从保险计算到医疗诊断的许多问题</li><li>随着数据的收集和可获得性，统计数据真正实现了腾飞。 罗纳德·费舍尔（1890-1962）对统计理论和在遗传学中的应用做出了重大贡献。 他的许多算法（如线性判别分析）和公式（如费舍尔信息矩阵）至今仍被频繁使用</li><li>机器学习的第二个影响来自克劳德·香农(1916–2001)的信息论和艾伦·图灵（1912-1954）的计算理论。 图灵在他著名的论文《计算机器与智能》中提出了“机器能思考吗？”的问题（图灵测试）</li><li>唐纳德·赫布 (1904–1985)开创性的著作《行为的组织》提出神经元通过积极强化学习，是Rosenblatt感知器学习算法的原型，被称为“赫布学习”。 这个算法也为当今深度学习的许多随机梯度下降算法奠定了基础：强化期望行为和减少不良行为，从而在神经网络中获得良好的参数设置</li><li>神经网络（neural networks）的得名源于生物灵感。 一个多世纪以来（追溯到1873年亚历山大·贝恩和1890年詹姆斯·谢林顿的模型），研究人员一直试图组装类似于相互作用的神经元网络的计算电路。 随着时间的推移，对生物学的解释变得不再肤浅，但这个名字仍然存在。 其核心是当今大多数网络中都可以找到的几个关键原则：<ul><li>线性和非线性处理单元的交替，通常称为层（layers）。</li><li>使用链式规则（也称为反向传播（backpropagation））一次性调整网络中的全部参数</li></ul></li><li>神经网络的研究从1995年左右一直开始停滞不前，直到到2005年才稍有起色。 这主要是因为两个原因。 首先，训练网络（在计算上）非常昂贵， 其次，数据集相对较小</li><li>大约2010年开始，那些在计算上看起来不可行的神经网络算法变得热门起来，实际上是以下两点导致的： 其一，随着互联网的公司的出现，为数亿在线用户提供服务，大规模数据集变得触手可及。 另外，廉价又高质量的传感器、廉价的数据存储（克莱德定律）以及廉价计算（摩尔定律）的普及，特别是GPU的普及，使大规模算力唾手可得</li><li>很明显，随机存取存储器没有跟上数据增长的步伐。 与此同时，算力的增长速度已经超过了现有数据的增长速度。 这意味着统计模型需要提高内存效率（这通常是通过添加非线性来实现的）</li><li>同时由于计算预算的增加，能够花费更多时间来优化这些参数。 因此，机器学习和统计的关注点从（广义的）线性模型和核方法转移到了深度神经网络。 这也造就了许多深度学习的中流砥柱，如多层感知机、卷积神经网络、长短期记忆网络和Q学习，在相对休眠了相当长一段时间之后，在过去十年中被“重新发现</li></ul><h3 id="深度学习的成功案例"><a href="#深度学习的成功案例" class="headerlink" title="深度学习的成功案例"></a>深度学习的成功案例</h3><ul><li>感知 -&gt; 推理 -&gt; 知识 -&gt; 规划：自然语言处理 -&gt; 计算机视觉 -&gt; 深度学习</li><li>深度学习应用：图片地图、样式迁移、人脸合成、文字生成图片、文字生成、无人驾驶</li><li>案例研究：广告点击<ul><li>触发 -&gt; 点击率预估 -&gt; 排序（$点击率 * 竞价$）</li><li>预测：特征提取 -&gt; 模型 -&gt; 点击率预测</li><li>训练：训练数据（过去广告展现与用户点击） -&gt; 特征和用户点击 -&gt; 模型</li><li>领域专家：点击 -&gt; 展现</li><li>数据科学家：数据 -&gt; 模型（模型控制广告展现，这些用来训练新的模型）</li><li>AI 专家：提升模型精度和性能</li></ul></li></ul><h3 id="深度学习的特点"><a href="#深度学习的特点" class="headerlink" title="深度学习的特点"></a>深度学习的特点</h3><ul><li>机器学习可以使用数据来学习输入和输出之间的转换，例如在语音识别中将音频转换为文本。 在这样做时，通常需要以适合算法的方式表示数据，以便将这种表示转换为输出</li><li>深度学习是“深度”的，模型学习了许多“层”的转换，每一层提供一个层次的表示。 例如，靠近输入的层可以表示数据的低级细节，而接近分类输出的层可以表示用于区分的更抽象的概念。 由于表示学习（representation learning）目的是寻找表示本身，因此深度学习可以称为“多级表示学习”</li><li>多层模型能够以以前的工具所不能的方式处理低级的感知数据。 毋庸置疑，深度学习方法中最显著的共同点是使用端到端训练。 也就是说，与其基于单独调整的组件组装系统，不如构建系统，然后联合调整它们的性能。</li><li>在过去的日子里，将机器学习应用于这些问题的关键部分是提出人工设计的特征工程方法，将数据转换为某种适合于浅层模型的形式。 然而，与一个算法自动执行的数百万个选择相比，人类通过特征工程所能完成的事情很少。 当深度学习开始时，这些特征抽取器被自动调整的滤波器所取代，产生了更高的精确度</li><li>因此，深度学习的一个关键优势是它不仅取代了传统学习管道末端的浅层模型，而且还取代了劳动密集型的特征工程过程。 此外，通过取代大部分特定领域的预处理，深度学习消除了以前分隔计算机视觉、语音识别、自然语言处理、医学信息学和其他应用领域的许多界限，为解决各种问题提供了一套统一的工具</li><li>除了端到端的训练，我们正在经历从参数统计描述到完全非参数模型的转变。 当数据稀缺时，人们需要依靠简化对现实的假设来获得有用的模型。 当数据丰富时，可以用更准确地拟合实际情况的非参数模型来代替。</li><li>现在人们可以借助于相关偏微分方程的数值模拟，而不是用手来求解电子行为的参数近似。这导致了更精确的模型，尽管常常以牺牲可解释性为代价。与以前工作的另一个不同之处是接受次优解，处理非凸非线性优化问题，并且愿意在证明之前尝试。 这种在处理统计问题上新发现的经验主义，加上人才的迅速涌入，导致了实用算法的快速进步</li></ul><h3 id="安装动手学深度学习-v2"><a href="#安装动手学深度学习-v2" class="headerlink" title="安装动手学深度学习 v2"></a>安装动手学深度学习 v2</h3><ul><li><p>安装环境：Ubuntu 18.04 + build-essential + Python 3.8 + </p></li><li><p>安装 Miniconda 到 <code>\root\miniconda3</code></p><pre><code class="bash">wget https://repo.anaconda.com/miniconda/Miniconda3-py38_4.11.0-Linux-x86_64.shbash Miniconda3-py38_4.11.0-Linux-x86_64.sh</code></pre></li><li><p>安装其他软件包</p><pre><code class="bash">pip install jupyter d2l torch torchvision</code></pre></li><li><p>拷贝 Jupyter 记事本</p><pre><code class="bash">wget https://zh-v2.d2l.ai/d2l-zh.zipgit clone git@github.com:d2l-ai/d2l-zh-pytorch-slides.git</code></pre></li><li><p>远程运行 Jupyter Notebook</p><pre><code class="bash">jupyter notebook --allow-root</code></pre></li><li><p>将远端 localhost 映射到本地 localhost（端口 :8888）</p><pre><code class="bash">ssh -L8888:localhost:8888 root@106.15.200.147</code></pre></li><li><p>安装 jupyter 插件</p><pre><code class="bash">pip install rise</code></pre></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>机器学习研究计算机系统如何利用经验（通常是数据）来提高特定任务的性能。它结合了统计学、数据挖掘和优化的思想。通常，它是被用作实现人工智能解决方案的一种手段</li><li>表示学习作为机器学习的一类，其研究的重点是如何自动找到合适的数据表示方式。深度学习是通过学习多层次的转换来进行的多层次的表示学习</li><li>深度学习不仅取代了传统机器学习的浅层模型，而且取代了劳动密集型的特征工程</li><li>最近在深度学习方面取得的许多进展，大都是由廉价传感器和互联网规模应用所产生的大量数据，以及（通过GPU）算力的突破来触发的</li><li>整个系统优化是获得高性能的关键环节。有效的深度学习框架的开源使得这一点的设计和实现变得非常容易</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机器学习（machine learning，ML）是一类强大的可以从经验中学习的技术。 通常采用观测数据或与环境交互的形式，机器学习算法会积累更多的经验，其性能也会逐步提高就在过去的五年里，深度学习给世界带来了惊喜，推动了计算机视觉、自然语言处理、自动语音识别、强化学习和统计建模等领域的快速发展。我选择动手学深度学习 v2 课程来开启机器学习之旅，并特别关注深度学习（deep learning，DL）的基础知识深度学习。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://blog.zhuangzhihao.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>macOS + Ubuntu 实现远程开发配置</title>
    <link href="http://blog.zhuangzhihao.top/Ubuntu%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.zhuangzhihao.top/Ubuntu%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-05-23T10:37:31.975Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>刚刚续费了一年的阿里云轻量应用服务器，打算把大多数的开发环境放到服务器上，实现远程开发。我使用的是 macOS Monterey 和基于 Ubuntu 18.04 的 LNMP 镜像系统，IDE 选取 Visual Studio Code 和 IntelliJ IDEA 进行开发学习。</p></blockquote><a id="more"></a><h3 id="一、服务器镜像信息"><a href="#一、服务器镜像信息" class="headerlink" title="一、服务器镜像信息"></a>一、服务器镜像信息</h3><p>我使用的是阿里云轻量应用服务器提供的 LNMP 7.4 镜像，该镜像为LNMP（Ubuntu18.04 64位+Nginx+MySQL5.7+PHP5.3～8.0切换）架构，jemalloc优化内存管理，脚本菜单式添加Nginx虚拟主机绑定，并支持内网OSS备份功能，是常见的搭建Web应用所需的环境，支持高并发性能。</p><p>应用程序安装信息：</p><ul><li><p>Nginx 1.18：<code>/usr/local/nginx</code></p></li><li><p>PHP 7.4：<code>/usr/local/php</code></p></li><li><p>MySQL 5.7：<code>/usr/local/mysql</code></p></li><li><p>数据库地址：127.0.0.1:3306 </p></li><li><p>网站根目录：<code>/data/wwwroot</code></p></li></ul><p>查询数据库和 FTP 密码</p><pre><code class="bash">sudo cat /root/ReadMe</code></pre><h3 id="二、Ubuntu-系统配置"><a href="#二、Ubuntu-系统配置" class="headerlink" title="二、Ubuntu 系统配置"></a>二、Ubuntu 系统配置</h3><p>依赖源设置：</p><pre><code class="bash">mv /etc/apt/sources.list&#123;,bak&#125; #备份sources.listcat &gt; /etc/apt/sources.list &lt;&lt; EOFdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverseEOFapt update</code></pre><p>在防火墙添加规则放行 21、20000/30000 端口，允许通过 FTP 连接。</p><h3 id="三、搭建开发环境"><a href="#三、搭建开发环境" class="headerlink" title="三、搭建开发环境"></a>三、搭建开发环境</h3><p>C/C++ 开发环境：</p><pre><code class="bash">sudo apt-get install build-essential</code></pre><p>Python3 开发环境：</p><pre><code class="bash">python3 --version  sudo apt-get install python3-pip</code></pre><p>Java 开发环境：</p><pre><code class="bash">sudo apt install openjdk-11-jdk</code></pre><p>Go 开发环境：</p><pre><code class="bash">sudo wget -c https://dl.google.com/go/go1.15.6.linux-amd64.tar.gz -O - | sudo tar -xz -C /usr/localvim /etc/profile</code></pre><p>添加以下内容：</p><pre><code class="bash">export GOROOT=/usr/local/goexport GOPATH=/tufei/code/goexport GOBIN=$GOPATH/binexport PATH=$GOPATH:$GOBIN:$GOROOT/bin:$PATH</code></pre><p>保存：</p><pre><code class="bash">source  /etc/profilego version</code></pre><p>Git 安装配置：</p><pre><code class="bash">sudo apt-get install gitgit config --global user.name &quot;Zhuang Zhihao&quot;git config --global user.email &quot;bezhuang@outlook.com&quot;ssh-keygen -t rsa -C &quot;bezhuang@outlook.com&quot;cat /root/.ssh/id_rsa.pub</code></pre><p>提交公钥到 Github 或其他 Git 仓库。</p><h3 id="四、管理服务"><a href="#四、管理服务" class="headerlink" title="四、管理服务"></a>四、管理服务</h3><p>Nginx：</p><pre><code class="bash">service nginx &#123;start|stop|status|restart|reload|configtest&#125;</code></pre><p>MySQL：</p><pre><code class="bash">service mysqld &#123;start|stop|restart|reload|status&#125;</code></pre><p>PHP：</p><pre><code class="bash">service php-fpm &#123;start|stop|restart|reload|status&#125;</code></pre><p>Pure-Ftpd：</p><pre><code class="bash">service pureftpd &#123;start|stop|restart|status&#125;</code></pre><p>Redis：</p><pre><code class="bash">service redis-server &#123;start|stop|status|restart&#125;</code></pre><p>Memcached：</p><pre><code class="bash">service memcached &#123;start|stop|status|restart|reload&#125;</code></pre><h3 id="五、虚拟主机管理"><a href="#五、虚拟主机管理" class="headerlink" title="五、虚拟主机管理"></a>五、虚拟主机管理</h3><p>添加虚拟主机：</p><pre><code class="bash">cd /root/oneinstack./vhost.sh</code></pre><p>删除虚拟主机：</p><pre><code class="bash">./vhost.sh --del</code></pre><h3 id="六、本地开发环境"><a href="#六、本地开发环境" class="headerlink" title="六、本地开发环境"></a>六、本地开发环境</h3><p>使用 Visual Studio Code 中的 Remote -SSH 插件连接，</p><p>使用 Termius 进行 SSH 和 SFTP 连接，</p><p>博客现仍使用 Hexo，Typora 软件用于编写博客文章，uPic 软件用于上传图床。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;刚刚续费了一年的阿里云轻量应用服务器，打算把大多数的开发环境放到服务器上，实现远程开发。我使用的是 macOS Monterey 和基于 Ubuntu 18.04 的 LNMP 镜像系统，IDE 选取 Visual Studio Code 和 IntelliJ IDEA 进行开发学习。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="其他开发" scheme="http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Linux" scheme="http://blog.zhuangzhihao.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言基础知识总结</title>
    <link href="http://blog.zhuangzhihao.top/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/"/>
    <id>http://blog.zhuangzhihao.top/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/</id>
    <published>2022-02-12T16:00:00.000Z</published>
    <updated>2022-05-23T10:33:38.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Go 语言是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，它用批判吸收的眼光，融合 C 语言、Java 等众家之长，将简洁、高效演绎得淋漓尽致。Golang非常适合用来做网络并发方面的服务，比如消息推送、监控、容器等。初次学习我选择的是 <a href="https://go-zh.org/">Go 编程语言</a>指南，指南涵盖了该语言的大部分重要特性，放在以下为所记笔记，另附有随堂代码放在 <a href="https://github.com/Bezhuang/Learn-CS/tree/main/Learn%20Programming/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85">Github 仓库</a>中，可供参考。</p></blockquote><a id="more"></a><h3 id="包、变量和函数"><a href="#包、变量和函数" class="headerlink" title="包、变量和函数"></a>包、变量和函数</h3><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><ul><li><p>每个 Go 程序都是由包构成的</p></li><li><p>程序从 <code>main</code> 包开始运行</p><pre><code class="go">package main</code></pre></li></ul><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><ul><li><p>此代码用圆括号组合了导入，这是“分组”形式的导入语句</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;math&quot;)</code></pre></li><li><p>当然也可以编写多个导入语句，不过使用分组导入语句是更好的形式</p></li></ul><h4 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h4><ul><li><p>在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，<code>Pizza</code> 就是个已导出名，<code>Pi</code> 也同样，它导出自 <code>math</code> 包</p><pre><code class="go">func main() &#123;    fmt.Println(math.Pi)&#125;</code></pre></li><li><p>在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问</p></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li><p>函数可以没有参数或接受多个参数</p><pre><code class="go">// add 接受两个 int 类型的参数func add(x int, y int) int &#123;    return x + y&#125;</code></pre></li><li><p>注意类型在变量名 <strong>之后</strong></p></li><li><p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略</p><pre><code class="go">func add(x, y int) int &#123;    return x + y&#125;</code></pre></li></ul><h4 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h4><ul><li><p>函数可以返回任意数量的返回值</p></li><li><p><code>swap</code> 函数返回了两个字符串</p><pre><code class="go">func swap(x, y string) (string, string) &#123;    return y, x&#125;</code></pre></li></ul><h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><ul><li><p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量</p></li><li><p>返回值的名称应当具有一定的意义，它可以作为文档使用</p></li><li><p>没有参数的 <code>return</code> 语句返回已命名的返回值。也就是 <code>直接</code> 返回</p></li><li><p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性</p><pre><code class="go">func split(sum int) (x, y int) &#123;    x = sum * 4 / 9    y = sum - x    return&#125;</code></pre></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</p></li><li><p><code>var</code> 语句可以出现在包或函数级别</p><pre><code class="go">var c, python, java boolfunc main() &#123;    var i int    fmt.Println(i, c, python, java)&#125;</code></pre></li></ul><h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><ul><li><p>变量声明可以包含初始值，每个变量对应一个</p></li><li><p>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型</p><pre><code class="go">var i, j int = 1, 2func main() &#123;    var c, python, java = true, false, &quot;no!&quot;    fmt.Println(i, j, c, python, java)&#125;</code></pre></li></ul><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><ul><li><p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明</p></li><li><p>函数外的每个语句都必须以关键字开始（<code>var</code>, <code>func</code> 等等），因此 <code>:=</code> 结构不能在函数外使用</p><pre><code class="go">func main() &#123;    var i, j int = 1, 2    k := 3    c, python, java := true, false, &quot;no!&quot;    fmt.Println(i, j, k, c, python, java)&#125;</code></pre></li></ul><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul><li><p>Go 的基本类型有</p><pre><code>boolstringint  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名，表示一个 Unicode 码点float32 float64complex64 complex128</code></pre></li><li><p>同导入语句一样，变量声明也可以“分组”成一个语法块</p><pre><code class="go">var (    ToBe   bool       = false    MaxInt uint64     = 1&lt;&lt;64 - 1    z      complex128 = cmplx.Sqrt(-5 + 12i))</code></pre></li><li><p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽</p></li><li><p>当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型</p></li></ul><h4 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h4><ul><li>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong><ul><li>数值类型零值为 <code>0</code></li><li>布尔类型零值为 <code>false</code></li><li>字符串零值为 <code>&quot;&quot;</code>（空字符串）</li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li><p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p><pre><code class="go">i := 42f := float64(i)u := uint(f)</code></pre></li><li><p>与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换</p><pre><code class="go">var i int = 42var f float64 = float64(i)var u uint = uint(f)</code></pre></li></ul><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><ul><li><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法）</p></li><li><p>变量的类型由右值推导得出</p></li><li><p>当右值声明了类型时，新变量的类型与其相同：</p><pre><code class="go">var i intj := i // j 也是一个 int</code></pre></li><li><p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p><pre><code class="go">i := 42           // intf := 3.142        // float64g := 0.867 + 0.5i // complex128</code></pre></li></ul><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul><li><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字</p></li><li><p>常量可以是字符、字符串、布尔值或数值</p></li><li><p>常量不能用 <code>:=</code> 语法声明</p><pre><code class="go">const Pi = 3.14</code></pre></li></ul><h4 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h4><ul><li><p>数值常量是高精度的 <strong>值</strong></p></li><li><p>一个未指定类型的常量由上下文来决定其类型</p></li><li><p><code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少</p><pre><code class="go">const (    // 将 1 左移 100 位来创建一个非常大的数字    // 即这个数的二进制是 1 后面跟着 100 个 0    Big = 1 &lt;&lt; 100    // 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2    Small = Big &gt;&gt; 99)func needInt(x int) int &#123; return x*10 + 1 &#125;func needFloat(x float64) float64 &#123;    return x * 0.1&#125;</code></pre></li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ul><li><p>Go 只有一种循环结构：<code>for</code> 循环</p></li><li><p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开</p><ul><li>初始化语句：在第一次迭代前执行</li><li>条件表达式：在每次迭代前求值</li><li>后置语句：在每次迭代的结尾执行</li></ul><pre><code class="go">for i := 0; i &lt; 10; i++ &#123;        sum += i&#125;</code></pre></li><li><p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见</p></li><li><p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止</p></li><li><p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的</p></li></ul><h4 id="for-是-Go-中的-“while”"><a href="#for-是-Go-中的-“while”" class="headerlink" title="for 是 Go 中的 “while”"></a>for 是 Go 中的 “while”</h4><ul><li><p>初始化语句和后置语句是可选的</p></li><li><p>此时你可以去掉分号，因为 C 的 <code>while</code> 在 Go 中叫做 <code>for</code></p><pre><code class="go">sum := 1for sum &lt; 1000 &#123;    sum += sum&#125;</code></pre></li><li><p>如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑</p><pre><code class="go">func main() &#123;    for &#123;    &#125;&#125;</code></pre></li></ul><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><ul><li><p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的</p><pre><code class="go">func sqrt(x float64) string &#123;    if x &lt; 0 &#123;        return sqrt(-x) + &quot;i&quot;    &#125;    return fmt.Sprint(math.Sqrt(x))&#125;</code></pre></li><li><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 <code>if</code> 之内</p><pre><code class="go">func pow(x, n, lim float64) float64 &#123;    if v := math.Pow(x, n); v &lt; lim &#123;        return v    &#125;    return lim&#125;</code></pre></li></ul><h4 id="if-和-else"><a href="#if-和-else" class="headerlink" title="if  和 else"></a>if  和 else</h4><ul><li><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用</p><pre><code class="go">func pow(x, n, lim float64) float64 &#123;    if v := math.Pow(x, n); v &lt; lim &#123;        return v    &#125; else &#123;        fmt.Printf(&quot;%g &gt;= %g\n&quot;, v, lim)    &#125;    // 这里开始就不能使用 v 了    return lim&#125;</code></pre></li></ul><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><ul><li><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法，它运行第一个值等于条件表达式的 case 语句</p></li><li><p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case</p></li><li><p>实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句</p></li><li><p>除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止</p></li><li><p>Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数</p><pre><code class="go">switch os := runtime.GOOS; os &#123;    case &quot;darwin&quot;:        fmt.Println(&quot;OS X.&quot;)    case &quot;linux&quot;:        fmt.Println(&quot;Linux.&quot;)    default:        fmt.Println(&quot;%s. \n&quot;, os)</code></pre></li><li><p>switch 的求值顺序：case 语句从上到下顺次执行，直到匹配成功时停止</p><pre><code class="go">switch i &#123;case 0:case f():  // 在 i==0 时 f 不会被调用&#125;</code></pre></li><li><p>没有条件的 switch 同 <code>switch true</code> 一样。这种形式能将一长串 <code>if-then-else</code> 写得更加清晰</p><pre><code class="go">switch &#123;    case t.Hour() &lt; 12:        fmt.Println(&quot;Good morning!&quot;)    case t.Hour() &lt; 17:        fmt.Println(&quot;Good afternoon.&quot;)    default:        fmt.Println(&quot;Good evening.&quot;)</code></pre></li></ul><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><ul><li><p>defer 语句会将函数推迟到外层函数返回之后执行</p></li><li><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</p><pre><code class="go">func main() &#123;    defer fmt.Println(&quot;world&quot;)    fmt.Println(&quot;hello&quot;)&#125; // 输出：hello world</code></pre></li></ul><h4 id="defer-栈"><a href="#defer-栈" class="headerlink" title="defer 栈"></a>defer 栈</h4><ul><li><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用</p><pre><code class="go">func main() &#123;    fmt.Println(&quot;counting&quot;)    defer fmt.Println(&quot;done&quot;)    for i := 0; i &lt; 10; i++ &#123;        defer fmt.Println(i)    &#125;&#125; // 输出：counting 9 8 7 6 5 4 3 2 1 0 done</code></pre></li></ul><h3 id="结构体、数组、切片和映射"><a href="#结构体、数组、切片和映射" class="headerlink" title="结构体、数组、切片和映射"></a>结构体、数组、切片和映射</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul><li><p>Go 拥有指针。指针保存了值的内存地址</p></li><li><p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code></p><pre><code class="go">var p *int</code></pre></li><li><p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p><pre><code class="go">i := 42p = &amp;i</code></pre></li><li><p><code>*</code> 操作符表示指针指向的底层值</p><pre><code class="go">fmt.Println(*p) // 通过指针 p 读取 i*p = 21         // 通过指针 p 设置 i</code></pre></li><li><p>这也就是通常所说的“间接引用”或“重定向”</p></li><li><p>与 C 不同，Go 没有指针运算</p></li></ul><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><ul><li><p>一个结构体（<code>struct</code>）就是一组字段（field）</p><pre><code class="go">type Vertex struct &#123;    X int    Y int&#125;func main() &#123;    fmt.Println(Vertex&#123;1, 2&#125;)&#125;</code></pre></li><li><p>结构体字段使用点号来访问</p><pre><code class="go">func main() &#123;    v := Vertex&#123;1, 2&#125;    v.X = 4    fmt.Println(v, v.X, v.Y)&#125;</code></pre></li></ul><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><ul><li><p>结构体字段可以通过结构体指针来访问</p></li><li><p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code> 就可以</p><pre><code class="go">func main() &#123;    v := Vertex&#123;1, 2&#125;    p = &amp;v    p.X = 1e9    fmt.Println(v)&#125;</code></pre></li></ul><h4 id="结构体文法"><a href="#结构体文法" class="headerlink" title="结构体文法"></a>结构体文法</h4><ul><li><p>结构体文法通过直接列出字段的值来新分配一个结构体</p></li><li><p>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</p></li><li><p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针</p><pre><code class="go">type Vertex struct &#123;    X, Y int&#125;var (    v1 = Vertex&#123;1, 2&#125;  // 创建一个 Vertex 类型的结构体    &#123;1, 2&#125;     v2 = Vertex&#123;X: 1&#125;  // Y:0 被隐式地赋予    &#123;1, 0&#125;     v3 = Vertex&#123;&#125;      // X:0 Y:0    &#123;0, 0&#125;     p  = &amp;Vertex&#123;1, 2&#125; // 创建一个 *Vertex 类型的结构体（指针）   &amp;&#123;1, 2&#125;)</code></pre></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p><pre><code class="go">var a [2]string  // 会将变量 a 声明为拥有 10 个整数的数组a[0] = &quot;Hello&quot;a[1] = &quot;World&quot;  </code></pre></li><li><p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组</p></li></ul><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><ul><li><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p></li><li><p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p></li><li><p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p><pre><code class="go">a[low : high] // 选择一个半开区间，包括第一个元素，但排除最后一个元素</code></pre><pre><code class="go">primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125;var s []int = primes[1:4] // 创建了一个切片，它包含 primes 中下标从 1 到 3 的元素 fmt.Println(s)  // 输出：[3 5 7]</code></pre></li><li><p>切片就像数组的引用，切片并不存储任何数据，它只是描述了底层数组中的一段</p></li><li><p>更改切片的元素会修改其底层数组中对应的元素，与它共享底层数组的切片都会观测到这些修改</p></li></ul><h4 id="切片文法"><a href="#切片文法" class="headerlink" title="切片文法"></a>切片文法</h4><ul><li><p>切片文法类似于没有长度的数组文法。</p></li><li><p>这是一个数组文法：</p><pre><code class="go">[3]bool&#123;true, true, false&#125;</code></pre></li><li><p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p><pre><code class="go">[]bool&#123;true, true, false&#125;</code></pre></li></ul><h4 id="切片的默认行为"><a href="#切片的默认行为" class="headerlink" title="切片的默认行为"></a>切片的默认行为</h4><ul><li><p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p></li><li><p>切片下界的默认值为 <code>0</code>，上界则是该切片的长度</p><pre><code class="go">var a [10]int// 以下切片是等价的a[0:10]a[:10]a[0:]a[:]</code></pre></li></ul><h4 id="切片的长度与容量"><a href="#切片的长度与容量" class="headerlink" title="切片的长度与容量"></a>切片的长度与容量</h4><ul><li><p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p></li><li><p>切片的长度就是它所包含的元素个数。</p></li><li><p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p></li><li><p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取</p><pre><code class="go">func main() &#123;    s := []int&#123;2, 3, 5, 7, 11, 13&#125;    printSlice(s)    // 截取切片使其长度为 0    s = s[:0]    printSlice(s)    // 拓展其长度    s = s[:4]    printSlice(s)    // 舍弃前两个值    s = s[2:]    printSlice(s)&#125;func printSlice(s []int) &#123;    fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)&#125;</code></pre></li></ul><h4 id="nil-切片"><a href="#nil-切片" class="headerlink" title="nil 切片"></a>nil 切片</h4><ul><li><p>切片的零值是 <code>nil</code>。</p></li><li><p>nil 切片的长度和容量为 0 且没有底层数组</p><pre><code class="go">var s []int    // s == nilfmt.Println(s, len(s), cap(s))  // [] 0 0</code></pre></li></ul><h4 id="用-make-创建切片"><a href="#用-make-创建切片" class="headerlink" title="用 make 创建切片"></a>用 make 创建切片</h4><ul><li><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p></li><li><p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p><pre><code class="go">a := make([]int, 5)  // len(a)=5</code></pre></li><li><p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p><pre><code class="go">b := make([]int, 0, 5)  // len(b)=0, cap(b)=5b = b[:cap(b)]  // len(b)=5, cap(b)=5b = b[1:]      // len(b)=4, cap(b)=4</code></pre></li></ul><h4 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a>切片的切片</h4><ul><li><p>切片可包含任何类型，甚至包括其它的切片</p><pre><code class="go">func main() &#123;    // 创建一个井字板（经典游戏）    board := [][]string&#123;        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,    &#125;    // 两个玩家轮流打上 X 和 O    board[0][0] = &quot;X&quot;    board[2][2] = &quot;O&quot;    board[1][2] = &quot;X&quot;    board[1][0] = &quot;O&quot;    board[0][2] = &quot;X&quot;    for i := 0; i &lt; len(board); i++ &#123;        fmt.Printf(&quot;%s\n&quot;, strings.Join(board[i], &quot; &quot;))    &#125;&#125;</code></pre></li></ul><h4 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h4><ul><li><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数</p><pre><code class="go">func append(s []T, vs ...T) []T</code></pre></li><li><p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾</p></li><li><p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片</p></li><li><p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组</p></li></ul><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><ul><li><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p></li><li><p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本</p><pre><code class="go">var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;func main() &#123;    for i, v := range pow &#123;        fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)    &#125;&#125;</code></pre></li><li><p>可以将下标或值赋予 <code>_</code> 来忽略它</p><pre><code class="go">for i, _ := range powfor _, value := range pow</code></pre></li><li><p>若你只需要索引，忽略第二个变量即可。</p><pre><code class="go">for i := range pow</code></pre></li></ul><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><ul><li><p>映射将键映射到值</p></li><li><p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键</p></li><li><p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用</p><pre><code class="go">var m map[key_type]value_typem = make(map[key_type]value_type)</code></pre></li><li><p>短声明写法</p><pre><code class="go">m := make(map[string]int)  // m := make(map[key_type]value_type)</code></pre></li><li><p>映射的文法与结构体相似，不过必须有键名</p><pre><code class="go">type Vertex struct &#123;    Lat, Long float64&#125;var m = map[string]Vertex&#123;    &quot;Bell Labs&quot;: Vertex&#123;        40.68433, -74.39967,    &#125;,    &quot;Google&quot;: Vertex&#123;        37.42202, -122.08408,    &#125;,&#125;</code></pre></li><li><p>若顶级类型只是一个类型名，你可以在文法的元素中省略它</p><pre><code class="go">var m = map[string]Vertex&#123;    &quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;,    &quot;Google&quot;:    &#123;37.42202, -122.08408&#125;,&#125;</code></pre></li></ul><h4 id="修改映射"><a href="#修改映射" class="headerlink" title="修改映射"></a>修改映射</h4><ul><li><p>在映射 <code>m</code> 中插入或修改元素：</p><pre><code class="go">m[key] = elem</code></pre></li><li><p>获取元素：</p><pre><code class="go">elem = m[key]</code></pre></li><li><p>删除元素：</p><pre><code class="go">delete(m, key)</code></pre></li><li><p>通过双赋值检测某个键是否存在：</p><pre><code class="go">elem, ok = m[key]</code></pre></li><li><p>若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明</p><pre><code class="go">elem, ok := m[key]</code></pre></li><li><p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code></p></li><li><p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值</p><pre><code class="go">v, ok := m[&quot;Answer&quot;]fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)  // The value: 0 Present? false</code></pre></li><li><p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值</p></li></ul><h4 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h4><ul><li><p>函数也是值。它们可以像其它值一样传递。</p></li><li><p>函数值可以用作函数的参数或返回值</p><pre><code class="go">hypot := func(x, y float64) float64 &#123;    return math.Sqrt(x*x + y*y)&#125;</code></pre></li></ul><h4 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h4><ul><li><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p></li><li><p>例如，函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code> 变量上</p><pre><code class="go">func adder() func(int) int &#123;    sum := 0    return func(x int) int &#123;        sum += x        return sum    &#125;&#125;func main() &#123;    pos, neg := adder(), adder()    for i := 0; i &lt; 10; i++ &#123;        fmt.Println(            pos(i),            neg(-2*i),        )    &#125;&#125;</code></pre></li></ul><h3 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>Go 没有类。不过你可以为结构体类型定义方法。</p></li><li><p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p></li><li><p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p></li><li><p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者</p><pre><code class="go">type Vertex struct &#123;    X, Y float64&#125;func (v Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    fmt.Println(v.Abs())&#125;</code></pre></li><li><p>记住：方法只是个带接收者参数的函数。</p></li><li><p>现在这个 <code>Abs</code> 的写法就是个正常的函数，功能并没有什么变化</p><pre><code class="go">func Abs(v Vertex) float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    fmt.Println(Abs(v))&#125;</code></pre></li><li><p>也可以为非结构体类型声明方法。</p></li><li><p>在此例中，我们看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code></p><pre><code class="go">func (f MyFloat) Abs() float64 &#123;    if f &lt; 0 &#123;        return float64(-f)    &#125;    return float64(f)&#125;func main() &#123;    f := MyFloat(-math.Sqrt2)    fmt.Println(f.Abs())&#125;</code></pre></li><li><p>只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法（就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p></li></ul><h4 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h4><ul><li><p>可以为指针接收者声明方法。</p></li><li><p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p></li><li><p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法</p><pre><code class="go">type Vertex struct &#123;    X, Y float64&#125;func (v Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale(f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    v.Scale(10)    fmt.Println(v.Abs())&#125;</code></pre></li><li><p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p></li><li><p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作。（对于函数的其它参数也是如此。）<code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p></li></ul><h4 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h4><ul><li><p>注意：带指针参数的函数必须接受一个指针</p><pre><code class="go">func ScaleFunc(v *Vertex, f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    ScaleFunc(v, 5)  // 编译错误！    ScaleFunc(&amp;v, 5) // OK&#125;</code></pre></li><li><p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针</p><pre><code class="go">func (v *Vertex) Scale(f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    v.Scale(5)  // OK    p := &amp;v    p.Scale(10) // OK    &#125;</code></pre></li><li><p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code></p></li><li><p>同样的事情也发生在相反的方向。</p></li><li><p>接受一个值作为参数的函数必须接受一个指定类型的值</p><pre><code class="go">func AbsFunc(v Vertex) float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    fmt.Println(AbsFunc(v))  // OK    fmt.Println(AbsFunc(&amp;v)) // 编译错误！&#125;</code></pre></li><li><p>而以值为接收者的方法被调用时，接收者既能为值又能为指针</p><pre><code class="go">func (v Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    var v Vertex    fmt.Println(v.Abs()) // OK    p := &amp;v    fmt.Println(p.Abs()) // OK&#125;</code></pre></li><li><p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code></p></li></ul><h4 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h4><ul><li><p>使用指针接收者的原因有二：</p><ol><li>首先，方法能够修改其接收者指向的值。</li><li>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</li></ol></li><li><p>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 <code>Abs</code> 并不需要修改其接收者。</p><pre><code class="go">func (v *Vertex) Scale(f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func (v *Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := &amp;Vertex&#123;3, 4&#125;    fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs())    v.Scale(5)    fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())&#125;</code></pre></li><li><p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用</p></li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p></li><li><p>接口类型的变量可以保存任何实现了这些方法的值</p><pre><code class="go">type Abser interface &#123;    Abs() float64&#125;func main() &#123;    var a Abser    f := MyFloat(-math.Sqrt2)    v := Vertex&#123;3, 4&#125;    a = f  // a MyFloat 实现了 Abser    a = &amp;v // a *Vertex 实现了 Abser    fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123;    if f &lt; 0 &#123;        return float64(-f)    &#125;    return float64(f)&#125;type Vertex struct &#123;    X, Y float64&#125;func (v *Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;</code></pre></li></ul><h4 id="接口与隐式实现"><a href="#接口与隐式实现" class="headerlink" title="接口与隐式实现"></a>接口与隐式实现</h4><ul><li><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p></li><li><p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p></li><li><p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p><pre><code class="go">type I interface &#123;    M()&#125;type T struct &#123;    S string&#125;// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。func (t T) M() &#123;    fmt.Println(t.S)&#125;func main() &#123;    var i I = T&#123;&quot;hello&quot;&#125;    i.M()&#125;</code></pre></li></ul><h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><ul><li><p>接口也是值。它们可以像其它值一样传递。</p></li><li><p>接口值可以用作函数的参数或返回值。</p></li><li><p>在内部，接口值可以看做包含值和具体类型的元组：<code>(value, type)</code></p></li><li><p>接口值保存了一个具体底层类型的具体值。</p></li><li><p>接口值调用方法时会执行其底层类型的同名方法。</p><pre><code class="go">type I interface &#123;    M()&#125;type T struct &#123;    S string&#125;func (t *T) M() &#123;    fmt.Println(t.S)&#125;type F float64func (f F) M() &#123;    fmt.Println(f)&#125;func main() &#123;    var i I    i = &amp;T&#123;&quot;Hello&quot;&#125;    describe(i)    i.M()    i = F(math.Pi)    describe(i)    i.M()&#125;func describe(i I) &#123;    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)&#125;</code></pre></li></ul><h4 id="底层值为-nil-的接口值"><a href="#底层值为-nil-的接口值" class="headerlink" title="底层值为 nil 的接口值"></a>底层值为 nil 的接口值</h4><ul><li>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</li><li>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code> 方法）。</li><li><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</li><li>nil 接口值既不保存值也不保存具体类型。</li><li>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</li></ul><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><ul><li><p>指定了零个方法的接口值被称为 <em>空接口：</em></p><pre><code>interface&#123;&#125;</code></pre></li><li><p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p></li><li><p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。</p><pre><code class="go">func main() &#123;    var i interface&#123;&#125;    describe(i)    i = 42    describe(i)    i = &quot;hello&quot;    describe(i)&#125;func describe(i interface&#123;&#125;) &#123;    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)&#125;</code></pre></li></ul><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><ul><li><p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。</p><pre><code class="go">t := i.(T)</code></pre></li><li><p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p></li><li><p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个恐慌。</p></li><li><p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p><pre><code class="go">t, ok := i.(T)</code></pre></li><li><p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p></li><li><p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p></li><li><p>请注意这种语法和读取一个映射时的相同之处</p><pre><code class="go">func main() &#123;    var i interface&#123;&#125; = &quot;hello&quot;    s := i.(string)    fmt.Println(s)    s, ok := i.(string)    fmt.Println(s, ok)    f, ok := i.(float64)    fmt.Println(f, ok)    f = i.(float64) // 报错(panic)    fmt.Println(f)&#125;</code></pre></li></ul><h4 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h4><ul><li><p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。</p></li><li><p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p><pre><code>switch v := i.(type) &#123;case T:    // v 的类型为 Tcase S:    // v 的类型为 Sdefault:    // 没有匹配，v 与 i 的类型相同&#125;</code></pre></li><li><p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</p></li><li><p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p><pre><code class="go">func do(i interface&#123;&#125;) &#123;    switch v := i.(type) &#123;    case int:        fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2)    case string:        fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v))    default:        fmt.Printf(&quot;I don&#39;t know about type %T!\n&quot;, v)    &#125;&#125;func main() &#123;    do(21)    do(&quot;hello&quot;)    do(true)&#125;</code></pre></li></ul><h4 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h4><ul><li><p><a href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p><pre><code class="go">type Stringer interface &#123;    String() string&#125;</code></pre></li><li><p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p><pre><code class="go">type Person struct &#123;    Name string    Age  int&#125;func (p Person) String() string &#123;    return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)&#125;func main() &#123;    a := Person&#123;&quot;Arthur Dent&quot;, 42&#125;    z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125;    fmt.Println(a, z)&#125;</code></pre></li></ul><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><ul><li><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p></li><li><p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p><pre><code class="go">type error interface &#123;    Error() string&#125;</code></pre></li><li><p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p></li><li><p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p><pre><code class="go">i, err := strconv.Atoi(&quot;42&quot;)if err != nil &#123;    fmt.Printf(&quot;couldn&#39;t convert number: %v\n&quot;, err)    return&#125;fmt.Println(&quot;Converted integer:&quot;, i)</code></pre></li><li><p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败</p><pre><code class="go">type MyError struct &#123;    When time.Time    What string&#125;func (e *MyError) Error() string &#123;    return fmt.Sprintf(&quot;at %v, %s&quot;,        e.When, e.What)&#125;func run() error &#123;    return &amp;MyError&#123;        time.Now(),        &quot;it didn&#39;t work&quot;,    &#125;&#125;func main() &#123;    if err := run(); err != nil &#123;        fmt.Println(err)    &#125;&#125;</code></pre></li></ul><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><ul><li><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p></li><li><p>Go 标准库包含了该接口的<a href="https://go-zh.org/search?q=Read#Global">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p></li><li><p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p><pre><code class="go">func (T) Read(b []byte) (n int, err error)</code></pre></li><li><p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p></li><li><p>示例代码创建了一个 <a href="https://go-zh.org/pkg/strings/#Reader"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出</p><pre><code class="go">func main() &#123;    r := strings.NewReader(&quot;Hello, Reader!&quot;)    b := make([]byte, 8)    for &#123;        n, err := r.Read(b)        fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)        fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])        if err == io.EOF &#123;            break        &#125;    &#125;&#125;</code></pre></li></ul><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul><li><p><a href="https://go-zh.org/pkg/image/#Image"><code>image</code></a> 包定义了 <code>Image</code> 接口：</p><pre><code class="go">package imagetype Image interface &#123;    ColorModel() color.Model    Bounds() Rectangle    At(x, y int) color.Color&#125;</code></pre></li><li><p><strong>注意:</strong> <code>Bounds</code> 方法的返回值 <code>Rectangle</code> 实际上是一个 <a href="https://go-zh.org/pkg/image/#Rectangle"><code>image.Rectangle</code></a>，它在 <code>image</code> 包中声明。</p></li><li><p>参阅<a href="https://go-zh.org/pkg/image/#Image">文档</a>了解全部信息</p></li><li><p><code>color.Color</code> 和 <code>color.Model</code> 类型也是接口，但是通常因为直接使用预定义的实现 <code>image.RGBA</code> 和 <code>image.RGBAModel</code> 而被忽视了。这些接口和类型由 <a href="https://go-zh.org/pkg/image/color/"><code>image/color</code></a> 包定义</p><pre><code class="go">func main() &#123;    m := image.NewRGBA(image.Rect(0, 0, 100, 100))    fmt.Println(m.Bounds())    fmt.Println(m.At(0, 0).RGBA())&#125;</code></pre></li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="Go-程"><a href="#Go-程" class="headerlink" title="Go 程"></a>Go 程</h4><ul><li><p>Go 程（goroutine）是由 Go 运行时管理的轻量级线程。</p><pre><code>go f(x, y, z)</code></pre></li><li><p>会启动一个新的 Go 程并执行</p><pre><code>f(x, y, z)</code></pre></li><li><p><code>f</code>, <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go 程中，而 <code>f</code> 的执行发生在新的 Go 程中。</p></li><li><p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。<a href="https://go-zh.org/pkg/sync/"><code>sync</code></a> 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法</p></li></ul><h4 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h4><ul><li><p>信道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p><pre><code class="go">ch &lt;- v    // 将 v 发送至信道 ch。v := &lt;-ch  // 从 ch 接收值并赋予 v。</code></pre></li><li><p>（“箭头”就是数据流的方向。）</p></li><li><p>和映射与切片一样，信道在使用前必须创建：</p><pre><code class="go">ch := make(chan int)</code></pre></li><li><p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p></li><li><p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果</p><pre><code class="go">func sum(s []int, c chan int) &#123;    sum := 0    for _, v := range s &#123;        sum += v    &#125;    c &lt;- sum // 将和送入 c&#125;func main() &#123;    s := []int&#123;7, 2, 8, -9, 4, 0&#125;    c := make(chan int)    go sum(s[:len(s)/2], c)    go sum(s[len(s)/2:], c)    x, y := &lt;-c, &lt;-c // 从 c 中接收    fmt.Println(x, y, x+y)&#125;</code></pre></li></ul><h4 id="带缓冲的信道"><a href="#带缓冲的信道" class="headerlink" title="带缓冲的信道"></a>带缓冲的信道</h4><ul><li><p>信道可以是 <em>带缓冲的</em>。将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道：</p><pre><code class="go">ch := make(chan int, 100)</code></pre></li><li><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><pre><code class="go">func main() &#123;    ch := make(chan int, 2)    ch &lt;- 1    ch &lt;- 2    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)&#125;</code></pre></li></ul><h4 id="range-和-close"><a href="#range-和-close" class="headerlink" title="range 和 close"></a>range 和 close</h4><ul><li><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p><pre><code>v, ok := &lt;-ch</code></pre></li><li><p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p></li><li><p>循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p></li><li><p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p></li><li><p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p><pre><code class="go">func fibonacci(n int, c chan int) &#123;    x, y := 0, 1    for i := 0; i &lt; n; i++ &#123;        c &lt;- x        x, y = y, x+y    &#125;    close(c)&#125;func main() &#123;    c := make(chan int, 10)    go fibonacci(cap(c), c)    for i := range c &#123;        fmt.Println(i)    &#125;&#125;</code></pre></li></ul><h4 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h4><ul><li><p><code>select</code> 语句使一个 Go 程可以等待多个通信操作。</p></li><li><p><code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行</p><pre><code class="go">func fibonacci(c, quit chan int) &#123;    x, y := 0, 1    for &#123;        select &#123;        case c &lt;- x:            x, y = y, x+y        case &lt;-quit:            fmt.Println(&quot;quit&quot;)            return        &#125;    &#125;&#125;func main() &#123;    c := make(chan int)    quit := make(chan int)    go func() &#123;        for i := 0; i &lt; 10; i++ &#123;            fmt.Println(&lt;-c)        &#125;        quit &lt;- 0    &#125;()    fibonacci(c, quit)&#125;</code></pre></li></ul><h4 id="默认选择"><a href="#默认选择" class="headerlink" title="默认选择"></a>默认选择</h4><ul><li><p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。</p></li><li><p>为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p><pre><code class="go">select &#123;case i := &lt;-c:    // 使用 idefault:    // 从 c 中接收会阻塞时执行&#125;</code></pre></li></ul><h4 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h4><ul><li><p>我们已经看到信道非常适合在各个 Go 程间进行通信。</p></li><li><p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p></li><li><p>这里涉及的概念叫做 互斥（<code>mutual*exclusion</code>），我们通常使用 互斥锁（Mutex）这一数据结构来提供这种机制。</p></li><li><p>Go 标准库中提供了 <a href="https://go-zh.org/pkg/sync/#Mutex"><code>sync.Mutex</code></a> 互斥锁类型及其两个方法：</p><ul><li><code>Lock</code></li><li><code>Unlock</code></li></ul></li><li><p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。参见 <code>Inc</code> 方法。</p></li><li><p>我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见 <code>Value</code> 方法</p></li></ul><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><ul><li>Go <a href="https://go-zh.org/doc/">文档</a></li><li><a href="https://go-zh.org/doc/code.html">如何使用Go编程</a></li><li><a href="https://go-zh.org/pkg/">包手册</a></li><li><a href="https://go-zh.org/ref/spec">语言规范</a></li><li>进一步探索 Go 的并发模型，参阅 <a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go 并发模型</a>(<a href="https://talks.go-zh.org/2012/concurrency.slide">幻灯片</a>)以及<a href="https://www.youtube.com/watch?v=QDDwwePbDtw">深入 Go 并发模型</a>(<a href="https://talks.go-zh.org/2013/advconc.slide">幻灯片</a>)并阅读<a href="https://go-zh.org/doc/codewalk/sharemem/">通过通信共享内存</a>的代码之旅</li><li><a href="https://vimeo.com/53221558">一个简单的编程环境</a>(<a href="https://talks.go-zh.org/2012/simple.slide">幻灯片</a>)</li><li><a href="https://go-zh.org/doc/articles/wiki/">编写 Web 应用</a>的指南</li><li><a href="https://go-zh.org/doc/codewalk/functions/">函数：Go 中的一等公民</a>展示了有趣的函数类型</li><li><a href="https://blog.go-zh.org/">Go 博客</a>有着众多关于 Go 的文章和信息</li><li><a href="https://www.mikespook.com/tag/golang/">mikespook 的博客</a>中有大量中文的关于 Go 的文章和翻译</li><li>开源电子书 <a href="https://github.com/astaxie/build-web-application-with-golang">Go Web 编程</a>和 <a href="https://github.com/Unknwon/the-way-to-go_ZH_CN">Go 入门指南</a>能够帮助你更加深入的了解和学习 Go 语言</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Go 语言是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，它用批判吸收的眼光，融合 C 语言、Java 等众家之长，将简洁、高效演绎得淋漓尽致。Golang非常适合用来做网络并发方面的服务，比如消息推送、监控、容器等。初次学习我选择的是 &lt;a href=&quot;https://go-zh.org/&quot;&gt;Go 编程语言&lt;/a&gt;指南，指南涵盖了该语言的大部分重要特性，放在以下为所记笔记，另附有随堂代码放在 &lt;a href=&quot;https://github.com/Bezhuang/Learn-CS/tree/main/Learn%20Programming/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85&quot;&gt;Github 仓库&lt;/a&gt;中，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="其他开发" scheme="http://blog.zhuangzhihao.top/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
</feed>
