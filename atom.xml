<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bezhuang&#39;s Blog</title>
  
  
  <link href="http://blog.zhuangzhihao.top/atom.xml" rel="self"/>
  
  <link href="http://blog.zhuangzhihao.top/"/>
  <updated>2022-05-16T05:49:29.986Z</updated>
  <id>http://blog.zhuangzhihao.top/</id>
  
  <author>
    <name>Bezhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过编写猫咪相册应用学习 HTML</title>
    <link href="http://blog.zhuangzhihao.top/HTML%E7%8C%AB%E5%92%AA%E7%9B%B8%E5%86%8C%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.zhuangzhihao.top/HTML%E7%8C%AB%E5%92%AA%E7%9B%B8%E5%86%8C%E5%BA%94%E7%94%A8/</id>
    <published>2022-05-14T16:00:00.000Z</published>
    <updated>2022-05-16T05:49:29.986Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>freeCodeCamp 响应式网页设计的认证课程第一章。HTML 标签赋予了网页结构。你可以使用 HTML 标签添加照片、按钮和其它元素到你的网页。在通过编写猫咪相册应用学习 HTML 的课程中，通过编写一个猫咪相册应用，学习最常见的 HTML 标签。</p></blockquote><a id="more"></a><h3 id="一、重点代码"><a href="#一、重点代码" class="headerlink" title="一、重点代码"></a>一、重点代码</h3><p>页面格式：</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;header&gt;&lt;title&gt;CatPhotoApp&lt;/title&gt;&lt;/header&gt;    &lt;body&gt;      &lt;main&gt;        &lt;section&gt;&lt;/section&gt;  &lt;!--多个分块--&gt;      &lt;/main&gt;      &lt;footer&gt;&lt;p&gt;Copyright&lt;/p&gt;&lt;/footer&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>figure 标签，用于规定独立的流内容（图像、图表、照片、代码等）：</p><pre><code class="html">&lt;figure&gt;    &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/lasagna.jpg&quot; alt=&quot;A slice of lasagna on a plate.&quot;&gt;   &lt;!--img 标签自闭和--&gt;    &lt;figcaption&gt;Cats &lt;em&gt;love&lt;/em&gt; lasagna.&lt;/figcaption&gt;&lt;/figure&gt;</code></pre><p>form 表单提交：</p><pre><code class="html">&lt;form action=&quot;https://freecatphotoapp.com/submit-cat-photo&quot;&gt;  &lt;input type=&quot;text&quot; name=&quot;catphotourl&quot; placeholder=&quot;cat photo URL&quot; required&gt;  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;</code></pre><p>用 fieldset 标签对表单进行分组，一个表单可以有多个 fieldset：</p><pre><code class="html">&lt;fieldset&gt;    &lt;legend&gt;Is your cat an indoor or outdoor cat?&lt;/legend&gt;    &lt;label&gt;&lt;input id=&quot;indoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;indoor&quot; checked&gt; Indoor&lt;/label&gt;    &lt;label&gt;&lt;input id=&quot;outdoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;outdoor&quot;&gt; Outdoor&lt;/label&gt;&lt;/fieldset&gt;&lt;fieldset&gt;    &lt;legend&gt;What&#39;s your cat&#39;s personality?&lt;/legend&gt;    &lt;input id=&quot;loving&quot; type=&quot;checkbox&quot; name=&quot;personality&quot; value=&quot;loving&quot; checked&gt; &lt;label for=&quot;loving&quot;&gt;Loving&lt;/label&gt;    &lt;input id=&quot;lazy&quot; type=&quot;checkbox&quot; name=&quot;personality&quot; value=&quot;lazy&quot;&gt; &lt;label for=&quot;lazy&quot;&gt;Lazy&lt;/label&gt;    &lt;input id=&quot;energetic&quot; type=&quot;checkbox&quot; name=&quot;personality&quot; value=&quot;energetic&quot;&gt; &lt;label for=&quot;energetic&quot;&gt;Energetic&lt;/label&gt;&lt;/fieldset&gt;</code></pre><h3 id="二、页面展示"><a href="#二、页面展示" class="headerlink" title="二、页面展示"></a>二、页面展示</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://free-code-camp-demo.vercel.app/通过编写猫咪相册应用学习HTML/index.html" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;freeCodeCamp 响应式网页设计的认证课程第一章。HTML 标签赋予了网页结构。你可以使用 HTML 标签添加照片、按钮和其它元素到你的网页。在通过编写猫咪相册应用学习 HTML 的课程中，通过编写一个猫咪相册应用，学习最常见的 HTML 标签。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="前端" scheme="http://blog.zhuangzhihao.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="HTML" scheme="http://blog.zhuangzhihao.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Request 和 Response 对象详解</title>
    <link href="http://blog.zhuangzhihao.top/Request&amp;Response/"/>
    <id>http://blog.zhuangzhihao.top/Request&amp;Response/</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-05-16T05:49:06.035Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java Web 核心第二章。在 Java Servlet 中，Request 对象是用来封装请求数据的对象，Response 对象是用来封装响应数据的对象。Web 服务器收到客户端的 HTTP 请求，会针对每一次请求分别创建一个用于代表请求的 Request 对象和代表响应的 Response 对象。</p></blockquote><a id="more"></a><h3 id="一、Request-和-Response-对象的使用"><a href="#一、Request-和-Response-对象的使用" class="headerlink" title="一、Request 和 Response 对象的使用"></a>一、Request 和 Response 对象的使用</h3><p>Request 和 Response 这两个参数的作用是什么?</p><p>Request：获取请求数据</p><ul><li>浏览器会发送 HTTP 请求到后台服务器（Tomcat）。</li><li>HTTP 的请求中会包含很多请求数据（请求行 + 请求头 + 请求体）。</li><li>后台服务器会对 HTTP 请求中的数据进行解析并把解析结果存入到一个对象中。</li><li>所存入的对象即为 Request 对象，所以我们可以从 Request 对象中获取请求的相关参数。</li><li>获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务。</li></ul><p>Response：设置响应数据</p><ul><li>业务处理完后，后台就需要给前端返回业务处理的结果，即响应数据。</li><li>把响应数据封装到 Response 对象中。</li><li>后台服务器（Tomcat）会解析 Response 对象，按照（响应行 + 响应头 + 响应体）格式拼接结果。</li><li>浏览器最终解析结果，把内容展示在浏览器给用户浏览。</li></ul><p>初步体验下 Request 和 Response 对象的使用案例。</p><pre><code class="java">@WebServlet(&quot;/demo3&quot;)public class ServletDemo3 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //使用request对象 获取请求数据        String name = request.getParameter(&quot;name&quot;);//url?name=zhangsan        //使用response对象 设置响应数据        response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);        response.getWriter().write(&quot;&lt;h1&gt;&quot;+name+&quot;,欢迎您！&lt;/h1&gt;&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;Post...&quot;);    &#125;&#125;</code></pre><h3 id="二、Request-对象"><a href="#二、Request-对象" class="headerlink" title="二、Request 对象"></a>二、Request 对象</h3><h4 id="Request-继承体系"><a href="#Request-继承体系" class="headerlink" title="Request 继承体系"></a>Request 继承体系</h4><p>当我们的 Servlet 类实现的是 Servlet 接口的时候，service 方法中的参数是 ServletRequest 和 ServletResponse，当我们的 Servlet 类继承的是 HttpServlet 类的时候，doGet 和 doPost 方法中的参数就变成 HttpServletRequest 和 HttpServletReponse。</p><p>Request 的继承体系：</p><pre><code class="mermaid">graph BTRequestFacade --&gt; HttpServletRequest --&gt; ServletRequest</code></pre><p>ServletRequest 和 HttpServletRequest 是继承关系，并且两个都是接口，接口是无法创建对象，需要用到 RequestFacade：该类实现了 HttpServletRequest 接口，也间接实现了ServletRequest接口。Servlet 类中的 service 方法、doGet 方法或者是 doPost 方法最终都是由 Web 服务器来调用的，所以 Tomcat 提供了方法参数接口的具体实现类，并完成了对象的创建。</p><p>要想了解 RequestFacade 中都提供了哪些方法，我们可以直接查看 JavaEE API 文档中关于 ServletRequest 和 HttpServletRequest 的接口文档，因为 RequestFacade 实现了其接口就需要重写接口中的方法。</p><pre><code class="java">@WebServlet(&quot;/demo2&quot;)public class ServletDemo2 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(request);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    &#125;&#125;</code></pre><h4 id="Request-获取请求数据"><a href="#Request-获取请求数据" class="headerlink" title="Request 获取请求数据"></a>Request 获取请求数据</h4><p>获取请求行数据：请求行包含三块内容，分别是 <code>请求方式</code>、<code>请求资源路径</code>、<code>HTTP协议及版本</code>。</p><pre><code class="java">@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // String getMethod()：获取请求方式： GET        String method = req.getMethod();        System.out.println(method);//GET        // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo        String contextPath = req.getContextPath();        System.out.println(contextPath);        // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1        StringBuffer url = req.getRequestURL();        System.out.println(url.toString());        // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1        String uri = req.getRequestURI();        System.out.println(uri);        // String getQueryString()：获取请求参数（GET方式）： username=zhangsan        String queryString = req.getQueryString();        System.out.println(queryString);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;&#125;</code></pre><p>获取请求头数据：请求头的数据格式为 <code>key: value</code>。</p><pre><code class="java">@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //获取请求头: user-agent: 浏览器的版本信息        String agent = req.getHeader(&quot;user-agent&quot;);        System.out.println(agent);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;&#125;</code></pre><p>获取请求体数据：浏览器在发送 GET 请求的时候是没有请求体的，所以需要把请求方式变更为 POST。</p><ol><li><p>  如果前端发送的是字节数据，比如传递的是文件数据，则使用 <code>getInputStream()</code> 方法获取字节输入流。</p></li><li><p>  如果前端发送的是纯文本数据，则使用 <code>getReader()</code> 方法获取字符输入流。</p></li></ol><pre><code class="java">@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;         //获取post 请求体：请求参数        //1. 获取字符输入流        BufferedReader br = req.getReader();        //2. 读取数据        String line = br.readLine();        System.out.println(line);    &#125;&#125;</code></pre><p>BufferedReader 流是通过 request 对象来获取的，当请求完成后 request 对象就会被销毁，request 对象被销毁后，BufferedReader 流就会自动关闭，所以此处就不需要手动关闭流了。</p><h4 id="获取请求参数的通用方式"><a href="#获取请求参数的通用方式" class="headerlink" title="获取请求参数的通用方式"></a>获取请求参数的通用方式</h4><p>请求参数是请求数据中的部分内容（如：用户名和密码），请求数据则是包含请求行、请求头和请求体的所有数据，如果是 GET 请求，请求参数在请求行中，如果是 POST 请求，请求参数一般在请求体中。</p><ol><li><p>  GET 方式获取请求参数：<code>String getQueryString()</code></p></li><li><p>  POST 方式获取请求参数：<code>BufferedReader getReader();</code></p></li></ol><pre><code class="java">@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;                //GET 方式获取请求参数        String result = req.getQueryString();        System.out.println(result);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // POST 方式获取请求参数          BufferedReader br = req.getReader();        String result = br.readLine();        System.out.println(result);    &#125;&#125;</code></pre><p>GET 请求方式和 POST 请求方式区别主要在于获取请求参数的方式不一样，为了统一获取请求参数，Request 对象为我们提供了如下方法：</p><ol><li><p>  获取所有参数Map集合：<code>Map&lt;String,String[]&gt; getParameterMap()</code></p></li><li><p>  根据名称获取参数值（数组）：<code>String[] getParameterValues(String name)</code></p></li><li><p>  根据名称获取参数值（单个值）：<code>String getParameter(String name)</code></p></li></ol><pre><code class="java">/** * request 通用方式获取请求参数 */@WebServlet(&quot;/req2&quot;)public class RequestDemo2 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //GET请求逻辑        System.out.println(&quot;get....&quot;);        //1. 获取所有参数的Map集合        Map&lt;String, String[]&gt; map = req.getParameterMap();        for (String key : map.keySet()) &#123;            // username:zhangsan lisi            System.out.print(key+&quot;:&quot;);            //获取值            String[] values = map.get(key);            for (String value : values) &#123;                System.out.print(value + &quot; &quot;);            &#125;            System.out.println();        &#125;        //2. 获取GET请求参数中的爱好，结果是数组值        System.out.println(&quot;------------&quot;);        String[] hobbies = req.getParameterValues(&quot;hobby&quot;);        for (String hobby : hobbies) &#123;            System.out.println(hobby);        &#125;          //3. 获取GET请求参数中的用户名和密码，结果是单个值        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);        System.out.println(username);        System.out.println(password);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;&#125;</code></pre><p><code>req.getParameter()</code> 方法使用的频率会比较高，以后我们再写代码的时候，就只需要按照如下格式来编写：</p><pre><code class="java">public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;       //采用request提供的获取请求参数的通用方式来获取请求参数       //编写其他的业务代码...    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        this.doGet(req,resp);    &#125;&#125;</code></pre><h4 id="请求参数中文乱码问题"><a href="#请求参数中文乱码问题" class="headerlink" title="请求参数中文乱码问题"></a>请求参数中文乱码问题</h4><p>POST 的请求参数是通过 request 的 <code>getReader()</code> 来获取流中的数据，Tomcat 在获取流的时候采用的编码是ISO-8859-1（不支持中文），需要通过 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code> 把 Tomcat 在获取流数据之前的编码设置为UTF-8。</p><pre><code class="java">@WebServlet(&quot;/req4&quot;)public class RequestDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 解决乱码: POST getReader()        //设置字符输入流的编码，设置的字符集要和页面保持一致        request.setCharacterEncoding(&quot;UTF-8&quot;);       //2. 获取username       String username = request.getParameter(&quot;username&quot;);       System.out.println(username);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>GET 请求获取请求参数的方式是 <code>request.getQueryString()</code>，并没有通过流的方式获取数据，所以 GET 请求不能用设置编码的方式来解决中文乱码问题。</p><p>GET 请求中文参数出现乱码的原因，是浏览器把中文参数按照  <code>UTF-8</code>  进行 URL 编码，而后台的 Tomcat 对获取到的内容进行 <code>ISO-8859-1</code> 的 URL 解码，我们可以按照 ISO-8859-1 编码获取乱码对应的字节数组，再按照 UTF-8 编码获取字节数组对应的字符串，在转换的过程中它们的编码一致，就可以解决中文乱码问题。</p><p>URL编码实现方式:</p><ul><li><p>编码：<code>URLEncoder.encode(str,&quot;UTF-8&quot;);</code></p></li><li><p>解码：<code>URLDecoder.decode(s,&quot;ISO-8859-1&quot;);</code></p></li></ul><pre><code class="java">public class URLDemo &#123;  public static void main(String[] args) throws UnsupportedEncodingException &#123;        String username = &quot;张三&quot;;        //1. URL编码        String encode = URLEncoder.encode(username, &quot;utf-8&quot;);        System.out.println(encode);        //2. URL解码        String decode = URLDecoder.decode(encode, &quot;ISO-8859-1&quot;);        System.out.println(decode); //此处打印的是对应的乱码数据        //3. 转换为字节数据,编码        byte[] bytes = decode.getBytes(&quot;ISO-8859-1&quot;);        for (byte b : bytes) &#123;            System.out.print(b + &quot; &quot;);        &#125;        //此处打印的是:-27 -68 -96 -28 -72 -119        //4. 将字节数组转为字符串，解码        String s = new String(bytes, &quot;utf-8&quot;);        System.out.println(s); //此处打印的是张三    &#125;&#125;</code></pre><p>通用中文乱码解决方案：先解码，再编码。</p><pre><code class="java">@WebServlet(&quot;/req4&quot;)public class RequestDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 解决乱码：POST，getReader()        //request.setCharacterEncoding(&quot;UTF-8&quot;);//设置字符输入流的编码        //2. 获取username        String username = request.getParameter(&quot;username&quot;);        System.out.println(&quot;解决乱码前：&quot;+username);        //3. GET,获取参数的方式：getQueryString        // 乱码原因：tomcat进行URL解码，默认的字符集ISO-8859-1       /* //3.1 先对乱码数据进行编码：转为字节数组        byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1);        //3.2 字节数组解码        username = new String(bytes, StandardCharsets.UTF_8);*/        username  = new String(username.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);        System.out.println(&quot;解决乱码后：&quot;+username);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>把 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code> 代码注释掉后，会发现 GET 请求参数乱码解决方案同时也可也把 POST 请求参数乱码的问题也解决了，只不过对于 POST 请求参数一般都会比较多，采用这种方式解决乱码起来比较麻烦，所以对于 POST 请求还是建议使用设置编码的方式进行。</p><p>Tomcat 8.0 之后的版本已将 GET 请求乱码问题解决，设置默认的解码方式为 UTF-8。</p><h4 id="Request-请求转发"><a href="#Request-请求转发" class="headerlink" title="Request 请求转发"></a>Request 请求转发</h4><p>请求转发（forward）是一种在服务器内部的资源跳转方式。</p><p>请求转发的实现方式：<code>req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);</code>。</p><pre><code class="java">@WebServlet(&quot;/req5&quot;)public class RequestDemo5 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;demo5...&quot;);        //请求转发        request.getRequestDispatcher(&quot;/req6&quot;).forward(request,response);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>请求转发资源间共享数据：使用 Request 对象。</p><ol><li><p>  存储数据到 request 域中：<code>void setAttribute(String name,Object o);</code></p></li><li><p>  根据 key 获取值：<code>Object getAttribute(String name);</code></p></li><li><p>  根据 key 删除该键值对：<code>void removeAttribute(String name);</code></p></li></ol><pre><code class="java">@WebServlet(&quot;/req5&quot;)public class RequestDemo5 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;demo5...&quot;);        //存储数据        request.setAttribute(&quot;msg&quot;,&quot;hello&quot;);        //请求转发        request.getRequestDispatcher(&quot;/req6&quot;).forward(request,response);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;@WebServlet(&quot;/req6&quot;)public class RequestDemo6 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;demo6...&quot;);        //获取数据        Object msg = request.getAttribute(&quot;msg&quot;);        System.out.println(msg);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>请求转发的特点：浏览器地址栏路径不发生变化，只能转发到当前服务器的内部资源，而不能从一个服务器通过转发访问另一台服务器。一次请求可以在转发资源间使用 request 共享数据。</p><h3 id="三、Response-对象"><a href="#三、Response-对象" class="headerlink" title="三、Response 对象"></a>三、Response 对象</h3><p>Reponse 的继承体系和 Request 的继承体系非常相似</p><p>Servlet -&gt; <code>service(request, response)</code></p><pre><code class="mermaid">graph BTReponseFacade --&gt; HttpServletReponse --&gt; ServletReponse</code></pre><h4 id="Response-设置响应数据"><a href="#Response-设置响应数据" class="headerlink" title="Response 设置响应数据"></a>Response 设置响应数据</h4><p>HTTP响应数据总共分为三部分内容，分别是响应行、响应头、响应体，对于这三部分内容的数据，respone 对象都提供了哪些方法来进行设置?</p><p>对于响应头，比较常用的就是设置响应状态码：<code>void setStatus(int sc);</code>。</p><p>设置响应头键值对：<code>void setHeader(String name,String value);</code>。</p><p>对于响应体，是通过字符、字节输出流的方式往浏览器写，获取字符输出流：<code>PrintWriter getWriter();</code>，或获取字节输出流：<code>ServletOutputStream getOutputStream();</code>。</p><p>介绍完这些方法后，后面我们会通过案例把这些方法都用一用，首先先来完成下重定向的功能开发。</p><h4 id="Respones-请求重定向"><a href="#Respones-请求重定向" class="headerlink" title="Respones 请求重定向"></a>Respones 请求重定向</h4><p>Response 重定向（redirect）是一种资源跳转方式。浏览器发送请求给服务器，服务器中对应的资源 A 接收到请求。当资源 A 现在无法处理该请求，就会给浏览器响应一个 302 的状态码 + location 的一个访问资源 B 的路径。浏览器接收到响应状态码为 302 就会重新发送请求到 location 对应的访问地址去访问资源 B。资源 B 接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向。</p><p>重定向的实现方式：</p><pre><code class="http">resp.setStatus(302);resp.setHeader(&quot;location&quot;,&quot;资源B的访问路径&quot;);</code></pre><ol><li>  具体使用，我们先创建 ResponseDemo1 类</li></ol><pre><code class="java">@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><ol start="2"><li>  创建 ResponseDemo2 类</li></ol><pre><code class="java">@WebServlet(&quot;/resp2&quot;)public class ResponseDemo2 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp2....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><ol start="3"><li>  在 ResponseDemo1 的 doGet 方法中给前端响应数据</li></ol><pre><code class="java">@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);        //重定向        //1.设置响应状态码 302        response.setStatus(302);        //2. 设置响应头 Location        response.setHeader(&quot;Location&quot;,&quot;/request-demo/resp2&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><ol start="4"><li>  虽然功能已经实现，但是从设置重定向的两行代码来看，会发现除了重定向的地址不一样，其他的内容都是一模一样，所以request对象给我们提供了简化的编写方式为：<code>resposne.sendRedirect(&quot;/request-demo/resp2&quot;)</code>。</li></ol><pre><code class="java">@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);        //重定向        resposne.sendRedirect(&quot;/request-demo/resp2&quot;)；    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>重定向的特点</p><ul><li><p>浏览器地址栏路径发送变化：当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化。</p></li><li><p>可以重定向到任何位置的资源(服务内容、外部均可)，因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。</p></li><li><p>两次请求，不能在多个资源使用 request 共享数据，因为浏览器发送了两次请求，是两个不同的 request 对象，就无法通过 request 对象进行共享数据</p></li></ul><h4 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h4><ol><li><p>转发的时候路径上没有加 <code>/request-demo</code> 而重定向加了，因为对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录。对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。</p></li><li><p>在重定向的代码中，<code>/request-demo</code> 是固定编码的，如果后期通过 Tomcat 插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，因此我们可以在代码中动态去获取项目访问的虚拟目录进行优化，具体可以借助 request 对象 <code>getContextPath() </code>方法，修改后的代码如下：</p></li></ol><pre><code class="java">@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);        //简化方式完成重定向        //动态获取虚拟目录        String contextPath = request.getContextPath();        response.sendRedirect(contextPath+&quot;/resp2&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>重新启动访问测试，功能依然能够实现，此时就可以动态获取项目访问的虚拟路径，从而降低代码的耦合度。</p><h4 id="Response-响应字符数据"><a href="#Response-响应字符数据" class="headerlink" title="Response 响应字符数据"></a>Response 响应字符数据</h4><p>要想将字符数据写回到浏览器，我们需要两个步骤：首先通过 Response 对象获取字符输出流（<code>PrintWriter writer = resp.getWriter();</code>），再通过字符输出流写数据（<code>writer.write(&quot;aaa&quot;);</code>）</p><ol><li>返回一个简单的字符串 <code>aaa</code>。</li></ol><pre><code class="java">/** * 响应字符数据：设置字符数据的响应体 */@WebServlet(&quot;/resp3&quot;)public class ResponseDemo3 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        //1. 获取字符输出流        PrintWriter writer = response.getWriter();         writer.write(&quot;aaa&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><ol start="2"><li>返回一串 html 字符串，并且能被浏览器解析。</li></ol><pre><code class="java">PrintWriter writer = response.getWriter();//content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签response.setHeader(&quot;content-type&quot;,&quot;text/html&quot;);writer.write(&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;);//一次请求响应结束后，response 对象就会被销毁掉，所以不要手动关闭流。</code></pre><ol start="3"><li>返回一个中文的字符串 <code>你好</code>，需要注意设置响应数据的编码为 <code>utf-8</code></li></ol><pre><code class="java">//设置响应的数据格式及数据的编码response.setContentType(&quot;text/html;charset=utf-8&quot;);writer.write(&quot;你好&quot;);</code></pre><h4 id="Response-响应字节数据"><a href="#Response-响应字节数据" class="headerlink" title="Response 响应字节数据"></a>Response 响应字节数据</h4><p>要想将字节数据写回到浏览器，我们需要两个步骤：首先通过Response对象获取字节输出流（<code>ServletOutputStream outputStream = resp.getOutputStream();</code>），再通过字节输出流写数据（<code>outputStream.write(字节数据);</code>）。</p><p>响应字符数据的实际应用：</p><ol><li>返回一个图片文件到浏览器</li></ol><pre><code class="java">/** * 响应字节数据：设置字节数据的响应体 */@WebServlet(&quot;/resp4&quot;)public class ResponseDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 读取文件        FileInputStream fis = new FileInputStream(&quot;d://a.jpg&quot;);        //2. 获取response字节输出流        ServletOutputStream os = response.getOutputStream();        //3. 完成流的copy        byte[] buff = new byte[1024];        int len = 0;        while ((len = fis.read(buff))!= -1)&#123;            os.write(buff,0,len);        &#125;        fis.close();    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre><p>上述代码中，对于流的 copy 的代码还是比较复杂的，所以我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是：</p><ol><li>  pom.xml 添加依赖</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>  调用工具类方法</li></ol><pre><code class="java">//fis:输入流//os:输出流IOUtils.copy(fis,os);</code></pre><p>优化后的代码：</p><pre><code class="java">/** * 响应字节数据：设置字节数据的响应体 */@WebServlet(&quot;/resp4&quot;)public class ResponseDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 读取文件        FileInputStream fis = new FileInputStream(&quot;d://a.jpg&quot;);        //2. 获取response字节输出流        ServletOutputStream os = response.getOutputStream();        //3. 完成流的copy          IOUtils.copy(fis,os);        fis.close();    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java Web 核心第二章。在 Java Servlet 中，Request 对象是用来封装请求数据的对象，Response 对象是用来封装响应数据的对象。Web 服务器收到客户端的 HTTP 请求，会针对每一次请求分别创建一个用于代表请求的 Request 对象和代表响应的 Response 对象。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="Servlet" scheme="http://blog.zhuangzhihao.top/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议和 Servlet</title>
    <link href="http://blog.zhuangzhihao.top/HTTP&amp;Servlet/"/>
    <id>http://blog.zhuangzhihao.top/HTTP&amp;Servlet/</id>
    <published>2022-04-04T16:00:00.000Z</published>
    <updated>2022-05-16T05:49:21.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java Web 核心第一章。Java Web 是用 Java 技术来解决相关 web 互联网领域的技术栈，国内很多大型网站公司也是首选 Java 语言来解决 web 互联网相关的问题。要了解 Java Web 开发的技术栈，首先需要理解 HTTP 协议和 HTTP 请求与响应数据的格式，理解 Servlet 的执行流程和生命周期，掌握 Servlet 的使用和相关配置。</p></blockquote><a id="more"></a><h3 id="一、HTTP-协议"><a href="#一、HTTP-协议" class="headerlink" title="一、HTTP 协议"></a>一、HTTP 协议</h3><p>HyperText Transfer Protocol（超文本传输协议）规定了浏览器和服务器之间数据传输的规则。数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。</p><p>HTTP 协议是基于 TCP 的协议，TCP 是一种面向连接的（建立连接前是需经过三次握手）、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。</p><p>HTTP 同样也是基于请求—响应模型的，一次请求对应一次响应，请求和响应是一一对应关系。</p><p>HTTP 协议是无状态协议，对于事物处理没有记忆能力，每次请求—响应都是独立的。无状态指的是客户端发送 HTTP 请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点，缺点是多次请求间不能共享数据，但速度快。</p><p>请求之间无法共享数据会引发的问题，如电商网站加入购物车和去购物车结算是两次请求，加入购物车请求响应结束后，并未记录加入购物车是何商品，发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据，在 Java Web 中要使用会话技术（Cookie、Session）来解决这个问题。</p><h4 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a>请求数据格式</h4><p>HTTP 请求数据总共分为三部分内容，分别是请求行、请求头、请求体，请求方式有七种，最常用的是 GET 和 POST 方法。</p><p>请求行是 HTTP 请求中的第一行数据，请求行包含三块内容，分别是 <code>[请求方式] /[请求URL路径] / [HTTP协议及版本]</code>。</p><pre><code class="http">GET / HTTP/1.1</code></pre><p>请求头从第二行开始，格式均为 <code>key: value</code> 形式，请求头中会包含若干个属性。</p><pre><code class="HTTP">Host: 请求的主机名User-Agent: 浏览器版本, Mozilla/5.0 Chrome/79Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等</code></pre><p>服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，比如浏览器兼容问题。</p><p>请求体是 POST 请求的最后一部分，存储请求参数，请求体和请求头之间是有一个空行隔开。</p><pre><code class="http">username=bezhuang@password=1234</code></pre><p>GET 和 POST 两个请求的区别：GET 请求请求参数在请求行中，没有请求体，POST 请求请求参数在请求体中，GET 请求请求参数大小有限制，POST 没有。</p><h4 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h4><p>响应数据总共分为三部分内容，分别是响应行、响应头、响应体。</p><p>响应行是响应数据的第一行，响应行包含三块内容，分别是 <code>[HTTP协议及版本] [响应状态码] [状态码的描述]</code>。</p><pre><code class="http">HTTP/1.1 200 OK</code></pre><p>响应状态码</p><ul><li>200  ok 客户端请求成功</li><li>404  Not Found 请求资源不存在</li><li>500 Internal Server Error 服务端发生不可预期的错误</li></ul><p>响应头从第二行开始，格式也为 <code>key：value</code> 形式，响应头中会包含若干个属性。</p><pre><code class="http">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；Content-Length：表示该响应内容的长度（字节数）；Content-Encoding：表示该响应压缩算法，例如gzip；Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒</code></pre><p>响应体是最后一部分，存放响应数据，<code>&lt;html&gt;数据内容&lt;/html&gt;</code>。</p><h4 id="自定义服务器"><a href="#自定义服务器" class="headerlink" title="自定义服务器"></a>自定义服务器</h4><p>可以使用 Java 编写服务器，用来接受页面发送的请求和响应数据给前端浏览器，主要使用到的是 <code>ServerSocket</code> 和 <code>Socket</code>。</p><pre><code class="java">package com.itheima;import sun.misc.IOUtils;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.nio.charset.StandardCharsets;import java.nio.file.Files;public class Server &#123;    public static void main(String[] args) throws IOException &#123;        ServerSocket ss = new ServerSocket(8080); // 监听指定端口        System.out.println(&quot;server is running...&quot;);        while (true)&#123;            Socket sock = ss.accept();            System.out.println(&quot;connected from &quot; + sock.getRemoteSocketAddress());            Thread t = new Handler(sock);            t.start();        &#125;    &#125;&#125;class Handler extends Thread &#123;    Socket sock;    public Handler(Socket sock) &#123;        this.sock = sock;    &#125;    public void run() &#123;        try (InputStream input = this.sock.getInputStream()) &#123;            try (OutputStream output = this.sock.getOutputStream()) &#123;                handle(input, output);            &#125;        &#125; catch (Exception e) &#123;            try &#123;                this.sock.close();            &#125; catch (IOException ioe) &#123;            &#125;            System.out.println(&quot;client disconnected.&quot;);        &#125;    &#125;    private void handle(InputStream input, OutputStream output) throws IOException &#123;        BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));        // 读取HTTP请求:        boolean requestOk = false;        String first = reader.readLine();        if (first.startsWith(&quot;GET / HTTP/1.&quot;)) &#123;            requestOk = true;        &#125;        for (;;) &#123;            String header = reader.readLine();            if (header.isEmpty()) &#123; // 读取到空行时, HTTP Header读取完毕                break;            &#125;            System.out.println(header);        &#125;        System.out.println(requestOk ? &quot;Response OK&quot; : &quot;Response Error&quot;);        if (!requestOk) &#123;            // 发送错误响应:            writer.write(&quot;HTTP/1.0 404 Not Found\r\n&quot;);            writer.write(&quot;Content-Length: 0\r\n&quot;);            writer.write(&quot;\r\n&quot;);            writer.flush();        &#125; else &#123;            // 发送成功响应:            //读取html文件，转换为字符串            BufferedReader br = new BufferedReader(new FileReader(&quot;http/html/a.html&quot;));            StringBuilder data = new StringBuilder();            String line = null;            while ((line = br.readLine()) != null)&#123;                data.append(line);            &#125;            br.close();            int length = data.toString().getBytes(StandardCharsets.UTF_8).length;            writer.write(&quot;HTTP/1.1 200 OK\r\n&quot;);            writer.write(&quot;Connection: keep-alive\r\n&quot;);            writer.write(&quot;Content-Type: text/html\r\n&quot;);            writer.write(&quot;Content-Length: &quot; + length + &quot;\r\n&quot;);            writer.write(&quot;\r\n&quot;); // 空行标识Header和Body的分隔            writer.write(data.toString());            writer.flush();        &#125;    &#125;&#125;</code></pre><h3 id="二、Tomcat-服务器"><a href="#二、Tomcat-服务器" class="headerlink" title="二、Tomcat 服务器"></a>二、Tomcat 服务器</h3><p>Web 服务器是一个安装在服务器端的对 HTTP 协议的操作进行封装的应用程序，使得程序员不必直接对协议进行操作，让 Web 开发更加便捷，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><p>Tomcat 是 Apache 软件基金会一个核心项目，是一个开源免费的轻量级 Web 服务器，支持 Servlet/JSP 少量 JavaEE 规范。JavaEE 规范是指 Java 企业级开发的技术规范总和。因为 Tomcat 支持 Servlet/JSP 规范，所以 Tomcat 也被称为Web容器、Servlet容器。Servlet需要依赖 Tomcat 才能运行。</p><p>使用 Maven 工具能更加简单快捷的把 Web 项目给创建出来，创建方式有两种：使用骨架和不使用骨架。使用骨架，默认没有 java 和 resources 目录，需要手动完成创建补齐，不使用骨架要在 pom.xml 设置打包方式为 war、补齐 Maven Web 项目缺失 webapp 的目录结构和 WEB-INF/web.xml 的目录结构。</p><p>Maven Web 项目创建成功后，通过 Maven 的 package 命令可以将项目打包成 war 包，将 war 文件拷贝到 Tomcat 的 webapps 目录下，启动 Tomcat 就可以将项目部署成功，然后通过浏览器进行访问即可。</p><p>在 IDEA 中可以直接使用 Maven 中的 Tomcat 插件来部署项目，即在 pom.xml 中添加 Tomcat 插件，再使用 Maven Helper 插件快速启动项目。</p><pre><code class="xml">&lt;build&gt;    &lt;plugins&gt;        &lt;!--Tomcat插件 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;            &lt;configuration&gt;                &lt;port&gt;80&lt;/port&gt;&lt;!--访问端口号 --&gt;                &lt;!--项目访问路径                    未配置访问路径: http://localhost:80/tomcat-demo2/a.html                    配置/后访问路径: http://localhost:80/a.html                    如果配置成 /hello,访问路径会变成什么?                        答案: http://localhost:80/hello/a.html                --&gt;                &lt;path&gt;/&lt;/path&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><h3 id="三、Servlet"><a href="#三、Servlet" class="headerlink" title="三、Servlet"></a>三、Servlet</h3><p>Servlet 是 Java Web 最为核心的内容，它是 Java 提供的一门动态 web 资源开发技术。使用 Servlet 就可以实现根据不同的登录用户在页面上动态显示不同内容。Servlet 是 JavaEE 规范之一，其实就是一个接口，将来我们需要定义 Servlet 类实现 Servlet 接口，并由 web 服务器运行 Servlet。</p><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>编写一个 Servlet 类，并使用 IDEA 中 Tomcat 插件进行部署，最终通过浏览器访问所编写的 Servlet 程序。具体的实现步骤如下：</p><ol><li>创建 Web 项目 <code>web-demo</code>，导入 Servlet 依赖坐标。</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;!--      此处为什么需要添加该标签?      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错    --&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>创建：定义一个类，实现 Servlet 接口，并重写接口中所有方法，并在 service 方法中输入一句话。</li></ol><pre><code class="java">package com.itheima.web;import javax.servlet.*;import java.io.IOException;public class ServletDemo1 implements Servlet &#123;    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;        System.out.println(&quot;servlet hello world~&quot;);    &#125;    public void init(ServletConfig servletConfig) throws ServletException &#123;    &#125;    public ServletConfig getServletConfig() &#123;        return null;    &#125;    public String getServletInfo() &#123;        return null;    &#125;    public void destroy() &#123;    &#125;&#125;</code></pre><ol start="3"><li>配置：在类上使用 <code>@WebServlet</code> 注解，配置该 Servlet 的访问路径。</li></ol><pre><code class="java">@WebServlet(&quot;/demo1&quot;)</code></pre><ol start="4"><li>访问：启动 Tomcat，浏览器中输入 URL 地址访问该 Servlet。</li></ol><pre><code class="http">http://localhost:8080/web-demo/demo1</code></pre><ol start="5"><li>通过浏览器访问后，在控制台会打印 <code>servlet hello world~</code> ，说明 servlet 程序已经成功运行。</li></ol><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>Servlet 的执行流程：浏览器发出 <code>http://localhost:8080/web-demo/demo1</code> 请求，从请求中可以解析出三部分内容，分别是 <code>localhost:8080</code>、<code>web-demo</code>、<code>demo1</code>，根据 <code>localhost:8080</code> 可以找到要访问的 Tomcat Web 服务器，根据 <code>web-demo</code> 可以找到部署在 Tomcat 服务器上的 web-demo 项目，根据 <code>demo1</code> 可以找到要访问的是项目中的哪个 Servlet 类，根据 <code>@WebServlet</code> 后面的值进行匹配。</p><p>找到 ServletDemo1 这个类后，Tomcat Web 服务器就会为 ServletDemo1 这个类创建一个对象，然后调用对象中的 service 方法。</p><p>ServletDemo1 实现了 Servlet 接口，所以类中必然会重写 service 方法供 Tomcat Web 服务器进行调用，service 方法中 ServletRequest 和 ServletResponse 两个参数，ServletRequest 封装的是请求数据，ServletResponse 封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互。</p><p>Servlet 由 web 服务器创建，Servlet 方法由 web 服务器调用。</p><p>因为我们自定义的 Servlet 必须实现 Servlet 接口并复写其方法，而 Servlet 接口中有 service 方法，因此服务器知道 Servlet 中一定有 service 方法。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>对象的生命周期指一个对象从被创建到被销毁的整个过程。</p><p>Servlet 运行在 Servlet 容器（web 服务器）中，其生命周期由容器来管理，分为 4 个阶段：</p><ol><li>加载和实例化：默认情况下，当 Servlet 第一次被访问时，由容器创建 Servlet 对象，，但是如果创建 Servlet 比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们可以把 Servlet 的创建放到服务器启动的时候来创建。</li></ol><pre><code class="java">@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)/*loadOnstartup的取值有两类情况    （1）负整数:第一次访问时创建Servlet对象    （2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高*/</code></pre><ol start="2"><li>初始化：在 Servlet 实例化之后，容器将调用 Servlet 的 <code>init()</code> 方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次。</li><li>请求处理：每次请求 Servlet 时，Servlet 容器都会调用 Servlet 的 <code>service()</code> 方法对请求进行处理</li><li>服务终止：当需要释放内存或者容器关闭时，容器就会调用 Servlet 实例的 <code>destroy()</code> 方法完成资源的释放。在 <code>destroy()</code> 方法调用之后，容器会释放这个 Servlet 实例，该实例随后会被 Java 的垃圾收集器所回收。</li></ol><p>通过案例演示 Servlet 生命周期方法</p><pre><code class="java">package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/*** Servlet生命周期方法*/@WebServlet(urlPatterns = &quot;/demo2&quot;,loadOnStartup = 1)public class ServletDemo2 implements Servlet &#123;    /**     *  初始化方法     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用     *  2.调用次数: 1次     * @param config     * @throws ServletException     */    public void init(ServletConfig config) throws ServletException &#123;        System.out.println(&quot;init...&quot;);    &#125;    /**     * 提供服务     * 1.调用时机:每一次Servlet被访问时，调用     * 2.调用次数: 多次     * @param req     * @param res     * @throws ServletException     * @throws IOException     */    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        System.out.println(&quot;servlet hello world~&quot;);    &#125;    /**     * 销毁方法     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用     * 2.调用次数: 1次     */    public void destroy() &#123;        System.out.println(&quot;destroy...&quot;);    &#125;    public ServletConfig getServletConfig() &#123;        return null;    &#125;    public String getServletInfo() &#123;        return null;    &#125;&#125;</code></pre><p>Servlet 对象默认是第一次访问的时候被创建，可以使用 <code>@WebServlet(urlPatterns = &quot;/demo2&quot;,loadOnStartup = 1)</code> 的 loadOnStartup 修改成在服务器启动的时候创建。</p><p>Servlet 生命周期中涉及到三个方法，分别是 <code>init()</code>、<code>service()</code>、<code>destroy()</code>，<code>init</code> 方法在 Servlet 对象被创建的时候执行，只执行 1 次，service 方法在 Servlet 被访问的时候调用，每访问 1 次就调用 1 次，destroy 方法在 Servlet 对象被销毁的时候调用，只执行 1 次。</p><h4 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h4><p>Servlet 中总共有5个方法，我们已经介绍过其中的三个，剩下的两个方法为 <code>getServletInfo()</code> 和 <code>getServletConfig() </code>。</p><ol><li>初始化方法，在 Servlet 被创建时执行，只执行一次。</li></ol><pre><code class="java">void init(ServletConfig config) </code></pre><ol start="2"><li>提供服务方法， 每次 Servlet 被访问，都会调用该方法。</li></ol><pre><code class="java">void service(ServletRequest req, ServletResponse res)</code></pre><ol start="3"><li>销毁方法，当 Servlet 被销毁时，调用该方法。在内存释放或服务器关闭时销毁 Servlet。</li></ol><pre><code class="java">void destroy() </code></pre><ol start="4"><li>获取 Servlet 信息方法</li></ol><pre><code class="java">String getServletInfo() //该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可public String getServletInfo() &#123;    return &quot;&quot;;&#125;</code></pre><ol start="5"><li>获取 ServletConfig 对象方法</li></ol><pre><code class="java">ServletConfig getServletConfig()</code></pre><p>ServletConfig 对象在 init 方法的参数中有，而 Tomcat Web 服务器在创建 Servlet 对象的时候会调用 init 方法，必定会传入一个  ServletConfig 对象，我们只需要将服务器传过来的 ServletConfig 进行返回即可。</p><pre><code class="java">package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import java.io.IOException;/** * Servlet方法介绍 */@WebServlet(urlPatterns = &quot;/demo3&quot;,loadOnStartup = 1)public class ServletDemo3 implements Servlet &#123;    private ServletConfig servletConfig;    /**     *  初始化方法     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用     *  2.调用次数: 1次     * @param config     * @throws ServletException     */    public void init(ServletConfig config) throws ServletException &#123;        this.servletConfig = config;        System.out.println(&quot;init...&quot;);    &#125;    public ServletConfig getServletConfig() &#123;        return servletConfig;    &#125;    /**     * 提供服务     * 1.调用时机:每一次Servlet被访问时，调用     * 2.调用次数: 多次     * @param req     * @param res     * @throws ServletException     * @throws IOException     */    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        System.out.println(&quot;servlet hello world~&quot;);    &#125;    /**     * 销毁方法     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用     * 2.调用次数: 1次     */    public void destroy() &#123;        System.out.println(&quot;destroy...&quot;);    &#125;        public String getServletInfo() &#123;        return &quot;&quot;;    &#125;&#125;</code></pre><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>B/S 架构的 web 项目都是针对 HTTP 协议，所以我们自定义 Servlet，会通过继承 HttpServlet，具体的编写格式如下:</p><pre><code class="java">@WebServlet(&quot;/demo4&quot;)public class ServletDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //TODO GET 请求方式处理逻辑        System.out.println(&quot;get...&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //TODO Post 请求方式处理逻辑        System.out.println(&quot;post...&quot;);    &#125;&#125;</code></pre><p>要想发送一个 GET 请求，请求该 Servlet，只需要通过浏览器发送 <code>http://localhost:8080/web-demo/demo4</code>，就能看到 doGet 方法被执行了。</p><p>要想发送一个 POST 请求，请求该 Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个 form 表单来发送请求，在 webapp 下创建一个 <code>a.html</code> 页面，启动测试，即可看到 doPost 方法被执行了。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/web-demo/demo4&quot; method=&quot;post&quot;&gt;        &lt;input name=&quot;username&quot;/&gt;&lt;input type=&quot;submit&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>因为前端发送 GET 和 POST 请求的时候，参数的位置不一致，GET 请求参数在请求行中，POST 请求参数在请求体中，为了能处理不同的请求方式，我们得在 service 方法中进行判断，然后写不同的业务处理。</p><pre><code class="java">package com.itheima.web;import javax.servlet.*;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/demo5&quot;)public class ServletDemo5 implements Servlet &#123;    public void init(ServletConfig config) throws ServletException &#123;    &#125;    public ServletConfig getServletConfig() &#123;        return null;    &#125;    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        //如何调用?        //获取请求方式，根据不同的请求方式进行不同的业务处理        HttpServletRequest request = (HttpServletRequest)req;       //1. 获取请求方式        String method = request.getMethod();        //2. 判断        if(&quot;GET&quot;.equals(method))&#123;            // get方式的处理逻辑        &#125;else if(&quot;POST&quot;.equals(method))&#123;            // post方式的处理逻辑        &#125;    &#125;    public String getServletInfo() &#123;        return null;    &#125;    public void destroy() &#123;    &#125;&#125;</code></pre><p>这样能实现，但是每个 Servlet 类中都将有相似的代码，针对这个问题，我们可以对 Servlet 接口进行继承封装，来简化代码开发。</p><pre><code class="java">package com.itheima.web;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class MyHttpServlet implements Servlet &#123;    public void init(ServletConfig config) throws ServletException &#123;    &#125;    public ServletConfig getServletConfig() &#123;        return null;    &#125;    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        HttpServletRequest request = (HttpServletRequest)req;        //1. 获取请求方式        String method = request.getMethod();        //2. 判断        if(&quot;GET&quot;.equals(method))&#123;            // get方式的处理逻辑            doGet(req,res);        &#125;else if(&quot;POST&quot;.equals(method))&#123;            // post方式的处理逻辑            doPost(req,res);        &#125;    &#125;    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;    protected void doGet(ServletRequest req, ServletResponse res) &#123;    &#125;    public String getServletInfo() &#123;        return null;    &#125;    public void destroy() &#123;    &#125;&#125;</code></pre><p>有了 MyHttpServlet 这个类，以后我们再编写 Servlet 类的时候，只需要继承 MyHttpServlet，重写父类中的 doGet 和 doPost 方法，就可以用来处理 GET 和 POST 请求的业务逻辑。</p><pre><code class="java">@WebServlet(&quot;/demo5&quot;)public class ServletDemo5 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;post...&quot;);    &#125;&#125;</code></pre><p>将来页面发送的是 GET 请求，则会进入到 doGet 方法中进行执行，如果是 POST 请求，则进入到 doPost 方法。这样代码在编写的时候就相对来说更加简单快捷。</p><p>类似 MyHttpServlet 这样的类 Servlet 中已经为我们提供好了，就是 HttpServlet。</p><pre><code class="java">protected void service(HttpServletRequest req, HttpServletResponse resp)        throws ServletException, IOException    &#123;        String method = req.getMethod();        if (method.equals(METHOD_GET)) &#123;            long lastModified = getLastModified(req);            if (lastModified == -1) &#123;                // servlet doesn&#39;t support if-modified-since, no reason                // to go through further expensive logic                doGet(req, resp);            &#125; else &#123;                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);                if (ifModifiedSince &lt; lastModified) &#123;                    // If the servlet mod time is later, call doGet()                    // Round down to the nearest second for a proper compare                    // A ifModifiedSince of -1 will always be less                    maybeSetLastModified(resp, lastModified);                    doGet(req, resp);                &#125; else &#123;                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);                &#125;            &#125;        &#125; else if (method.equals(METHOD_HEAD)) &#123;            long lastModified = getLastModified(req);            maybeSetLastModified(resp, lastModified);            doHead(req, resp);        &#125; else if (method.equals(METHOD_POST)) &#123;            doPost(req, resp);        &#125; else if (method.equals(METHOD_PUT)) &#123;            doPut(req, resp);        &#125; else if (method.equals(METHOD_DELETE)) &#123;            doDelete(req, resp);        &#125; else if (method.equals(METHOD_OPTIONS)) &#123;            doOptions(req,resp);        &#125; else if (method.equals(METHOD_TRACE)) &#123;            doTrace(req,resp);               &#125; else &#123;            //            // Note that this means NO servlet supports whatever            // method was requested, anywhere on this server.            //            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);            Object[] errArgs = new Object[1];            errArgs[0] = method;            errMsg = MessageFormat.format(errMsg, errArgs);            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);        &#125;    &#125;</code></pre><p>HttpServlet 的使用步骤是先继承 HttpServlet，再重写 doGet、doPost 或其他方法。HttpServlet 的原理就是获取请求方式，并根据不同的请求方式，调用不同的 doXxx 方法。</p><h4 id="urlPattern-配置"><a href="#urlPattern-配置" class="headerlink" title="urlPattern 配置"></a>urlPattern 配置</h4><p>Servlet 类编写好后，要想被访问到，就需要配置其访问路径（urlPattern），一个 Servlet，可以配置多个 urlPattern。</p><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;/*** urlPattern: 一个 Servlet 可以配置多个访问路径*/@WebServlet(urlPatterns = &#123;&quot;/demo7&quot;,&quot;/demo8&quot;&#125;)public class ServletDemo7 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo7 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125;// 在浏览器上输入 http://localhost:8080/web-demo/demo7, http://localhost:8080/web-demo/demo8 这两个地址都能访问到 ServletDemo7 的 doGet 方法</code></pre><p>urlPattern 总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配，配置的优先级为 精确匹配 &gt; 目录匹配 &gt; 扩展名匹配 &gt; <code>/*</code> &gt; <code>/</code> 。</p><ol><li>精确匹配</li></ol><pre><code class="java">@WebServlet(urlPatterns = &quot;/user/select&quot;)public class ServletDemo8 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo8 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125; //访问路径：http://localhost:8080/web-demo/user/select</code></pre><ol start="2"><li>目录匹配：<code>/*</code></li></ol><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;/user/*&quot;)public class ServletDemo9 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo9 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125; //访问路径：http://localhost:8080/web-demo/user/任意</code></pre><ol start="3"><li>扩展名匹配：<code>*.do</code></li></ol><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;*.do&quot;)public class ServletDemo10 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo10 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125;  //访问路径：http://localhost:8080/web-demo/任意.do</code></pre><ol start="4"><li>任意匹配：<code>/</code> 或 <code>/*</code></li></ol><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;/&quot;)public class ServletDemo11 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo11 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125; //访问路径：http://localhost:8080/demo-web/任意</code></pre><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &quot;/*&quot;)public class ServletDemo12 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo12 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125; // 访问路径：http://localhost:8080/demo-web/任意</code></pre><p>当我们的项目中的 Servlet 配置了 <code>/</code>，会覆盖掉 tomcat 中的 DefaultServlet，当其他的 url-pattern 都匹配不上时都会走这个 Servlet。当我们的项目中配置了 <code>/*</code>，意味着匹配任意访问路径。</p><p>DefaultServlet 是用来处理静态资源，如果配置了 <code>/</code> 会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的 Servlet 类，最终导致静态资源不能被访问。</p><h4 id="XML-配置"><a href="#XML-配置" class="headerlink" title="XML 配置"></a>XML 配置</h4><p>一般情况下 Servlet 使用的是注解配置 <code>@WebServlet</code>，但 3.0 版本前只支持 XML 配置文件的配置方法。对于 XML 的配置步骤有两步：</p><ol><li>编写Servlet类。</li></ol><pre><code class="java">package com.itheima.web;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;public class ServletDemo13 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo13 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125;</code></pre><ol start="2"><li>在 web.xml 中配置该 Servlet。</li></ol><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--         Servlet 全类名    --&gt;    &lt;servlet&gt;        &lt;!-- servlet的名称，名字任意--&gt;        &lt;servlet-name&gt;demo13&lt;/servlet-name&gt;        &lt;!--servlet的类全名--&gt;        &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;!--         Servlet 访问路径    --&gt;    &lt;servlet-mapping&gt;        &lt;!-- servlet的名称，要和上面的名称一致--&gt;        &lt;servlet-name&gt;demo13&lt;/servlet-name&gt;        &lt;!-- servlet的访问路径--&gt;        &lt;url-pattern&gt;/demo13&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java Web 核心第一章。Java Web 是用 Java 技术来解决相关 web 互联网领域的技术栈，国内很多大型网站公司也是首选 Java 语言来解决 web 互联网相关的问题。要了解 Java Web 开发的技术栈，首先需要理解 HTTP 协议和 HTTP 请求与响应数据的格式，理解 Servlet 的执行流程和生命周期，掌握 Servlet 的使用和相关配置。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="HTTP" scheme="http://blog.zhuangzhihao.top/tags/HTTP/"/>
    
    <category term="Servlet" scheme="http://blog.zhuangzhihao.top/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 基础知识总结</title>
    <link href="http://blog.zhuangzhihao.top/MyBatis%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.zhuangzhihao.top/MyBatis%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-18T16:00:00.000Z</published>
    <updated>2022-05-05T11:47:00.363Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><a id="more"></a><h3 id="一、Mybatis-概述"><a href="#一、Mybatis-概述" class="headerlink" title="一、Mybatis 概述"></a>一、Mybatis 概述</h3><p>MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发。</p><p>MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。</p><p>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a> 。</p><p>持久层：负责将数据到保存到数据库的那一层代码。以后开发我们会将操作数据库的 Java 代码作为持久层。而 Mybatis 就是对 jdbc 代码进行了封装。</p><p>JavaEE三层架构：表现层、业务层、持久层。</p><p>框架：框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。在框架的基础之上构建软件编写更加高效、规范、通用、可扩展。</p><h4 id="JDBC-缺点"><a href="#JDBC-缺点" class="headerlink" title="JDBC 缺点"></a>JDBC 缺点</h4><p>硬编码：注册驱动、获取连接代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要换成其他的关系型数据库的话，要修改源代码。如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。</p><p>操作繁琐：手动设置参数。手动封装结果集。</p><p>使用Mybatis 优化：硬编码可以配置到配置文件，操作繁琐的地方 MyBatis 都自动完成。</p><h4 id="MyBatis-快速入门"><a href="#MyBatis-快速入门" class="headerlink" title="MyBatis 快速入门"></a>MyBatis 快速入门</h4><p>需求：查询 user 表中所有的数据。</p><p>创建 user 表，添加数据。</p><pre><code class="sql">create database mybatis;use mybatis;drop table if exists tb_user;create table tb_user(    id int primary key auto_increment,    username varchar(20),    password varchar(20),    gender char(1),    addr varchar(30));INSERT INTO tb_user VALUES (1, &#39;zhangsan&#39;, &#39;123&#39;, &#39;男&#39;, &#39;北京&#39;);INSERT INTO tb_user VALUES (2, &#39;李四&#39;, &#39;234&#39;, &#39;女&#39;, &#39;天津&#39;);INSERT INTO tb_user VALUES (3, &#39;王五&#39;, &#39;11&#39;, &#39;男&#39;, &#39;西安&#39;);</code></pre><p>创建模块，导入坐标：需要在项目的 resources 目录下创建 logback 的配置文件。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;!--        CONSOLE ：表示当前的日志信息是可以输出到控制台的。    --&gt;    &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;[%level] %blue(%d&#123;HH:mm:ss.SSS&#125;) %cyan([%thread]) %boldGreen(%logger&#123;15&#125;) - %msg %n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;logger name=&quot;com.itheima&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;Console&quot;/&gt;    &lt;/logger&gt;    &lt;!--      level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF     ， 默认debug      &lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个输出位置将会被本日志级别控制。      --&gt;    &lt;root level=&quot;DEBUG&quot;&gt;        &lt;appender-ref ref=&quot;Console&quot;/&gt;    &lt;/root&gt;&lt;/configuration&gt;</code></pre><p>在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标。</p><pre><code class="xml">&lt;dependencies&gt;    &lt;!--mybatis 依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--mysql 驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.46&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--junit 单元测试--&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.13&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- 添加slf4j日志api --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;        &lt;version&gt;1.7.20&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 添加logback-classic依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;        &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 添加logback-core依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;        &lt;artifactId&gt;logback-core&lt;/artifactId&gt;        &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>编写 MyBatis 核心配置文件 – &gt; 替换连接信息 解决硬编码问题。</p><ul><li>  在模块下的 resources 目录下创建 MyBatis 的配置文件 <code>mybatis-config.xml</code>，内容如下：</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.itheima.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--    environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment    --&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!--数据库连接信息--&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;        &lt;environment id=&quot;test&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!--数据库连接信息--&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;       &lt;!--加载sql映射文件--&gt;       &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>编写 SQL 映射文件：统一管理sql语句，解决硬编码问题。</p><ul><li>  在模块的 <code>resources</code> 目录下创建映射配置文件 <code>UserMapper.xml</code>，内容如下：</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt;        select * from tb_user;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>编码</p><ul><li>  在 <code>com.itheima.pojo</code> 包下创建 User类。</li></ul><pre><code class="java">public class User &#123;    private int id;    private String username;    private String password;    private String gender;    private String addr;    //添加 setter 和 getter&#125;</code></pre><ul><li>  在 <code>com.itheima</code> 包下编写 MybatisDemo 测试类。</li></ul><pre><code class="java">public class MyBatisDemo &#123;    public static void main(String[] args) throws IOException &#123;        //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //2. 获取SqlSession对象，用它来执行sql        SqlSession sqlSession = sqlSessionFactory.openSession();        //3. 执行sql        List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;); //参数是一个字符串，该字符串必须是映射配置文件的namespace.id        System.out.println(users);        //4. 释放资源        sqlSession.close();    &#125;&#125;</code></pre><h3 id="二、Mapper-代理开发"><a href="#二、Mapper-代理开发" class="headerlink" title="二、Mapper 代理开发"></a>二、Mapper 代理开发</h3><p>Mapper 代理方式的目的：解决原生方式中的硬编码，简化后期执行SQL。</p><h4 id="使用-Mapper-代理要求"><a href="#使用-Mapper-代理要求" class="headerlink" title="使用 Mapper 代理要求"></a>使用 Mapper 代理要求</h4><ul><li><p>定义与 SQL 映射文件同名的 Mapper 接口，并且将 Mapper 接口和 SQL 映射文件放置在同一目录下。</p></li><li><p>设置 SQL 映射文件的 namespace 属性为 Mapper 接口全限定名。</p></li><li><p>在 Mapper 接口中定义方法，方法名就是 SQL 映射文件中 sql 语句的 id，并保持参数类型和返回值类型一致。</p></li></ul><h4 id="Mapper-代理代码实现"><a href="#Mapper-代理代码实现" class="headerlink" title="Mapper 代理代码实现"></a>Mapper 代理代码实现</h4><p>在 <code>com.itheima.mapper</code> 包下创建 UserMapper接口，代码如下：</p><pre><code class="java">public interface UserMapper &#123;    List&lt;User&gt; selectAll();    User selectById(int id);&#125;</code></pre><p>在 <code>resources</code> 下创建 <code>com/itheima/mapper</code> 目录，并在该目录下创建 UserMapper.xml 映射配置文件：</p><pre><code class="xml">&lt;!--    namespace:名称空间。必须是对应接口的全限定名--&gt;&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt;        select * from tb_user;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>在 <code>com.itheima</code> 包下创建 MybatisDemo2 测试类，代码如下：</p><pre><code class="java">/** * Mybatis 代理开发 */public class MyBatisDemo2 &#123;    public static void main(String[] args) throws IOException &#123;        //1. 加载mybatis的核心配置文件，获取 SqlSessionFactory        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //2. 获取SqlSession对象，用它来执行sql        SqlSession sqlSession = sqlSessionFactory.openSession();        //3. 执行sql        //3.1 获取UserMapper接口的代理对象        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        List&lt;User&gt; users = userMapper.selectAll();        System.out.println(users);        //4. 释放资源        sqlSession.close();    &#125;&#125;</code></pre><p>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。</p><p>也就是将核心配置文件的加载映射配置文件的配置修改为：</p><pre><code class="xml">&lt;mappers&gt;    &lt;!--加载sql映射文件--&gt;    &lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt;    &lt;!--Mapper代理方式--&gt;    &lt;package name=&quot;com.itheima.mapper&quot;/&gt;&lt;/mappers&gt;</code></pre><h3 id="三、MyBatis-核心配置文件"><a href="#三、MyBatis-核心配置文件" class="headerlink" title="三、MyBatis 核心配置文件"></a>三、MyBatis 核心配置文件</h3><h4 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h4><p>在核心配置文件的 <code>environments</code> 标签中其实是可以配置多个 <code>environment</code> ，使用 <code>id</code> 给每段环境起名，在 <code>environments</code> 中使用 <code>default=&#39;环境id&#39;</code> 来指定使用哪儿段配置。一般就配置一个 <code>environment</code> 即可。</p><pre><code class="xml">&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;/&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;!--数据库连接信息--&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;    &lt;environment id=&quot;test&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;/&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;!--数据库连接信息--&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;=</code></pre><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>在映射配置文件中的 <code>resultType</code> 属性需要配置数据封装的类型（类的全限定名）。</p><p>Mybatis 提供了 <code>类型别名</code>(typeAliases) 可以简化这部分的书写。</p><p>首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。</p><pre><code class="xml">&lt;typeAliases&gt;    &lt;!--name属性的值是实体类所在包--&gt;    &lt;package name=&quot;com.itheima.pojo&quot;/&gt; &lt;/typeAliases&gt;</code></pre><p>通过上述的配置，我们就可以简化映射配置文件中 <code>resultType</code> 属性值的编写。</p><pre><code class="xml">&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt;        select * from tb_user;    &lt;/select&gt;&lt;/mapper&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="MyBatis" scheme="http://blog.zhuangzhihao.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Maven 项目管理知识总结</title>
    <link href="http://blog.zhuangzhihao.top/Maven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.zhuangzhihao.top/Maven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2022-03-13T16:00:00.000Z</published>
    <updated>2022-05-05T11:51:50.776Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Maven 是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理，也可被用于构建和管理其他语言编写的各种项目，例如 C#，Ruby，Scala。</p></blockquote><a id="more"></a><h3 id="一、Maven-概述"><a href="#一、Maven-概述" class="headerlink" title="一、Maven 概述"></a>一、Maven 概述</h3><ul><li>Maven 是专门用于管理和构建 Java 项目的工具，它提供了一套标准化的项目结构，提供了一套标准化的构建流程（编译，测试，打包，发布……），提供了一套依赖管理机制。</li></ul><p>标准化的项目结构：每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。在 Eclipse 中创建的目录，无法在 IDEA 中进行使用，这就造成了很大的不方便，而 Maven 提供了一套标准化的项目结构，所有的 IDE 使用 Maven 构建的项目完全一样，所以 IDE 创建的 Maven 项目可以通用。</p><p>标准化的构建流程：开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而 Maven 提供了一套简单的命令来完成项目构建。</p><p>依赖管理：管理你项目所依赖的第三方资源（jar包、插件），而 Maven 使用标准的坐标配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。</p><p>Maven 模型：</p><ol><li>  项目对象模型（Project Object Model）：将我们自己抽象成一个对象模型，有自己专属的坐标。</li></ol><pre><code class="xml">&lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;artifactId&gt;maven&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code></pre><ol start="2"><li>  依赖管理模型（Dependency）：使用坐标来描述当前项目依赖哪儿些第三方jar包。</li></ol><pre><code class="xml">&lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.32&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>Maven 仓库</p><ul><li>本地仓库：自己计算机上的一个目录。</li><li>中央仓库：由 Maven 团队维护的全球唯一的仓库： <a href="https://repo1.maven.org/maven2/%E3%80%82">https://repo1.maven.org/maven2/。</a></li><li>远程仓库(私服)：一般由公司团队搭建的私有仓库。</li><li>当项目中使用坐标引入对应依赖 jar 包后，首先会查找本地仓库中是否有对应的 jar 包，如果有，则在项目直接引用；如果没有，则去中央仓库中下载对应的jar包到本地仓库。</li><li>如果还可以搭建远程仓库，将来jar包的查找顺序则变为：本地仓库 –&gt; 远程仓库–&gt; 中央仓库。</li></ul><p>Maven 安装配置</p><ul><li>IDEA 自带 Maven 且 Mac 无需配置环境变量。</li><li>安装 Maven Helper 插件。</li></ul><h3 id="二、Maven-基本使用"><a href="#二、Maven-基本使用" class="headerlink" title="二、Maven 基本使用"></a>二、Maven 基本使用</h3><h4 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h4><p><code>mvn compile</code> ：编译，在项目下会生成一个 <code>target</code> 目录。</p><p><code>mvn clean</code>：清理，删除项目下的 <code>target</code> 目录。</p><p><code>mvn test</code>：测试，执行所有的测试代码。</p><p><code>mvn package</code>：打包，将当前项目打成的 jar 包。</p><p><code>mvn install</code>：安装，将当前项目打成jar包，并安装到本地仓库。</p><h4 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h4><p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件。</p><p>Maven 对项目构建的生命周期划分为3套：</p><ul><li><p>clean ：清理工作。</p></li><li><p>default ：核心工作，例如编译，测试，打包，安装等。</p></li><li><p>site ： 产生报告，发布站点等。这套声明周期一般不会使用。</p></li></ul><p>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。当我们执行 <code>install</code>（安装）命令时，它会先执行 <code>compile</code>命令，再执行 <code>test </code> 命令，再执行 <code>package</code> 命令，最后执行 <code>install</code> 命令；当我们执行 <code>package</code> （打包）命令时，它会先执行 <code>compile</code> 命令，再执行 <code>test</code> 命令，最后执行 <code>package</code> 命令。</p><h4 id="Maven-坐标详解"><a href="#Maven-坐标详解" class="headerlink" title="Maven 坐标详解"></a>Maven 坐标详解</h4><p>Maven 中的坐标是资源的唯一标识，资源可以是插件、依赖、当前项目。</p><p>使用坐标来定义项目或引入项目中需要的依赖。</p><p>Maven 坐标主要组成：</p><ul><li><p>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）。</p></li><li><p>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）。</p></li><li><p>version：定义当前项目版本号。</p></li></ul><p>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</p><h3 id="三、Maven-依赖管理"><a href="#三、Maven-依赖管理" class="headerlink" title="三、Maven 依赖管理"></a>三、Maven 依赖管理</h3><h4 id="使用坐标引入-jar-包"><a href="#使用坐标引入-jar-包" class="headerlink" title="使用坐标引入 jar 包"></a>使用坐标引入 jar 包</h4><p>在项目的 pom.xml 中编写<code> &lt;dependencies&gt;</code> 标签。</p><p>在 <code>&lt;dependencies&gt; </code>标签中 使用 <code>&lt;dependency&gt;</code> 引入坐标。</p><p>定义坐标的 <code> groupId</code>，<code>artifactId</code>，<code>version</code>。</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.32&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h4><p>通过设置坐标的依赖范围（scope），可以设置对应 jar 包的作用范围：编译环境、测试环境、运行环境。</p><p>通过 <code>scope</code> 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p><pre><code class="xml">&lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.32&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p><code>scope</code> 的取值：</p><table><thead><tr><th><strong>依赖范围</strong></th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td><strong>compile</strong></td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td><strong>test</strong></td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td><strong>provided</strong></td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td><strong>runtime</strong></td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td><strong>system</strong></td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table><p>compile：作用于编译环境、测试环境、运行环境。</p><p>test：作用于测试环境。典型的就是 Junit 坐标，以后使用 Junit 时，都会将 scope 指定为该值。</p><p>provided：作用于编译环境、测试环境。我们后面会学习 <code>servlet-api</code> ，在使用它时，必须将 <code>scope</code> 设置为该值，不然运行时就会报错。</p><p>runtime： 作用于测试环境、运行环境。jdbc驱动一般将 <code>scope</code> 设置为该值，当然不设置也没有任何问题 。</p><p>如果引入坐标不指定 <code>scope</code> 标签时，默认就是 compile  值，大部分 jar 包都是使用默认值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Maven 是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理，也可被用于构建和管理其他语言编写的各种项目，例如 C#，Ruby，Scala。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="Maven" scheme="http://blog.zhuangzhihao.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>数据操作和数据预处理</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86/</id>
    <published>2022-03-12T16:00:00.000Z</published>
    <updated>2022-05-05T12:26:18.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>要学习深度学习，首先需要先掌握一些基本技能。 所有机器学习方法都涉及从数据中提取信息。 因此，动手学深度学习 v2 课程在第二章的一开始先教授了一些关于数据的实用技能，包括存储、操作和预处理数据，作为预备知识的内容。以下为学习 Dive to Deep Learning（d2l） 课程第二章数据操作 + 数据预处理所记笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><ul><li>为了能够完成各种数据操作，我们需要某种方法来存储和操作数据</li><li>通常，我们需要做两件重要的事：获取数据和将数据读入计算机后对其进行处理</li><li>如果没有某种方法来存储数据，那么获取数据是没有意义的</li></ul><h4 id="n-维数组"><a href="#n-维数组" class="headerlink" title="n 维数组"></a>n 维数组</h4><ul><li><p>深度学习存储和操作数据的主要接口是张量（n维数组）。它提供了各种功能，包括基本数学运算、广播、索引、切片、内存节省和转换其他Python对象</p></li><li><p>n 维数组，也称为张量（tensor）</p></li><li><p>深度学习框架的张量类（在MXNet中为<code>ndarray</code>， 在PyTorch和TensorFlow中为<code>Tensor</code>）与Numpy的<code>ndarray</code>类似</p></li><li><p>但深度学习框架又比Numpy的<code>ndarray</code>多一些重要功能： 首先，GPU 很好地支持加速计算，而 NumPy 仅支持CPU计算； 其次，张量类支持自动微分。 这些功能使得张量类更适合深度学习</p></li><li><p>张量表示由一个数值组成的数组，这个数组可能有多个维度。 具有一个轴的张量对应数学上的向量（vector）； 具有两个轴的张量对应数学上的矩阵（matrix）</p></li><li><p>可以使用<code>arange</code>创建一个行向量<code>x</code>。 这个行向量包含从0开始的前12个整数，它们被默认创建为浮点数。 张量中的每个值都称为张量的元素（element）</p><pre><code class="python">import torchx = torch.arange(12)x # tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</code></pre></li><li><p>可以通过张量的<code>shape</code>属性来访问张量（沿每个轴的长度）的形状</p><pre><code class="python">x.shape  # torch.Size([12])</code></pre></li><li><p>如果只想知道张量中元素的总数，即形状的所有元素乘积，可以检查它的大小（size）</p><pre><code class="python">x.numel() # 12</code></pre></li><li><p>要想改变一个张量的形状而不改变元素数量和元素值，可以调用<code>reshape</code>函数</p><pre><code class="python">X = x.reshape(3, 4)  # 张量x从形状为（12,）的行向量转换为形状为（3,4）的矩阵X # tensor([[ 0,  1,  2,  3],  #       [ 4,  5,  6,  7],  #       [ 8,  9, 10, 11]])</code></pre><ul><li>我们可以通过<code>-1</code>来调用此自动计算出维度的功能。 即我们可以用<code>x.reshape(-1,4)</code>或<code>x.reshape(3,-1)</code>来取代<code>x.reshape(3,4)</code></li></ul></li><li><p>使用全0、全1、其他常量，或者从特定分布中随机采样的数字来初始化矩阵</p><pre><code class="python">torch.zeros((2, 3, 4))  # tensor([[[0., 0., 0., 0.],                        #               [0., 0., 0., 0.],                                        #                  [0., 0., 0., 0.]],                                        #                 [[0., 0., 0., 0.],                                         #                  [0., 0., 0., 0.],                                         #                 [0., 0., 0., 0.]]])torch.ones((2, 3, 4))  # 一个形状为(2,3,4)的张量，其中所有元素都设置为1torch.randn(3, 4)  # 一个形状为（3,4）的张量。 其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样</code></pre></li><li><p>通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值。 在这里，最外层的列表对应于轴0，内层的列表对应于轴1</p><pre><code class="python">torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])  </code></pre></li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><p>在这些数据上执行数学运算，其中最简单且最有用的操作是按元素（elementwise）运算。 它们将标准标量运算符应用于数组的每个元素。</p></li><li><p>对于将两个数组作为输入的函数，按元素运算将二元运算符应用于两个数组中的每对位置对应的元素。 我们可以基于任何从标量到标量的函数来创建按元素函数</p></li><li><p>对于任意具有相同形状的张量，常见的标准算术运算符（<code>+</code>、<code>-</code>、<code>\*</code>、<code>/</code>和<code>**</code>）都可以被升级为按元素运算。 我们可以在同一形状的任意两个张量上调用按元素操作</p><pre><code class="python">x = torch.tensor([1.0, 2, 4, 8])y = torch.tensor([2, 2, 2, 2])x + y, x - y, x * y, x / y, x ** y  # **运算符是求幂运算</code></pre></li><li><p>按元素方式可以应用更多的计算，包括像求幂这样的一元运算符</p><pre><code class="python">torch.exp(x)</code></pre></li><li><p>除了按元素计算外，我们还可以执行线性代数运算，包括向量点积和矩阵乘法。</p></li><li><p>也可以把多个张量连结（concatenate）在一起， 把它们端对端地叠起来形成一个更大的张量。 我们只需要提供张量列表，并给出沿哪个轴连结</p><pre><code class="python">X = torch.arange(12, dtype=torch.float32).reshape((3,4))Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])torch.cat((X, Y), dim=0) # 沿行（轴-0，形状的第一个元素）连结两个矩阵torch.cat((X, Y), dim=1) # 按列（轴-1，形状的第二个元素）连结两个矩阵</code></pre><ul><li><p>第一个输出张量的轴 -0 长度（6）是两个输入张量轴 -0 长度的总和（3+3）； 第二个输出张量的轴 -1 长度（8）是两个输入张量轴 -1 长度的总和（4+4）</p></li><li><p>通过逻辑运算符构建二元张量： 对于每个位置，如果<code>X</code>和<code>Y</code>在该位置相等，则新张量中相应项的值为1。 这意味着逻辑语句<code>X == Y</code>在该位置处为真，否则该位置为0</p><pre><code class="python">X == Y # tensor([[False,  True, False,  True],       #                 [False, False, False, False],       #                 [False, False, False, False]])</code></pre></li><li><p>对张量中的所有元素进行求和，会产生一个单元素张量</p><pre><code class="python">X.sum() # tensor(66.)</code></pre></li></ul></li></ul><h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><ul><li><p>即使形状不同，我们仍然可以通过调用广播机制（broadcasting mechanism）来执行按元素操作</p></li><li><p>首先，通过适当复制元素来扩展一个或两个数组， 以便在转换之后，两个张量具有相同的形状。 其次，对生成的数组执行按元素操作。在大多数情况下，我们将沿着数组中长度为1的轴进行广播</p><pre><code class="python">a = torch.arange(3).reshape((3, 1))b = torch.arange(2).reshape((1, 2))a, b # (tensor([[0],     #                [1],     #                [2]]),     #  tensor([[0, 1]]))</code></pre></li><li><p>由于<code>a</code>和<code>b</code>分别是3×1和1×2矩阵，如果让它们相加，它们的形状不匹配。 我们将两个矩阵广播为一个更大的3×2矩阵，如下所示：矩阵<code>a</code>将复制列， 矩阵<code>b</code>将复制行，然后再按元素相加</p><pre><code class="python">a + b # tensor([[0, 1],      #              [1, 2],      #              [2, 3]])</code></pre></li></ul><h4 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h4><ul><li><p>就像在任何其他Python数组中一样，张量中的元素可以通过索引访问。</p></li><li><p>与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1； 可以指定范围以包含第一个元素和最后一个之前的元素</p><pre><code class="python">X[-1], X[1:3] # (tensor([ 8.,  9., 10., 11.]),              # tensor([[ 4.,  5.,  6.,  7.],              #         [ 8.,  9., 10., 11.]]))</code></pre></li><li><p>除读取外，我们还可以通过指定索引来将元素写入矩阵</p><pre><code class="python">X[1, 2] = 9 # 将第二行第三列元素改为 9</code></pre></li><li><p>为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值，例如，<code>[0:2, :]</code>访问第1行和第2行，其中 “:” 代表沿轴1（列）的所有元素</p><pre><code class="python">X[0:2, :] = 12 # tensor([[12., 12., 12., 12.],               #         [12., 12., 12., 12.],               #         [ 8.,  9., 10., 11.]])</code></pre></li></ul><h4 id="节省内存"><a href="#节省内存" class="headerlink" title="节省内存"></a>节省内存</h4><ul><li><p>运行一些操作可能会导致为新结果分配内存。 例如，如果我们用<code>Y = X + Y</code>，我们将取消引用<code>Y</code>指向的张量，而是指向新分配的内存处的张量</p><pre><code class="python">before = id(Y)Y = Y + Xid(Y) == before  # False</code></pre></li><li><p>执行原地操作非常简单。 我们可以使用切片表示法将操作的结果分配给先前分配的数组，例如<code>Y[:] = &lt;expression&gt;</code></p><pre><code class="python">Z = torch.zeros_like(Y) # 创建一个新的矩阵Z，其形状与另一个Y相同， 使用zeros_like来分配一个全 0 的块print(&#39;id(Z):&#39;, id(Z))Z[:] = X + Yprint(&#39;id(Z):&#39;, id(Z))  # id一样</code></pre><ul><li>如果在后续计算中没有重复使用<code>X</code>， 我们也可以使用<code>X[:] = X + Y</code>或<code>X += Y</code>来减少操作的内存开销</li></ul></li></ul><h4 id="转换为其他Python对象"><a href="#转换为其他Python对象" class="headerlink" title="转换为其他Python对象"></a>转换为其他Python对象</h4><ul><li><p>将深度学习框架定义的张量[转换为NumPy张量（<code>ndarray</code>）很容易，反之也同样容易</p></li><li><p>torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量</p><pre><code class="python">A = X.numpy()B = torch.tensor(A)type(A), type(B) # (numpy.ndarray, torch.Tensor)</code></pre></li><li><p>要(将大小为1的张量转换为Python标量，我们可以调用<code>item</code>函数或Python的内置函数</p><pre><code class="python">a = torch.tensor([3.5])a, a.item(), float(a), int(a)# (tensor([3.5000]), 3.5, 3.5, 3)</code></pre></li></ul><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><ul><li>为了能用深度学习来解决现实世界的问题，我们经常从预处理原始数据开始， 而不是从那些准备好的张量格式数据开始</li><li>在Python中常用的数据分析工具中，我们通常使用<code>pandas</code>软件包。 像庞大的Python生态系统中的许多其他扩展包一样，<code>pandas</code>可以与张量兼容</li></ul><h4 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h4><ul><li><p>首先创建一个人工数据集，并存储在CSV（逗号分隔值文件) <code>../data/house_tiny.csv</code>中。 以其他格式存储的数据也可以通过类似的方式进行处理</p><pre><code class="python">import osos.makedirs(os.path.join(&#39;..&#39;, &#39;data&#39;), exist_ok=True)data_file = os.path.join(&#39;..&#39;, &#39;data&#39;, &#39;house_tiny.csv&#39;)with open(data_file, &#39;w&#39;) as f:    f.write(&#39;NumRooms,Alley,Price\n&#39;)  # 列名    f.write(&#39;NA,Pave,127500\n&#39;)  # 每行表示一个数据样本    f.write(&#39;2,NA,106000\n&#39;)    f.write(&#39;4,NA,178100\n&#39;)    f.write(&#39;NA,NA,140000\n&#39;)</code></pre></li><li><p>要从创建的CSV文件中加载原始数据集，我们导入<code>pandas</code>包并调用<code>read_csv</code>函数</p><pre><code class="python">import pandas as pddata = pd.read_csv(data_file)print(data)</code></pre><ul><li>该数据集有四行三列。其中每行描述了房间数量（“NumRooms”）、巷子类型（“Alley”）和房屋价格（“Price”）</li></ul></li></ul><h4 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h4><ul><li><p>“NaN”项代表缺失值</p></li><li><p>为了处理缺失的数据，典型的方法包括插值法和删除法，其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值</p></li><li><p>插值法：通过位置索引<code>iloc</code>，将<code>data</code>分成<code>inputs</code>和<code>outputs</code>， 其中前者为<code>data</code>的前两列，而后者为<code>data</code>的最后一列</p><ul><li>对于<code>inputs</code>中缺少的数值，我们用同一列的均值替换“NaN”项</li></ul><pre><code class="python">inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]inputs = inputs.fillna(inputs.mean())print(inputs)</code></pre></li><li><p>对于<code>inputs</code>中的类别值或离散值，我们将“NaN”视为一个类别</p><pre><code class="python">inputs = pd.get_dummies(inputs, dummy_na=True)print(inputs)</code></pre></li></ul><h4 id="转换为张量格式"><a href="#转换为张量格式" class="headerlink" title="转换为张量格式"></a>转换为张量格式</h4><ul><li><p>现在<code>inputs</code>和<code>outputs</code>中的所有条目都是数值类型，它们可以转换为张量格式</p></li><li><p>当数据采用张量格式后，可以通过张量函数来进一步操作</p><pre><code class="python">import torchX, y = torch.tensor(inputs.values), torch.tensor(outputs.values)X, y</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;要学习深度学习，首先需要先掌握一些基本技能。 所有机器学习方法都涉及从数据中提取信息。 因此，动手学深度学习 v2 课程在第二章的一开始先教授了一些关于数据的实用技能，包括存储、操作和预处理数据，作为预备知识的内容。以下为学习 Dive to Deep Learning（d2l） 课程第二章数据操作 + 数据预处理所记笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://blog.zhuangzhihao.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PyTorch" scheme="http://blog.zhuangzhihao.top/tags/PyTorch/"/>
    
    <category term="pandas" scheme="http://blog.zhuangzhihao.top/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>Java 数据库基础知识总结</title>
    <link href="http://blog.zhuangzhihao.top/JDBC%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.zhuangzhihao.top/JDBC%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-11T16:00:00.000Z</published>
    <updated>2022-05-16T06:02:28.659Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java 数据库连接，JDBC（Java Database Connectivity），是 Java 语言编程中与数据库连接的 API，封装了各种数据库访问的 API 和基础类库，支持多种数据库连接，也是 Java Web 技术核心的第一部分，我把整个学习过程分为 MySQL 基础、MySQL 高级、JDBC 和数据连接池四个部分，便于理解。</p></blockquote><a id="more"></a><h3 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h3><h4 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h4><ul><li>英文：Structured Query Language，简称 SQL</li><li>结构化查询语言，一门操作关系型数据库的编程语言</li><li>定义操作所有关系型数据库的统一标准</li><li>对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方</li></ul><h4 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h4><ul><li><p>SQL 语句可以单行或多行书写，以分号结尾。</p></li><li><p>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</p></li><li><p>注释</p><ul><li><p>单行注释: <code>-- 注释内容</code> 或 <code>#注释内容</code></p></li><li><p>多行注释: <code>/* 注释 */</code></p></li></ul></li></ul><h4 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h4><ul><li><p>DDL (Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等</p></li><li><p>DML (Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改</p></li><li><p>DQL (Data Query Language) 数据查询语言，用来查询数据库中表的记录（数据）</p></li><li><p>DCL (Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户</p></li></ul><h4 id="DDL：操作数据库"><a href="#DDL：操作数据库" class="headerlink" title="DDL：操作数据库"></a>DDL：操作数据库</h4><ul><li> 查询所有的数据库</li></ul><pre><code class="sql">SHOW DATABASES;</code></pre><ul><li>创建数据库（先判断，如果不存在则创建）</li></ul><pre><code class="sql">CREATE DATABASE IF NOT EXISTS 数据库名称;</code></pre><ul><li>删除数据库（先判断，如果存在则删除）</li></ul><pre><code class="sql">DROP DATABASE IF EXISTS 数据库名称;</code></pre><ul><li>使用数据库</li></ul><pre><code class="sql">USE 数据库名称;</code></pre><ul><li>查看当前使用的数据库</li></ul><pre><code class="sql">SELECT DATABASE();</code></pre><h4 id="DDL：操作表"><a href="#DDL：操作表" class="headerlink" title="DDL：操作表"></a>DDL：操作表</h4><ul><li>查询当前数据库下所有表名称</li></ul><pre><code class="sql">SHOW TABLES;</code></pre><ul><li>查询表结构</li></ul><pre><code class="sql">DESC 表名称;</code></pre><ul><li>创建表</li></ul><pre><code class="sql">create table tb_user (    id int,    username varchar(20),    password varchar(32)  -- 最后一行末尾，不能加逗号);</code></pre><ul><li>删除表（先判断表是否存在）</li></ul><pre><code class="sql">DROP TABLE IF EXISTS 表名;</code></pre><ul><li>修改表名</li></ul><pre><code class="sql">ALTER TABLE 表名 RENAME TO 新的表名;</code></pre><ul><li>添加一列</li></ul><pre><code class="sql">ALTER TABLE 表名 ADD 列名 数据类型;-- 给stu表添加一列address，该字段类型是varchar(50)alter table stu add address varchar(50);</code></pre><ul><li>修改数据类型</li></ul><pre><code class="sql">ALTER TABLE 表名 MODIFY 列名 新数据类型;-- 将stu表中的address字段的类型改为 char(50)alter table stu modify address char(50);</code></pre><ul><li>修改列名和数据类型</li></ul><pre><code class="sql">ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;-- 将stu表中的address字段名改为 addr，类型改为varchar(50)alter table stu change address addr varchar(50);</code></pre><ul><li>删除列</li></ul><pre><code class="sql">ALTER TABLE 表名 DROP 列名;</code></pre><h4 id="SQL-的数据类型"><a href="#SQL-的数据类型" class="headerlink" title="SQL 的数据类型"></a>SQL 的数据类型</h4><ul><li><p>数值</p><pre><code class="sql">tinyint : 小整数型，占一个字节int    ： 大整数类型，占四个字节    eg ： age intdouble ： 浮点类型    使用格式： 字段名 double(总长度,小数点后保留的位数)    eg ： score double(5,2)   </code></pre></li><li><p>日期</p><pre><code class="sql">date ： 日期值。只包含年月日    eg ：birthday date ： datetime ： 混合日期和时间值。包含年月日时分秒</code></pre></li><li><p>字符串</p><pre><code class="sql">char ： 定长字符串。    优点：存储性能高    缺点：浪费空间    eg ： name char(10)  如果存储的数据字符个数不足10个，也会占10个的空间varchar ： 变长字符串。    优点：节约空间    缺点：存储性能底    eg ： name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间    </code></pre></li></ul><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><ul><li>查询所有数据</li></ul><pre><code class="sql">SELECT * FROM 表名;</code></pre><ul><li>给指定列添加数据</li></ul><pre><code class="sql">INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…);</code></pre><ul><li>给全部列添加数据</li></ul><pre><code class="sql">INSERT INTO 表名 VALUES(值1,值2,…);</code></pre><ul><li>批量添加数据</li></ul><pre><code class="sql">INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;</code></pre><ul><li>修改表数据</li></ul><pre><code class="sql">UPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ;-- 修改语句中如果不加条件，则将所有数据都修改！</code></pre><ul><li>删除数据</li></ul><pre><code class="sql">DELETE FROM 表名 [WHERE 条件] ;</code></pre><ul><li>删除表中所有的数据</li></ul><pre><code class="sql">DELETE FROM 表名;</code></pre><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><ul><li>查询多个字段</li></ul><pre><code class="sql">SELECT 字段列表 FROM 表名;SELECT * FROM 表名; -- 查询所有数据</code></pre><ul><li>去除重复记录</li></ul><pre><code class="sql">SELECT DISTINCT 字段列表 FROM 表名;</code></pre><ul><li>起别名</li></ul><pre><code class="sql">SELECT 字段列表 AS: 别名 FROM 表名; -- AS 也可以省略</code></pre><ul><li>条件查询</li></ul><pre><code class="sql">SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></pre><ul><li>模糊查询<ul><li>使用 <code>LIKE</code> 关键字，可以使用通配符进行占位</li><li><code>_</code> ：代表单个任意字符</li><li><code>%</code> ：代表任意个数字符</li></ul></li></ul><pre><code class="sql">select * from stu where name like &#39;马%&#39;;  -- 查询姓&#39;马&#39;的学员信息select * from stu where name like &#39;_花%&#39;;  -- 查询第二个字是&#39;花&#39;的学员信息 select * from stu where name like &#39;%德%&#39;;  -- 查询名字中包含 &#39;德&#39; 的学员信息</code></pre><ul><li>排序查询</li></ul><pre><code class="sql">SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;/*排序方式有两种，分别是：ASC ： 升序排列（默认值）DESC ： 降序排列如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序*/</code></pre><ul><li>聚合函数<ul><li>将一列数据作为一个整体，进行纵向计算</li></ul></li></ul><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td><code>count(列名)</code></td><td>统计数量（一般选用不为null的列）</td></tr><tr><td><code>max(列名)</code></td><td>最大值</td></tr><tr><td><code>min(列名)</code></td><td>最小值</td></tr><tr><td><code>sum(列名)</code></td><td>求和</td></tr><tr><td><code>avg(列名)</code></td><td>平均值</td></tr></tbody></table><pre><code class="sql">SELECT 聚合函数名(列名) FROM 表;-- null 值不参与所有聚合函数运算</code></pre><ul><li>分组查询</li></ul><pre><code class="sql">SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];-- 分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</code></pre><ul><li><p>where 和 having 区别：</p><ul><li>执行时机不一样：<code>where</code> 是分组之前进行限定，不满足 <code>where</code> 条件，则不参与分组，而 <code>having</code> 是分组之后对结果进行过滤。</li></ul></li></ul><ul><li>可判断的条件不一样：<code>where</code> 不能对聚合函数进行判断，<code>having</code> 可以</li></ul><ul><li>分页查询</li></ul><pre><code class="sql">SELECT 字段列表 FROM 表名 LIMIT  起始索引 , 查询条目数;-- 起始索引是从0开始</code></pre><ul><li>起始索引计算公式：</li></ul><pre><code class="sql">起始索引 = (当前页码 - 1) * 每页显示的条数</code></pre><h3 id="MySQL-进阶"><a href="#MySQL-进阶" class="headerlink" title="MySQL 进阶"></a>MySQL 进阶</h3><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><ul><li><p>约束是作用于表中列上的规则，用于限制加入表的数据</p></li><li><p>约束的存在保证了数据库中数据的正确性、有效性和完整性</p></li><li><p>约束的分类</p><ul><li>非空约束：关键字是 <code>NOT NULL</code>，保证列中所有的数据不能有null值。</li></ul></li></ul><ul><li>唯一约束：关键字是 <code>UNIQUE</code>，保证列中所有数据各不相同</li></ul><ul><li>主键约束： 关键字是 <code>PRIMARY KEY</code>，主键是一行数据的唯一标识，要求非空且唯一</li></ul><ul><li>检查约束： 关键字是 <code>CHECK</code>，保证列中的值满足某一条件（MySQL不支持检查约束）</li></ul><ul><li>默认约束： 关键字是  <code>DEFAULT</code>，保存数据时，未指定值则采用默认值</li><li>外键约束： 关键字是 <code>FOREIGN KEY</code>，外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</li></ul><ul><li><p>非空约束</p><ul><li><p>用于保证列中所有数据不能有NULL值</p></li><li><p>添加约束</p><pre><code class="sql">-- 创建表时添加非空约束CREATE TABLE 表名(   列名 数据类型 NOT NULL,   …); </code></pre><pre><code class="sql">-- 建完表后添加非空约束ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL;</code></pre></li></ul></li></ul><pre><code>* 删除约束  ```sql  ALTER TABLE 表名 MODIFY 字段名 数据类型;  ```</code></pre><ul><li><p>唯一约束</p><ul><li>用于保证列中所有数据各不相同</li></ul></li></ul><pre><code>* 添加约束  ```sql  -- 创建表时添加唯一约束  CREATE TABLE 表名(     列名 数据类型 UNIQUE [AUTO_INCREMENT],     -- AUTO_INCREMENT: 当不指定值时自动增长     …  );   CREATE TABLE 表名(     列名 数据类型,     …     [CONSTRAINT] [约束名称] UNIQUE(列名)  );   ```  ```sql  -- 建完表后添加唯一约束  ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE;  ```* 删除约束  ```sql  ALTER TABLE 表名 DROP INDEX 字段名;  ```</code></pre><ul><li><p>主键约束</p><ul><li>主键是一行数据的唯一标识，要求非空且唯一</li><li>一张表只能有一个主键</li></ul><ul><li><p>添加约束</p><pre><code class="sql">-- 创建表时添加主键约束CREATE TABLE 表名(   列名 数据类型 PRIMARY KEY [AUTO_INCREMENT],   …); CREATE TABLE 表名(   列名 数据类型,   [CONSTRAINT] [约束名称] PRIMARY KEY(列名)); </code></pre><pre><code class="sql">-- 建完表后添加主键约束ALTER TABLE 表名 ADD PRIMARY KEY(字段名);</code></pre></li></ul></li></ul><ul><li><p>删除约束</p><pre><code class="sql">ALTER TABLE 表名 DROP PRIMARY KEY;</code></pre></li></ul><ul><li><p>默认约束</p><ul><li><p>保存数据时，未指定值则采用默认值</p></li><li><p>添加约束</p><pre><code class="sql">-- 创建表时添加默认约束CREATE TABLE 表名(   列名 数据类型 DEFAULT 默认值,   …); </code></pre><pre><code class="sql">-- 建完表后添加默认约束ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值;</code></pre></li><li><p>删除约束</p><pre><code class="sql">ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;</code></pre></li></ul></li></ul><ul><li>默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值</li></ul><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><ul><li>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</li></ul><ul><li>添加外键约束</li></ul><pre><code class="sql">-- 创建表时添加外键约束CREATE TABLE 表名(   列名 数据类型,   …   [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) ); </code></pre><pre><code class="sql">-- 建完表后添加外键约束ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</code></pre><ul><li>删除外键约束</li></ul><pre><code class="sql">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></pre><ul><li>添加数据</li></ul><pre><code class="sql">-- 添加 2 个部门insert into dept(dep_name,addr) values(&#39;研发部&#39;,&#39;广州&#39;),(&#39;销售部&#39;, &#39;深圳&#39;);-- 添加员工,dep_id 表示员工所在的部门INSERT INTO emp (NAME, age, dep_id) VALUES (&#39;张三&#39;, 20, 1),(&#39;李四&#39;, 20, 1),(&#39;王五&#39;, 20, 1),</code></pre><p>删除外键</p><pre><code class="sql">alter table emp drop FOREIGN key fk_emp_dept;</code></pre><p>重新添加外键</p><pre><code class="sql">alter table emp add CONSTRAINT fk_emp_dept FOREIGN key(dep_id) REFERENCES dept(id);</code></pre><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><ul><li><p>数据库设计概念</p><ul><li>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型</li><li>建立数据库中的表结构以及表与表之间的关联关系的过程</li><li>有哪些表？表里有哪些字段？表和表之间有什么关系？</li></ul></li><li><p>数据库设计的步骤</p><ul><li><p>需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么）</p></li><li><p>逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）</p></li><li><p>物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）</p></li><li><p>维护设计（1.对新的需求进行建表；2.表优化）</p></li></ul></li><li><p>表关系</p><ul><li><p>一对一（如：用户 和 用户详情）：一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</p></li><li><p>一对多（如：部门 和 员工）：一个部门对应多个员工，一个员工对应一个部门</p></li><li><p>多对多（如：商品 和 订单）：一个商品对应多个订单，一个订单包含多个商品</p></li></ul></li></ul><ul><li><p>表关系（一对多）</p><ul><li>实现方式：在多的一方建立外键，指向一的一方的主键</li></ul></li></ul><ul><li>以 <code>员工表</code> 和 <code>部门表</code> 举例：在员工表中添加一列（dep_id），指向于部门表的主键（id）</li></ul><pre><code class="sql">-- 删除表DROP TABLE IF EXISTS tb_emp;DROP TABLE IF EXISTS tb_dept;-- 部门表CREATE TABLE tb_dept(    id int primary key auto_increment,    dep_name varchar(20),    addr varchar(20));-- 员工表 CREATE TABLE tb_emp(    id int primary key auto_increment,    name varchar(20),    age int,    dep_id int,    -- 添加外键 dep_id,关联 dept 表的id主键    CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES tb_dept(id)    );</code></pre><ul><li><p>表关系（多对多）</p><ul><li>建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul><ul><li>以 <code>订单表</code> 和 <code>商品表</code> 举例：订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键：</li></ul><pre><code class="sql">  -- 删除表  DROP TABLE IF EXISTS tb_order_goods;  DROP TABLE IF EXISTS tb_order;  DROP TABLE IF EXISTS tb_goods;  -- 订单表  CREATE TABLE tb_order(  id int primary key auto_increment,  payment double(10,2),  payment_type TINYINT,  status TINYINT  );  -- 商品表  CREATE TABLE tb_goods(  id int primary key auto_increment,  title varchar(100),  price double(10,2)  );  -- 订单商品中间表  CREATE TABLE tb_order_goods(  id int primary key auto_increment,  order_id int,  goods_id int,  count int  );  -- 建完表后，添加外键  alter table tb_order_goods add CONSTRAINT fk_order_id FOREIGN key(order_id) REFERENCES tb_order(id);  alter table tb_order_goods add CONSTRAINT fk_goods_id FOREIGN key(goods_id) REFERENCES tb_goods(id);</code></pre></li><li><p>表关系（一对一）</p><ul><li>在任意一方加入外键，关联另一方主键，并且设置外键为唯一（<code>UNIQUE</code>）</li></ul></li></ul><ul><li>以 <code>用户表</code> 举例：在真正使用过程中发现 id、photo、nickname、age、gender 字段比较常用，此时就可以将这张表查分成两张表</li></ul><pre><code class="sql">create table tb_user_desc (    id int primary key auto_increment,    city varchar(20),    edu varchar(10),    income int,    status char(2),    des varchar(100));create table tb_user (    id int primary key auto_increment,    photo varchar(100),    nickname varchar(50),    age int,    gender char(1),    desc_id int unique,    -- 添加外键    CONSTRAINT fk_user_desc FOREIGN KEY(desc_id) REFERENCES tb_user_desc(id)    );</code></pre><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><ul><li>多表查询顾名思义就是从多张表中一次性的查询出我们想要的数据</li></ul><pre><code class="sql">DROP TABLE IF EXISTS emp;DROP TABLE IF EXISTS dept;# 创建部门表    CREATE TABLE dept(        did INT PRIMARY KEY AUTO_INCREMENT,        dname VARCHAR(20)    );    # 创建员工表    CREATE TABLE emp (        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(10),        gender CHAR(1), -- 性别        salary DOUBLE, -- 工资        join_date DATE, -- 入职日期        dep_id INT,        FOREIGN KEY (dep_id) REFERENCES dept(did) -- 外键，关联部门表(部门表的主键)    );    -- 添加部门数据    INSERT INTO dept (dNAME) VALUES (&#39;研发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;),(&#39;销售部&#39;);    -- 添加员工数据    INSERT INTO emp(NAME,gender,salary,join_date,dep_id) VALUES    (&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1),    (&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2),    (&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2),    (&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3),    (&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1),    (&#39;小白龙&#39;,&#39;男&#39;,2500,&#39;2011-02-14&#39;,null);    </code></pre><ul><li>执行下面的多表查询语句</li></ul><pre><code class="sql">select * from emp , dept;  -- 从emp和dept表中查询所有的字段数据</code></pre><ul><li>通过限制员工表中的 <code>dep_id</code> 字段的值和部门表 <code>did</code> 字段的值相等来消除无效的数据，</li></ul><pre><code class="sql">select * from emp , dept where emp.dep_id = dept.did;</code></pre><ul><li><p>连接查询 </p><ul><li>内连接查询 ：相当于查询AB交集数据</li><li>外连接查询<ul><li>左外连接查询 ：相当于查询A表所有数据和交集部门数据</li><li>右外连接查询 ： 相当于查询B表所有数据和交集部分数据</li></ul></li><li>子查询</li></ul></li></ul><ul><li>内连接查询</li></ul><pre><code class="sql">-- 隐式内连接SELECT 字段列表 FROM 表1,表2… WHERE 条件;-- 显示内连接SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件;</code></pre><ul><li>隐式内连接</li></ul><pre><code class="sql">SELECT * FROM emp, dept WHERE emp.dep_id = dept.did;</code></pre><ul><li>查询 emp 的 name， gender，dept 表的 dname</li></ul><pre><code class="sql">SELECT    t1. NAME,    t1.gender,    t2.dnameFROM    emp t1,    dept t2WHERE    t1.dep_id = t2.did;</code></pre><ul><li>显式内连接</li></ul><pre><code class="sql">select * from emp inner join dept on emp.dep_id = dept.did;-- 上面语句中的inner可以省略，可以书写为如下语句select * from emp  join dept on emp.dep_id = dept.did;</code></pre><ul><li>外连接查询</li></ul><pre><code class="sql">-- 左外连接：相当于查询A表所有数据和交集部分数据SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;-- 右外连接：相当于查询B表所有数据和交集部分数据SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;</code></pre><ul><li>查询emp表所有数据和对应的部门信息（左外连接）</li></ul><pre><code class="sql">select * from emp left join dept on emp.dep_id = dept.did;-- 结果显示查询到了左表（emp）中所有的数据及两张表能关联的数据</code></pre><ul><li>查询dept表所有数据和对应的员工信息（右外连接）</li></ul><pre><code class="sql">select * from emp right join dept on emp.dep_id = dept.did;-- 结果显示查询到了右表（dept）中所有的数据及两张表能关联的数据</code></pre><p>。要查询出部门表中所有的数据，也可以通过左外连接实现，只需要将两个表的位置进行互换：</p><pre><code class="sql">select * from dept left join emp on emp.dep_id = dept.did;</code></pre><ul><li><p>子查询</p><ul><li>查询中嵌套查询，称嵌套查询为子查询</li></ul></li></ul><ul><li>子查询根据查询结果不同，作用不同</li><li>子查询语句结果是单行单列，子查询语句作为条件值，使用 =  !=  &gt;  &lt;  等进行条件判断</li><li>子查询语句结果是多行单列，子查询语句作为条件值，使用 in 等关键字进行条件判断</li><li>子查询语句结果是多行多列，子查询语句作为虚拟表</li><li>查询 ‘财务部’ 和 ‘市场部’ 所有的员工信息</li></ul><pre><code class="sql">-- 查询 &#39;财务部&#39; 或者 &#39;市场部&#39; 所有的员工的部门didselect did from dept where dname = &#39;财务部&#39; or dname = &#39;市场部&#39;;select * from emp where dep_id in (select did from dept where dname = &#39;财务部&#39; or dname = &#39;市场部&#39;);</code></pre><ul><li>查询入职日期是 ‘2011-11-11’ 之后的员工信息和部门信息</li></ul><pre><code class="sql">-- 查询入职日期是 &#39;2011-11-11&#39; 之后的员工信息select * from emp where join_date &gt; &#39;2011-11-11&#39; ;-- 将上面语句的结果作为虚拟表和dept表进行内连接查询select * from (select * from emp where join_date &gt; &#39;2011-11-11&#39; ) t1, dept where t1.dep_id = dept.did;</code></pre><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul><li><p>概述</p><ul><li><p>数据库的事务（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令</p></li><li><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败</p></li><li><p>事务是一个不可分割的工作逻辑单元</p></li></ul></li></ul><ul><li><p>语法</p><ul><li>开启事务</li></ul><pre><code class="sql">START TRANSACTION;或者  BEGIN;</code></pre></li></ul><ul><li><p>提交事务</p><pre><code class="sql">commit;</code></pre></li></ul><ul><li><p>回滚事务</p><pre><code class="sql">rollback;</code></pre></li></ul><ul><li><p>代码验证</p><ul><li>环境准备</li></ul><pre><code class="sql">DROP TABLE IF EXISTS account;-- 创建账户表CREATE TABLE account(    id int PRIMARY KEY auto_increment,    name varchar(10),    money double(10,2));-- 添加数据INSERT INTO account(name,money) values(&#39;张三&#39;,1000),(&#39;李四&#39;,1000);</code></pre></li></ul><ul><li><p>不加事务演示问题</p><pre><code class="sql">-- 转账操作-- 1. 查询李四账户金额是否大于500-- 2. 李四账户 -500UPDATE account set money = money - 500 where name = &#39;李四&#39;;出现异常了...  -- 此处不是注释，在整体执行时会出问题，后面的sql则不执行-- 3. 张三账户 +500UPDATE account set money = money + 500 where name = &#39;张三&#39;;</code></pre></li></ul><ul><li><p>添加事务 sql</p><pre><code class="sql">-- 开启事务BEGIN;-- 转账操作-- 1. 查询李四账户金额是否大于500-- 2. 李四账户 -500UPDATE account set money = money - 500 where name = &#39;李四&#39;;出现异常了...  -- 此处不是注释，在整体执行时会出问题，后面的sql则不执行-- 3. 张三账户 +500UPDATE account set money = money + 500 where name = &#39;张三&#39;;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;</code></pre><ul><li>上面sql中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句，以后我们肯定不可能这样操作，而是在java中进行操作，在java中可以抓取异常，没出现异常提交事务，出现异常回滚事务</li></ul></li></ul><ul><li><p>事务的四大特征</p><ul><li>原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li>一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation） :多个事务之间，操作的可见性</li><li>持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li><li>MySQL 中事务是自动提交的，也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务<ul><li>可以通过下面语句查询默认提交方式：</li></ul></li></ul><pre><code class="java">SELECT @@autocommit;</code></pre></li><li><p> 查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式</p></li></ul><pre><code class="sql">set @@autocommit = 0;</code></pre><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><h4 id="JDBC-简介"><a href="#JDBC-简介" class="headerlink" title="JDBC 简介"></a>JDBC 简介</h4><ul><li><p>JDBC 概念</p><ul><li><p>JDBC 就是使用Java语言操作关系型数据库的一套API</p></li><li><p>JDBC 全称：( Java DataBase Connectivity ) Java 数据库连接</p></li><li><p>sun公司指定了一套标准接口（JDBC），JDBC中定义了所有操作关系型数据库的规则，众所周知接口是无法直接使用的，我们需要使用接口的实现类，而这套实现类（称之为：驱动）就由各自的数据库厂商给出</p></li></ul></li><li><p>JDBC本质</p><ul><li><p>官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口</p></li><li><p>各个数据库厂商去实现这套接口，提供数据库驱动jar包</p></li><li><p>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</p></li></ul></li></ul><ul><li><p>JDBC好处</p><ul><li><p>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发</p></li><li><p>可随时替换底层数据库，访问数据库的Java代码基本不变</p></li><li><p>以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包</p></li></ul></li></ul><h4 id="JDBC快速入门"><a href="#JDBC快速入门" class="headerlink" title="JDBC快速入门"></a>JDBC快速入门</h4><ul><li><p>通过Java操作数据库的流程</p><ul><li>第一步：编写Java代码</li></ul></li></ul><pre><code>- 第二步：Java代码将SQL发送到MySQL服务端- 第三步：MySQL服务端接收到SQL语句并执行该SQL语句- 第四步：将SQL语句执行的结果返回给Java代码</code></pre><ul><li><p>编写代码步骤</p><ul><li>创建工程，导入驱动 jar 包（mysql-connector-java-5.1.48.jar）</li></ul></li></ul><ul><li><p>注册驱动</p><pre><code class="sql">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></pre></li></ul><ul><li><p>获取连接</p><pre><code class="sql">Connection conn = DriverManager.getConnection(url, username, password);</code></pre><ul><li>Java代码需要发送SQL给MySQL服务端，就需要先建立连接</li></ul></li></ul><ul><li><p>定义SQL语句</p><pre><code class="sql">String sql =  &quot;select * from table;&quot; ;</code></pre></li></ul><ul><li><p>获取执行SQL对象</p><ul><li>执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象</li></ul><pre><code class="sql">Statement stmt = conn.createStatement();</code></pre></li><li><p>执行SQL</p><pre><code class="sql">stmt.executeUpdate(sql);  </code></pre></li></ul><ul><li>处理返回结果</li><li>释放资源</li><li>IDEA 中编写代码</li></ul><pre><code class="java">/** * JDBC快速入门 */public class JDBCDemo &#123;    public static void main(String[] args) throws Exception &#123;        //1. 注册驱动        //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //2. 获取连接        String url = &quot;jdbc:mysql://127.0.0.1:3306/db1?useSSL=false&quot;;        String username = &quot;root&quot;;        String password = &quot;1234&quot;;        Connection conn = DriverManager.getConnection(url, username, password);        //3. 定义sql        String sql = &quot;update account set money = 2000 where id = 1&quot;;        //4. 获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //5. 执行sql        int count = stmt.executeUpdate(sql);//受影响的行数        //6. 处理结果        System.out.println(count);        //7. 释放资源        stmt.close();        conn.close();    &#125;&#125;</code></pre><h4 id="JDBC-API-详解"><a href="#JDBC-API-详解" class="headerlink" title="JDBC API 详解"></a>JDBC API 详解</h4><ul><li><p>DriverManager（驱动管理类）</p><ul><li><p>注册驱动：<code>registerDriver</code> 方法是用于注册驱动的，但是我们之前做的入门案例并不是这样写的。而是如下实现</p><pre><code class="sql">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></pre></li><li><p>在该类中的静态代码块中已经执行了 <code>DriverManager</code> 对象的 <code>registerDriver()</code> 方法进行驱动的注册了，那么我们只需要加载 <code>Driver</code> 类，该静态代码块就会执行，而 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code> 就可以加载 <code>Driver</code> 类</p></li></ul></li></ul><pre><code>* 获取数据库连接  ```sql  Connection conn = DriverManager.getConnection(url, username, password);  ```  * url ： `jdbc:mysql://ip地址(域名):端口号/数据库名称?参数键值对1&amp;参数键值对2…`    * 配置 `useSSL=false` 参数，禁用安全连接方式，解决警告提示  * user ：用户名  * poassword ：密码</code></pre><ul><li><p>Connection（数据库连接对象）</p><ul><li><p>获取执行 SQL 的对象</p><ul><li>普通执行SQL对象</li></ul><pre><code class="sql">Statement createStatement()  -- 通过该方法获取执行对象Statement stmt = conn.createStatement();int count = stmt.executeUpdate(sql);</code></pre><ul><li>预编译SQL的执行SQL对象：防止SQL注入</li></ul><pre><code class="sql">PreparedStatement  prepareStatement(sql)</code></pre><ul><li><p>通过这种方式获取的 <code>PreparedStatement</code> SQL语句执行对象可以防止SQL注入</p></li><li><p>执行存储过程的对象</p><pre><code class="sql">CallableStatement prepareCall(sql)</code></pre></li><li><p>通过这种方式获取的 <code>CallableStatement</code> 执行对象是用来执行存储过程的，但存储过程在MySQL中不常用</p></li></ul></li></ul></li></ul><pre><code>- 事务管理  - MySQL事务管理的操作（MySQL默认是自动提交事务）    * 开启事务 ： `BEGIN;` 或者 `START TRANSACTION;`    * 提交事务 ： `COMMIT;`    * 回滚事务 ： `ROLLBACK;`  - JDBC事务管理的方法    - Connection几个接口中定义了3个对应的方法：      * 开启事务        ```sql        setAutoCommit(boolean autoCommit)        ```      * 参与 `autoCommit` 表示是否自动提交事务，true表示自动提交事务，false表示手动提交事务，而开启事务需要将该参数设为为 false      * 提交事务        ```sql        commit()        ```      * 回滚事务        ```sql        rollback;        ```</code></pre><ul><li><p>Statement（声明执行对象）</p><ul><li>Statement对象的作用就是用来执行SQL语句，而针对不同类型的SQL语句使用的方法也不一样</li></ul></li></ul><pre><code>* 执行DDL、DML语句  ```sql  int excuteUpdate(sql)  ```  * 返回值：DML语句影响的行数，DDL语句执行成功后可能返回0* 执行DQL语句  ```sql  ResultSet excuteQuery(sql)  ```  - 返回值： `ResultSet` 结果集对象</code></pre><ul><li><p>ResultSet（结果集对象）</p><ul><li>封装了SQL查询语句的结果，执行DQL语句后就会返回该对象<ul><li><code>ResultSet  executeQuery(sql)</code>：执行DQL 语句，返回 <code>ResultSet</code> 对象</li></ul></li></ul><ul><li><p><code>ResultSet</code> 对象提供了获取查询结果数据的方法</p><ul><li><p><code>boolean  next()</code>：将光标从当前位置向前移动一行，判断当前行是否为有效行</p></li><li><p>方法返回值：true （ 有效行，当前行有数据），false（无效行，当前行没有数据）</p></li><li><p><code>xxx  getXxx(参数)</code>：获取数据</p></li><li><p>xxx : 数据类型；如： <code>nt getInt(参数)</code> ；<code>String getString(参数)</code></p></li><li><p>int 类型的参数：列的编号，从1开始</p></li><li><p>String 类型的参数： 列的名称 </p></li></ul></li></ul></li></ul><ul><li><p>一开始光标指定于第一行前，当我们调用了 <code>next()</code> 方法后，光标就下移到第一行数据，并且方法返回 true，此时就可以通过 <code>getInt(&quot;id&quot;)</code> 获取当前行id字段的值，也可以通过 <code>getString(&quot;name&quot;)</code> 获取当前行name字段的值。如果想获取下一行的数据，继续调用 <code>next()</code>  方法，以此类推。</p></li><li><p>PreparedStatement</p><ul><li><p>预编译SQL语句并执行：预防SQL注入问题</p></li><li><p>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p></li><li><p>代码模拟SQL注入问题</p></li></ul><pre><code class="java">@Testpublic void testLogin() throws  Exception &#123;    //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写    String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;    String username = &quot;root&quot;;    String password = &quot;1234&quot;;    Connection conn = DriverManager.getConnection(url, username, password);    // 接收用户输入 用户名和密码    String name = &quot;sjdljfld&quot;;    String pwd = &quot;&#39; or &#39;1&#39; = &#39;1&quot;;    String sql = &quot;select * from tb_user where username = &#39;&quot;+name+&quot;&#39; and password = &#39;&quot;+pwd+&quot;&#39;&quot;;    // 获取stmt对象    Statement stmt = conn.createStatement();    // 执行sql    ResultSet rs = stmt.executeQuery(sql);    // 判断登录是否成功    if(rs.next())&#123;        System.out.println(&quot;登录成功~&quot;);    &#125;else&#123;        System.out.println(&quot;登录失败~&quot;);    &#125;    //7. 释放资源    rs.close();    stmt.close();    conn.close();&#125;</code></pre><ul><li>上面代码是将用户名和密码拼接到sql语句中，拼接后的sql语句如下</li></ul><pre><code class="sql">select * from tb_user where username = &#39;sjdljfld&#39; and password = &#39;&#39;or &#39;1&#39; = &#39;1&#39;</code></pre><ul><li>获取 PreparedStatement 对象</li></ul></li></ul><pre><code class="java">// SQL语句中的参数值，使用？占位符替代String sql = &quot;select * from user where username = ? and password = ?&quot;;// 通过Connection对象获取，并传入对应的sql语句PreparedStatement pstmt = conn.prepareStatement(sql);</code></pre><ul><li><p>设置参数值：PreparedStatement 的sql语句中参数使用 ? 进行占位，在之前之前肯定要设置这些 ?  的值</p></li><li><p>PreparedStatement对象：<code>setXxx(参数1，参数2)</code>：给 ? 赋值</p></li><li><p>Xxx：数据类型 ； 如 setInt (参数1，参数2)</p></li><li><p>参数：</p></li><li><p>参数1： ？的位置编号，从1 开始</p><ul><li>参数2： ？的值</li></ul></li></ul><ul><li><p>执行SQL语句</p><ul><li><code>executeUpdate()</code>;  执行DDL语句和DML语句</li><li><code>executeQuery()</code>;  执行DQL语句</li><li>调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了</li></ul></li></ul><ul><li><p>使用PreparedStatement改进</p><pre><code class="java">@Testpublic void testPreparedStatement() throws  Exception &#123;  //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写  String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;  String username = &quot;root&quot;;  String password = &quot;1234&quot;;  Connection conn = DriverManager.getConnection(url, username, password);  // 接收用户输入 用户名和密码  String name = &quot;zhangsan&quot;;  String pwd = &quot;&#39; or &#39;1&#39; = &#39;1&quot;;  // 定义sql  String sql = &quot;select * from tb_user where username = ? and password = ?&quot;;  // 获取pstmt对象  PreparedStatement pstmt = conn.prepareStatement(sql);  // 设置？的值  pstmt.setString(1,name);  pstmt.setString(2,pwd);  // 执行sql  ResultSet rs = pstmt.executeQuery();  // 判断登录是否成功  if(rs.next())&#123;      System.out.println(&quot;登录成功~&quot;);  &#125;else&#123;      System.out.println(&quot;登录失败~&quot;);  &#125;  //7. 释放资源  rs.close();  pstmt.close();  conn.close();&#125;</code></pre></li><li><p>PreparedStatement 实际上是将特殊字符进行了转义，转义的SQL如下：</p><pre><code class="sql">select * from tb_user where username = &#39;sjdljfld&#39; and password = &#39;\&#39;or \&#39;1\&#39; = \&#39;1&#39;</code></pre></li><li><p>PreparedStatement原理</p><ul><li>预编译SQL，性能更高</li><li>防止SQL注入：将敏感字符进行转义</li></ul><ul><li>将sql语句发送到MySQL服务器端</li></ul></li></ul><pre><code>* MySQL服务端会对sql语句进行如下操作  * 检查SQL语句的语法是否正确。  * 编译SQL语句。将SQL语句编译成可执行的函数。  * 检查SQL和编译SQL花费的时间比执行SQL的时间还要长。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行。这样就提高了性能。  * 执行SQL语句</code></pre><ul><li><p>开启预编译功能：<code>useServerPrepStmts=true</code></p><pre><code class="sql">String url = &quot;jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true&quot;;</code></pre></li><li><p>配置MySQL执行日志（重启mysql服务后生效）</p><ul><li>在mysql配置文件（my.ini）中添加如下配置</li></ul><pre><code class="ini">log-output=FILEgeneral-log=1general_log_file=&quot;D:\mysql.log&quot;slow-query-log=1slow_query_log_file=&quot;D:\mysql_slow.log&quot;long_query_time=2</code></pre></li></ul><ul><li>PreparedStatement 小结<ul><li>在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li><li>执行时就不用再进行这些步骤了，速度更快</li><li>如果sql模板一样，则只需要进行一次检查、编译</li></ul></li></ul><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h4 id="数据库连接池简介"><a href="#数据库连接池简介" class="headerlink" title="数据库连接池简介"></a>数据库连接池简介</h4><ul><li>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</li><li>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</li><li>好处<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li><li>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的</li><li>而数据库使用了数据库连接池后，就能达到Connection对象的复用</li><li>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度</li></ul><h4 id="数据库连接池实现"><a href="#数据库连接池实现" class="headerlink" title="数据库连接池实现"></a>数据库连接池实现</h4><ul><li><p>标准接口：DataSource</p></li><li><p>官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能：</p><pre><code class="java">Connection getConnection()</code></pre></li></ul><ul><li>那么以后就不需要通过 <code>DriverManager</code> 对象获取 <code>Connection</code> 对象，而是通过连接池（DataSource）获取 <code>Connection</code> 对象。</li></ul><ul><li><p>常见的数据库连接池</p><ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul><p>我们现在使用更多的是Druid，它的性能比其他两个会好一些。</p></li><li><p>Druid（德鲁伊）</p><ul><li><p>Druid连接池是阿里巴巴开源的数据库连接池项目 </p></li><li><p>功能强大，性能优秀，是Java语言最好的数据库连接池之一</p></li></ul></li></ul><h4 id="Driud-使用"><a href="#Driud-使用" class="headerlink" title="Driud 使用"></a>Driud 使用</h4><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件：src 目录下新建 <code>druid.properties</code></li></ul><pre><code class="properties">driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=trueusername=rootpassword=1234# 初始化连接数量initialSize=5# 最大连接数maxActive=10# 最大等待时间maxWait=3000</code></pre><ul><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ul><pre><code class="java">/** * Druid数据库连接池演示 */public class DruidDemo &#123;    public static void main(String[] args) throws Exception &#123;        // 加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(&quot;jdbc-demo/src/druid.properties&quot;));        // 获取连接池对象        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);        // 获取数据库连接 Connection        Connection connection = dataSource.getConnection();        System.out.println(connection); //获取到了连接后就可以继续做其他操作了        //System.out.println(System.getProperty(&quot;user.dir&quot;));    &#125;&#125;</code></pre><ul><li>druid 配置详解</li></ul><table><thead><tr><th align="center">属性</th><th align="center">说明</th><th align="center">建议值</th></tr></thead><tbody><tr><td align="center">url</td><td align="center">数据库的jdbc连接地址。一般为连接oracle/mysql。示例如下：</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">mysql : jdbc:mysql://ip:port/dbname?option1&amp;option2&amp;…</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">oracle : jdbc:oracle:thin:@ip:port:oracle_sid</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">username</td><td align="center">登录数据库的用户名</td><td align="center"></td></tr><tr><td align="center">password</td><td align="center">登录数据库的用户密码</td><td align="center"></td></tr><tr><td align="center">initialSize</td><td align="center">启动程序时，在连接池中初始化多少个连接</td><td align="center">10-50已足够</td></tr><tr><td align="center">maxActive</td><td align="center">连接池中最多支持多少个活动会话</td><td align="center"></td></tr><tr><td align="center">maxWait</td><td align="center">程序向连接池中请求连接时,超过maxWait的值后，认为本次请求失败，即连接池</td><td align="center">100</td></tr><tr><td align="center"></td><td align="center">没有可用连接，单位毫秒，设置-1时表示无限等待</td><td align="center"></td></tr><tr><td align="center">minEvictableIdleTimeMillis</td><td align="center">池中某个连接的空闲时长达到 N 毫秒后, 连接池在下次检查空闲连接时，将</td><td align="center">见说明部分</td></tr><tr><td align="center"></td><td align="center">回收该连接,要小于防火墙超时设置</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">net.netfilter.nf_conntrack_tcp_timeout_established的设置</td><td align="center"></td></tr><tr><td align="center">timeBetweenEvictionRunsMillis</td><td align="center">检查空闲连接的频率，单位毫秒, 非正整数时表示不进行检查</td><td align="center"></td></tr><tr><td align="center">keepAlive</td><td align="center">程序没有close连接且空闲时长超过 minEvictableIdleTimeMillis,则会执</td><td align="center">true</td></tr><tr><td align="center"></td><td align="center">行validationQuery指定的SQL,以保证该程序连接不会池kill掉,其范围不超</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">过minIdle指定的连接个数。</td><td align="center"></td></tr><tr><td align="center">minIdle</td><td align="center">回收空闲连接时，将保证至少有minIdle个连接.</td><td align="center">与initialSize相同</td></tr><tr><td align="center">removeAbandoned</td><td align="center">要求程序从池中get到连接后, N 秒后必须close,否则druid 会强制回收该</td><td align="center">false,当发现程序有未</td></tr><tr><td align="center"></td><td align="center">连接,不管该连接中是活动还是空闲, 以防止进程不会进行close而霸占连接。</td><td align="center">正常close连接时设置为true</td></tr><tr><td align="center">removeAbandonedTimeout</td><td align="center">设置druid 强制回收连接的时限，当程序从池中get到连接开始算起，超过此</td><td align="center">应大于业务运行最长时间</td></tr><tr><td align="center"></td><td align="center">值后，druid将强制回收该连接，单位秒。</td><td align="center"></td></tr><tr><td align="center">logAbandoned</td><td align="center">当druid强制回收连接后，是否将stack trace 记录到日志中</td><td align="center">true</td></tr><tr><td align="center">testWhileIdle</td><td align="center">当程序请求连接，池在分配连接时，是否先检查该连接是否有效。(高效)</td><td align="center">true</td></tr><tr><td align="center">validationQuery</td><td align="center">检查池中的连接是否仍可用的 SQL 语句,drui会连接到数据库执行该SQL, 如果</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">正常返回，则表示连接可用，否则表示连接不可用</td><td align="center"></td></tr><tr><td align="center">testOnBorrow</td><td align="center">程序 <strong>申请</strong> 连接时,进行连接有效性检查（低效，影响性能）</td><td align="center">false</td></tr><tr><td align="center">testOnReturn</td><td align="center">程序 <strong>返还</strong> 连接时,进行连接有效性检查（低效，影响性能）</td><td align="center">false</td></tr><tr><td align="center">poolPreparedStatements</td><td align="center">缓存通过以下两个方法发起的SQL:</td><td align="center">true</td></tr><tr><td align="center"></td><td align="center">public PreparedStatement prepareStatement(String sql)</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">public PreparedStatement prepareStatement(String sql,</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">int resultSetType, int resultSetConcurrency)</td><td align="center"></td></tr><tr><td align="center">maxPoolPrepareStatementPerConnectionSize</td><td align="center">每个连接最多缓存多少个SQL</td><td align="center">20</td></tr><tr><td align="center">filters</td><td align="center">这里配置的是插件,常用的插件有:</td><td align="center">stat,wall,slf4j</td></tr><tr><td align="center"></td><td align="center">监控统计: filter:stat</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">日志监控: filter:log4j 或者 slf4j</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">防御SQL注入: filter:wall</td><td align="center"></td></tr><tr><td align="center">connectProperties</td><td align="center">连接属性。比如设置一些连接池统计方面的配置。</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">比如设置一些数据库连接属性:</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java 数据库连接，JDBC（Java Database Connectivity），是 Java 语言编程中与数据库连接的 API，封装了各种数据库访问的 API 和基础类库，支持多种数据库连接，也是 Java Web 技术核心的第一部分，我把整个学习过程分为 MySQL 基础、MySQL 高级、JDBC 和数据连接池四个部分，便于理解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="MySQL" scheme="http://blog.zhuangzhihao.top/tags/MySQL/"/>
    
    <category term="JDBC" scheme="http://blog.zhuangzhihao.top/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>机器学习和深度学习介绍及入门</title>
    <link href="http://blog.zhuangzhihao.top/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.zhuangzhihao.top/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-07T16:00:00.000Z</published>
    <updated>2022-05-05T12:33:23.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习（machine learning，ML）是一类强大的可以从经验中学习的技术。 通常采用观测数据或与环境交互的形式，机器学习算法会积累更多的经验，其性能也会逐步提高就在过去的五年里，深度学习给世界带来了惊喜，推动了计算机视觉、自然语言处理、自动语音识别、强化学习和统计建模等领域的快速发展。我选择动手学深度学习 v2 课程来开启机器学习之旅，并特别关注深度学习（deep learning，DL）的基础知识深度学习。</p></blockquote><a id="more"></a><h3 id="日常生活中的机器学习"><a href="#日常生活中的机器学习" class="headerlink" title="日常生活中的机器学习"></a>日常生活中的机器学习</h3><ul><li>Hey, Siri：收集一个包含音频样本的巨大的数据集（dataset），并对包含和不包含唤醒词的样本进行标记</li><li>通过机器学习算法，我们不需要设计一个“明确地”识别唤醒词的系统。 相反，我们定义一个灵活的程序算法，其输出由许多参数（parameter）决定。 然后我们使用数据集来确定当下的“最佳参数集”，这些参数通过某种性能度量来获取完成任务的最佳性能</li><li>把参数看作是旋钮，我们可以转动旋钮来调整程序的行为。 任一调整参数后的程序，我们称为模型（model）</li><li>通过操作参数而生成的所有不同程序（输入-输出映射）的集合称为“模型族”</li><li>使用数据集来选择参数的元程序被称为学习算法（learning algorithm）</li><li>在我们开始用机器学习算法解决问题之前，我们必须精确地定义问题，确定输入（input）和输出（output）的性质，并选择合适的模型族</li><li>在机器学习中，学习（learning）是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据训练（train）我们的模型</li><li>训练过程通常包含如下步骤：<ol><li>从一个随机初始化参数的模型开始，这个模型基本毫不“智能”</li><li>获取一些数据样本（例如，音频片段以及对应的{是,否}{是,否}标签）</li><li>调整参数，使模型在这些样本中表现得更好</li><li>重复第2步和第3步，直到模型在任务中的表现令你满意</li></ol></li></ul><h3 id="机器学习的关键组件"><a href="#机器学习的关键组件" class="headerlink" title="机器学习的关键组件"></a>机器学习的关键组件</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul><li>每个数据集由一个个样本（example, sample）组成，大多时候，它们遵循独立同分布（independently and identically distributed, i.i.d.）</li><li> 样本有时也叫做数据点（data point）或者数据实例（data instance），通常每个样本由一组称为特征（features，或<em>协变量</em>（covariates））的属性组成，机器学习模型会根据这些属性进行预测</li><li>在监督学习问题中，要预测的是一个特殊的属性，它被称为标签（label，或目标（target））</li><li>当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的维数（dimensionality）。 固定长度的特征向量是一个方便的属性，它有助于我们量化学习大量样本</li><li>然而，并不是所有的数据都可以用“固定长度”的向量表示，例如文本数据。与传统机器学习方法相比，深度学习的一个主要优势是可以处理不同长度的数据</li><li>一般来说，我们拥有的数据越多，通常可以训练出更强大的模型，从而减少对预先设想假设的依赖。 数据集的由小变大为现代深度学习的成功奠定基础。 在没有大数据集的情况下，许多令人兴奋的深度学习模型黯然失色。 就算一些深度学习模型在小数据集上能够工作，但其效能并不比传统方法高</li><li>仅仅拥有海量的数据是不够的，我们还需要正确的数据。 如果数据中充满了错误，或者如果数据的特征不能预测任务目标，那么模型很可能无效</li><li>此外，糟糕的预测性能甚至会加倍放大事态的严重性。 在一些敏感应用中，如预测性监管、简历筛选和用于贷款的风险模型，我们必须特别警惕垃圾数据带来的后果。一种常见的问题来自不均衡的数据集，比如在一个有关医疗的训练数据集中，某些人群没有样本表示</li><li>当数据不具有充分代表性，甚至包含了一些社会偏见时，模型就很有可能有偏见</li></ul><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><ul><li>大多数机器学习会涉及到数据的转换。 比如，建立一个“摄取照片并预测笑脸”的系统</li><li>深度学习与经典方法的区别主要在于：前者关注的功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换，因此被称为深度学习（deep learning）</li></ul><h4 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h4><ul><li>在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，我们称之为目标函数（objective function）</li><li>我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为损失函数（loss function，或cost function）。 但这只是一个惯例，你也可以取一个新的函数，优化到它的最高点。 这两个函数本质上是相同的，只是翻转一下符号</li><li>当任务在试图预测数值时，最常见的损失函数是平方误差（squared error），即预测值与实际值之差的平方</li><li>当试图解决分类问题时，最常见的目标函数是最小化错误率，即预测与实际情况不符的样本比例</li><li>有些目标函数（如平方误差）很容易被优化，有些目标（如错误率）由于不可微性或其他复杂性难以直接优化。 在这些情况下，通常会优化替代目标</li><li>通常，损失函数是根据模型参数定义的，并取决于数据集。 在一个数据集上，我们通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称为训练数据集（training dataset，或称为训练集（training set））</li><li>然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的效能，这里的“新数据集”通常称为测试数据集（test dataset，或称为测试集（test set））</li><li>综上所述，我们通常将可用数据集分成两部分：训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。 然后我们观察模型在这两部分数据集的效能</li><li>换言之，测试性能可能会显著偏离训练性能。 当一个模型在训练集上表现良好，但不能推广到测试集时，我们说这个模型是“过拟合”（overfitting）的</li></ul><h4 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h4><ul><li>一旦我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，我们接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数</li><li>深度学习中，大多流行的优化算法通常基于一种基本方法——梯度下降（gradient descent）。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果你仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数</li></ul><h3 id="各种机器学习问题"><a href="#各种机器学习问题" class="headerlink" title="各种机器学习问题"></a>各种机器学习问题</h3><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><ul><li>监督学习（supervised learning）擅长在“给定输入特征”的情况下预测标签。 每个“特征-标签”对都称为一个样本（example）。 有时，即使标签是未知的，样本也可以指代输入特征。 我们的目标是生成一个模型，能够将任何输入特征映射到标签，即预测</li><li>监督学习之所以发挥作用，是因为在训练参数时，我们为模型提供了一个数据集，其中每个样本都有真实的标签。 用概率论术语来说，我们希望预测“估计给定输入特征的标签”的条件概率</li><li>虽然监督学习只是几大类机器学习问题之一，但是在工业中，大部分机器学习的成功应用都是监督学习。 这是因为在一定程度上，许多重要的任务可以清晰地描述为：在给定一组特定的可用数据的情况下，估计未知事物的概率</li><li>监督学习的学习过程：<ol><li>首先，从已知大量数据样本中随机选取一个子集，为每个样本获取基本的真实标签</li><li>有时，这些样本已有标签（例如，患者是否在下一年内康复？）； 有时，我们可能需要人工标记数据（例如，将图像分类）。这些输入和相应的标签一起构成了训练数据集</li><li>随后，我们选择有监督的学习算法，它将训练数据集作为输入，并输出一个“完成学习模型”</li><li>最后，我们将之前没见过的样本特征放到这个“完成学习模型”中，使用模型的输出作为相应标签的预测</li></ol></li><li>即使使用简单的描述“给定输入特征的预测标签”，监督学习也可以采取多种形式的模型，并且需要大量不同的建模决策，这取决于输入和输出的类型、大小和数量</li><li>回归<ul><li>回归（regression）是最简单的监督学习任务之一</li><li>回归问题本质上是输出决定的。 假设你在市场上寻找新房子，你可能需要估计一栋房子的公平市场价值。 销售价格，即标签，是一个数值。 当标签取任意数值时，我们称之为回归问题。 我们的目标是生成一个模型，它的预测非常接近实际标签值</li></ul></li><li>分类<ul><li>虽然回归模型可以很好地解决“有多少？”的问题，但是解决不了“哪一个？”的问题，这种问题叫做分类（classification）问题</li><li>在分类问题中，我们希望模型能够预测样本属于哪个类别（category，正式称为类（class））</li><li>最简单的分类问题是只有两类，我们称之为“二元分类”</li><li>在回归中，我们训练一个回归函数来输出一个数值； 而在分类中，我们训练一个分类器，它的输出即为预测的类别</li><li>可以试着用概率语言来理解模型。 给定一个样本特征，我们的模型为每个可能的类分配一个概率，比如，猫狗分类器可能会输出图像是猫的概率为0.9，即分类器90%确定图像描绘的是一只猫。 预测类别的概率的大小传达了一种模型的不确定性</li><li>当我们有两个以上的类别时，我们把这个问题称为多元分类（multiclass classification）问题，常见的例子包括手写字符识别 </li><li>与解决回归问题不同，分类问题的常见损失函数被称为交叉熵（cross-entropy）</li><li>最常见的类别不一定是你将用于决策的类别，或许不确定风险的影响远远大于收益。 因此，我们需要将“预期风险”作为损失函数。 也就是说，我们需要将结果的概率乘以与之相关的收益（或伤害）</li><li>有一些分类任务的变体可以用于寻找层次结构，层次结构假定在许多类之间存在某种关系。 因此，并不是所有的错误都是均等的。 我们宁愿错误地分入一个相关的类别，也不愿错误地分入一个遥远的类别，这通常被称为层次分类（hierarchical classification）</li></ul></li><li>标记问题<ul><li>学习预测不相互排斥的类别的问题称为多标签分类（multi-label classification）</li><li>举个例子，人们在技术博客上贴的标签，比如“机器学习”、“技术”、“小工具”、“编程语言”、“Linux”、“云计算”、“AWS”。 一篇典型的文章可能会用5-10个标签，因为这些概念是相互关联的。 关于“云计算”的帖子可能会提到“AWS”，而关于“机器学习”的帖子也可能涉及“编程语言”</li></ul></li><li>搜索<ul><li>有时，我们不仅仅希望输出为一个类别或一个实值。 在信息检索领域，我们希望对一组项目进行排序</li><li>以网络搜索为例，我们的目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。 搜索结果的排序也十分重要，我们的学习算法需要输出有序的元素子集</li><li>该问题的一种可能的解决方案：首先为集合中的每个元素分配相应的相关性分数，然后检索评级最高的元素。PageRank，谷歌搜索引擎背后最初的秘密武器就是这种评分系统的早期例子</li><li>如今，搜索引擎使用机器学习和用户行为模型来获取网页相关性得分，很多学术会议也致力于这一主题</li></ul></li><li>推荐系统<ul><li>另一类与搜索和排名相关的问题是推荐系统（recommender system），它的目标是向特定用户进行“个性化”推荐</li><li>简单来说，推荐系统会为“给定用户和物品”的匹配性打分，这个“分数”可能是估计的评级或购买的概率。 由此，对于任何给定的用户，推荐系统都可以检索得分最高的对象集，然后将其推荐给用户。工业生产的推荐系统还要先进得多，它会将详细的用户活动和项目特征考虑在内</li><li>尽管推荐系统具有巨大的应用价值，但单纯用它作为预测模型仍存在一些缺陷。首先，用户更倾向于给他们感觉强烈的事物打分，此外，推荐系统有可能形成反馈循环</li></ul></li><li>序列学习<ul><li>以上大多数问题都具有固定大小的输入和产生固定大小的输出，在这些情况下，模型只会将输入作为生成输出的“原料”，而不会“记住”输入的具体内容</li><li>但是如果输入是连续的，我们的模型可能就需要拥有“记忆”功能。 比如，处理视频片段时，每个视频片段可能由不同数量的帧组成，通过前一帧的图像，我们可能对后一帧中发生的事情更有把握。 语言也是如此，机器翻译的输入和输出都为文字序列</li><li>序列学习的实例，是机器学习最令人兴奋的应用之一。 序列学习需要摄取输入序列或预测输出序列，或两者兼而有之。 具体来说，输入和输出都是可变长度的序列，例如机器翻译和从语音中转录文本</li><li>标记和解析：这涉及到用属性注释文本序列。 换句话说，输入和输出的数量基本上是相同的。 例如，我们可能想知道动词和主语在哪里，或者，我们可能想知道哪些单词是命名实体。 通常，目标是基于结构和语法假设对文本进行分解和注释，以获得一些注释</li><li>自动语音识别：在语音识别中，输入序列是说话人的录音，输出序列是说话人所说内容的文本记录。 它的挑战在于，与文本相比，音频帧多得多，也就是说，音频和文本之间没有1:1的对应关系，因为数千个样本可能对应于一个单独的单词。 这也是“序列到序列”的学习问题，其中输出比输入短得多</li><li>文本到语音：这与自动语音识别相反。 换句话说，输入是文本，输出是音频文件。 在这种情况下，输出比输入长得多。 虽然人类很容易识判断发音别扭的音频文件，但这对计算机来说并不是那么简单</li><li>机器翻译：在语音识别中，输入和输出的出现顺序基本相同。 而在机器翻译中，颠倒输入和输出的顺序非常重要。 换句话说，虽然我们仍将一个序列转换成另一个序列，但是输入和输出的数量以及相应序列的顺序大都不会相同</li></ul></li></ul><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><ul><li>监督学习向模型提供巨大数据集，每个样本包含特征和相应标签值，准确地告诉模型在每种情况下应该做什么，直到模型学会从情况到行动的映射</li><li>如果没有十分具体的目标，就需要“自发”地去学习了，我们称这类数据中不含有“目标”的机器学习问题为无监督学习（unsupervised learning）</li><li>无监督学习可以回答什么样的问题<ul><li>聚类（clustering）问题：没有标签的情况下，我们是否能给数据分类。比如，给定一组照片，把它们分成风景照片、狗、婴儿、猫和山峰的照片</li><li>主成分分析（principal component analysis）问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性。比如，一个球的运动轨迹可以用球的速度、直径和质量来描述</li><li>因果关系（causality）和概率图模型（probabilistic graphical models）问题：我们能否描述观察到的许多数据的根本原因。例如，如果我们有关于房价、污染、犯罪、地理位置、教育和工资的人口统计数据，我们能否简单地根据经验数据发现它们之间的关系</li><li>生成对抗性网络（generative adversarial networks）：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的非结构化数据。潜在的统计机制是检查真实和虚假数据是否相同的测试，它是无监督学习的另一个重要而令人兴奋的领域</li></ul></li></ul><h4 id="与环境互动"><a href="#与环境互动" class="headerlink" title="与环境互动"></a>与环境互动</h4><ul><li>不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。 这里所有学习都是在算法与环境断开后进行的，被称为离线学习（offline learning）</li><li>离线学习可以孤立地进行模式识别，而不必分心于其他问题，但缺点是，解决的问题相当有限</li><li>你可能会期望人工智能不仅能够做出预测，而且能够与真实环境互动。 与预测不同，“与真实环境互动”实际上会影响环境。 这里的人工智能是“智能代理”，而不仅是“预测模型”。 因此，我们必须考虑到它的行为可能会影响未来的观察结果</li><li>考虑“与真实环境互动”将打开一整套新的建模问题<ul><li>环境还记得我们以前做过什么吗？</li><li>环境是否有助于我们建模？例如，用户将文本读入语音识别器。</li><li>环境是否想要打败模型？例如，一个对抗性的设置，如垃圾邮件过滤或玩游戏？</li><li>环境是否重要？</li><li>当训练和测试数据不同时，环境是否变化？这是分布偏移（distribution shift）的问题。例如，未来的数据是否总是与过去相似，还是随着时间的推移会发生变化？是自然变化还是响应我们的自动化工具而发生变化？</li></ul></li></ul><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><ul><li>如果你对使用机器学习开发与环境交互并采取行动感兴趣，那么你最终可能会专注于强化学习（reinforcement learning）。 这可能包括应用到机器人、对话系统，甚至开发视频游戏的人工智能（AI）</li><li>深度强化学习（deep reinforcement learning）将深度学习应用于强化学习的问题，是非常热门的研究领域</li><li>我们可以将任何监督学习问题转化为强化学习问题。 假设我们有一个分类问题，我们可以创建一个强化学习agent，每个分类对应一个“动作”。 然后，我们可以创建一个环境，该环境给予agent的奖励。 这个奖励与原始监督学习问题的损失函数是一致的</li><li>在监督学习中，我们总是希望输入与正确的标签相关联。 但在强化学习中，我们并不假设环境告诉agent每个观测的最优动作。 一般来说，agent只是得到一些奖励。</li><li>环境甚至可能不会告诉我们是哪些行为导致了奖励，因此，强化学习者必须处理学分分配（credit assignment）问题：决定哪些行为是值得奖励的，哪些行为是需要惩罚的</li><li>强化学习可能还必须处理部分可观测性问题。 也就是说，当前的观察结果可能无法阐述有关当前状态的所有信息</li><li>最后，在任何时间点上，强化学习agent可能知道一个好的策略，但可能有许多更好的策略从未尝试过的。 强化学习agent必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识）</li><li>环境可以是完整观察到的，也可以是部分观察到的，解释所有这些复杂性可能会对研究人员要求太高。 此外，并不是每个实际问题都表现出所有这些复杂性。 因此，学者们研究了一些特殊情况下的强化学习问题</li><li>当环境可被完全观察到时，我们将强化学习问题称为马尔可夫决策过程（markov decision process）。 当状态不依赖于之前的操作时，我们称该问题为上下文赌博机（contextual bandit problem）。 当没有状态，只有一组最初未知回报的可用动作时，这个问题就是经典的多臂赌博机（multi-armed bandit problem）</li></ul><h3 id="深度学习的发展"><a href="#深度学习的发展" class="headerlink" title="深度学习的发展"></a>深度学习的发展</h3><ul><li>为了解决各种各样的机器学习问题，深度学习提供了强大的工具。 虽然许多深度学习方法都是最近的才有重大突破，但使用数据和神经网络编程的核心思想已经研究了几个世纪</li><li>伯努利分布是以雅各布•伯努利（1654–1705）命名的。 而高斯分布是由卡尔•弗里德里希•高斯（1777—1855）发现的， 他发明了最小均方算法，至今仍用于解决从保险计算到医疗诊断的许多问题</li><li>随着数据的收集和可获得性，统计数据真正实现了腾飞。 罗纳德·费舍尔（1890-1962）对统计理论和在遗传学中的应用做出了重大贡献。 他的许多算法（如线性判别分析）和公式（如费舍尔信息矩阵）至今仍被频繁使用</li><li>机器学习的第二个影响来自克劳德·香农(1916–2001)的信息论和艾伦·图灵（1912-1954）的计算理论。 图灵在他著名的论文《计算机器与智能》中提出了“机器能思考吗？”的问题（图灵测试）</li><li>唐纳德·赫布 (1904–1985)开创性的著作《行为的组织》提出神经元通过积极强化学习，是Rosenblatt感知器学习算法的原型，被称为“赫布学习”。 这个算法也为当今深度学习的许多随机梯度下降算法奠定了基础：强化期望行为和减少不良行为，从而在神经网络中获得良好的参数设置</li><li>神经网络（neural networks）的得名源于生物灵感。 一个多世纪以来（追溯到1873年亚历山大·贝恩和1890年詹姆斯·谢林顿的模型），研究人员一直试图组装类似于相互作用的神经元网络的计算电路。 随着时间的推移，对生物学的解释变得不再肤浅，但这个名字仍然存在。 其核心是当今大多数网络中都可以找到的几个关键原则：<ul><li>线性和非线性处理单元的交替，通常称为层（layers）。</li><li>使用链式规则（也称为反向传播（backpropagation））一次性调整网络中的全部参数</li></ul></li><li>神经网络的研究从1995年左右一直开始停滞不前，直到到2005年才稍有起色。 这主要是因为两个原因。 首先，训练网络（在计算上）非常昂贵， 其次，数据集相对较小</li><li>大约2010年开始，那些在计算上看起来不可行的神经网络算法变得热门起来，实际上是以下两点导致的： 其一，随着互联网的公司的出现，为数亿在线用户提供服务，大规模数据集变得触手可及。 另外，廉价又高质量的传感器、廉价的数据存储（克莱德定律）以及廉价计算（摩尔定律）的普及，特别是GPU的普及，使大规模算力唾手可得</li><li>很明显，随机存取存储器没有跟上数据增长的步伐。 与此同时，算力的增长速度已经超过了现有数据的增长速度。 这意味着统计模型需要提高内存效率（这通常是通过添加非线性来实现的）</li><li>同时由于计算预算的增加，能够花费更多时间来优化这些参数。 因此，机器学习和统计的关注点从（广义的）线性模型和核方法转移到了深度神经网络。 这也造就了许多深度学习的中流砥柱，如多层感知机、卷积神经网络、长短期记忆网络和Q学习，在相对休眠了相当长一段时间之后，在过去十年中被“重新发现</li></ul><h3 id="深度学习的成功案例"><a href="#深度学习的成功案例" class="headerlink" title="深度学习的成功案例"></a>深度学习的成功案例</h3><ul><li>感知 -&gt; 推理 -&gt; 知识 -&gt; 规划：自然语言处理 -&gt; 计算机视觉 -&gt; 深度学习</li><li>深度学习应用：图片地图、样式迁移、人脸合成、文字生成图片、文字生成、无人驾驶</li><li>案例研究：广告点击<ul><li>触发 -&gt; 点击率预估 -&gt; 排序（$点击率 * 竞价$）</li><li>预测：特征提取 -&gt; 模型 -&gt; 点击率预测</li><li>训练：训练数据（过去广告展现与用户点击） -&gt; 特征和用户点击 -&gt; 模型</li><li>领域专家：点击 -&gt; 展现</li><li>数据科学家：数据 -&gt; 模型（模型控制广告展现，这些用来训练新的模型）</li><li>AI 专家：提升模型精度和性能</li></ul></li></ul><h3 id="深度学习的特点"><a href="#深度学习的特点" class="headerlink" title="深度学习的特点"></a>深度学习的特点</h3><ul><li>机器学习可以使用数据来学习输入和输出之间的转换，例如在语音识别中将音频转换为文本。 在这样做时，通常需要以适合算法的方式表示数据，以便将这种表示转换为输出</li><li>深度学习是“深度”的，模型学习了许多“层”的转换，每一层提供一个层次的表示。 例如，靠近输入的层可以表示数据的低级细节，而接近分类输出的层可以表示用于区分的更抽象的概念。 由于表示学习（representation learning）目的是寻找表示本身，因此深度学习可以称为“多级表示学习”</li><li>多层模型能够以以前的工具所不能的方式处理低级的感知数据。 毋庸置疑，深度学习方法中最显著的共同点是使用端到端训练。 也就是说，与其基于单独调整的组件组装系统，不如构建系统，然后联合调整它们的性能。</li><li>在过去的日子里，将机器学习应用于这些问题的关键部分是提出人工设计的特征工程方法，将数据转换为某种适合于浅层模型的形式。 然而，与一个算法自动执行的数百万个选择相比，人类通过特征工程所能完成的事情很少。 当深度学习开始时，这些特征抽取器被自动调整的滤波器所取代，产生了更高的精确度</li><li>因此，深度学习的一个关键优势是它不仅取代了传统学习管道末端的浅层模型，而且还取代了劳动密集型的特征工程过程。 此外，通过取代大部分特定领域的预处理，深度学习消除了以前分隔计算机视觉、语音识别、自然语言处理、医学信息学和其他应用领域的许多界限，为解决各种问题提供了一套统一的工具</li><li>除了端到端的训练，我们正在经历从参数统计描述到完全非参数模型的转变。 当数据稀缺时，人们需要依靠简化对现实的假设来获得有用的模型。 当数据丰富时，可以用更准确地拟合实际情况的非参数模型来代替。</li><li>现在人们可以借助于相关偏微分方程的数值模拟，而不是用手来求解电子行为的参数近似。这导致了更精确的模型，尽管常常以牺牲可解释性为代价。与以前工作的另一个不同之处是接受次优解，处理非凸非线性优化问题，并且愿意在证明之前尝试。 这种在处理统计问题上新发现的经验主义，加上人才的迅速涌入，导致了实用算法的快速进步</li></ul><h3 id="安装动手学深度学习-v2"><a href="#安装动手学深度学习-v2" class="headerlink" title="安装动手学深度学习 v2"></a>安装动手学深度学习 v2</h3><ul><li><p>安装环境：Ubuntu 18.04 + build-essential + Python 3.8 + </p></li><li><p>安装 Miniconda 到 <code>\root\miniconda3</code></p><pre><code class="bash">wget https://repo.anaconda.com/miniconda/Miniconda3-py38_4.11.0-Linux-x86_64.shbash Miniconda3-py38_4.11.0-Linux-x86_64.sh</code></pre></li><li><p>安装其他软件包</p><pre><code class="bash">pip install jupyter d2l torch torchvision</code></pre></li><li><p>拷贝 Jupyter 记事本</p><pre><code class="bash">wget https://zh-v2.d2l.ai/d2l-zh.zipgit clone git@github.com:d2l-ai/d2l-zh-pytorch-slides.git</code></pre></li><li><p>远程运行 Jupyter Notebook</p><pre><code class="bash">jupyter notebook --allow-root</code></pre></li><li><p>将远端 localhost 映射到本地 localhost（端口 :8888）</p><pre><code class="bash">ssh -L8888:localhost:8888 root@106.15.200.147</code></pre></li><li><p>安装 jupyter 插件</p><pre><code class="bash">pip install rise</code></pre></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>机器学习研究计算机系统如何利用经验（通常是数据）来提高特定任务的性能。它结合了统计学、数据挖掘和优化的思想。通常，它是被用作实现人工智能解决方案的一种手段</li><li>表示学习作为机器学习的一类，其研究的重点是如何自动找到合适的数据表示方式。深度学习是通过学习多层次的转换来进行的多层次的表示学习</li><li>深度学习不仅取代了传统机器学习的浅层模型，而且取代了劳动密集型的特征工程</li><li>最近在深度学习方面取得的许多进展，大都是由廉价传感器和互联网规模应用所产生的大量数据，以及（通过GPU）算力的突破来触发的</li><li>整个系统优化是获得高性能的关键环节。有效的深度学习框架的开源使得这一点的设计和实现变得非常容易</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机器学习（machine learning，ML）是一类强大的可以从经验中学习的技术。 通常采用观测数据或与环境交互的形式，机器学习算法会积累更多的经验，其性能也会逐步提高就在过去的五年里，深度学习给世界带来了惊喜，推动了计算机视觉、自然语言处理、自动语音识别、强化学习和统计建模等领域的快速发展。我选择动手学深度学习 v2 课程来开启机器学习之旅，并特别关注深度学习（deep learning，DL）的基础知识深度学习。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://blog.zhuangzhihao.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>macOS + Ubuntu 实现远程开发配置</title>
    <link href="http://blog.zhuangzhihao.top/Ubuntu%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.zhuangzhihao.top/Ubuntu%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/</id>
    <published>2022-03-05T16:00:00.000Z</published>
    <updated>2022-05-16T05:54:27.133Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>刚刚续费了一年的阿里云轻量应用服务器，打算把大多数的开发环境放到服务器上，实现远程开发。我使用的是 macOS Monterey 和基于 Ubuntu 18.04 的 LNMP 镜像系统，IDE 选取 Visual Studio Code 和 IntelliJ IDEA 进行开发学习。</p></blockquote><a id="more"></a><h3 id="一、服务器镜像信息"><a href="#一、服务器镜像信息" class="headerlink" title="一、服务器镜像信息"></a>一、服务器镜像信息</h3><p>我使用的是阿里云轻量应用服务器提供的 LNMP 7.4 镜像，该镜像为LNMP（Ubuntu18.04 64位+Nginx+MySQL5.7+PHP5.3～8.0切换）架构，jemalloc优化内存管理，脚本菜单式添加Nginx虚拟主机绑定，并支持内网OSS备份功能，是常见的搭建Web应用所需的环境，支持高并发性能。</p><p>应用程序安装信息：</p><ul><li><p>Nginx 1.18：<code>/usr/local/nginx</code></p></li><li><p>PHP 7.4：<code>/usr/local/php</code></p></li><li><p>MySQL 5.7：<code>/usr/local/mysql</code></p></li><li><p>数据库地址：127.0.0.1:3306 </p></li><li><p>网站根目录：<code>/data/wwwroot</code></p></li></ul><p>查询数据库和 FTP 密码</p><pre><code class="bash">sudo cat /root/ReadMe</code></pre><h3 id="二、Ubuntu-系统配置"><a href="#二、Ubuntu-系统配置" class="headerlink" title="二、Ubuntu 系统配置"></a>二、Ubuntu 系统配置</h3><p>依赖源设置：</p><pre><code class="bash">mv /etc/apt/sources.list&#123;,bak&#125; #备份sources.listcat &gt; /etc/apt/sources.list &lt;&lt; EOFdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverseEOFapt update</code></pre><p>在防火墙添加规则放行 21、20000/30000 端口，允许通过 FTP 连接。</p><h3 id="三、搭建开发环境"><a href="#三、搭建开发环境" class="headerlink" title="三、搭建开发环境"></a>三、搭建开发环境</h3><p>C/C++ 开发环境：</p><pre><code class="bash">sudo apt-get install build-essential</code></pre><p>Python3 开发环境：</p><pre><code class="bash">python3 --version  sudo apt-get install python3-pip</code></pre><p>Java 开发环境：</p><pre><code class="bash">sudo apt install openjdk-11-jdk</code></pre><p>Go 开发环境：</p><pre><code class="bash">sudo wget -c https://dl.google.com/go/go1.15.6.linux-amd64.tar.gz -O - | sudo tar -xz -C /usr/localvim /etc/profile</code></pre><p>添加以下内容：</p><pre><code class="bash">export GOROOT=/usr/local/goexport GOPATH=/tufei/code/goexport GOBIN=$GOPATH/binexport PATH=$GOPATH:$GOBIN:$GOROOT/bin:$PATH</code></pre><p>保存：</p><pre><code class="bash">source  /etc/profilego version</code></pre><p>Git 安装配置：</p><pre><code class="bash">sudo apt-get install gitgit config --global user.name &quot;Zhuang Zhihao&quot;git config --global user.email &quot;bezhuang@outlook.com&quot;ssh-keygen -t rsa -C &quot;bezhuang@outlook.com&quot;cat /root/.ssh/id_rsa.pub</code></pre><p>提交公钥到 Github 或其他 Git 仓库。</p><h3 id="四、管理服务"><a href="#四、管理服务" class="headerlink" title="四、管理服务"></a>四、管理服务</h3><p>Nginx：</p><pre><code class="bash">service nginx &#123;start|stop|status|restart|reload|configtest&#125;</code></pre><p>MySQL：</p><pre><code class="bash">service mysqld &#123;start|stop|restart|reload|status&#125;</code></pre><p>PHP：</p><pre><code class="bash">service php-fpm &#123;start|stop|restart|reload|status&#125;</code></pre><p>Pure-Ftpd：</p><pre><code class="bash">service pureftpd &#123;start|stop|restart|status&#125;</code></pre><p>Redis：</p><pre><code class="bash">service redis-server &#123;start|stop|status|restart&#125;</code></pre><p>Memcached：</p><pre><code class="bash">service memcached &#123;start|stop|status|restart|reload&#125;</code></pre><h3 id="五、虚拟主机管理"><a href="#五、虚拟主机管理" class="headerlink" title="五、虚拟主机管理"></a>五、虚拟主机管理</h3><p>添加虚拟主机：</p><pre><code class="bash">cd /root/oneinstack./vhost.sh</code></pre><p>删除虚拟主机：</p><pre><code class="bash">./vhost.sh --del</code></pre><h3 id="六、本地开发环境"><a href="#六、本地开发环境" class="headerlink" title="六、本地开发环境"></a>六、本地开发环境</h3><p>使用 Visual Studio Code 中的 Remote -SSH 插件连接，</p><p>使用 Termius 进行 SSH 和 SFTP 连接，</p><p>博客现仍使用 Hexo，Typora 软件用于编写博客文章，uPic 软件用于上传图床。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;刚刚续费了一年的阿里云轻量应用服务器，打算把大多数的开发环境放到服务器上，实现远程开发。我使用的是 macOS Monterey 和基于 Ubuntu 18.04 的 LNMP 镜像系统，IDE 选取 Visual Studio Code 和 IntelliJ IDEA 进行开发学习。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="云服务" scheme="http://blog.zhuangzhihao.top/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Linux" scheme="http://blog.zhuangzhihao.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言基础知识总结</title>
    <link href="http://blog.zhuangzhihao.top/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/"/>
    <id>http://blog.zhuangzhihao.top/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/</id>
    <published>2022-02-12T16:00:00.000Z</published>
    <updated>2022-05-05T12:58:19.840Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Go 语言是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，它用批判吸收的眼光，融合 C 语言、Java 等众家之长，将简洁、高效演绎得淋漓尽致。Golang非常适合用来做网络并发方面的服务，比如消息推送、监控、容器等。初次学习我选择的是 <a href="https://go-zh.org/">Go 编程语言</a>指南，指南涵盖了该语言的大部分重要特性，放在以下为所记笔记，另附有随堂代码放在 <a href="https://github.com/Bezhuang/Learn-CS/tree/main/Learn%20Programming/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85">Github 仓库</a>中，可供参考。</p></blockquote><a id="more"></a><h3 id="包、变量和函数"><a href="#包、变量和函数" class="headerlink" title="包、变量和函数"></a>包、变量和函数</h3><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><ul><li><p>每个 Go 程序都是由包构成的</p></li><li><p>程序从 <code>main</code> 包开始运行</p><pre><code class="go">package main</code></pre></li></ul><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><ul><li><p>此代码用圆括号组合了导入，这是“分组”形式的导入语句</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;math&quot;)</code></pre></li><li><p>当然也可以编写多个导入语句，不过使用分组导入语句是更好的形式</p></li></ul><h4 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h4><ul><li><p>在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，<code>Pizza</code> 就是个已导出名，<code>Pi</code> 也同样，它导出自 <code>math</code> 包</p><pre><code class="go">func main() &#123;    fmt.Println(math.Pi)&#125;</code></pre></li><li><p>在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问</p></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li><p>函数可以没有参数或接受多个参数</p><pre><code class="go">// add 接受两个 int 类型的参数func add(x int, y int) int &#123;    return x + y&#125;</code></pre></li><li><p>注意类型在变量名 <strong>之后</strong></p></li><li><p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略</p><pre><code class="go">func add(x, y int) int &#123;    return x + y&#125;</code></pre></li></ul><h4 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h4><ul><li><p>函数可以返回任意数量的返回值</p></li><li><p><code>swap</code> 函数返回了两个字符串</p><pre><code class="go">func swap(x, y string) (string, string) &#123;    return y, x&#125;</code></pre></li></ul><h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><ul><li><p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量</p></li><li><p>返回值的名称应当具有一定的意义，它可以作为文档使用</p></li><li><p>没有参数的 <code>return</code> 语句返回已命名的返回值。也就是 <code>直接</code> 返回</p></li><li><p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性</p><pre><code class="go">func split(sum int) (x, y int) &#123;    x = sum * 4 / 9    y = sum - x    return&#125;</code></pre></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</p></li><li><p><code>var</code> 语句可以出现在包或函数级别</p><pre><code class="go">var c, python, java boolfunc main() &#123;    var i int    fmt.Println(i, c, python, java)&#125;</code></pre></li></ul><h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><ul><li><p>变量声明可以包含初始值，每个变量对应一个</p></li><li><p>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型</p><pre><code class="go">var i, j int = 1, 2func main() &#123;    var c, python, java = true, false, &quot;no!&quot;    fmt.Println(i, j, c, python, java)&#125;</code></pre></li></ul><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><ul><li><p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明</p></li><li><p>函数外的每个语句都必须以关键字开始（<code>var</code>, <code>func</code> 等等），因此 <code>:=</code> 结构不能在函数外使用</p><pre><code class="go">func main() &#123;    var i, j int = 1, 2    k := 3    c, python, java := true, false, &quot;no!&quot;    fmt.Println(i, j, k, c, python, java)&#125;</code></pre></li></ul><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul><li><p>Go 的基本类型有</p><pre><code>boolstringint  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名，表示一个 Unicode 码点float32 float64complex64 complex128</code></pre></li><li><p>同导入语句一样，变量声明也可以“分组”成一个语法块</p><pre><code class="go">var (    ToBe   bool       = false    MaxInt uint64     = 1&lt;&lt;64 - 1    z      complex128 = cmplx.Sqrt(-5 + 12i))</code></pre></li><li><p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽</p></li><li><p>当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型</p></li></ul><h4 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h4><ul><li>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong><ul><li>数值类型零值为 <code>0</code></li><li>布尔类型零值为 <code>false</code></li><li>字符串零值为 <code>&quot;&quot;</code>（空字符串）</li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li><p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p><pre><code class="go">i := 42f := float64(i)u := uint(f)</code></pre></li><li><p>与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换</p><pre><code class="go">var i int = 42var f float64 = float64(i)var u uint = uint(f)</code></pre></li></ul><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><ul><li><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法）</p></li><li><p>变量的类型由右值推导得出</p></li><li><p>当右值声明了类型时，新变量的类型与其相同：</p><pre><code class="go">var i intj := i // j 也是一个 int</code></pre></li><li><p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p><pre><code class="go">i := 42           // intf := 3.142        // float64g := 0.867 + 0.5i // complex128</code></pre></li></ul><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul><li><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字</p></li><li><p>常量可以是字符、字符串、布尔值或数值</p></li><li><p>常量不能用 <code>:=</code> 语法声明</p><pre><code class="go">const Pi = 3.14</code></pre></li></ul><h4 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h4><ul><li><p>数值常量是高精度的 <strong>值</strong></p></li><li><p>一个未指定类型的常量由上下文来决定其类型</p></li><li><p><code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少</p><pre><code class="go">const (    // 将 1 左移 100 位来创建一个非常大的数字    // 即这个数的二进制是 1 后面跟着 100 个 0    Big = 1 &lt;&lt; 100    // 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2    Small = Big &gt;&gt; 99)func needInt(x int) int &#123; return x*10 + 1 &#125;func needFloat(x float64) float64 &#123;    return x * 0.1&#125;</code></pre></li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ul><li><p>Go 只有一种循环结构：<code>for</code> 循环</p></li><li><p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开</p><ul><li>初始化语句：在第一次迭代前执行</li><li>条件表达式：在每次迭代前求值</li><li>后置语句：在每次迭代的结尾执行</li></ul><pre><code class="go">for i := 0; i &lt; 10; i++ &#123;        sum += i&#125;</code></pre></li><li><p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见</p></li><li><p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止</p></li><li><p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的</p></li></ul><h4 id="for-是-Go-中的-“while”"><a href="#for-是-Go-中的-“while”" class="headerlink" title="for 是 Go 中的 “while”"></a>for 是 Go 中的 “while”</h4><ul><li><p>初始化语句和后置语句是可选的</p></li><li><p>此时你可以去掉分号，因为 C 的 <code>while</code> 在 Go 中叫做 <code>for</code></p><pre><code class="go">sum := 1for sum &lt; 1000 &#123;    sum += sum&#125;</code></pre></li><li><p>如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑</p><pre><code class="go">func main() &#123;    for &#123;    &#125;&#125;</code></pre></li></ul><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><ul><li><p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的</p><pre><code class="go">func sqrt(x float64) string &#123;    if x &lt; 0 &#123;        return sqrt(-x) + &quot;i&quot;    &#125;    return fmt.Sprint(math.Sqrt(x))&#125;</code></pre></li><li><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 <code>if</code> 之内</p><pre><code class="go">func pow(x, n, lim float64) float64 &#123;    if v := math.Pow(x, n); v &lt; lim &#123;        return v    &#125;    return lim&#125;</code></pre></li></ul><h4 id="if-和-else"><a href="#if-和-else" class="headerlink" title="if  和 else"></a>if  和 else</h4><ul><li><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用</p><pre><code class="go">func pow(x, n, lim float64) float64 &#123;    if v := math.Pow(x, n); v &lt; lim &#123;        return v    &#125; else &#123;        fmt.Printf(&quot;%g &gt;= %g\n&quot;, v, lim)    &#125;    // 这里开始就不能使用 v 了    return lim&#125;</code></pre></li></ul><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><ul><li><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法，它运行第一个值等于条件表达式的 case 语句</p></li><li><p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case</p></li><li><p>实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句</p></li><li><p>除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止</p></li><li><p>Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数</p><pre><code class="go">switch os := runtime.GOOS; os &#123;    case &quot;darwin&quot;:        fmt.Println(&quot;OS X.&quot;)    case &quot;linux&quot;:        fmt.Println(&quot;Linux.&quot;)    default:        fmt.Println(&quot;%s. \n&quot;, os)</code></pre></li><li><p>switch 的求值顺序：case 语句从上到下顺次执行，直到匹配成功时停止</p><pre><code class="go">switch i &#123;case 0:case f():  // 在 i==0 时 f 不会被调用&#125;</code></pre></li><li><p>没有条件的 switch 同 <code>switch true</code> 一样。这种形式能将一长串 <code>if-then-else</code> 写得更加清晰</p><pre><code class="go">switch &#123;    case t.Hour() &lt; 12:        fmt.Println(&quot;Good morning!&quot;)    case t.Hour() &lt; 17:        fmt.Println(&quot;Good afternoon.&quot;)    default:        fmt.Println(&quot;Good evening.&quot;)</code></pre></li></ul><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><ul><li><p>defer 语句会将函数推迟到外层函数返回之后执行</p></li><li><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</p><pre><code class="go">func main() &#123;    defer fmt.Println(&quot;world&quot;)    fmt.Println(&quot;hello&quot;)&#125; // 输出：hello world</code></pre></li></ul><h4 id="defer-栈"><a href="#defer-栈" class="headerlink" title="defer 栈"></a>defer 栈</h4><ul><li><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用</p><pre><code class="go">func main() &#123;    fmt.Println(&quot;counting&quot;)    defer fmt.Println(&quot;done&quot;)    for i := 0; i &lt; 10; i++ &#123;        defer fmt.Println(i)    &#125;&#125; // 输出：counting 9 8 7 6 5 4 3 2 1 0 done</code></pre></li></ul><h3 id="结构体、数组、切片和映射"><a href="#结构体、数组、切片和映射" class="headerlink" title="结构体、数组、切片和映射"></a>结构体、数组、切片和映射</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul><li><p>Go 拥有指针。指针保存了值的内存地址</p></li><li><p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code></p><pre><code class="go">var p *int</code></pre></li><li><p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p><pre><code class="go">i := 42p = &amp;i</code></pre></li><li><p><code>*</code> 操作符表示指针指向的底层值</p><pre><code class="go">fmt.Println(*p) // 通过指针 p 读取 i*p = 21         // 通过指针 p 设置 i</code></pre></li><li><p>这也就是通常所说的“间接引用”或“重定向”</p></li><li><p>与 C 不同，Go 没有指针运算</p></li></ul><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><ul><li><p>一个结构体（<code>struct</code>）就是一组字段（field）</p><pre><code class="go">type Vertex struct &#123;    X int    Y int&#125;func main() &#123;    fmt.Println(Vertex&#123;1, 2&#125;)&#125;</code></pre></li><li><p>结构体字段使用点号来访问</p><pre><code class="go">func main() &#123;    v := Vertex&#123;1, 2&#125;    v.X = 4    fmt.Println(v, v.X, v.Y)&#125;</code></pre></li></ul><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><ul><li><p>结构体字段可以通过结构体指针来访问</p></li><li><p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code> 就可以</p><pre><code class="go">func main() &#123;    v := Vertex&#123;1, 2&#125;    p = &amp;v    p.X = 1e9    fmt.Println(v)&#125;</code></pre></li></ul><h4 id="结构体文法"><a href="#结构体文法" class="headerlink" title="结构体文法"></a>结构体文法</h4><ul><li><p>结构体文法通过直接列出字段的值来新分配一个结构体</p></li><li><p>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</p></li><li><p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针</p><pre><code class="go">type Vertex struct &#123;    X, Y int&#125;var (    v1 = Vertex&#123;1, 2&#125;  // 创建一个 Vertex 类型的结构体    &#123;1, 2&#125;     v2 = Vertex&#123;X: 1&#125;  // Y:0 被隐式地赋予    &#123;1, 0&#125;     v3 = Vertex&#123;&#125;      // X:0 Y:0    &#123;0, 0&#125;     p  = &amp;Vertex&#123;1, 2&#125; // 创建一个 *Vertex 类型的结构体（指针）   &amp;&#123;1, 2&#125;)</code></pre></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p><pre><code class="go">var a [2]string  // 会将变量 a 声明为拥有 10 个整数的数组a[0] = &quot;Hello&quot;a[1] = &quot;World&quot;  </code></pre></li><li><p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组</p></li></ul><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><ul><li><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p></li><li><p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p></li><li><p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p><pre><code class="go">a[low : high] // 选择一个半开区间，包括第一个元素，但排除最后一个元素</code></pre><pre><code class="go">primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125;var s []int = primes[1:4] // 创建了一个切片，它包含 primes 中下标从 1 到 3 的元素 fmt.Println(s)  // 输出：[3 5 7]</code></pre></li><li><p>切片就像数组的引用，切片并不存储任何数据，它只是描述了底层数组中的一段</p></li><li><p>更改切片的元素会修改其底层数组中对应的元素，与它共享底层数组的切片都会观测到这些修改</p></li></ul><h4 id="切片文法"><a href="#切片文法" class="headerlink" title="切片文法"></a>切片文法</h4><ul><li><p>切片文法类似于没有长度的数组文法。</p></li><li><p>这是一个数组文法：</p><pre><code class="go">[3]bool&#123;true, true, false&#125;</code></pre></li><li><p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p><pre><code class="go">[]bool&#123;true, true, false&#125;</code></pre></li></ul><h4 id="切片的默认行为"><a href="#切片的默认行为" class="headerlink" title="切片的默认行为"></a>切片的默认行为</h4><ul><li><p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p></li><li><p>切片下界的默认值为 <code>0</code>，上界则是该切片的长度</p><pre><code class="go">var a [10]int// 以下切片是等价的a[0:10]a[:10]a[0:]a[:]</code></pre></li></ul><h4 id="切片的长度与容量"><a href="#切片的长度与容量" class="headerlink" title="切片的长度与容量"></a>切片的长度与容量</h4><ul><li><p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p></li><li><p>切片的长度就是它所包含的元素个数。</p></li><li><p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p></li><li><p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取</p><pre><code class="go">func main() &#123;    s := []int&#123;2, 3, 5, 7, 11, 13&#125;    printSlice(s)    // 截取切片使其长度为 0    s = s[:0]    printSlice(s)    // 拓展其长度    s = s[:4]    printSlice(s)    // 舍弃前两个值    s = s[2:]    printSlice(s)&#125;func printSlice(s []int) &#123;    fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)&#125;</code></pre></li></ul><h4 id="nil-切片"><a href="#nil-切片" class="headerlink" title="nil 切片"></a>nil 切片</h4><ul><li><p>切片的零值是 <code>nil</code>。</p></li><li><p>nil 切片的长度和容量为 0 且没有底层数组</p><pre><code class="go">var s []int    // s == nilfmt.Println(s, len(s), cap(s))  // [] 0 0</code></pre></li></ul><h4 id="用-make-创建切片"><a href="#用-make-创建切片" class="headerlink" title="用 make 创建切片"></a>用 make 创建切片</h4><ul><li><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p></li><li><p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p><pre><code class="go">a := make([]int, 5)  // len(a)=5</code></pre></li><li><p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p><pre><code class="go">b := make([]int, 0, 5)  // len(b)=0, cap(b)=5b = b[:cap(b)]  // len(b)=5, cap(b)=5b = b[1:]      // len(b)=4, cap(b)=4</code></pre></li></ul><h4 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a>切片的切片</h4><ul><li><p>切片可包含任何类型，甚至包括其它的切片</p><pre><code class="go">func main() &#123;    // 创建一个井字板（经典游戏）    board := [][]string&#123;        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,        []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,    &#125;    // 两个玩家轮流打上 X 和 O    board[0][0] = &quot;X&quot;    board[2][2] = &quot;O&quot;    board[1][2] = &quot;X&quot;    board[1][0] = &quot;O&quot;    board[0][2] = &quot;X&quot;    for i := 0; i &lt; len(board); i++ &#123;        fmt.Printf(&quot;%s\n&quot;, strings.Join(board[i], &quot; &quot;))    &#125;&#125;</code></pre></li></ul><h4 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h4><ul><li><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数</p><pre><code class="go">func append(s []T, vs ...T) []T</code></pre></li><li><p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾</p></li><li><p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片</p></li><li><p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组</p></li></ul><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><ul><li><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p></li><li><p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本</p><pre><code class="go">var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;func main() &#123;    for i, v := range pow &#123;        fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)    &#125;&#125;</code></pre></li><li><p>可以将下标或值赋予 <code>_</code> 来忽略它</p><pre><code class="go">for i, _ := range powfor _, value := range pow</code></pre></li><li><p>若你只需要索引，忽略第二个变量即可。</p><pre><code class="go">for i := range pow</code></pre></li></ul><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><ul><li><p>映射将键映射到值</p></li><li><p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键</p></li><li><p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用</p><pre><code class="go">var m map[key_type]value_typem = make(map[key_type]value_type)</code></pre></li><li><p>短声明写法</p><pre><code class="go">m := make(map[string]int)  // m := make(map[key_type]value_type)</code></pre></li><li><p>映射的文法与结构体相似，不过必须有键名</p><pre><code class="go">type Vertex struct &#123;    Lat, Long float64&#125;var m = map[string]Vertex&#123;    &quot;Bell Labs&quot;: Vertex&#123;        40.68433, -74.39967,    &#125;,    &quot;Google&quot;: Vertex&#123;        37.42202, -122.08408,    &#125;,&#125;</code></pre></li><li><p>若顶级类型只是一个类型名，你可以在文法的元素中省略它</p><pre><code class="go">var m = map[string]Vertex&#123;    &quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;,    &quot;Google&quot;:    &#123;37.42202, -122.08408&#125;,&#125;</code></pre></li></ul><h4 id="修改映射"><a href="#修改映射" class="headerlink" title="修改映射"></a>修改映射</h4><ul><li><p>在映射 <code>m</code> 中插入或修改元素：</p><pre><code class="go">m[key] = elem</code></pre></li><li><p>获取元素：</p><pre><code class="go">elem = m[key]</code></pre></li><li><p>删除元素：</p><pre><code class="go">delete(m, key)</code></pre></li><li><p>通过双赋值检测某个键是否存在：</p><pre><code class="go">elem, ok = m[key]</code></pre></li><li><p>若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明</p><pre><code class="go">elem, ok := m[key]</code></pre></li><li><p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code></p></li><li><p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值</p><pre><code class="go">v, ok := m[&quot;Answer&quot;]fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)  // The value: 0 Present? false</code></pre></li><li><p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值</p></li></ul><h4 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h4><ul><li><p>函数也是值。它们可以像其它值一样传递。</p></li><li><p>函数值可以用作函数的参数或返回值</p><pre><code class="go">hypot := func(x, y float64) float64 &#123;    return math.Sqrt(x*x + y*y)&#125;</code></pre></li></ul><h4 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h4><ul><li><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p></li><li><p>例如，函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code> 变量上</p><pre><code class="go">func adder() func(int) int &#123;    sum := 0    return func(x int) int &#123;        sum += x        return sum    &#125;&#125;func main() &#123;    pos, neg := adder(), adder()    for i := 0; i &lt; 10; i++ &#123;        fmt.Println(            pos(i),            neg(-2*i),        )    &#125;&#125;</code></pre></li></ul><h3 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>Go 没有类。不过你可以为结构体类型定义方法。</p></li><li><p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p></li><li><p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p></li><li><p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者</p><pre><code class="go">type Vertex struct &#123;    X, Y float64&#125;func (v Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    fmt.Println(v.Abs())&#125;</code></pre></li><li><p>记住：方法只是个带接收者参数的函数。</p></li><li><p>现在这个 <code>Abs</code> 的写法就是个正常的函数，功能并没有什么变化</p><pre><code class="go">func Abs(v Vertex) float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    fmt.Println(Abs(v))&#125;</code></pre></li><li><p>也可以为非结构体类型声明方法。</p></li><li><p>在此例中，我们看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code></p><pre><code class="go">func (f MyFloat) Abs() float64 &#123;    if f &lt; 0 &#123;        return float64(-f)    &#125;    return float64(f)&#125;func main() &#123;    f := MyFloat(-math.Sqrt2)    fmt.Println(f.Abs())&#125;</code></pre></li><li><p>只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法（就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p></li></ul><h4 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h4><ul><li><p>可以为指针接收者声明方法。</p></li><li><p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p></li><li><p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法</p><pre><code class="go">type Vertex struct &#123;    X, Y float64&#125;func (v Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale(f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    v.Scale(10)    fmt.Println(v.Abs())&#125;</code></pre></li><li><p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p></li><li><p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作。（对于函数的其它参数也是如此。）<code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p></li></ul><h4 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h4><ul><li><p>注意：带指针参数的函数必须接受一个指针</p><pre><code class="go">func ScaleFunc(v *Vertex, f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    ScaleFunc(v, 5)  // 编译错误！    ScaleFunc(&amp;v, 5) // OK&#125;</code></pre></li><li><p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针</p><pre><code class="go">func (v *Vertex) Scale(f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    v.Scale(5)  // OK    p := &amp;v    p.Scale(10) // OK    &#125;</code></pre></li><li><p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code></p></li><li><p>同样的事情也发生在相反的方向。</p></li><li><p>接受一个值作为参数的函数必须接受一个指定类型的值</p><pre><code class="go">func AbsFunc(v Vertex) float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    fmt.Println(AbsFunc(v))  // OK    fmt.Println(AbsFunc(&amp;v)) // 编译错误！&#125;</code></pre></li><li><p>而以值为接收者的方法被调用时，接收者既能为值又能为指针</p><pre><code class="go">func (v Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := Vertex&#123;3, 4&#125;    var v Vertex    fmt.Println(v.Abs()) // OK    p := &amp;v    fmt.Println(p.Abs()) // OK&#125;</code></pre></li><li><p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code></p></li></ul><h4 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h4><ul><li><p>使用指针接收者的原因有二：</p><ol><li>首先，方法能够修改其接收者指向的值。</li><li>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</li></ol></li><li><p>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 <code>Abs</code> 并不需要修改其接收者。</p><pre><code class="go">func (v *Vertex) Scale(f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;func (v *Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;    v := &amp;Vertex&#123;3, 4&#125;    fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs())    v.Scale(5)    fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())&#125;</code></pre></li><li><p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用</p></li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p></li><li><p>接口类型的变量可以保存任何实现了这些方法的值</p><pre><code class="go">type Abser interface &#123;    Abs() float64&#125;func main() &#123;    var a Abser    f := MyFloat(-math.Sqrt2)    v := Vertex&#123;3, 4&#125;    a = f  // a MyFloat 实现了 Abser    a = &amp;v // a *Vertex 实现了 Abser    fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123;    if f &lt; 0 &#123;        return float64(-f)    &#125;    return float64(f)&#125;type Vertex struct &#123;    X, Y float64&#125;func (v *Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;</code></pre></li></ul><h4 id="接口与隐式实现"><a href="#接口与隐式实现" class="headerlink" title="接口与隐式实现"></a>接口与隐式实现</h4><ul><li><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p></li><li><p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p></li><li><p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p><pre><code class="go">type I interface &#123;    M()&#125;type T struct &#123;    S string&#125;// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。func (t T) M() &#123;    fmt.Println(t.S)&#125;func main() &#123;    var i I = T&#123;&quot;hello&quot;&#125;    i.M()&#125;</code></pre></li></ul><h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><ul><li><p>接口也是值。它们可以像其它值一样传递。</p></li><li><p>接口值可以用作函数的参数或返回值。</p></li><li><p>在内部，接口值可以看做包含值和具体类型的元组：<code>(value, type)</code></p></li><li><p>接口值保存了一个具体底层类型的具体值。</p></li><li><p>接口值调用方法时会执行其底层类型的同名方法。</p><pre><code class="go">type I interface &#123;    M()&#125;type T struct &#123;    S string&#125;func (t *T) M() &#123;    fmt.Println(t.S)&#125;type F float64func (f F) M() &#123;    fmt.Println(f)&#125;func main() &#123;    var i I    i = &amp;T&#123;&quot;Hello&quot;&#125;    describe(i)    i.M()    i = F(math.Pi)    describe(i)    i.M()&#125;func describe(i I) &#123;    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)&#125;</code></pre></li></ul><h4 id="底层值为-nil-的接口值"><a href="#底层值为-nil-的接口值" class="headerlink" title="底层值为 nil 的接口值"></a>底层值为 nil 的接口值</h4><ul><li>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</li><li>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code> 方法）。</li><li><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</li><li>nil 接口值既不保存值也不保存具体类型。</li><li>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</li></ul><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><ul><li><p>指定了零个方法的接口值被称为 <em>空接口：</em></p><pre><code>interface&#123;&#125;</code></pre></li><li><p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p></li><li><p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。</p><pre><code class="go">func main() &#123;    var i interface&#123;&#125;    describe(i)    i = 42    describe(i)    i = &quot;hello&quot;    describe(i)&#125;func describe(i interface&#123;&#125;) &#123;    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)&#125;</code></pre></li></ul><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><ul><li><p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。</p><pre><code class="go">t := i.(T)</code></pre></li><li><p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p></li><li><p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个恐慌。</p></li><li><p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p><pre><code class="go">t, ok := i.(T)</code></pre></li><li><p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p></li><li><p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p></li><li><p>请注意这种语法和读取一个映射时的相同之处</p><pre><code class="go">func main() &#123;    var i interface&#123;&#125; = &quot;hello&quot;    s := i.(string)    fmt.Println(s)    s, ok := i.(string)    fmt.Println(s, ok)    f, ok := i.(float64)    fmt.Println(f, ok)    f = i.(float64) // 报错(panic)    fmt.Println(f)&#125;</code></pre></li></ul><h4 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h4><ul><li><p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。</p></li><li><p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p><pre><code>switch v := i.(type) &#123;case T:    // v 的类型为 Tcase S:    // v 的类型为 Sdefault:    // 没有匹配，v 与 i 的类型相同&#125;</code></pre></li><li><p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</p></li><li><p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p><pre><code class="go">func do(i interface&#123;&#125;) &#123;    switch v := i.(type) &#123;    case int:        fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2)    case string:        fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v))    default:        fmt.Printf(&quot;I don&#39;t know about type %T!\n&quot;, v)    &#125;&#125;func main() &#123;    do(21)    do(&quot;hello&quot;)    do(true)&#125;</code></pre></li></ul><h4 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h4><ul><li><p><a href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p><pre><code class="go">type Stringer interface &#123;    String() string&#125;</code></pre></li><li><p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p><pre><code class="go">type Person struct &#123;    Name string    Age  int&#125;func (p Person) String() string &#123;    return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)&#125;func main() &#123;    a := Person&#123;&quot;Arthur Dent&quot;, 42&#125;    z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125;    fmt.Println(a, z)&#125;</code></pre></li></ul><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><ul><li><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p></li><li><p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p><pre><code class="go">type error interface &#123;    Error() string&#125;</code></pre></li><li><p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p></li><li><p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p><pre><code class="go">i, err := strconv.Atoi(&quot;42&quot;)if err != nil &#123;    fmt.Printf(&quot;couldn&#39;t convert number: %v\n&quot;, err)    return&#125;fmt.Println(&quot;Converted integer:&quot;, i)</code></pre></li><li><p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败</p><pre><code class="go">type MyError struct &#123;    When time.Time    What string&#125;func (e *MyError) Error() string &#123;    return fmt.Sprintf(&quot;at %v, %s&quot;,        e.When, e.What)&#125;func run() error &#123;    return &amp;MyError&#123;        time.Now(),        &quot;it didn&#39;t work&quot;,    &#125;&#125;func main() &#123;    if err := run(); err != nil &#123;        fmt.Println(err)    &#125;&#125;</code></pre></li></ul><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><ul><li><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p></li><li><p>Go 标准库包含了该接口的<a href="https://go-zh.org/search?q=Read#Global">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p></li><li><p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p><pre><code class="go">func (T) Read(b []byte) (n int, err error)</code></pre></li><li><p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p></li><li><p>示例代码创建了一个 <a href="https://go-zh.org/pkg/strings/#Reader"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出</p><pre><code class="go">func main() &#123;    r := strings.NewReader(&quot;Hello, Reader!&quot;)    b := make([]byte, 8)    for &#123;        n, err := r.Read(b)        fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)        fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])        if err == io.EOF &#123;            break        &#125;    &#125;&#125;</code></pre></li></ul><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul><li><p><a href="https://go-zh.org/pkg/image/#Image"><code>image</code></a> 包定义了 <code>Image</code> 接口：</p><pre><code class="go">package imagetype Image interface &#123;    ColorModel() color.Model    Bounds() Rectangle    At(x, y int) color.Color&#125;</code></pre></li><li><p><strong>注意:</strong> <code>Bounds</code> 方法的返回值 <code>Rectangle</code> 实际上是一个 <a href="https://go-zh.org/pkg/image/#Rectangle"><code>image.Rectangle</code></a>，它在 <code>image</code> 包中声明。</p></li><li><p>参阅<a href="https://go-zh.org/pkg/image/#Image">文档</a>了解全部信息</p></li><li><p><code>color.Color</code> 和 <code>color.Model</code> 类型也是接口，但是通常因为直接使用预定义的实现 <code>image.RGBA</code> 和 <code>image.RGBAModel</code> 而被忽视了。这些接口和类型由 <a href="https://go-zh.org/pkg/image/color/"><code>image/color</code></a> 包定义</p><pre><code class="go">func main() &#123;    m := image.NewRGBA(image.Rect(0, 0, 100, 100))    fmt.Println(m.Bounds())    fmt.Println(m.At(0, 0).RGBA())&#125;</code></pre></li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="Go-程"><a href="#Go-程" class="headerlink" title="Go 程"></a>Go 程</h4><ul><li><p>Go 程（goroutine）是由 Go 运行时管理的轻量级线程。</p><pre><code>go f(x, y, z)</code></pre></li><li><p>会启动一个新的 Go 程并执行</p><pre><code>f(x, y, z)</code></pre></li><li><p><code>f</code>, <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go 程中，而 <code>f</code> 的执行发生在新的 Go 程中。</p></li><li><p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。<a href="https://go-zh.org/pkg/sync/"><code>sync</code></a> 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法</p></li></ul><h4 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h4><ul><li><p>信道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p><pre><code class="go">ch &lt;- v    // 将 v 发送至信道 ch。v := &lt;-ch  // 从 ch 接收值并赋予 v。</code></pre></li><li><p>（“箭头”就是数据流的方向。）</p></li><li><p>和映射与切片一样，信道在使用前必须创建：</p><pre><code class="go">ch := make(chan int)</code></pre></li><li><p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p></li><li><p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果</p><pre><code class="go">func sum(s []int, c chan int) &#123;    sum := 0    for _, v := range s &#123;        sum += v    &#125;    c &lt;- sum // 将和送入 c&#125;func main() &#123;    s := []int&#123;7, 2, 8, -9, 4, 0&#125;    c := make(chan int)    go sum(s[:len(s)/2], c)    go sum(s[len(s)/2:], c)    x, y := &lt;-c, &lt;-c // 从 c 中接收    fmt.Println(x, y, x+y)&#125;</code></pre></li></ul><h4 id="带缓冲的信道"><a href="#带缓冲的信道" class="headerlink" title="带缓冲的信道"></a>带缓冲的信道</h4><ul><li><p>信道可以是 <em>带缓冲的</em>。将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道：</p><pre><code class="go">ch := make(chan int, 100)</code></pre></li><li><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><pre><code class="go">func main() &#123;    ch := make(chan int, 2)    ch &lt;- 1    ch &lt;- 2    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)&#125;</code></pre></li></ul><h4 id="range-和-close"><a href="#range-和-close" class="headerlink" title="range 和 close"></a>range 和 close</h4><ul><li><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p><pre><code>v, ok := &lt;-ch</code></pre></li><li><p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p></li><li><p>循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p></li><li><p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p></li><li><p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p><pre><code class="go">func fibonacci(n int, c chan int) &#123;    x, y := 0, 1    for i := 0; i &lt; n; i++ &#123;        c &lt;- x        x, y = y, x+y    &#125;    close(c)&#125;func main() &#123;    c := make(chan int, 10)    go fibonacci(cap(c), c)    for i := range c &#123;        fmt.Println(i)    &#125;&#125;</code></pre></li></ul><h4 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h4><ul><li><p><code>select</code> 语句使一个 Go 程可以等待多个通信操作。</p></li><li><p><code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行</p><pre><code class="go">func fibonacci(c, quit chan int) &#123;    x, y := 0, 1    for &#123;        select &#123;        case c &lt;- x:            x, y = y, x+y        case &lt;-quit:            fmt.Println(&quot;quit&quot;)            return        &#125;    &#125;&#125;func main() &#123;    c := make(chan int)    quit := make(chan int)    go func() &#123;        for i := 0; i &lt; 10; i++ &#123;            fmt.Println(&lt;-c)        &#125;        quit &lt;- 0    &#125;()    fibonacci(c, quit)&#125;</code></pre></li></ul><h4 id="默认选择"><a href="#默认选择" class="headerlink" title="默认选择"></a>默认选择</h4><ul><li><p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。</p></li><li><p>为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p><pre><code class="go">select &#123;case i := &lt;-c:    // 使用 idefault:    // 从 c 中接收会阻塞时执行&#125;</code></pre></li></ul><h4 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h4><ul><li><p>我们已经看到信道非常适合在各个 Go 程间进行通信。</p></li><li><p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p></li><li><p>这里涉及的概念叫做 互斥（<code>mutual*exclusion</code>），我们通常使用 互斥锁（Mutex）这一数据结构来提供这种机制。</p></li><li><p>Go 标准库中提供了 <a href="https://go-zh.org/pkg/sync/#Mutex"><code>sync.Mutex</code></a> 互斥锁类型及其两个方法：</p><ul><li><code>Lock</code></li><li><code>Unlock</code></li></ul></li><li><p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。参见 <code>Inc</code> 方法。</p></li><li><p>我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见 <code>Value</code> 方法</p></li></ul><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><ul><li>Go <a href="https://go-zh.org/doc/">文档</a></li><li><a href="https://go-zh.org/doc/code.html">如何使用Go编程</a></li><li><a href="https://go-zh.org/pkg/">包手册</a></li><li><a href="https://go-zh.org/ref/spec">语言规范</a></li><li>进一步探索 Go 的并发模型，参阅 <a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go 并发模型</a>(<a href="https://talks.go-zh.org/2012/concurrency.slide">幻灯片</a>)以及<a href="https://www.youtube.com/watch?v=QDDwwePbDtw">深入 Go 并发模型</a>(<a href="https://talks.go-zh.org/2013/advconc.slide">幻灯片</a>)并阅读<a href="https://go-zh.org/doc/codewalk/sharemem/">通过通信共享内存</a>的代码之旅</li><li><a href="https://vimeo.com/53221558">一个简单的编程环境</a>(<a href="https://talks.go-zh.org/2012/simple.slide">幻灯片</a>)</li><li><a href="https://go-zh.org/doc/articles/wiki/">编写 Web 应用</a>的指南</li><li><a href="https://go-zh.org/doc/codewalk/functions/">函数：Go 中的一等公民</a>展示了有趣的函数类型</li><li><a href="https://blog.go-zh.org/">Go 博客</a>有着众多关于 Go 的文章和信息</li><li><a href="https://www.mikespook.com/tag/golang/">mikespook 的博客</a>中有大量中文的关于 Go 的文章和翻译</li><li>开源电子书 <a href="https://github.com/astaxie/build-web-application-with-golang">Go Web 编程</a>和 <a href="https://github.com/Unknwon/the-way-to-go_ZH_CN">Go 入门指南</a>能够帮助你更加深入的了解和学习 Go 语言</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Go 语言是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言，它用批判吸收的眼光，融合 C 语言、Java 等众家之长，将简洁、高效演绎得淋漓尽致。Golang非常适合用来做网络并发方面的服务，比如消息推送、监控、容器等。初次学习我选择的是 &lt;a href=&quot;https://go-zh.org/&quot;&gt;Go 编程语言&lt;/a&gt;指南，指南涵盖了该语言的大部分重要特性，放在以下为所记笔记，另附有随堂代码放在 &lt;a href=&quot;https://github.com/Bezhuang/Learn-CS/tree/main/Learn%20Programming/Go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85&quot;&gt;Github 仓库&lt;/a&gt;中，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端" scheme="http://blog.zhuangzhihao.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 实现银行 ATM 系统</title>
    <link href="http://blog.zhuangzhihao.top/ATM%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.zhuangzhihao.top/ATM%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-02-04T16:00:00.000Z</published>
    <updated>2022-05-05T12:16:45.366Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在复习完 Java SE 的全部基础知识点后，为了更加熟练掌握 Java 面向对象的特性，进一步掌握编程技巧和调试技巧，使用 Java 模拟实现一个银行 ATM 系统软件，共 Account.java 和 ATM.java 两个 Java 类。</p></blockquote><a id="more"></a><h3 id="一、银行-ATM-系统技术选型分析"><a href="#一、银行-ATM-系统技术选型分析" class="headerlink" title="一、银行 ATM 系统技术选型分析"></a>一、银行 ATM 系统技术选型分析</h3><p>面向对象编程：每个用户对象要对应一个账户对象，所以需要设计账户类 <code>Account</code>。</p><p>使用集合容器：系统需要提供一个容器用于存储这些账户对象的信息，选用 <code>ArrayList</code> 集合。</p><p>程序流程控制：需要结合分支、循环、跳转等相关操作控制程序的业务逻辑。</p><p>使用常见API：内容比较，分析，数据处理等需要用到 <code>String</code> 等常用 API。</p><h3 id="二、Account-账户类设计"><a href="#二、Account-账户类设计" class="headerlink" title="二、Account 账户类设计"></a>二、Account 账户类设计</h3><p>每个用户一个账户对象，需要设计账户类 <code>Account</code>，账户类至少包含（卡号、用户名、余额、取现额度、密码）。</p><pre><code class="java">public class Account &#123;    private String cardId; // 卡号    private String userName; // 用户名称    private String passWord; // 密码    private double money; // 账户余额    private double quotaMoney; // 每次取现额度限度。    public String getCardId() &#123;        return cardId;    &#125;    public void setCardId(String cardId) &#123;        this.cardId = cardId;    &#125;    public String getUserName() &#123;        return userName;    &#125;    public void setUserName(String userName) &#123;        this.userName = userName;    &#125;    public String getPassWord() &#123;        return passWord;    &#125;    public void setPassWord(String passWord) &#123;        this.passWord = passWord;    &#125;    public double getMoney() &#123;        return money;    &#125;    public void setMoney(double money) &#123;        this.money = money;    &#125;    public double getQuotaMoney() &#123;        return quotaMoney;    &#125;    public void setQuotaMoney(double quotaMoney) &#123;        this.quotaMoney = quotaMoney;    &#125;&#125;</code></pre><h4 id="三、首页设计"><a href="#三、首页设计" class="headerlink" title="三、首页设计"></a>三、首页设计</h4><p>需要定义一个 <code>ArrayList</code> 的集合用于存储账户对象。</p><pre><code class="java">ArrayList accounts = new ArrayList&lt;&gt;();</code></pre><p>需要展示欢迎页包含2个功能：注册开户、登录账户。</p><pre><code class="java">public static void main(String[] args) &#123;        // 2、创建一个集合对象，用于后期存入账户对象。        ArrayList&lt;Account&gt; accounts = new ArrayList&lt;&gt;();        // 3、展示系统欢迎页面        System.out.println(&quot;======欢迎您进入到黑马ATM系统===============&quot;);        while (true) &#123;            System.out.println(&quot;1、登录账户&quot;);            System.out.println(&quot;2、注册账户&quot;);            System.out.println(&quot;请您选择操作：&quot;);            Scanner sc = new Scanner(System.in);            int command = sc.nextInt();            switch (command)&#123;                case 1:                    // 登录操作                    login(accounts, sc);                    break;                case 2:                    // 注册账户                    register(accounts, sc);                    break;                default:                    System.out.println(&quot;当前输入的操作不存在！&quot;);            &#125;        &#125;    &#125;</code></pre><h3 id="四、用户开户功能实现"><a href="#四、用户开户功能实现" class="headerlink" title="四、用户开户功能实现"></a>四、用户开户功能实现</h3><p>开户功能应该独立定义成方法，并传入当前集合对象给该方法。</p><pre><code class="java">public static void register(ArrayList&lt;Account&gt; accounts) &#123;…&#125;</code></pre><p>需要提示用户输入个人信息，开户的卡号是系统自动生成的8位数。</p><pre><code class="java">public static String createCardId()&#123;…&#125;</code></pre><p>注意自动生成的卡号不能与其他用户的卡号重复。</p><p>最终把用户开户的信息封装成 <code>Account</code> 对象，存入到集合中。</p><pre><code class="java">    /**       用户开户功能     */        private static void register(ArrayList&lt;Account&gt; accounts, Scanner sc) &#123;        System.out.println(&quot;==================欢迎您进入到开户操作======================&quot;);        // 2、创建一个账户对象封装账户信息        Account acc = new Account();        // 1、录入用户账户信息        System.out.println(&quot;请您输入账户名称：&quot;);        String userName =sc.next();        acc.setUserName(userName);        while (true) &#123;            System.out.println(&quot;请您输入账户密码：&quot;);            String passWord =sc.next();            System.out.println(&quot;请您输入确认密码：&quot;);            String okPassWord =sc.next();            if(okPassWord.equals(passWord))&#123;                // 密码无问题                acc.setPassWord(okPassWord);                break;            &#125;else &#123;                System.out.println(&quot;两次输入的密码不一致！&quot;);            &#125;        &#125;        System.out.println(&quot;请您设置当次取现额度：&quot;);        double quataMoney = sc.nextDouble();        acc.setQuotaMoney(quataMoney);        // 关键点：为当前账户生成一个随机的8位数字作为卡号，卡号不能与其他用户的卡号重复。        String cardId = createCardId(accounts);        acc.setCardId(cardId);        // 3、把账户对象存入到集合容器对象中去        accounts.add(acc);        System.out.println(&quot;恭喜您,&quot;+acc.getUserName()+&quot;先生/女士，您开户完成，您的卡号是：&quot; + acc.getCardId());    &#125;    public static String createCardId(ArrayList&lt;Account&gt; accounts)&#123;        while (true) &#123;            String cardId = &quot;&quot;;            // 随机8个数字            Random r = new Random();            for (int i = 1; i &lt;= 8 ; i++) &#123;                cardId += r.nextInt(10);            &#125;            // 判断这个卡号是否重复：根据卡号去查询账户对象            Account account = getAccountByCardId(cardId , accounts);            if(account == null)&#123;                return cardId;            &#125;        &#125;    &#125;    public static Account getAccountByCardId(String cardId , ArrayList&lt;Account&gt; accounts)&#123;        for (int i = 0; i &lt; accounts.size(); i++) &#123;            Account acc = accounts.get(i);            if(acc.getCardId().equals(cardId))&#123;                return acc;            &#125;        &#125;        return null;    &#125;&#125;</code></pre><h3 id="五、用户登录功能和界面实现"><a href="#五、用户登录功能和界面实现" class="headerlink" title="五、用户登录功能和界面实现"></a>五、用户登录功能和界面实现</h3><p>定义方法：</p><pre><code class="java">public static void login(ArrayList&lt;Account&gt; accounts) &#123;…&#125;</code></pre><p>需要根据卡号去集合中查询对应的账户对象。如果找到了账户对象，说明卡号存在，继续输入密码。如果密码也正确，则登录成功。</p><p>用户登录成功后，需要进入用户操作页。查询就是直接展示当前登录成功的账户对象的信息。退出账户是需要回到首页的。</p><pre><code class="java">    /**       用户登录功能     */    private static void login(ArrayList&lt;Account&gt; accounts, Scanner sc) &#123;        System.out.println(&quot;==================欢迎您进入到登录操作======================&quot;);        if(accounts.size() &gt; 0)&#123;            while (true) &#123;                System.out.println(&quot;请您输入登录的卡号：&quot;);                String cardId = sc.next();                // 2、根据卡号去集合中查询是否存在账户对象                Account acc = getAccountByCardId(cardId , accounts);                // 判断账户对象是否存在，存在说明卡号正确                if(acc != null)&#123;                    while (true) &#123;                        // 3、判断密码是否正确                        System.out.println(&quot;请您输入登录的密码：&quot;);                        String passWord = sc.next();                        if(acc.getPassWord().equals(passWord))&#123;                            // 登录成功了！                            System.out.println(&quot;欢迎你：&quot; + acc.getUserName() + &quot;先生/女士进入系统，您可开始办理你的业务了!&quot;);                            // 展示登录成功后的操作界面。                            showCommand(sc, acc, accounts);                            return;                        &#125;else &#123;                            System.out.println(&quot;您的密码不正确！&quot;);                        &#125;                    &#125;                &#125;else &#123;                    System.out.println(&quot;卡号不存在，请确认！&quot;);                &#125;            &#125;        &#125;else &#123;            System.out.println(&quot;当前系统无任何账户，请先注册再登录！&quot;);        &#125;    &#125;    /**      登录后展示的界面     */    private static void showCommand(Scanner sc, Account acc, ArrayList&lt;Account&gt; accounts) &#123;        while (true) &#123;            System.out.println(&quot;==================欢迎您进入到操作界面======================&quot;);            System.out.println(&quot;1、查询&quot;);            System.out.println(&quot;2、存款&quot;);            System.out.println(&quot;3、取款&quot;);            System.out.println(&quot;4、转账&quot;);            System.out.println(&quot;5、修改密码&quot;);            System.out.println(&quot;6、退出&quot;);            System.out.println(&quot;7、注销账户&quot;);            System.out.println(&quot;请您输入操作命令：&quot;);            int command = sc.nextInt();            switch (command) &#123;                case 1:                    // 查询账户信息展示                    showAccount(acc);                    break;                case 2:                    // 存款                    depositMoney(acc,sc);                    break;                case 3:                    // 取款                    drawMoney(acc,sc);                    break;                case 4:                    // 转账                    transferMoney(acc, accounts, sc);                    break;                case 5:                    // 修改密码                    updatePassWord(acc, sc);                    return; // 跳出当前操作的方法，最终回到首页                case 6:                    // 退出 回到首页                    System.out.println(&quot;欢迎下次继续光临！！&quot;);                    return; // 结束登录后的全部操作                case 7:                    // 注销账户                    accounts.remove(acc); // 从集合对象中删除当前账户对象。                    System.out.println(&quot;您的账户已经完成了销毁，您将不可以进行登录了！&quot;);                    return;                default:                    System.out.println(&quot;您的操作命令有误！&quot;);            &#125;        &#125;    &#125;</code></pre><h3 id="六、用户转账、存款、取款功能"><a href="#六、用户转账、存款、取款功能" class="headerlink" title="六、用户转账、存款、取款功能"></a>六、用户转账、存款、取款功能</h3><p>转账功能要分析对方账户是否存在的问题。还要分析自己的余额是否足够的问题。</p><p>存款和取款都是拿到当前用户的账户对象，通过调用账户对象的 <code>set</code> 方法修改其余额。</p><pre><code class="java">    /**     * 从当前账户对象中把金额转给其他账户对象。     * @param acc     * @param accounts     * @param sc     */    private static void transferMoney(Account acc, ArrayList&lt;Account&gt; accounts, Scanner sc) &#123;        // 1、判断自己的账户中是否有钱        if(acc.getMoney() &lt;= 0)&#123;            System.out.println(&quot;您自己都没钱，就别转了吧！&quot;);            return;        &#125;        // 2、判断总账户数量是否大于等于2个。        if(accounts.size() &gt;= 2)&#123;            while (true) &#123;                // 3、让当前用户输入对方的账号进行转账                System.out.println(&quot;请您输入对方卡号：&quot;);                String cardId = sc.next();                // 4、根据卡号查询出集合中的账户对象                Account otherAcc = getAccountByCardId(cardId , accounts);                // 5、判断账户对象是否存在，而且这个账户对象不能是自己。                if(otherAcc != null)&#123;                    // 6、判断当前账户是否是自己。                    if(acc.getCardId().equals(otherAcc.getCardId()))&#123;                        System.out.println(&quot;不能给自己账户转账！&quot;);                    &#125;else &#123;                        // 7、正式进入到转账逻辑了                        // 黑马刘德华                        String rs = &quot;*&quot; + otherAcc.getUserName().substring(1);                        System.out.println(&quot;请您确认[&quot;+rs +&quot;]的姓氏来确认！&quot;);                        System.out.println(&quot;请您输入对方的姓氏：&quot;);                        String preName = sc.next();                        if(otherAcc.getUserName().startsWith(preName))&#123;                            // 认证通过                            while (true) &#123;                                System.out.println(&quot;请您输入转账的金额（您最多可以转账：&quot; + acc.getMoney() +&quot;元）：&quot;);                                double money = sc.nextDouble();                                if(money &gt; acc.getMoney())&#123;                                    System.out.println(&quot;你不听话，没有这么多钱可以转！&quot;);                                &#125;else &#123;                                    // 开始转                                    acc.setMoney(acc.getMoney() - money); // 更新自己账户                                    otherAcc.setMoney(otherAcc.getMoney() + money);                                    System.out.println(&quot;您已经完成转账！您当前还剩余：&quot; + acc.getMoney());                                    return;                                &#125;                            &#125;                        &#125;else &#123;                            System.out.println(&quot;您输入对方的信息有误！&quot;);                        &#125;                    &#125;                &#125;else &#123;                    System.out.println(&quot;您输入的转账卡号不存在！&quot;);                &#125;            &#125;        &#125;else &#123;            System.out.println(&quot;当前系统中没有其他账户可以转账，去注册一个账户吧！&quot;);        &#125;    &#125;    private static void drawMoney(Account acc, Scanner sc) &#123;        System.out.println(&quot;==================欢迎进入账户取款操作======================&quot;);        // 1、判断账户的余额是否高于等于100        double money = acc.getMoney();        if(money &gt;= 100) &#123;            while (true) &#123;                // 2、输入取钱的金额                System.out.println(&quot;请您输入取钱的金额：&quot;);                double drawMoney = sc.nextDouble();                // 3、判断取钱金额是否超过了当次限额                if(drawMoney &gt; acc.getQuotaMoney())&#123;                    System.out.println(&quot;您当前取款金额超过了每次限额！&quot;);                &#125;else &#123;                    // 4、判断当前取钱金额是超过了账户的余额                    if(drawMoney &gt; money)&#123;                        System.out.println(&quot;当前余额不足！当前余额是：&quot; + money);                    &#125;else &#123;                        // 更新账户余额                        acc.setMoney(money - drawMoney);                        System.out.println(&quot;您当前取钱完成，请拿走你的钱，当前剩余余额是：&quot; + acc.getMoney());                        break;                    &#125;                &#125;            &#125;        &#125;else &#123;            System.out.println(&quot;您当前账户余额不足100元，存钱去吧！&quot;);        &#125;    &#125;    private static void depositMoney(Account acc, Scanner sc) &#123;        System.out.println(&quot;==================欢迎进入账户存款操作======================&quot;);        System.out.println(&quot;请您输入存款金额：&quot;);        double money = sc.nextDouble();        acc.setMoney(acc.getMoney() + money);        showAccount(acc);    &#125;    private static void showAccount(Account acc) &#123;        System.out.println(&quot;==================您当前账户详情信息如下======================&quot;);        System.out.println(&quot;卡号：&quot; + acc.getCardId());        System.out.println(&quot;户主：&quot; + acc.getUserName());        System.out.println(&quot;余额：&quot; + acc.getMoney());        System.out.println(&quot;当次取现额度：&quot; + acc.getQuotaMoney());    &#125;    /**     * 从当前账户对象中把金额转给其他账户对象。     * @param acc     * @param accounts     * @param sc     */    private static void transferMoney(Account acc, ArrayList&lt;Account&gt; accounts, Scanner sc) &#123;        // 1、判断自己的账户中是否有钱        if(acc.getMoney() &lt;= 0)&#123;            System.out.println(&quot;您自己都没钱，就别转了吧！&quot;);            return;        &#125;        // 2、判断总账户数量是否大于等于2个。        if(accounts.size() &gt;= 2)&#123;            while (true) &#123;                // 3、让当前用户输入对方的账号进行转账                System.out.println(&quot;请您输入对方卡号：&quot;);                String cardId = sc.next();                // 4、根据卡号查询出集合中的账户对象                Account otherAcc = getAccountByCardId(cardId , accounts);                // 5、判断账户对象是否存在，而且这个账户对象不能是自己。                if(otherAcc != null)&#123;                    // 6、判断当前账户是否是自己。                    if(acc.getCardId().equals(otherAcc.getCardId()))&#123;                        System.out.println(&quot;不能给自己账户转账！&quot;);                    &#125;else &#123;                        // 7、正式进入到转账逻辑了                        // 黑马刘德华                        String rs = &quot;*&quot; + otherAcc.getUserName().substring(1);                        System.out.println(&quot;请您确认[&quot;+rs +&quot;]的姓氏来确认！&quot;);                        System.out.println(&quot;请您输入对方的姓氏：&quot;);                        String preName = sc.next();                        if(otherAcc.getUserName().startsWith(preName))&#123;                            // 认证通过                            while (true) &#123;                                System.out.println(&quot;请您输入转账的金额（您最多可以转账：&quot; + acc.getMoney() +&quot;元）：&quot;);                                double money = sc.nextDouble();                                if(money &gt; acc.getMoney())&#123;                                    System.out.println(&quot;你不听话，没有这么多钱可以转！&quot;);                                &#125;else &#123;                                    // 开始转                                    acc.setMoney(acc.getMoney() - money); // 更新自己账户                                    otherAcc.setMoney(otherAcc.getMoney() + money);                                    System.out.println(&quot;您已经完成转账！您当前还剩余：&quot; + acc.getMoney());                                    return;                                &#125;                            &#125;                        &#125;else &#123;                            System.out.println(&quot;您输入对方的信息有误！&quot;);                        &#125;                    &#125;                &#125;else &#123;                    System.out.println(&quot;您输入的转账卡号不存在！&quot;);                &#125;            &#125;        &#125;else &#123;            System.out.println(&quot;当前系统中没有其他账户可以转账，去注册一个账户吧！&quot;);        &#125;    &#125;    private static void drawMoney(Account acc, Scanner sc) &#123;        System.out.println(&quot;==================欢迎进入账户取款操作======================&quot;);        // 1、判断账户的余额是否高于等于100        double money = acc.getMoney();        if(money &gt;= 100) &#123;            while (true) &#123;                // 2、输入取钱的金额                System.out.println(&quot;请您输入取钱的金额：&quot;);                double drawMoney = sc.nextDouble();                // 3、判断取钱金额是否超过了当次限额                if(drawMoney &gt; acc.getQuotaMoney())&#123;                    System.out.println(&quot;您当前取款金额超过了每次限额！&quot;);                &#125;else &#123;                    // 4、判断当前取钱金额是超过了账户的余额                    if(drawMoney &gt; money)&#123;                        System.out.println(&quot;当前余额不足！当前余额是：&quot; + money);                    &#125;else &#123;                        // 更新账户余额                        acc.setMoney(money - drawMoney);                        System.out.println(&quot;您当前取钱完成，请拿走你的钱，当前剩余余额是：&quot; + acc.getMoney());                        break;                    &#125;                &#125;            &#125;        &#125;else &#123;            System.out.println(&quot;您当前账户余额不足100元，存钱去吧！&quot;);        &#125;    &#125;    private static void depositMoney(Account acc, Scanner sc) &#123;        System.out.println(&quot;==================欢迎进入账户存款操作======================&quot;);        System.out.println(&quot;请您输入存款金额：&quot;);        double money = sc.nextDouble();        acc.setMoney(acc.getMoney() + money);        showAccount(acc);    &#125;    private static void showAccount(Account acc) &#123;        System.out.println(&quot;==================您当前账户详情信息如下======================&quot;);        System.out.println(&quot;卡号：&quot; + acc.getCardId());        System.out.println(&quot;户主：&quot; + acc.getUserName());        System.out.println(&quot;余额：&quot; + acc.getMoney());        System.out.println(&quot;当次取现额度：&quot; + acc.getQuotaMoney());    &#125;</code></pre><h3 id="七、用户密码修改功能、销户功能"><a href="#七、用户密码修改功能、销户功能" class="headerlink" title="七、用户密码修改功能、销户功能"></a>七、用户密码修改功能、销户功能</h3><p>修改密码就是把当前对象的密码属性使用 <code>set</code> 方法进行更新。销户是从集合对象中删除当前对象，并回到首页。</p><pre><code class="java">    /**      修改当前账户对象的密码     * @param acc     */    private static void updatePassWord(Account acc, Scanner sc) &#123;        // 1、判断旧密码是否正确        while (true) &#123;            System.out.println(&quot;请您输入当前密码认证：&quot;);            String passWord = sc.next();            if(acc.getPassWord().equals(passWord))&#123;                while (true) &#123;                    // 2、输入新密码                    System.out.println(&quot;请您输入新密码：&quot;);                    String newPassWord = sc.next();                    System.out.println(&quot;请您确认新密码：&quot;);                    String okPassWord = sc.next();                    // 3、比对两次密码是否一致                    if(newPassWord.equals(okPassWord))&#123;                        acc.setPassWord(okPassWord);                        System.out.println(&quot;密码已经修改成功，请重新登录！&quot;);                        return;                    &#125;else &#123;                        System.out.println(&quot;两次密码不一致！&quot;);                    &#125;                &#125;            &#125;else &#123;                System.out.println(&quot;您输入的密码有误。请重新确认密码！&quot;);            &#125;        &#125;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在复习完 Java SE 的全部基础知识点后，为了更加熟练掌握 Java 面向对象的特性，进一步掌握编程技巧和调试技巧，使用 Java 模拟实现一个银行 ATM 系统软件，共 Account.java 和 ATM.java 两个 Java 类。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Accenture Coding Virtual Experience Program</title>
    <link href="http://blog.zhuangzhihao.top/Accenture-Coding-Virtual-Experience/"/>
    <id>http://blog.zhuangzhihao.top/Accenture-Coding-Virtual-Experience/</id>
    <published>2022-01-15T16:00:00.000Z</published>
    <updated>2022-05-05T12:51:34.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The Accenture Know-the-Code Virtual Experience Program covers the fundamentals of software development, including object-oriented programming, code refactoring, and agile delivery. It empowers me to explore what a career in software development could look like at Accenture while practicing my coding skills. The following are the notes I took during this virtual experience.</p></blockquote><a id="more"></a><div class="row">    <embed src="/pdf/Accenture-Coding-Virtual-Experience.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Task-1-Object-Oriented-Programming"><a href="#Task-1-Object-Oriented-Programming" class="headerlink" title="Task 1: Object Oriented Programming"></a>Task 1: Object Oriented Programming</h3><h4 id="Background-Information"><a href="#Background-Information" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Recently, a company has brought on Accenture to help with the development of its e-commerce website written in Java using the Spring Boot framework. The first task they need help with is searching for products</li><li>One of the UX designers at Accenture has already implemented the new search capability in the UI</li><li>My responsibility is to implement the search capability in our backend Java app</li></ul><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Expose an HTTP GET request on the path <code>/api/products/search</code></li><li>The request should take a single parameter named “<code>query</code>” which will be the text that was entered in the search bar</li><li>The request will return a Collection of <code>ProductItem</code> which are the matching products for the search</li></ul><h4 id="Implement-a-new-controller-to-handle-searching"><a href="#Implement-a-new-controller-to-handle-searching" class="headerlink" title="Implement a new controller to handle searching"></a>Implement a new controller to handle searching</h4><ol><li>Download and unzip the mock-company-webapp codebase</li><li>Open the application in IDEA with Gradle support</li><li>Follow the README.md instructions for setting up the development environment</li><li>Implement the “<code>search</code>” method of the class <code>SearchController</code>, the relevant code is outlined with a TODO comment</li><li>The controller should use the “<code>productItemRepository</code>” to interface with the product database</li><li>Review the tests and implement the controller to the spec</li></ol><h4 id="Practical-skills-gained"><a href="#Practical-skills-gained" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Object Oriented Programming</li><li>Java</li><li>Spring</li></ul><h3 id="Task-2-Code-Refactoring"><a href="#Task-2-Code-Refactoring" class="headerlink" title="Task 2: Code Refactoring"></a>Task 2: Code Refactoring</h3><h4 id="Background-Information-1"><a href="#Background-Information-1" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Now we’ve identified some code in the <code>ReportController</code> class that seems to be doing similar product searching</li><li>I need to refactor the <code>SearchController</code> logic into a new <code>SearchService</code> class that can be used in the <code>SearchController</code> as well as in the <code>ReportController</code></li></ul><h4 id="Requirements-1"><a href="#Requirements-1" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Logic moved from <code>SearchController</code> to <code>SearchService</code></li><li><code>SearchController</code> and <code>ReportController</code> both updated to use the <code>SearchService</code></li><li>All unit tests pass</li></ul><h4 id="Refactor-controllers-to-a-shared-service"><a href="#Refactor-controllers-to-a-shared-service" class="headerlink" title="Refactor controllers to a shared service"></a>Refactor controllers to a shared service</h4><ol><li>Follow the README.md instructions for setting up the development environment</li><li>Create the new <code>SearchService</code> class in the “<code>services</code>” package. All of the search logic from the <code>SearchController</code> should be moved into a function in this class for reusability. The relevant code is outlined with a TODO comment</li><li>Using <code>@Autowired</code>, inject the <code>SearchService</code> into the <code>SearchController</code> and <code>ReportController</code></li><li>Refactor both controller classes to use the service by rewriting their functions to use the new service</li><li>Ensure unit tests all pass</li></ol><h4 id="Practical-skills-gained-1"><a href="#Practical-skills-gained-1" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Java</li><li>Spring</li></ul><h3 id="Task-3-Continuous-Integration"><a href="#Task-3-Continuous-Integration" class="headerlink" title="Task 3: Continuous Integration"></a>Task 3: Continuous Integration</h3><h4 id="Background-Information-2"><a href="#Background-Information-2" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Continuous Integration is the practice of automating the integration of code changes from multiple contributors into a single software project</li><li>It’s a primary DevOps best practice, allowing developers to frequently merge code changes into a central repository where building and test runs can occur</li><li>Use the most popular Continuous Integration tool, Jenkins</li><li>Creating a <code>Jenkinsfile</code> that will build and test the application on all branches of the repository</li></ul><h4 id="Requirements-2"><a href="#Requirements-2" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>GitHub account created, Git CLI setup, mock-company-webapp repository forked and cloned</li><li><code>Jenkinsfile</code> defined with stages setting it up to run on commit to any branch in the repository</li><li>Continuous Integration server runs <code>build/test</code> and succeeds</li><li>Change made to code that breaks test</li><li>Continuous Integration server runs <code>build/test</code> and fails</li></ul><h4 id="Simulating-Jenkins-using-the-Jenkinsfile-Runner-Action-in-a-GitHub-Workflow"><a href="#Simulating-Jenkins-using-the-Jenkinsfile-Runner-Action-in-a-GitHub-Workflow" class="headerlink" title="Simulating Jenkins using the Jenkinsfile Runner Action in a GitHub Workflow"></a>Simulating Jenkins using the <code>Jenkinsfile</code> Runner Action in a GitHub Workflow</h4><ol><li>Create an account with GitHub and fork the mock-company-webapp repository</li><li>Setup the Git CLI on workstation and “<code>clone</code>” the repository you forked to workstation</li><li>Install the Pipelines application from the GitHub marketplace to use Jenkins directly</li><li>use the Simulated Jenkins for GitHub link to add a <code>.github/workflows/workflow.yml</code> to the repository.</li><li>Add the following stages to the <code>Jenkinsfile</code>, the relevant code is outlined with a TODO comment.<ul><li>Build: <code>./gradlew assemble</code></li><li>Test: <code>./gradlew test</code></li></ul></li><li>Continue to tweak the <code>Jenkinsfile</code> until the build is successful</li><li>Change the <code>SearchService</code> to always return <code>Collections.emptyList()</code> in order to break the tests.</li><li>Commit the change and validate the Continuous Integration build fails which proves that we’ve properly set up Continuous Integration guard rails, that will catch failing tests each time a commit is made by a developer</li></ol><h4 id="Practical-skills-gained-2"><a href="#Practical-skills-gained-2" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Continuous Integration</li><li>Jenkins</li><li>DevOps</li></ul><h3 id="Task-4-Agile-Planning"><a href="#Task-4-Agile-Planning" class="headerlink" title="Task 4: Agile Planning"></a>Task 4: Agile Planning</h3><h4 id="Background-Information-3"><a href="#Background-Information-3" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>In an Agile planning session, developers are given a set of large software features that they then must break up into smaller units of work, called stories, that can be completed within a one to three week period, called a sprint</li><li>A story is an informal, general explanation of a software feature written from the perspective of the end user or customer and is made up of the following components:<ul><li>Who the feature is for</li><li>What they need</li><li>Why they need it</li><li>What shows it’s done</li></ul></li></ul><h4 id="Requirements-3"><a href="#Requirements-3" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Stories are written in the following format: As a <code>&lt;who the feature is for&gt;</code>, I need to be able to <code>&lt;what they need&gt;</code> so I can <code>&lt;why they need it&gt;</code></li><li>The “<code>what shows it’s done</code>”, called acceptance criteria, must be provided with the story as well</li><li>Stories are then pointed or sized which means to assign some kind of value indicating the difficulty of implementing the story</li><li>Use a T-Shirt size strategy assigning a value of small/medium/large to each story</li><li>It’s very important that stories are broken down as small as they can be so try and keep them either small or medium</li><li>This allows for better concurrency throughout the sprint and easier completion within a single sprint</li></ul><h4 id="planning-a-sprint-to-implement-the-checkout-feature-of-the-site"><a href="#planning-a-sprint-to-implement-the-checkout-feature-of-the-site" class="headerlink" title="planning a sprint to implement the checkout feature of the site"></a>planning a sprint to implement the checkout feature of the site</h4><ul><li>Create a document that defines around 10 to 20 stories around the checkout feature</li><li>Pull in a subset of these stories based on our capacity to work on in the next sprint</li><li>Make sure the stories are broken up as small as possible, and the acceptance criteria is testable</li></ul><h4 id="Practical-skills-gained-3"><a href="#Practical-skills-gained-3" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Agile Methodology</li><li>Software Development Lifecycle (SDLC)</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;The Accenture Know-the-Code Virtual Experience Program covers the fundamentals of software development, including object-oriented programming, code refactoring, and agile delivery. It empowers me to explore what a career in software development could look like at Accenture while practicing my coding skills. The following are the notes I took during this virtual experience.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
    <category term="Spring" scheme="http://blog.zhuangzhihao.top/tags/Spring/"/>
    
    <category term="Spring Boot" scheme="http://blog.zhuangzhihao.top/tags/Spring-Boot/"/>
    
    <category term="Gradle" scheme="http://blog.zhuangzhihao.top/tags/Gradle/"/>
    
    <category term="Jenkins" scheme="http://blog.zhuangzhihao.top/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-12-09T16:00:00.000Z</published>
    <updated>2022-05-05T12:50:40.925Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。</p></blockquote><a id="more"></a><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h4><ul><li>计算机网络就是一些互联的、自治的计算机系统的集合。</li><li>自治计算机就是能够进行自我管理、配置和维护的计算机。</li><li>计算机网络包括硬件、软件、协议三大部分。<ul><li>硬件由主机、通信处理机、通信线路和交换设备组成。</li></ul></li><li>从工作方式上看，计算机网络可分为边缘部分和核心部分。</li><li>从功能组成上看，计算机网络由通信子网和资源子网两部分构成。<ul><li>通信子网包括物理层、数据链路层和网络层。</li></ul></li><li>数据通信是计算机网络最基本和最重要的功能。</li><li>资源共享包括数据资源、软件资源以及硬件资源。</li></ul><h4 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h4><ul><li>实体是任何可发送或接收信息的硬件或软件进程。</li><li>对等层是不同机器上的同一层，对等实体是同一层上的实体。</li><li>协议是控制2个对等实体进行通信的规则。</li><li>接口又称服务访问点，没有接口就不能提供服务。从物理层开始，每一层都向上层提供服务访问点。</li><li>服务数据单元 SDU，协议控制信息 PCI，接口控制信息 ICI。</li><li>协议数据单元 PDU，表示的是同等层对等实体间传送的数据单元。<code>n-SDU</code>+<code>n-PCI</code>=<code>n-PDU</code>，<code>n-PDU</code>=<code>(n-1)-SDU</code></li><li>接口数据单元 IDU，表示的是在相邻层接口间传送的数据单元。<code>n-SDU</code>+<code>n-ICI</code>=<code>n-IDU</code></li><li>服务至下层为相邻上层提供的功能调用。只有那些能够被高一层实体看得见的功能才成为服务。</li><li>面向连接的服务（TCP），面向无连接的服务（IP和UDP）。</li><li>第n层的实体使用第n-1层的服务，向第n+1层提供本层的服务。该服务是第n层及其下各层所提供的服务的总和。</li><li>最高层向用户提供服务，下一层提供服务的实现细节对上一层透明。</li><li>OSI参考模型具有7层结构，而TCP/IP模型仅有4层结构。<ul><li>应用层（用户对用户），提供系统与用户的接口。文件传输、访问和管理、电子邮件服务。FTP，smtp，pop3，HTTP。</li><li>传输层（应用对应用，进程对进程），负责主机中2个进程之间的通信。为端到端连接提供可靠的运输服务、流量控制、差错控制、服务质量管理。TCP、udp、ARQ。</li><li>网络层（主机对主机），为传输层提供服务、组包和拆包、路由选择、拥塞控制。ICMP、Arp、RARP、IP、IGMP。</li><li>网络接口层 = 数据链路层 + 物理层</li><li>数据链路层，将网络层传下来的IP数据报组装成帧数。PPP、HDLC。</li><li>物理层，为数据端设备提供传送数据通路，传输比特流。 </li><li>应用层 = 应用层 + 表示层 + 会话层</li><li>会话层的主要功能是在2个节点间建立维护和释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传送。</li><li>表示层负责处理在2个内部数据表示结构不同的通信系统间交换信息的表示格式，数据压缩及解压。</li><li>TCP/IP模型没有明确区分服务、接口、协议，且网络层仅有无连接。OSI参考模型网络层有连接和无连接，但传输层仅面向连接。</li></ul></li></ul><h4 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h4><ul><li>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</li><li>数据传输率是由总时延决定的，而带宽仅决定了发送时延。</li><li>发送时延 = 数据帧长度（bit）/ 发送速率（bit/s）</li><li>传播时延 = 信道长度（m）/ 电磁波在信道上的传播速度（m/s）</li><li>时延带宽积 = 传播时延 × 带宽</li><li>利用率包括信道利用率和网络利用率（全网络的信道利用率的加权平均值）。</li><li>1 MB/s = 8 Mbit/s</li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><h4 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h4><ul><li>数据是传送信息的实体。而信号是数据的电气或电磁的表现。</li><li>基带对应数字信号，宽带对应模拟信号。</li><li>数据传输方式分为串行传输和并行传输。通信方式分为同步通信和异步通信。通信模式分为单向通信、双向交替通信、双向同时通信。</li><li>波特率（码元传输速率）表示单位时间内数字通信系统所传输的码元个数，单位波特（Baud）。</li><li>比特率（信息传输速率）表示单位时间内通信数字系统所传输的二进制码元个数，单位比特数（bit/s）。</li><li>每比特只能表示两种信号变化，可看成二进制。</li><li>带宽表示在单位时间内从网络中的某一点到另一点所能通过的最高数据率（网络的通信线路所能传送数据的能力）。单位比特每秒（bit/s）。</li><li>在通信领域，带宽是指信号最高频率与最低频率之差（Hz）。因此将模拟信号转换成数字信号时，采样频率必须大于等于最大频率f的2倍。</li><li>奈奎斯特定理给出了在无噪声情况下码元的最大传输速率。f表示理想低通信道的带宽。N表示每个码元的离散电平的数目。<ul><li>$C_{\max }=f_1<em>\log _{2}N=2f</em>\log _{2}N$</li></ul></li><li>信噪比是信号的平均功率和噪声的平均功率之比。S/N（dB）‘</li><li>香农公式给出了信号传输速率的极限。W为信道的带宽。<ul><li>$C_{\max }=W*\log _{2}\left( 1+\dfrac{S}{N}\right)$</li></ul></li><li>要使信息的极限传输速率提高，就必须提高信道的带宽或信道中的信噪比。实际信道的传输速率要比极限速率低不少。</li><li>模拟数据和数字数据都可以转化成模拟信号（调制）或数字信号（编码）。</li><li>数据传输方式包括电路交换、报文交换和分组交换。<ul><li>电路交换一定面向连接。通信时延小、实时性强、有序传输，但信道利用率低、缺乏统一标准、灵活性差。</li><li>报文交换，报文携带有目的地址、源地址。无需建立连接、动态分配线路，但报文大小没限制，要求网络节点需要有较大的存储缓存空间。</li><li>分组交换仍采用存储转发传输方式。将一个长报文分割成若干个较短的分组。加速传输、简化存储管理、减少出错概率和重发数据量，但存在传输时延、可能出现失序、丢失或重复分组现象。</li><li>TCP可以向应用层提供面向连接的服务，而UDP在传输层是无连接的。</li><li>分组交换可分为面向连接的虚电路方式和面向无连接的数据报方式，二者都由网络层提供。</li><li>数据报无需建立连接、提高吞吐量、对故障适应力强，每个分组包含完整的源地址和目的地址，可靠通信由用户主机来保证。</li><li>虚电路时延小、按序到达，每个分组包含一个虚电路号，可靠通信由网络来保证。</li></ul></li></ul><h4 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h4><ul><li>传输介质分为导向性传输介质和非导向性传输介质。<ul><li>导向性传输介质包含双绞线、同轴电缆和光纤。</li><li>双绞线分为无屏蔽双绞线和屏蔽双绞线。</li><li>同轴电缆分为基带同轴电缆（50Ω）和宽带同轴电缆（75Ω）。</li><li>光纤分为单模光纤（远距离）和多模光纤（近距离）。</li><li>非导向性传输介质有短波、微波、红外线与可见光等。</li></ul></li><li>传输介质并不是物理层，在传输介质中传输的是信号。物理层主要的功能就是确定与传输介质的接口有关的一些特性，即物理层接口的特性，如机械特性、电气特性、功能特性、规程特性。</li><li>物理层设备主要包含中继器和集线器。放大器放大的是模拟信号，中继器放大的是数字信号。</li><li>集线器实际就是一个多端口的中继器（Hub）。集线器在一个时钟周期内只能传输一组信息。集线器不能隔离冲突域。</li><li>通过中继器或集线器连接起来的几个网段仍然是一个局域网。使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用CSMA/CD协议，共享逻辑上的总线。</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h4><ul><li>数据链路层在物理层所提供的服务的基础上向网络层提供服务，分为无确认的无连接服务、有确认的无连接服务和有确认的有连接服务。</li><li>数据链路层的主要功能分为链路管理、帧同步、差错控制、透明传输。</li><li>当2个主机互相传送信息时，网络层的分组。必须封装成帧，并以帧的格式进行传送。即将一段数据的前后分别添加首部和尾部形成帧，首部和尾部中有很多控制信息，如帧定界。</li></ul><h4 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h4><ul><li>组帧方法分为字符计数法、字节填充的首尾界符法、比特填充的首尾标志法、物理编码违例法。</li><li>在网络中以帧为最小单位进行传输，所以组帧既要有首部又要加尾部，确定接收端清楚该帧在一串比特流中从哪里开始、到哪里结束。</li><li>字符计数法用一个特殊的字符表示一帧的开始，用一个计数字段表明该帧包含的字节数，计数字段提供的字节数包含自身所占的一个字节。</li><li>首尾界符法选定2个字符（SOH/EOT）作为每一个帧的开始和结束。字符填充的首尾界符法是将数据中可能出现的控制字符<code>SOH</code>和<code>EOT</code>在接收端不解释为控制字符。</li><li>比特填充的首尾标志法使用<code>01111110</code>作为帧的开始和结束标志。零比特填充法每有5个连续的<code>1</code>马上在其后插入<code>0</code>，接收方每收到5个连续的<code>1</code>自动删除后面紧跟的<code>0</code>恢复原始数据。</li><li>物理编码违例法利用物理介质上的编码的违法标志来区分帧的开始和结束，例如在曼彻斯特编码中高-高和低-低电平的编码方式是无效的，用来作为帧的起始和结束标志。</li></ul><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><ul><li>检错编码分为奇偶校验码和循环冗余码。<ul><li>奇偶校验码是在信息码后面加1位校验码，分为奇校验和偶校验。奇校验是添加1位校验码后使得整个码字里面<code>1</code>的个数是奇数。</li><li>循环冗余码（CRC）是在发送端产生一个冗余码，附加在信息位后面一起发送到接收端，接收端收到的信息按发送端形成循冗余码同样的算法进行校验，如果发现错误则通知发送端重发。</li><li>CRC的本质是模-2除法的余数，采用的除数不同，CRC的类型也就不一样。</li><li>循环冗余码具有r检测位的多项式能够检测出所有小于或等于r的突发错误，长度大于r+1的错误逃脱的概率是 $\dfrac{1}{2^{r}}$。</li></ul></li><li>常见的纠错编码是海明码，在 k 位信息字段中插入若干位数据用于监督码字里的哪一位数据发生变化，具有一位纠错能力。<ul><li>确认校验码的位数 r：$2^{r}-1\geq k+r$</li><li>校验码$P_i$在编码中的位置为$2^{i-1}$</li><li>出错位$e_n$等于所有有关位$M_n$互为异或，求出$P_i$，按序写出海明码</li><li>校验海明码：出错位$e_n$等于所有有关位$M_n$互为异或，求出$e_n$</li><li>出错位$e_n$对应的十进制数就是出错的位数</li></ul></li></ul><h4 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h4><ul><li>流量控制就是要控制发送方发送数据的速率使接收方来得及接收，分为停止-等待流量控制和滑动窗口流量控制。<ul><li>停止-等待流量控制就是发送方发出一帧，等接收方收到一帧后返回应答信号，再发送下一帧。</li><li>滑动窗口流量控制允许一次发送多个帧。在任意时刻发送方都维持一组连续的允许发送的帧的序号，称为发送窗口。同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送端每收到一个帧的确认，发送窗口就向前移动1个帧的位置。</li><li>只有在接收窗口向前滑动时，发送窗口才有可能向前滑动。</li><li>只要当接收窗口大小为1时，则可保证帧按序接受。</li></ul></li><li>端到端的可靠传输就是在传输层使用面向连接的TCP，而不是数据链路层。</li><li>可靠传输一般使用确认和超时重传两种机制共同完成（ARQ自动请求重发）。</li><li>可靠传输机制包括停止-等待协议、后退N帧协议和选择重传协议。<ul><li>停止等待协议就是发送窗口和接收窗口大小均为1。帧一般分为数据帧和确认帧。</li><li>后退N帧协议：发送方连续发送若干个数据帧，如果收到接收方的确认帧接着发送数据，如果某个帧出错，接收方只能简单丢弃该帧及后续所有帧。增加吞吐量，但造成一定浪费。</li><li>后退N帧协议接收窗口大小=1，$1&lt;发送窗口大小W_{T}\leq 2^{n}-1$。n为对帧编号的比特数。</li><li>选择重传（SR）协议：当一帧出错时，后续帧先存入接收方的缓冲区中,同时要求发送方重传出错帧。提高信道利用率但增加缓冲空间。</li><li>选择重传协议的接收窗口尺寸和发送窗口尺寸都大于1，以便能一次性接受多个帧。发送窗口的最大尺寸也不能超过序列号范围的一半。当发送窗口等于接收窗口=$2^{n}-1$时达到最大效率。</li><li>按序到达的且没有被交付给主机的帧被放在接收缓存里。不按序到达的数据且没有错误的帧放在接收窗口里。不直接给主机，等缺少的帧收到后再一起放到接收缓存。</li></ul></li></ul><h4 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h4><ul><li>静态分配信道的方法是信道划分介质访问控制。动态分配信道的方法分为随机访问介质访问控制和轮询访问介质访问控制。</li><li>多路复用技术是在一条介质上同时携带多个传输信号，使多个计算机或终端设备共享信道资源，提高信道的利用率。实现信道划分介质访问控制。</li><li>信道划分介质访问控制分为频分多路复用、时分多路复用、波分多路复用和码分多路复用。<ul><li>频分多路复用时如果复用数增加，那么信号的频率带宽增加。</li><li>统计时分复用是一种动态的时间分配。</li><li>波分多路复用就是光的频分多路复用。</li><li>码分多路复用，又称为码分多址（CDMA），既共享信道的频率又共享时间，主要用于无线通信系统。</li><li>任意2个站点的码片向量的规格化内积一定为1。任意站点的码片向量与该码片向量自身的规格化内积一定为1。任何站点的码片向量和该码片的反码向量的规格化内积一定为负1。</li></ul></li><li>动态划分信道分为随机接入（争用性协议）和受控接入。<ul><li>ALOHA协议：不检测发送数据，一段时间没收到确认即为发送冲突，发生冲突的节点等待一段随机事件后再发送数据。</li><li>时分ALOHA：所有节点的时间被划分为间隔相同的时隙，并规定每个节点就会等到下一个时隙到来时才可发送数据。</li><li>载波侦听多路访问（CSMA）协议：每个节点发送数据之前，都使用载波侦听技术来判定通信信道是否空闲，在局域网中被广泛的应用。</li><li>1-坚持CSMA：监听到信道空闲时，立即发送数据，否则继续监听。</li><li>p-坚持CSMA：监听到信道空闲时，以概率P发送数据，以概率(1-P)延迟一段时间并重新监听。</li><li>非坚持CSMA。监听到信道空闲时，立即发送数据，否则延迟一段随机的时间再重新监听。</li><li>CSMA/CD协议（带冲突检测的载波侦听多路访问协议）：检测超过发送站点本身发送的载波信号的幅度，由此判断出冲突的存在，并向总线上发一串阻塞信号。</li><li>CSMA/CD工作流程：先听后发，边听边发，冲突停发，随机重发。</li><li>CSMACD用于信道使用半双工的网络环境，而对于使用全双工的网络环境，则无需采用这种介质访问控制技术。</li><li>争用期（$2\tau$）：以太网端到端的往返时延，又称冲突窗口或碰撞窗口。只有经过争用期还没有检测到冲突，才能肯定这次发送不会发生冲突。</li><li>以太网规定最短帧长为64B，凡长度小于64B的都是由于冲突而异常停止的无效帧。以太网端到端的单程时延实际上小于争用期的一半（25.6μs）。</li><li>最短有效帧长和最远2个站的距离及传输速率成正比。</li><li>截断二进制指数类型退避算法：发生碰撞的站在停止发送数据后要推迟一个随机时间才能发送数据，基本退避时间一般取争用期（$2\tau$），重传需要推迟的平均时间随重传次数的增大而增大。</li><li>CSMA/CA协议主要用在无线局域网中，在CSMA的基础上增加了冲突避免的功能。</li><li>CSMA/CA协议要对正确接收到的数据帧进行确认。</li></ul></li><li>轮询访问介质访问控制主要用于在令牌环局域网中。典型的轮询访问介质访问控制协议就是令牌传递协议。</li></ul><h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><ul><li>局域网（local area network，LAN）是指一个较小范围内的多台计算机或其他通信设备通过双绞线、同轴电缆等连接介质互联起来，以达到资源和信息共享目的的互联网络。<ul><li>局域网有较高的数据率、较低的时延和较小的误码率，具有广播功能，便于系统的扩展和演变。</li><li>局域网的主要技术要素包括网络拓扑结构传输介质与介质访问控制方法。局域网的主要拓扑结构包括星型网环形网总线型网和树型网（星型网和总线型网的结合）。双绞线为局域网的主流传输介质。</li><li>局域网的主要介质访问控制方法包括CSMA/CD、令牌总线和令牌环。前两种作用于总线型网，令牌环作用于环形网。</li><li>局域网对应OSI参考模型中的数据链路层和物理层，并将数据链路层拆分为2个子层，逻辑链路控制（LLC）子层和媒体接入控制（MAC）子层。</li></ul></li><li>以太网采用总线拓扑结构。所有计算机都共享一条总线信息，以广播方式发送，使用CSMACD技术对总线进行访问控制。<ul><li>以太网采用无连接的工作方式，不对发送的数据帧进行编号，也不要求对发送方发送确认。以太网提供的服务是不可靠服务，所以有重传机制，且差错纠正由传输层的TCP完成。</li><li>数据传输速率达到或超过100Mbit/s的以太网称为高速以太网。100base-T以太网称为快速以太网。吉比特以太网成为千兆以太网,允许在全双工和半双工两种方式工作。在半双工方式下工作时必须使用CSMA/CD协议进行冲突检测。</li></ul></li><li>无线局域网分为有固定基础设施和无固定基础设施两类。IEEE802.11规定有固定基础设施的无线局域网的最小构建为基本服务集（BSS），BSS中的基站称为接入点（AP）。<ul><li>基本服务集可以是孤立的，也可以通过接入点连接到一个主干分配系统（DS）构成扩展的服务器（ESS），ESS还可通过门桥（portal）设备为无线用户提供到非IEEE802.11无线局域网的接入。</li><li>IEEE802.11标准中的物理层有跳频扩频（FHSS）、直接序列扩频（DSS）、红外线（IR）3种实现方法。</li><li>IEEE802.11标准中的MAC层在物理层上，包括2个子层，从下往上依次为分布协调功能（DCF）子层和点协调功能（PCF）子层。在带有碰撞避免功能的CSMA/CA协议的基础上增加确认机制。</li></ul></li><li>广域网是覆盖范围很广的长距离网络，由一些节点交换机以及连接这些交换机的链路组成。节点交换机完成分组存储转发的功能。<ul><li>广域网是通过交换机连接多个局域网组成，因特网是由广域网和局域网共同通过路由器相连。</li><li>局域网使用的协议主要在数据链路层，而广域网使用的协议主要在网络层。</li><li>广域网的路由选择协议负责搜索分组从某个节点到目的节点的最佳传输路由，以便构成路由表，从路由表再构造出转发分组的转发表，分组是通过转发表进行转发的。</li></ul></li><li>点对点协议（PPP）由一个将IP数据报封装到串行链路的方法、一个用于建立配置和测试数据链路连接的链路控制协议（LCP）和一套用来建立和配置不同的网络层协议的网络控制协议（NCP），其中每个协议支持不同的网络层协议。<ul><li>PPP是一个面向字节的协议，不需要纠错（只负责检错）、流量控制（由TCP负责）、序号（不可靠的传输协议）、多点线路，只支持全双工链路。</li></ul></li><li>高级数据链路控制（HDLC）协议是ISO制定的面向比特的数据链路控制协议，可适用于链路的非平衡配置（一个主站控制整个链路的工作）和平衡配置（链路两端2个站都是复合站）。<ul><li>PPP帧比HDLC协议帧多一个2字节的协议字段，当协议字段值为Ox0021时表示信息字段是IP数据报。</li><li>PPP不使用序号和确认机制，只保证无差错接收（通过硬件进行循环冗余码校验），HDLC协议的信息帧使用了编号和确认机制。</li></ul></li></ul><h4 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h4><ul><li>在物理层拓展局域网使用中继器和集线器扩大冲突域，但总吞吐量未提高，且不能互联使用不同以太网技术的局域网。</li><li>在数据链路层扩展局域网使用网桥，具有过滤帧的功能。网桥至少有2个端口，每一个端口与一个网段相连。<ul><li>网桥从一个端口接收一个帧，先暂存到缓存中，若未出现差错，且发往目的站MAC地址属于另一网段，则通过查找转发表将该帧从对应端口发出。</li><li>网桥过滤通信量、扩大物理范围、提高可靠性、可互连不同物理层、不同MAC子层和不同速率的以太网，但存储转发增加时延，且在MAC层并没有流量控制功能，用户过多会因传播过多的广播信息而产生网络拥塞（广播风暴）。</li><li>网桥包括透明网桥（选择的不是最佳路由）和源选径网桥（选择的是最佳路由）。最佳路由并不一定是经过路由器最少的路由，也可以是发送帧往返时间最短的路由（实现负载平衡）。</li></ul></li><li>局域网交换机实质上是工作在数据链路层的多端口网桥。局域网交换机的每个端口都直接与主机或集线器相连，并且一般都工作在全双工方式。<ul><li>交换机总容量 = 端口数×每个端口带宽（半双工）or 端口数×每个端口带宽×2（全双工）</li><li>交换机分为直通式交换和存储转发式交换，工作原理与网桥类似。</li><li>网桥的端口一般连接到局域网的网段，而以太网交换机的每个端口一般都直接与主机相连，也可连接到Hub。</li></ul></li><li>一块网卡发出一个广播，能收到这个广播的所有网卡集合为一个广播域。通常情况下，一个网段就是一个冲突域，一个局域网就是一个广播域。</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h4><ul><li>网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务，并且网络层不提供服务质量的承诺。</li><li>这样的好处在于网络造价大大降低，运行方式灵活。</li></ul><h4 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h4><ul><li>网际协议IP是TCP/IP体系中两个最主要的协议之一。其中，与IP协议配套使用的有三种协议：<ul><li>地址解析协议ARP</li><li>网际控制报文协议ICMP</li><li>网际组管理协议IGMP</li></ul></li><li>其中，ICMP、IGMP协议是往基层向上提供的两种服务</li></ul><h4 id="互联网络"><a href="#互联网络" class="headerlink" title="互联网络"></a>互联网络</h4><ul><li>因为用户的需求是多种多样的，没有一种单一的网络能够适应所有用户的需求,所以不同的网络之间，将网络互联起来需要使用一些中间设备。<ul><li>物理层使用的中间设备是转发器</li><li>数据链路层使用的中间设备是网桥或者桥接器</li><li>网络层使用的中间设备是路由器</li><li>网络层以上使用的中间设备叫网关</li></ul></li></ul><h5 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h5><ul><li><p>物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和网络层以上各层使用的地址</p></li><li><p>在发送数据时，数据从高层下到底层，然后才到通信链路上使用IP的IP数据报一旦交给了数据链路层，就被封装成MAC帧（MAC地址）</p></li></ul><h5 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h5><ul><li><p>已知一个机器的IP地址，如何找出其所对应的硬件地址呢？这就是ARP的主要任务。</p><ul><li>ARP协议的主要内容在于从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。</li></ul></li></ul><ul><li>工作原理：一个主机都设有一个ARP高速缓存，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。</li></ul><h4 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h4><ul><li>一个IP数据报由首部（20 字节+可选字段）和数据两部分组成</li></ul><h4 id="划分子网和构建超网"><a href="#划分子网和构建超网" class="headerlink" title="划分子网和构建超网"></a>划分子网和构建超网</h4><ul><li><p>两级IP到三级IP</p><ul><li><p>两级IP（&lt;网络号&gt;，&lt;主机号&gt;）的缺陷：</p></li><li><p>IP地址的空间利用率有时很低</p><ul><li>两级IP地址不够灵活</li></ul></li><li><p>给每一个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏。</p></li><li><p>三级IP地址：将其中二级IP的主机号取出并高x位变成子网络，形成网络号+子网号+主机号的地址格式</p></li><li><p>划分子网：划分子网属于一个单位内部的事情，它将二级IP地址变为三级IP地址</p></li></ul></li></ul><h4 id="无分类编制CIDR"><a href="#无分类编制CIDR" class="headerlink" title="无分类编制CIDR"></a>无分类编制CIDR</h4><ul><li><p>CIDR取消了传统的A类、B类和C类地址以及划分子网的概念，并且用网络前缀代替网络号和子网号，后面的部分指明主机。因此，CIDR使IP地址从三级地址(使用子网掩码)，又回到了两级地址（无分类的两级编址）。</p></li><li><p>CIDR把网络前缀相同的连续的IP地址组成一个”CIDR地址块”只要知道CIDR地址块中的任何一个地址，就可以知道这地址块的起始地址(即最小地址)和最大地址，以及地址块中的地址数。具体看如下例子</p></li><li><p>地址掩码：是一连串的1和0组成，而1的个数救赎网络前缀长度。在斜线记法中。斜线后面的数字就是地址掩码中1的个数。</p></li><li><p>构成超网：由于一个CIDR地址块中含有很多地址，所以在路由表中就利用CIDR地址块来查找目标网络，这种地址的聚合常称为路由聚合，也称构成超网。</p></li></ul><h4 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h4><ul><li><p>最长前缀匹配之前，使用CIDR时，每个项目由网络前缀和下一跳地址组成。但是在查找路由表时会得到不止一个匹配结果该怎么办呢？</p></li><li><p>此时应该选择匹配结果中，有最长网络前缀的路由。因为网络前缀越长，可分配的地址数就越少，其地址信息路由就越具体</p></li></ul><h4 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h4><ul><li><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP是互联网的标准协议，但不是高层协议。其种类如下：</p><ul><li>ICMP差错报告报文</li></ul></li></ul><ul><li><p>ICMP询问报文</p></li><li><p>ICMP的应用在于分组网间探测PING，以用来测试两台主机之间的连通性。</p></li></ul><h4 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h4><ul><li><p>路由选择协议分为两大类：</p><ul><li>内部网关协议</li></ul></li></ul><ul><li><p>外部网关协议</p></li><li><p>内部网关协议</p><ul><li>RIP是内部网关协议中最先得到广泛应用的协议，也被称为路由信息协议，但是其很少被使用。其主要特点如下：<ul><li>仅和相邻路由器交换信息。</li><li>路由器交换的信息是当前路由器所知道的全部信息，即自己现在的路由</li><li>按固定的时间间隔交换路由信息，例如，每隔30秒。</li><li>因此，RIP有如下的优缺点。</li><li>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。</li><li>RIP 协议最大的优点就是实现简单，开销较小。</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li></ul></li></ul></li><li><p>OSPF最主要的特征就是使用分布式的链路状态协议，其主要特点：</p><ul><li>使用洪泛法向本自治系统中所有路由器发送信息。</li></ul></li></ul><ul><li><p>发送的信息是与本路由器相邻的所有路由器的链路状态。</p></li><li><p>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p></li></ul><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><ul><li>解决IP地址耗尽的根本措施在于采用具有更大地址空间的新版本IP，即IPv6。它有两大部分组成：基本首部，有效载荷</li><li>IPv6采用的是点分十六进制的记法，把每个十六位的值用十六进制表示，并且各个值之间用冒号分割</li><li>冒号十六进制允许零压缩，但只能使用一次零压缩</li><li>冒号十六进制可以结合使用点分十进制记法的后缀。</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h4><ul><li>运输层功能<ul><li>运输层应用进程之间提供端到端的逻辑通信。这与网络层的区别在于网络层是为主机之间提供逻辑通信的</li><li>运输层需要对收到的报文进行差错检验</li><li>运输层有两种不同的运输协议，即面向连接的TCP和无连接的UDP</li></ul></li><li>TCP/IP的运输层有两个不同的协议：<ul><li>用户数据报协议UDP</li><li>传输控制协议TCP</li></ul></li><li>UDP协议特点<ul><li>提供无连接服务</li><li>尽最大努力交付</li><li>面向报文，UDP 一次交付一个完整的报文</li><li>没有拥塞控制，网络拥塞不会使源主机的发送速率降低</li><li>支持一对一、一对多、多对一和多对多的交互通信</li><li>首部开销小，只有 8 个字节</li><li>应用：对可靠性要求不高，需要传送的数据不多，使用频率不高。并且可以实时应用。</li></ul></li><li>TCP协议特点<ul><li>提供面向连接的服务</li><li>可靠传输：主要以字节为单位的滑动窗口和超时重传时间的选择</li><li>面向字节流</li><li>拥塞控制：避免由于对网络中某资源的需求超过可用资源，令网络的性能变坏</li><li>TCP 的流量控制：让发送方的发送速率不要太快</li><li>总结：TCP和UDP协议的区别</li></ul></li><li>TCP的特点<ul><li>面向连接协议</li><li>提供交互保证</li><li>较UDP实时性低</li><li>TCP首部开销20个字节</li><li>TCP速度较慢</li><li>拥塞机制</li><li>TCP将数据看成一连串的字节</li><li>重量级协议，资源占用多</li><li>只有点对点连接</li></ul></li><li>UDP的特点<ul><li>无连接协议</li><li>尽最大努力交付，不提供有序、序列保证</li><li>较好的实时性</li><li>首部开销8字节</li><li>运行速度较快</li><li>无拥塞机制</li><li>面向报文</li><li>轻量级</li><li>一对一，一对多，多对多</li></ul></li><li>运输层的端口<ul><li>运行在计算机中的进程是用进程标识符来标志的。但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。<br>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。</li><li>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。有时我们会改换接收报文的进程，但并不需要通知所有发送方。所以我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</li><li>解决这个问题的方法就是在运输层使用协议端口号 (protocol port number)，或通常简称为端口(port)。虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP来完成。</li></ul></li></ul><h4 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h4><ul><li><p>以字节单位的滑动窗口</p><ul><li><p>TCP使用流水线传输和滑动窗口协议实现高效、可靠的传输。TCP 的滑动窗口是以字节为单位的。</p></li><li><p>发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。</p></li></ul></li></ul><ul><li>发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。</li></ul><ul><li>接收窗口表示：只允许接收落入窗口内的数据。</li></ul><ul><li><p>超时重传时间的选择</p><ul><li>重传机制是 TCP 中最重要和最复杂的问题之一。</li><li>TCP 每发送一个报文段，就对这个报文段设置一次计时器。</li><li>只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。</li><li>重传时间的选择是 TCP 最复杂的问题之一。</li></ul></li><li><p>利用滑动窗口实现流量控制</p><ul><li>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</li><li>流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li><li>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。</li></ul></li><li><p>拥塞机制</p><ul><li>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。</li><li>最坏结果：系统崩溃。</li></ul></li><li><p>网络拥塞往往是由许多因素引起的。例如：</p><ul><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li><li>总的来说，出现拥塞的原因在于对资源的需求大于可用资源</li></ul></li><li><p>TCP的拥塞控制方法</p><ul><li><p>慢开始与拥塞窗口</p><ul><li><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。</p></li><li><p>TCP发送方维持一个拥塞窗口 cwnd</p></li><li><p>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。</p></li><li><p>发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况</p></li><li><p>只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。</p></li><li><p>但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p></li><li><p>其中，对于拥塞的判断，有以下两个指标：1.重传定时器超时。2.收到三个重复的ACK。</p></li></ul></li></ul></li></ul><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><ul><li><p>应用层协议主要定义运行在不同端系统上的应用程序进程之间如何相互传递信息</p></li><li><p>常用的几种协议：DNS、FTP、HTTP、DHCP 的作用</p><ul><li>DNS：域名系统DNS是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。DNS同时占用TCP协议与UDP协议的53号端口。</li><li>FTP：文件传送协议FTP是互联网上使用的最广泛的文件传送协议。FTP使用的传输层协议是</li><li>TCP，FTP 传数据流占用20号端口，FTP传控制流占用21号端口。</li><li>HTTP：HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。HTTP使用传输层协议为TCP，端口号为80。</li><li>DHCP：互联网目前广泛使用的动态主机配置协议DHCP，它提供一种机制，成为即插即用联网。DHCP使用UDP，端口号为67和68。</li></ul></li><li><p>在应用层，用到DNS协议，作用是域名解析，HTTP协议浏览器和服务器之间的交互访问协议。</p></li><li><p>在传输层，运用UDP域名解析协议使用的运输层协议，TCP浏览器和WWW服务器之间建立连接，提供可靠的数据传输。</p></li><li><p>在网际层IP，IP数据报传输和路由选择，ICMP提供网络传输中的差错检测，ARP将本机缺省的网关IP地址映射成物理地址（MAC地址）</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="慕课MOOC" scheme="http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-11-29T16:00:00.000Z</published>
    <updated>2022-05-05T12:50:25.458Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。</p></blockquote><a id="more"></a><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><h4 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h4><ul><li>冯诺依曼模型：运算器、存储器、控制器、输入设备和输出设备</li><li>引入操作系统的目的：提供一个计算机用户与计算机硬件系统之间的接口、有效的控制和管理计算机系统中的各种硬件和软件资源、合理地组织计算机系统的工作流程</li><li>操作系统是计算机系统的资源管理程序</li><li>操作系统的核心是控制和协调进程的运行，解决进程之间的通信</li><li>操作系统的发展：无操作系统阶段 -&gt; 单道批处理系统 -&gt; 多道批处理系统</li></ul><h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><ul><li>并行性：2个或多个事件在同一时刻发生</li><li>并发性：2个或多个事件在同一时间间隔内发生</li><li>并发和共享是操作系统的2个最基本的特征，二者之间互为存在条件</li><li>资源共享方式：互斥共享、同时访问</li><li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物</li><li>异步性</li></ul><h4 id="操作系统的功能和服务"><a href="#操作系统的功能和服务" class="headerlink" title="操作系统的功能和服务"></a>操作系统的功能和服务</h4><ul><li>处理器管理：进程控制、进程同步、进程通信、进程调度</li><li>存储器管理：内存分配、内存保护、内存扩充</li><li>设备管理：设备分配、设备传输控制、设备独立性</li><li>文件管理：文件存储空间的管理、目录管理、文件操作管理、文件保护</li><li>用户接口：命令接口、程序接口、图形接口<ul><li>联机命令接口又称交互式命令结构</li><li>脱机命令接口又称批处理命令接口</li></ul></li><li>操作系统3种基本类型：批处理操作系统、分时操作系统、实时操作系统</li><li>其他操作系统：嵌入式操作系统、集群系统、网络操作系统、分布式操作系统</li></ul><h4 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h4><ul><li>处理器的执行状态分为核心态与用户态<ul><li>核心态是操作系统管理程序执行时机器所处的状态</li><li>用户态是用户程序执行时机器所处的状态</li></ul></li><li>特权指令是只能由操作系统内核部分使用，不允许用户直接使用的指令，如I/O指令、设置中断屏蔽指令、清内存指令、存储保护指令和设置时钟指令</li><li>内核的指令操作工作在核心态<ul><li>时钟管理</li><li>中断机制</li><li>原语</li><li>系统控制的数据结构及处理</li></ul></li><li>异常，也称内中断，是由错误引起的</li><li>通常异常会引起中断，而中断未必是由异常引起的</li><li>系统调用（API）：进程控制、文件系统控制、系统控制、内存管理、网络管理、socket 管控、制用户管理以及进程间通信</li></ul><h4 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h4><ul><li>操作系统的体系结构主要包括模块组合结构、层次结构和微内核结构</li><li>模块组合结构<ul><li>接口简单直接，系统的效率相对较高</li><li>系统结构不清晰、可扩展性差、可适应性差</li></ul></li><li>层次结构<ul><li>按功能的调用次序排列成若干层</li><li>组织和依赖关系清晰明了，可读性、可适应性及可靠性都得到了增强</li><li>通常要将为进程提供服务的系统调用模块放在系统的内层。</li></ul></li><li>微内核结构<ul><li>客户服务器模式（C/S 模式）</li><li>每个服务进程运行在独立的用户进程中，可靠性好，灵活性好，便于维护</li><li>适合分布式处理的计算环境</li><li>效率不高，尤其是通信频繁的系统</li></ul></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li><p>在计算机操作系统中，进程是资源分配的基本单位，也是独立运行的基本单位</p><ul><li>程序顺序执行时的特征：顺序性，封闭性，可再现性</li><li>程序的并发执行的特征：间断性，失去封闭性，不可再现性</li></ul></li><li><p>程序并发执行且其结果具有可再现性的条件（Bernstein 条件）</p><ul><li>R(p1) ∩ W(p2) = ∅</li><li>R(p2) ∩ W(p1) = ∅</li><li>W(p1) ∩ W(p2) = ∅</li></ul></li><li><p>进程的特征：动态性、并发性、独立性、异步性、结构特征（程序段、数据段和进程控制块）</p></li><li><p>进程和程序的关系</p><ul><li>进程和程序的关系程序是静止的</li><li>进程是暂时的，程序是永久的</li><li>进程的组成包括程序段、数据块和进程控制块（Process Control Block）</li><li>通过多次执行，一个程序可以产生多个不同的进程，通过调用关系，一个进程可以执行多个程序</li><li>进程可创建其他进程，而程序不能形成新的程序</li></ul></li><li><p>由程序段、相关数据段和PCB三部分构成的是进程映像，也叫进程实体</p><ul><li>映像是静态的，进程是动态的，进程是进程实体的运行过程</li></ul></li><li><p>进程和作业的区别</p><ul><li>作业是用户需要计算机完成某项任务而要求计算机所做的工作的集合</li><li>作业提交、作业收容、作业执行、作业完成</li><li>进程是已提交完毕的作业的执行过程，是资源分配的基本单位</li><li>作业是用户向计算机提交任务的任务实体，而进程是完成用户任务的执行实体</li><li>这个作业可由多个进程组成，而必须至少由一个进程组成，但一个进程不能构成多个作业</li></ul></li><li><p>进程的组成</p><ul><li>进程控制块（PCB）：标识进程的存在，刻画执行瞬间特征的数据机构</li><li>其他组成部分：程序段、数据段、进程标识符（PID）、进程当前状态、进程队列指针、程序和数据地址，进程优先级、CPU 现场保护区、通信信息、家族联系、占有资源清单</li></ul></li><li><p>PCB 是进程存在的唯一标志</p><ul><li>PCB 存在是为了保证程序的并发执行</li><li>创建进程实质上是创建进程的 PCB，而撤销进程实质上是撤销进程的 PCB</li><li>系统总是通过 PCB 对进程进行控制的</li></ul></li><li><p>进程的5种基本状态：就续状态、执行状态、阻塞状态、创建状态、结束状态</p><ul><li>执行状态只能由就绪状态转换，而无法由阻塞状态直接转换</li><li>不能从就绪状态变为阻塞状态</li><li>进程状态是唯一的</li></ul></li><li><p>进程的创建</p><ul><li>进程创建是通过创建原语实现的</li><li>申请一个空闲 PCB，并指定唯一的 PID -&gt; 分配必要的资源 -&gt; 将新进程的PCB初始化 -&gt; 插入到就绪队列</li><li>导致进程创建的事件：用户登录、作业调度和请求服务</li></ul></li><li><p>撤销一个进程：撤销原语</p><ul><li>找到被撤销进程的PCB -&gt; 停止该进程的执行 -&gt; 回收被撤销进程所占用的资源 -&gt; 回收PCB</li></ul></li><li><p>进程的阻塞与唤醒：两条低级进程通讯原语</p><ul><li>阻塞原语（P 原语）的功能是将进行进程由执行状态转为阻塞状态</li><li>唤醒原语（V 原语）的功能是将进程由阻塞状态变为就绪状态</li><li>一个进程由执行状态变为阻塞状态，是由这个进程自己调用阻塞原语去完成的</li><li>进程由阻塞状态变为就绪状态，是由另一个发现者进程调用唤醒原语去实现的。一般这个发现者进程与被唤醒进程是合作的并发进程</li></ul></li><li><p>调度是决定将系统资源分配给哪个进程，进程切换是实际分配系统资源</p><ul><li>进程切换一定会产生中断，但处理器模式切换不一定产生进程切换</li></ul></li><li><p>进程的互斥与同步就是一种进程间的通信方式</p><ul><li>高级进程通信方式：共享存储器系、消息传递系统、管道（共享文件）通信系统</li></ul></li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程是进程内一个相对独立的可调度的执行单元<ul><li>内核级线程依赖于内核，一个内核级线程由于 I/O 操作而阻塞时不会影响其他线程的运行</li><li>用户级线程不依赖于操作系统核心，由于操作系统内核不了解用户线程的存在，当一个线程阻塞时，整个进程必须等待</li></ul></li><li>进程与线程<ul><li>线程谁独立调度的基本单位，进程是拥有资源的基本单位</li><li>线程不拥有资源，但线程可以访问其隶属进程的系统资源</li><li>进程之间可以并发执行，同一进程内的多个线程之间也可以并发执行</li><li>多线程之间的同步与通信非常容易实现</li></ul></li><li>多线程模型：多对一模型，一对一模型，多对多模型（将多个用户级线程映射到多个内核级线程）</li></ul><h4 id="处理器的三级调度"><a href="#处理器的三级调度" class="headerlink" title="处理器的三级调度"></a>处理器的三级调度</h4><ul><li>高级调度（作业调度）：从外存上处于后备状态的作业中选择一个或多个，给他们分配内存等必要资源并建立相应的进程，以便该作业具有获得竞争处理器的权利<ul><li>作业调度每次要接纳多少个作业进入内存取决于多道程序的并发程度</li><li>多道程序的并发程度应根据系统的规模和运算速度来决定</li><li>应将哪些作业从外存调入内存取决于所采取的调度算法</li></ul></li><li>中级调度（交换调度）：按照给定的原则和策略，将处于外存对换区中具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待</li><li>低级调度（进程调度）：按照某种策略和方法，从就绪队列中选取一个进程，将处理器先分配给他<ul><li>进程调度的运行频率很高</li><li>作业调度的结果是为作业创造进程，而进程调度的结果是进程被执行</li></ul></li><li>衡量调度算法的性能： CPU利用率、系统吞吐量、响应时间、周转时间<ul><li>作业的周转时间 = 作业的完成时间 - 作业的提交时间</li><li>平均周转时间：多个作业周转时间的平均值</li><li>带权周转时间是作业周转时间与运行时间的比</li></ul></li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><ul><li>处理器分配的任务由进程调度程序完成</li><li>进程调度的功能：记录系统中所有进程的有关情况以及状态特征，选择获得处理器的进程和处理器分配</li><li>引起进程调度的原因<ul><li>当前运行进程运行结束</li><li>当前运行进程因某种原因从运行状态进入阻塞状态</li><li>执行完系统调用等系统程序后返回用户进程</li><li>在采用抢占调度方式的系统中，一个更高优先级的进程要求使用处理器</li><li>在分时系统中分配给该进程的时间片已用完</li></ul></li><li>不能进行进程调度的情况<ul><li>处理中断的过程中</li><li>在操作系统内核程序临界区中</li><li>其他需要完全屏蔽中断的原子操作过程中</li></ul></li><li>进程调度的方式：抢占方式、非抢占方式</li></ul><h4 id="常见调度算法"><a href="#常见调度算法" class="headerlink" title="常见调度算法"></a>常见调度算法</h4><ul><li>先来先服务调度算法（作业调度、进程调度）<ul><li>FCFS：按照进程进入就绪队列的先后次序来分配处理器</li></ul></li><li>短作业优先调度算法（作业调度、进程调度）<ul><li>SJF：把处理器分配给最快完成的作业或进程</li></ul></li><li>优先级调度算法（作业调度、进程调度）<ul><li>静态优先级是在创建进程时确定的，确定之后整个进程运行期间不再改变</li><li>按进程类、作业的资源要求、用户类型和要求确定静态优先级</li><li>动态优先级是指在创建进程时根据进程的特点及相关情况确定一个优先级</li><li>根据进程占有CPU时间的长短和就绪进程等待CPU时间的长短确定动态优先级</li><li>基于优先级的调度算法还可按调度方式的不同，分为非抢占优先级调度算法和抢占优先级调度算法</li><li>在优先级相同的情况下，通常按照先来先服务或者短作业优先的顺序执行</li></ul></li><li>时间片轮转调度算法（进程调度）<ul><li>分时系统必须满足系统对响应时间的要求</li><li>就绪队列中的进程数与时间片的大小成反比</li><li>系统的处理能力决定时间片的大小</li></ul></li><li>高响应比优先调度算法（作业调度）<ul><li>响应比 = 作业响应时间 / 估计运行时间</li><li>作业响应时间 = 作业等待时间 + 估计运行时间</li></ul></li><li>多级反馈队列调度算法（作业调度）<ul><li>时间片轮转调度算法和优先级调度算法的综合与发展</li></ul></li></ul><h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><ul><li><p>互斥是间接相互制约关系，而同步是直接相互制约关系</p></li><li><p>只要是同类进程即为互斥关系，不同类进程即为同步关系</p></li><li><p>临界资源：同时仅允许一个进程使用的资源</p><ul><li>进入区、临界区、退出区、剩余区</li><li>临界区：进程中用于访问临界资源的代码，又称临界段</li><li>临界资源是必须互斥访问的资源，这种资源同时只能被一个进程所使用，但需要这种资源的进程不止一个，因此需要对使用临界资源的进程进行管理</li><li>每个进程的临界区代码可以不相同</li></ul></li><li><p>互斥的要求：空闲让进，忙则等待，有限等待，让权等待</p></li><li><p>互斥实现方法</p><ul><li>软件实现方法</li><li>互斥实现的硬件方法：中断屏蔽、硬件指令</li><li>硬件方法适用范围广，支持多个临界区，但不能实现让权等待</li></ul></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>信号量 <code>(s,q)</code> 及同步原语<ul><li>整型变量 s 表示系统中某类资源的数目，q 是一个初始状态为空的队列</li><li>信号量的值仅能由 P 操作（wait）操作和 V 操作（signal）操作改变，操作系统利用它的状态对进程和资源进行管理</li><li> P 操作相当于申请资源，V 操作相当于释放资源</li></ul></li><li>信号量分为整型信号量和记录型信号量（资源信号量）<ul><li>记录型信号量添加了链表结构用于链接所有等待该资源的进程，解决忙等的问题</li></ul></li><li>信号量可以用来实现进程互斥和描述前趋关系</li></ul><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><ul><li>生产者-消费者问题<ul><li>P(full) / P(empty) 与 P(mutex) 的顺序不可倒，必须先对资源信号量进行 P 操作，再对互斥信号量进行 P 操作。否则会导致死锁</li><li>互斥信号量就是给同类进程准备的</li></ul></li><li>读者写者问题（许多进程共享数据区）<ul><li>读者不互斥，写者必须互斥</li><li>读者优先，公平情况和写者优先三种不同算法</li></ul></li><li>哲学家进餐问题<ul><li>最多允许4个哲学家同时进餐</li><li>仅当一个哲学家左右两边的筷子同时可用时，他才可以拿起筷子</li><li>将哲学家编号要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子</li></ul></li><li>理发师问题</li><li>信号量机制问题的解题步骤分析<ul><li>关系分析</li><li>确定临界资源</li><li>整理思路</li></ul></li><li>实现同步互斥的 P、V 操作必须成对出现，先进行 P 操作进入临界区，后进行 V 操作退出临界区</li><li> P、V操作要分别紧靠临界区的头尾部</li><li>通常用于互斥的信号量初值设为 1</li></ul><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><ul><li>管程定义了一个数据结构和能为并发进程所执行的一组操作<ul><li>局部于管程的数据只能被局部于管程内的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程，即进程互斥地通过调用内部过程进入管程</li></ul></li><li>管程的互斥访问完全由编译程序在编译时自动添加</li><li>为实现进程间的同步，管程还必须包含若干用于同步的设施<ul><li>局限于管程并仅能从管程内进行访问的若干变量，用于区别各种不同的等待原因</li><li>在条件变量上进行操作的两个函数过程，wait 和 signal</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>死锁的概念<ul><li>参死锁的进程至少有两个</li><li>每个参与死锁的进程均等待资源</li><li>参与死锁的进程中至少有两个进程占有资源</li><li>死锁进程是系统中当前进程集合的一个子集</li></ul></li><li>死锁产生的原因是竞争资源<ul><li>一个资源是否属于可剥夺资源，完全取决于资源本身的性质</li></ul></li><li>死锁产生的必要条件<ul><li>互斥条件</li><li>不剥夺条件</li><li>请求于保持条件：可采用预先静态分配方法</li><li>环路等待条件：可采用有序资源分配法</li></ul></li><li>处理死锁的方法：鸵鸟算法、预防死锁、避免死锁、检测及解除死锁（被动）<ul><li>死锁预防对系统加的限制条件通常很严格，对系统的并发性会产生很大的副作用</li><li>死锁避免往往在资源被分配出去之前，要计算分配之后系统是否安全</li></ul></li><li>死锁的避免<ul><li>系统在进行资源分配之前，先计算资源分配的安全性（安全序列）</li><li>并非所有不安全状态都是死锁状态，死锁是不安全状态的真子集</li><li>银行家算法</li></ul></li><li>死锁的检测和解除<ul><li>系统资源分配图（system resource allocation graph）可定义为一个二元组</li><li><code>SRAG = (V,E)</code></li><li>死锁定理：不同简化顺序将得到相同的不可简化图。系统状态 S 为死锁状态的条件是当且仅当 S 状态的资源分配图是不可完全简化的</li><li>死锁检测算法：available、allocation、request、临时变量（work与finish）</li><li>死锁解除：剥夺资源，撤销进程，进程回退</li></ul></li><li>进程与饿死<ul><li>当等待时间给进程推进和响应带来明显影响时，发生进程饥饿</li><li>当饥饿到一定程度，进程所赋予的任务即使完成也不再具有实际意义时，进程被饿死</li><li>活锁：在忙时等待条件下发生的饥饿</li><li>饥饿和饿死与资源分配策略有关，因而可从公平性方面考虑防止饥饿与饿死</li></ul></li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h4><ul><li>内存管理的功能是为多道程序的运行提供良好的环境<ul><li>内存的分配和回收：记住内存空间的使用情况、实施内存的分配、回收系统或用户释放的内存空间</li><li>地址变换：将逻辑地址转换为物理地址</li><li>扩充内存：虚拟存储技术或其他自动覆盖技术</li><li>存储保护：由硬件和软件配合完成</li></ul></li><li>应用程序的编译、链接与装入<ol><li>经过编译程序将源代码编译为若干个目标模块</li><li>通过链接程序将编译好的目标模块以及所需的库函数链接在一起，形成完整的装入模块</li><li>通过装入程序将这些装入模块装入内存并执行</li></ol></li><li>源程序（名地址）-&gt; 目标程序（逻辑地址）-&gt; 可执行程序（物理地址）<ul><li>对程序设计者来说，数据的存放地址由数据名称决定，称为名地址或符号名地址，即为源程序的地址空间</li><li>当链接程序将多个模块链接为装入模块时，链接程序会按照各个模块的相对地址，将其地址构成统一的从0号单元开始编址的相对地址</li><li>当装入程序将可执行代码装入内存时，程序的逻辑地址与程序存在内存的实际地址，通常不同这就需要通过地址转换将逻辑地址转为物理地址，这个过程叫重定位</li></ul></li><li>程序链接的 3 种方式<ul><li>静态链接：在程序运行之前，先将各目标模块及所需的库函数连接成一个完整的可执行程序（装入模块），之后不再拆开</li><li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式</li><li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是物理地址便于修改和更新，便于实现对目标模块的共享</li></ul></li><li>程序装入的 3 种方式<ul><li>绝对装入：在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码</li><li>可重定位装入：根据内存当前情况将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，容易实现，无需增加硬件地址变换机构</li><li>动态运行装入：允许程序运行时在内存中移动位置，在程序执行过程中，每当访问到相应指令或数据时，才将要访问的程序或数据的相对地址转换为物理地址，可以将程序分配到不连续的存储区中</li></ul></li><li>在重定位中通常会设一个重定位寄存器，用来存放进程分配的内存空间的地址（基址寄存器）<ul><li>当 CPU 需要访问内存时，将逻辑地址转换为物理地址</li><li>物理地址 = 基址计算器内容 + 逻辑地址</li></ul></li><li>逻辑地址和物理地址<ul><li>逻辑地址是指由程序产生的与段相关的偏移部分地址（与页无关，因为只有段对用户可见）</li><li>物理地址是指出现在 CPU 外部地址总线上的寻址物理内存的地址信号，是逻辑地址变换后的最终结果地址，物理地址空间是指内存中物理地址单元的集合</li><li>从逻辑地址到物理地址的转换过程由硬件自动完成，这个转换过程叫做地址重定位</li></ul></li><li>内存保护<ol><li>界限寄存器方法<ul><li>上、下界寄存器方法：分别存放作业的结束地址和开始地址</li><li>基址和限长寄存器方法</li></ul></li><li>存储保护键方法：给每个存储块分配一个单独的保护键</li></ol></li></ul><h4 id="交换与覆盖"><a href="#交换与覆盖" class="headerlink" title="交换与覆盖"></a>交换与覆盖</h4><ul><li>覆盖技术，就是把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位<ul><li>把程序执行时并不要求同时装入内存的复盖组成一组，称为覆盖段</li><li>将这个覆盖段分配到同一存储区域，这个存储区域称为覆盖区</li><li>覆盖区与覆盖段一一对应</li><li>覆盖技术只能覆盖与覆盖程序段无关的程序段</li><li>为了使一个覆盖区能被相应覆盖段中每个覆盖在不同时刻共享，其大小应由覆盖段中最大覆盖来确定</li><li>覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时执行程序的代码量超过主存时，程序仍然不能运行</li></ul></li><li>交换技术就是把暂时不用的某个程序及数据部分从内存移到外存中，以便腾出必要的内存空间，或把指定的程序或数据从外存读到相应的内存中，并将控制权转让给他，让其在系统上运行的一种内存扩充技术<ul><li>处理器三级调度中的中级调度就是采用了交换技术</li><li>与覆盖技术相比，交换技术不要求程序员给出程序段之间的覆盖结构，且交换主要是在进程或作业之间进行，而覆盖主要在同一个作业或进程中进行</li><li>交换进程由换出和换入两个过程组成</li><li>交换技术的特点是打破了一个程序一旦进入主存便一直运行到结束的限制，但运行的进程大小仍然受实际主存的限制</li><li>交换需要备份存储</li><li>影响交换时间的因素主要是转移时间</li><li>如果换出进程，必须确保该进程完全空闲</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统</li><li>交换通常在有许多进程运行，且内存空间紧张时开始启动，而在系统负荷减轻时暂停</li></ul></li></ul><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ul><li>内部碎片和外部碎片<ul><li>内部碎片是指已经分配给作业，但不能被利用的内部空间</li><li>外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块</li></ul></li><li>单一连续分配：将内存分为两个连续存储区域，其中一个存储区域固定的分配给操作系统使用，通常放在内存低地址部分，另一个存储区域给用户作业使用<ul><li>通常用户作业只占用所有分配空间的一部分，剩下一部分实际上浪费掉了</li><li>单一连续分配方式采用静态分配，适合单道程序，可采用覆盖技术</li><li>作业一旦进入内存，就要等到其结束后才能释放内存，因此这种分配方式不支持虚拟存储器的实现，无法实现多道程序共享主存</li><li>单一连续分配会产生内部碎片</li></ul></li><li>固定分区分配：将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序<ul><li>分区的大小可以不等，但事先必须确定，在运行时不能改变</li><li>当有空闲分区时，便从后备队列中选择一个适当大小的作业装入运行</li><li>固定分区分配中程序通常采用静态重定位方式装入内存</li><li>固定分区分配的优点是可用于多道程序系统最简单的存储分配，缺点是不能实现多进程共享一个主存区，利用率较低，会产生内部碎片</li></ul></li><li>动态分区分配：作业进入主存时，根据作业的大小动态的建立分区，并使分区的大小正好满足作业的需要，因此系统中分区的大小是可变的，分区数目也是可变的<ul><li>空闲分区表、空闲分区链</li><li>首次适应算法（FF）、下次适应算法（NF）、最佳适应算法（BF）、最差适应算法（WF）</li><li>分区回收</li><li>分区分配的动态管理：拼接技术、动态重定位分区分配技术</li></ul></li><li>动态分区分配的优缺点<ul><li>优点：实现了多道程序共用主存、管理方案相对简单、实现存储保护的手段比较简单</li><li>缺点：主存利用不够充分，存在外部碎片、无法实现多进程共享存储器信息、无法实现主存的扩充，进程地址空间受实际存储空间的限制</li></ul></li></ul><h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><ul><li>非连续分配允许一个程序分散地装入到不相邻的内存分区中</li><li>非连续分配管理方式根据分区大小是否固定为分页存储管理方式和分段存储管理方式</li><li>分页存储管理方式根据运行作业时是否需要把作业的所有页都装入内存才能运行而分为基本分页存储管理方式和请求分页存储管理方式</li><li>基本分页存储管理方式（物理单位）<ul><li>分页原理：用户作业的地址空间被划分成若干个大小相等的区域，称为页或页面</li><li>将主存的存储空间分成与页面大小相等的区域，称为块或物理块</li><li>在为作业分配存储空间时，总是以块为单位来分配，可以将作业中的任意一页放到主存的任意一块中</li><li>主存中与页面大小相等的物理块也可称为页框</li><li>为了将逻辑地址上连续的页号映射到物理内存中后成为离散分布的多个物理块，需要将每个页面和每个物理块一一对应，这种映射关系体现在页表中</li><li>每个页表项由页号和块号组成</li><li>基本地址变换机构：页表寄存器（PTR）</li><li>具有快表（TLB）的地址的地址变换机构：具有并行查找功能的高度缓冲存储器</li><li>两级页表和多级页表</li></ul></li><li>基本分页存储管理方式优缺点<ul><li>优点：内存利用率高、实现了离散分配、便于存储访问控制、无外部碎片</li><li>缺点：需要硬件支持（快表）、内存访问效率下降、共享困难、内部碎片</li></ul></li><li>基本分段存储管理方式（逻辑单位）<ul><li>逻辑地址结构由段号 S 和段内位移 W（段内偏移量）组成</li><li>段的长度不定</li><li>作业空间地址是二维的</li><li>段表及地址变换过程</li></ul></li><li>基本分段存储管理方式优缺点<ul><li>优点：便于程序模块化处理和处理变换的数据结构、便于动态链接和共享、无内部碎片</li><li>缺点：与分页类似，需要硬件支持、为满足分段的动态增长和减少外部碎片，要采用拼接手段、分段的最大尺寸受到主存可用空间的限制、有外部碎片</li></ul></li></ul><h4 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h4><ul><li><p>在真实的操作系统中，通常采用段页式存储管理，段面向用户，页面向硬件</p></li><li><p>虚拟内存解决的问题</p><ul><li>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：①作业很大时，不能全部装入内存，导致大作业无法运行；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li><li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li></ul></li><li><p>虚拟内存的实现：</p><ul><li>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行</li><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</li><li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。</li></ul></li></ul><h4 id="请求分页管理"><a href="#请求分页管理" class="headerlink" title="请求分页管理"></a>请求分页管理</h4><ul><li>请求分页管理：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</li><li>缺页中断： 在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断</li><li>缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，同时要注意，若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面</li><li>理解缺页，缺页就像货架上缺少了商品，需要从仓库里调取商品，就先暂停这个货架的销售，等商品调取完毕再重新出售。</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li><p>置换算法的评价指标是：缺页的次数，某种算法让缺页次数最低，调度效率最高，那就是最优的算法</p></li><li><p>最佳置换算法：每次淘汰的页面都是以后永久不用或最长时间不使用的页面，保证最低的缺页率。显然，这种需要预测未来的算法不可能实现。</p></li><li><p>先进先出算法FIFO：缺页时，淘汰最早进入的页面。算法简单，但局限性也明显，例如某些经常使用的页面一直被换进换出，和使用频率低的页面有相同的被换出的机会。</p></li><li><p>最近最久未使用置换算法LRU：每次淘汰的页面都是最近最久未使用的页面。需要在页面中添加一个记录项，记录上次被访问以来经历的时间t，当需要淘汰页面时，选择时间t最大的淘汰，也就是最久未使用的淘汰。算法设计虽好，但开销很大，实现困难。</p></li><li><p>时钟置换算法：时钟置换算法也可以称为最近未使用算法。是一种性能和开销均衡的算法。</p></li><li><p>简单的时钟算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)</p></li></ul><h3 id="I-O原理"><a href="#I-O原理" class="headerlink" title="I/O原理"></a>I/O原理</h3><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><ul><li><p>文件可以分为两类：</p><ul><li><p>无结构文件：文件内部数据就是一系列二进制流或字符流。最典型的就是txt文件。</p></li><li><p>有结构文件：由一组相似的记录组成，又称记录式文件。典型的excel表、数据库表等。</p></li></ul></li><li><p>有结构文件的逻辑结构又分顺序文件、索引文件、索引顺序文件，注意逻辑结构是展示给用户的，是文件的组织形式，例如是一张顺序存储的excel表格，还是一张excel索引表加上excel顺序表，还是多级索引加顺序，而不是在计算机上的存储方式。</p></li><li><p>顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p></li><li><p>顺序存储即逻辑相邻的文件物理上也相邻，链式存储即在末尾添加新的文件。</p></li><li><p>记录的类型又分为可变长和不可变长记录</p></li></ul><ul><li>索引顺序文件：索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项，索引表项的地址直接指向顺序文件所在区域，再顺序查找到所需的文件，从而节省了很大的空间。(例如我们可以通过An Qi找到An Kang、An Jie等，而不用在索引表中存放这么多信息。另外索引项之间不需要有按照逻辑关系排列)</li><li>多级索引顺序文件：在索引顺序文件的基础上再增加层次深度，可以减少查找的次数(顺序查找范围缩小了)</li></ul><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><ul><li><p>文件目录可以分为：单级目录结构、两级目录结构、多级目录结构(树形目录结构)</p></li><li><p>单极目录结构：顾名思义，所有的文件放在一个目录中，类似于一个仓库把所有文件不加整理的堆放在一起，显然效率会很低下</p></li><li><p>两级目录结构:主要分为主文件目录和用户文件目录。类似于仓库中加了几个员工货架，不同员工的货物放在不同货架，但在一个货架中文件还是采用堆砌式的存储。</p></li><li><p>多级目录结构，又称树形目录结构:我们当前主流操作系统都是多级目录结构，简而言之就是文件目录可以一级一级的延申，从而文件更有条理。</p></li><li><p>FCB(文件控制块)，首先来看一张图，如果文件目录都以这种表的形式进行信息查找，会大大降低运行效率，增加系统负担。</p></li><li><p>提出对策，其实在查找各级目录的过程中，只需要用到文件名这个信息，可以考虑让目录表瘦身来提升效率。</p></li><li><p>索引结点指针指向索引结点(文件名之外的其他信息就存放在结点中，从而按需读取，提升效率)</p></li><li><p>每一个文件都有一个FCB，记录了文件的地址、信息、权限等等属性</p></li></ul><h4 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h4><ul><li><p>最重要的三种物理结构：顺序、链接、索引，其中最主要使用的是索引文件，可以随机访问，同时增删效率高</p></li><li><p>文件的物理结构是文件分配在计算机存储上的分配方式。分配的基本单位是 物理块,可以构想一下，一个大文件，如一首音乐23MB，难道直接一整个塞入硬盘吗？显然可能会出现一些问题，硬盘的空间也需要不断调整，就像内存分页一样，硬盘也被分为小的物理块号方便进行调度。</p></li><li><p>连续分配</p><ul><li>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</li><li>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</li></ul></li><li><p>链式分配</p><ul><li>隐式：采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul></li></ul><ul><li><p>显式：直观理解就是在隐式的基础上添加了一张表，从表上能看出不同物理块号的下一块的地址</p></li><li><p>结论：采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问i 号逻辑块时，并不需要依次访问之前的0 ~ i-1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多</p></li><li><p>显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。</p></li><li><p>索引分配</p><ul><li>索引就是文件分成不同的物理块存入磁盘，对每个物理块都有一个索引与之对应，需要读写时就通过索引表查询其物理地址进行相关操作</li></ul></li></ul><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><ul><li><p>磁道：每一圈就是一个磁道，最内侧磁道面积最小，所以数据密度最大</p></li><li><p>扇区：磁道被划分为小的磁盘块</p></li><li><p>一个盘片可能有两个盘面;每个盘面对应一个磁头；所有磁头连在一起，共进退；每个盘面的相对位置的磁道组成柱面</p></li></ul><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><ul><li><p>磁盘调度算法要解决的核心问题就是寻道时间，即移动磁头的时间，而其他的启动时间、传输时间都很迅速，不是最主要的时间消耗</p></li><li><p>先来先服务FCFS</p><ul><li>根据进程请求房屋内磁盘的现后顺序进行调度。符合惯性思维，但在很多时候，效果很差。</li></ul></li><li><p>最短寻找时间优先(学过数据结构与算法的话，核心思想就是贪心算法)，该算法会优先处理与当前磁头最近的磁道的需求</p><ul><li>那么很可能磁头就会如图所示的移动，也会存在饥饿问题：磁头只在一个小区域移动，而不能满足需要远距离移动的需求。例如不断有18-&gt;38，38-&gt;18的需求，那磁头就不会执行18-&gt;150的请求，从而产生饥饿</li></ul></li><li><p>扫描算法</p><ul><li>核心思想，只有磁头移动到最外侧磁道的时候才能往内侧移动，移动到最内侧的时候才能向外侧移动。这样就不会产生饥饿问题。</li></ul></li></ul><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><ul><li>文件共享分两种链接方式，硬链接和软连接<ul><li>硬链接就是在另一个用户的目录中，索引结点指针直接指向了发送分享的用户的索引节点，从而实现了共享，count的数量代表文件正在被几个用户使用。</li><li>软连接，类似于快捷方式，记录了原文件的路径，然后层层查找。</li></ul></li></ul><h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><ul><li><p>文件保护有三种方式口令、加密、访问控制</p><ul><li>口令：为文件设置一串口令，就像打开手机需要先解锁。</li></ul></li></ul><ul><li><p>加密：使用加密方法对文件加密，只有拥有正确的解密方法才能解密，有点像不同军队之间进行通信，要实现进行加密，要是想窥探敌情，就要对密文进行破解。</p></li><li><p>访问控制：每个文件的FCB或者索引结点中设置访问控制表，如windows中，设置了很多的访问权限，例如</p></li></ul><h4 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h4><ul><li><p>I/O就是输入输出，I/O设备就是可以将数据输入到计算机或将计算机数据输出的设备，常见的：鼠标、键盘、音响、显示器、打印机、话筒、摄像头等等。</p></li><li><p>I/O控制器:CPU无法直接控制I/O设备，需要一个电子部件去充当中间人，这个部件就是I/O控制器，CPU控制I/O控制器，I/O控制器控制I/O设备。</p></li><li><p>假如我们的CPU能够控制I/O设备，那不同的厂商、不同型号的设备，都要对应进行编码，显然是不切实际的，所以CPU要采用通用调度方式调度I/O设备从而需要I/O控制器。</p></li><li><p>Java语言中，调用System.out.Println()，这本身并不能在显示器上打印，而需要通过操作系统调用write方法，接着调用字符设备接口，命令显示器写</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="慕课MOOC" scheme="http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2022-05-05T12:50:52.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。</p></blockquote><a id="more"></a><h3 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h3><h4 id="计算机系统的多层次结构"><a href="#计算机系统的多层次结构" class="headerlink" title="计算机系统的多层次结构"></a>计算机系统的多层次结构</h4><ul><li>硬件：<ol><li>微程序机器层M0（微指令系统），由硬件直接执行微指令</li><li>传统机器M1（机器语言机器），用微程序解释机器指令</li></ol></li><li>软件：<ol><li>虚拟机器M2（操作系统机器），用机器语言解释操作系统</li><li>汇编语言M3（汇编语言机器），用汇编程序翻译成机器语言程序</li><li>虚拟机器M4（高级语言机器），用编译程序翻译成汇编语言程序</li></ol></li></ul><h4 id="冯·诺依曼机"><a href="#冯·诺依曼机" class="headerlink" title="冯·诺依曼机"></a>冯·诺依曼机</h4><ul><li><p>基本工作方式：控制流驱动方式</p></li><li><p>最根本的特征：采用存储程序原理，即按地址访问并顺序执行指令</p></li><li><p>指令和数据均以二进制形式存放在存储器中</p></li><li><p>CPU区分依据是：指令周期的不同阶段</p></li><li><p>冯·诺依曼计算机：以运算器为中心</p></li><li><p>现代的计算器：以存储器为中心</p></li><li><p>5大部件：存储器、运算器、控制器、输入设备、输出设备（适配器）</p></li><li><p>三大部分：CPU（运算器、控制器）、I/O设备（输入设备、输出设备）、主存储器</p></li><li><p>哈佛结构：将指令和数据放在两个独立的存储器，允许在一个机器周期内同时获得指令和操作数，提高了执行速度</p></li></ul><h4 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h4><ul><li><p>机器字长：</p><ul><li>CPU一次能处理数据的位数，通常与CPU的寄存器位数有关，字长越长，精度越高</li><li>机器的字长也会影响机器的运算速度：字长较短，运算位数多，可能需要多次运算才能完成</li><li>对硬件造价有影响：直接影响ALU、数据总线以及存储字长的位数</li></ul></li><li><p>存储容量：主存容量、辅存容量</p></li></ul><ul><li><p>运算速度：</p><ul><li>吞吐量和响应时间</li><li>主频和CPU时钟周期</li><li>CPI：执行一条指令所需的时钟周期数</li><li>CPU执行时间：指运行一个程序所花费的时间。取决于：主频、CPI、指令条数</li><li>MIPS：每秒执行多少百万条指令</li><li>MFLOPS：每秒执行多少百万次浮点运算（标志系统性能最有用参数）</li><li>GFLOPS：每秒执行多少十亿次浮点运算</li><li>TFLOPS：每秒执行多少万亿次浮点运算</li></ul></li></ul><h3 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h3><h4 id="汉字的编码"><a href="#汉字的编码" class="headerlink" title="汉字的编码"></a>汉字的编码</h4><ul><li>输入码（外码）：区位码、国际码、拼音码、电报码、表形码等</li><li>内码：0、1（机器码）</li><li>输出码：汉字字形码</li><li>汉字编码包括汉字的输入编码、汉字内码、汉字字形。用两个字节表示一个汉字，每个字节用七位码。区位码是4位十进制数，前2位是区码，后2位是位码</li><li>国标码是将十进制的区位码转换为十六进制后，再在每个字节上加上20H。为了方便计算机区分中文字符和英文字符，将国标码两个字节的最高位都改为“1”，这就是汉字内码（十六进制）</li></ul><h4 id="字符串的存放"><a href="#字符串的存放" class="headerlink" title="字符串的存放"></a>字符串的存放</h4><ul><li>小端模式：按先存储低位字节、后存储高位字节的顺序存放字符串的内容</li><li>大端模式：按先存储高位字节、后存储低位字节的顺序存放字符串的内容</li></ul><h4 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h4><ul><li>奇偶校验码：只能检出一位错误，不能确定出错的位置；只能检验处奇数位错误，不能检测出偶数位错误。<ul><li>奇校验码：整个校验码中“1”的个数为奇数。</li><li>偶校验码：整个校验码中“1”的个数为偶数。</li></ul></li><li>海明（汉明）检验码：可检出错位位置</li><li>循环冗余校验（CRC）码：可检出错误位置（通过除法运算）</li></ul><h4 id="原码、反码、补码、移码"><a href="#原码、反码、补码、移码" class="headerlink" title="原码、反码、补码、移码"></a>原码、反码、补码、移码</h4><ul><li>原码、补码、反码三种机器数的最高位均是符号位</li><li>当真值为正时，原码、补码、反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同</li><li>当真值为负时，原码、补码、反码的表示形式不同，但其符号位都用“1”表示，而数值部分补码是原码的“求反加1”，反码是原码的“每位求反”。</li><li>同一个真值的移码和补码仅差一个符号位。</li><li>4、不同机器数表示±0时，其形式不同。</li><li>[+0]原≠[-0]原， [+0]反≠[-0]反，[+0]补=[-0]补，[+0]移=[-0]移</li><li>当机器字长确定后，补码比原码、反码能多表示一个负数</li><li>移码只能表示整数，用它表示浮点数的阶码时，能方便地判断阶码的大小</li></ul><h4 id="补码定点数的加-减运算"><a href="#补码定点数的加-减运算" class="headerlink" title="补码定点数的加/减运算"></a>补码定点数的加/减运算</h4><ul><li>基本公式：（将符号位和数值部分一起参加运算，并且将符号位产生的进位自然丢掉即可）</li><li>加法：[A]补+[B]补=[A+B]补</li><li>减法：[A-B]补=[A]补+[-B]补（[-B]补由[B]补连同符号位在内，每位取反，末尾加1）</li></ul><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><ul><li>用一位符号判断溢出：实际参加操作的两个数符号相同，结果又与原操作数的符号不同，即为溢出</li><li>用两位符号位判断溢出：当2位符号位不同时，表示溢出，否则，无溢出。不论是否发生溢出，高位（第1位）符号永远代表真正的符号。（变形补码，运算时多一位）</li><li>01正溢出（上溢）；10负溢出（下溢）</li><li>采用一位符号位根据数据位的进位情况判断溢出。如果符号位的进位与最高数位的进位不同，则表示结果溢出</li></ul><h4 id="浮点数的加-减运算"><a href="#浮点数的加-减运算" class="headerlink" title="浮点数的加/减运算"></a>浮点数的加/减运算</h4><ul><li>对阶：两个数的小数点位置对齐（使阶码相等），两个数的阶码相减求阶差，使小阶的尾数向右移位，每右移一位，阶码加1</li><li>尾数求和：将对阶后的两个尾数按定点加（减）运算规则进行运算</li><li>规格化：补码规格化形式为[S]补 00.1××××；[S]补 11.0××××<ul><li>左规：尾数出现00.0××××或11.1××××时，需左规。尾数左移一位，阶码减1</li><li>右规：尾数出现01.××××或10.××××时，表示尾数溢出，但在浮点运算中不算溢出，可通过右规处理。尾数右移一位，阶码加1</li></ul></li><li>舍入：在对阶和右规的过程中，可能会将尾数的低位丢失，引起误差，影响精度，用舍入法来提高尾数的精度<ul><li>“0舍1入”法：被移去的最高位数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。又溢出时，再右规……</li><li>“恒置1”法：不论丢掉的最高数位是“1”还是“0”，都使尾数末位恒置“1”。</li><li>两种方法同样都有使尾数变大和变小两种可能</li></ul></li><li>溢出判断（是否溢出由阶码的符号决定）<ul><li>上溢：阶码[j]补=01，×××，作溢出处理</li><li>下溢：阶码[j]补=10，×××，按机器零处理</li></ul></li></ul><h4 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h4><ul><li><p>上溢：当浮点数阶码大于最大阶码时，上溢，机器停止运算，进行中断溢出处理。</p></li><li><p>下溢：当浮点数阶码小于最小阶码时，下溢，溢出的数绝对值很小，通常将位数各位强制为0，按机器零处理，机器可以继续运行。</p></li></ul><h4 id="8位二进制整数范围"><a href="#8位二进制整数范围" class="headerlink" title="8位二进制整数范围"></a>8位二进制整数范围</h4><ul><li>原码、反码：-127—+127</li><li>补码、移码：-128—+127</li></ul><h4 id="标准IEEE-754标准"><a href="#标准IEEE-754标准" class="headerlink" title="标准IEEE 754标准"></a>标准IEEE 754标准</h4><ul><li><p>现代计算机中，浮点数一般采用IEEE制定的国际标准：</p></li><li><p>常用的浮点数有三种：阶码用移码表示</p></li><li><p>短实数、长实数、临时实数的偏移量用十六进制数表示分别为7FH（127）、3FFH、3FFFH</p></li><li><p>尾数部分通常是用原码、规格化表示，即非“0”的有效位最高位总是“1”，但在IEEE标准中，有效位呈如下形式：1▲ff…ffff</p></li><li><p>其中▲表示假想的二进制小数点。在实际表示中，对短实数和长实数，这个整数位的1省略，称隐藏位；对于临时实数不采用隐藏位方案</p></li></ul><h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><h4 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h4><ul><li><p>存储器主要性能指标：速度、容量、每位价格（位价）</p></li><li><p>一般来说，速度越高，位价越高；容量越大，位价越低；容量越大，速度越低。</p></li><li><p>层次结构主要体现在缓存-主存和主存-辅存这两个层次上。</p><ul><li>缓存-主存：主要解决CPU和主存速度不匹配问题（由硬件自动完成）数据调动对任何程序员透明。</li><li>主存-辅存：主要解决存储系统的容量问题（由硬件和操作系统共同完成）数据调动对应用程序员透明</li></ul></li></ul><h4 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h4><ul><li>一般取2ms，对动态RAM的全部基本单元电路必作一次刷新，称为刷新周期，又称再生周期。刷新的单位是行，仅需要行地址。</li><li>集中刷新：在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作，称“死时间”或“死区”。（全部一起刷）</li><li>分散刷新：对每行存储单元的刷新分到每个存取周期内完成。优点：没有死区。缺点：存取周期加长，整个系统速度降低。（一个个刷）</li><li>异步刷新：是前两种方式的结合，既缩短“死时间”，又充分利用最大刷新时间间隔为2ms的特点。（一行行刷）</li><li>一行行刷的平均刷新时间<ul><li>行数 = 芯片容量 / 每行存储单元个数</li><li>平均刷新时间 = 间隔最长 / 行数</li></ul></li></ul><h5 id="存储容量的扩展"><a href="#存储容量的扩展" class="headerlink" title="存储容量的扩展"></a>存储容量的扩展</h5><ul><li>位扩展<ul><li>增加存储字长</li><li>例如：2片1K4位的存储芯片可组成1K8位的存储器。</li><li>注意：其中一片的数据线作为高4位D7-D4，另一片的数据线作为低4位D3-D0。</li></ul></li><li>字扩展<ul><li>增加存储器字的数量</li><li>例如：2片1K8位的存储芯片可组成一个2K8位的存储器。</li><li>注意：两片都连地址线A0-A9。（从低位连起）</li></ul></li><li>字、位扩展<ul><li>既增加存储字的数量又增加存储字长。</li></ul></li></ul><h4 id="双口RAM和多模块存储器"><a href="#双口RAM和多模块存储器" class="headerlink" title="双口RAM和多模块存储器"></a>双口RAM和多模块存储器</h4><ul><li>为了提高CPU访问存储器的速度，可以采用双端口存储器（空间并行）、多模块存储器（时间并行）等技术，都属于并行技术。</li></ul><h4 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h4><ul><li>为了提高访存速度（CPU速度比存储器快，同时从存储器中取出n条指令，可以充分利用CPU资源，提高运行速度）</li><li>单体多字系统<ul><li>在一个存取周期内，从同一地址取出n条指令，然后逐条将指令送至CPU执行，即每隔1/n存取周期，主存向CPU送一条指令，增大了存储器的带宽，提高了存储器的工作速度。</li><li>例如：从同一地址取出4条指令，为单体四字结构，每字W位。按地址在一个存取周期内可读出4*W位的指令或数据，使主存带宽提高到4倍。</li><li>缺点：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。</li></ul></li><li>多体并行系统</li><li>采用多提模块组成的存储器。每个模块可以并行工作，也可以交叉工作。<ul><li>低位交叉编址<ul><li>程序连续存放在相邻体中（交叉存储）。低位地址表示体号，高位地址表示体内地址。<br>地址的低n为片选。</li><li>优点：相邻地址单元的数据放在不同组，各组可以并行工作，能较好提高存储器的带宽。</li><li>缺点：某一组出现故障，会影响整个存储器的正常工作。</li></ul></li><li>高位交叉编址<ul><li>按体内地址顺序存放（顺序存储）。高位地址表示体号，低位地址表示体内地址。</li><li>地址的高n位片选。</li><li>优点： 某一组的故障不影响其他组，且容易通过添加模块来扩充容量。</li><li>缺点：相邻地址单元的数据放在同一组存储单元，各组间串行工作，不利于提升存储器的带宽。</li></ul></li></ul></li></ul><h4 id="Cache中主存块之间的映射方式"><a href="#Cache中主存块之间的映射方式" class="headerlink" title="Cache中主存块之间的映射方式"></a>Cache中主存块之间的映射方式</h4><ul><li>由主存地址映射到Cache地址称为地址映射</li><li>直接映射<ul><li>主存数据只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无需使用替换算法）。</li><li>优点：实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。</li><li>缺点：不够灵活，降低命中率。</li></ul></li><li>全相联映射<ul><li>允许主存中每一字块映射到Cache中的任何一块位置上。可以从已被占满的Cache中替换出任一旧字块。</li><li>通常采用昂贵的“按内容寻址”的相联存储器来完成。</li><li>优点：灵活，命中率高，缩小了块冲突率，空间利用率高。</li><li>缺点：地址变换速度慢，实现成本高</li></ul></li><li>组相联映射（上述两种映射的折中）<ul><li>将Cache空间分成大小相同的组，主存的一个数据块可以装入到一组内的任何一个位置（组间采取直接映射，组内采取全相联映射）。</li></ul></li></ul><h4 id="Cache中主存块的替换算法"><a href="#Cache中主存块的替换算法" class="headerlink" title="Cache中主存块的替换算法"></a>Cache中主存块的替换算法</h4><ul><li>先进先出（First-In-First-Out，FIFO）算法</li><li>近期最少使用（Least Recently Used，LRU）算法</li><li>随机法</li></ul><h4 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h4><ul><li>磁盘寻址的最小单位是扇区。</li><li>道密度：沿磁盘半径方向单位长度的磁道数。</li><li>位密度：单位长度磁道上记录二进制的位数。</li><li>平均寻道时间：从一个磁道转移到另一个磁道的平均时间。（全部寻道时间的一半）</li><li>平均等待时间：旋转等待的平均时间。（转一周时间的一半）</li><li>一扇区的传送时间：T=1 / (转速×扇区数)</li><li>存取一个扇区的时间：T=每个扇区位数 / (转速×扇区数)</li><li>平均存取时间=平均寻道时间 + 平均等待时间 + 传输时间</li><li>每个记录面的磁道数：K=[(外直径-内直径)/2]*磁道密度</li><li>盘组格式化容量：C = 记录面数 * K * 每个扇区字节数 * 扇区数</li><li>盘组非格式化容量：CN = 记录面数 * K * 最内圈磁道周长 * 内层位密度</li><li>WE 为写允许信号：低电平0为写，高电平1为读</li><li>CS为片选信号：低电平0有效</li><li>借位/进位C：1=结果的最高位发生了进位，0=结果的最高位未发生进位</li><li>溢出标志位V：1=溢出，0=没有溢出</li></ul><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><h4 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h4><ul><li>寻址模式是大多数中央处理器 （CPU）设计中的指令集架构的一个方面</li><li>在给定指令集架构中定义的各种寻址模式决定了该架构中的机器语言指令如何识别每个指令的操作数</li><li>寻址模式指定如何通过使用寄存器中保存的信息和/或机器指令中包含的常量或其他地方包含的常量来计算操作数的有效存储器地址。</li></ul><h4 id="CISC和RISE"><a href="#CISC和RISE" class="headerlink" title="CISC和RISE"></a>CISC和RISE</h4><ul><li>从硬件角度来看CISC处理的是不等长指令集，它必须对不等长指令进行分割，因此在执行单一指令的时候需要进行较多的处理工作。而RISC执行的是等长精简指令集，CPU在执行指令的时候速度较快且性能稳定。因此在并行处理方面RISC明显优于CISC，RISC可同时执行多条指令，它可将一条指令分割成若干个进程或线程，交由多个处理器同时执行。由于RISC执行的是精简指令集，所以它的制造工艺简单且成本低廉。</li><li>从软件角度来看，CISC运行的则是我们所熟识的DOS、Windows操作系统。而且它拥有大量的应用程序。因为全世界有65%以上的软件厂商都理为基于CISC体系结构的PC及其兼容机服务的，象赫赫有名的Microsoft就是其中的一家。而RISC在此方面却显得有些势单力薄。虽然在RISC上也可运行DOS、Windows，但是需要一个翻译过程，所以运行速度要慢许多。</li></ul><h4 id="地址指令操作数物理位置的三种形式"><a href="#地址指令操作数物理位置的三种形式" class="headerlink" title="地址指令操作数物理位置的三种形式"></a>地址指令操作数物理位置的三种形式</h4><ul><li>寄存器——寄存器型（RR型）；</li><li>寄存器——存储器型指令（RS型）；</li><li>存储器——存储器型（SS型）。</li></ul><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><h4 id="计算机工作过程"><a href="#计算机工作过程" class="headerlink" title="计算机工作过程"></a>计算机工作过程</h4><ul><li>加电——》产生reset信号——》执行程序——》停机——》停电</li><li>产生reset信号的任务<ul><li>任务一：使计算机处于初始状态</li><li>任务二：从PC中取出指令地址</li></ul></li><li>控制器作用是协调并控制计算机各部件执行程序的指令序列</li></ul><h4 id="控制器的组成"><a href="#控制器的组成" class="headerlink" title="控制器的组成"></a>控制器的组成</h4><ul><li>控制器的功能<ul><li>取指令：发出指令地址，取出指令的内容</li></ul></li><li>分析指令<ul><li>对操作码译码产生操作相应部件的控制信号</li><li>根据寻址方式形成操作数地址</li></ul></li><li>执行指令<ul><li>根据分析指令后产生控制信号、操作数地址信号序列，通过CPU及输入输出设备的执行实现每条指令的功能</li><li>结果回送存储器</li><li>形成下条指令的地址</li></ul></li><li>控制程序和数据的输入和结果输出</li><li>对异常情况和某些请求的处理<ul><li>异常情况的处理：例如算术运算的溢出、数据传送奇偶错</li><li>某些请求的处理</li><li>“中断请求”信号</li><li>DMA请求信号</li></ul></li><li>控制器的组成<ul><li>程序计数器（PC）：即地址寄存器，用来存放当前正在执行的指令地址或即将要执行的下一条指令地址</li><li>指令寄存器（IR）：用以存放当前正在执行的指令，以便在指令执行过程中控制完成一条指令的全部功能</li><li>指令译码器或操作码译码器：对指令寄存器中的操作码进行分析解释，产生相应的控制信号</li><li>脉冲源及启停线路：脉冲源参数一定评率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号，在机器刚加电时，还应产生一个总清信号（reset）</li><li>时序控制信号形成部件：当程序启动后，在CLK时钟作用下，根据当前正在执行的指令的需要，产生相应的时序控制信号，并根据被控制功能部件的反馈信号调整时序控制信号<ul><li>控制存储器</li><li>微指令寄存器：控制字段+下址</li></ul></li></ul></li><li>周期概念<ul><li>指令周期：完成一条指令所需的时间，包括取指令、分析指令、执行指令</li><li>机器周期：也称为CPU周期，是CPU从内存中读取一个指令的时间，通常等于取指周期</li><li>时钟周期：称为节拍脉冲或T周期，是基准脉冲信号</li><li>三条假设<ul><li>程序是存放在主存中的，当执行完一条指令后才从主存中取下一条指令（非流水线）</li><li>指令的长度是固定的，并限制了寻址方式的多样化</li><li>在程序运行前，程序和数据都已存在主存中</li></ul></li></ul></li><li>指令执行过程（运算器和控制器配合）</li><li>组成控制器的基本电路<ul><li>具有记忆功能的触发器以及由它组成的寄存器，计数器和存储单元</li><li>没有记忆功能的门电路及由它组成的加法器，算术逻辑运算单元（ALU）和各种逻辑电路</li></ul></li><li>控制器的功能就是按每一条指令的要求产生所需的控制信号</li><li>产生控制信号的方法<ul><li>微程序控制</li><li>硬布线控制</li></ul></li></ul><h4 id="微程序控制计算机的基本工作原理"><a href="#微程序控制计算机的基本工作原理" class="headerlink" title="微程序控制计算机的基本工作原理"></a>微程序控制计算机的基本工作原理</h4><ul><li>微指令：在微程序控制的计算机中，将由同时发出的控制信号所执行的一组微操作</li><li>微命令：将指令分为若干条微指令，按次序执行这些微指令。组成微指令的操作即微命令</li><li>微程序：计算机的程序由指令序列构成，而计算机每条指令的功能均由微指令序列解释完成，这些微指令序列的集合就叫做微程序</li><li>控制存储器<ul><li>微程序一般是存放在专门的存储器中的，由于该存储器主要存放控制命令（信号）与下一条执行的微指令地址（简称下址）</li><li>存储单元内容<ul><li>微指令的控制信号——控制位</li><li>下条微指令的地址——下址字段</li></ul></li><li>存储芯片：ROM</li></ul></li><li>执行一条指令实际上就是执行一段存放在控制存储器中的微程序</li><li>实现微程序控制的基本原理<ul><li>控制信号（23条）</li><li>加法的过程</li><li>微指令格式：控制字段+下址字段</li><li>23个控制位，12个下址位——》容量为4K</li><li>取址微指令的操作对所有指令都是相同的，所以是一条公用的微指令，其下址由操作码译码产生</li></ul></li><li>微程序控制器</li><li>时序信号及工作脉冲的形成</li><li>停机和停电的区别</li><li>停机：电压稳定、存放内容保持、重启PC内容为断点指令地址</li><li>停电：电压消失、RAM的内容消失、重启PC内容为第一条指令地址</li></ul><h4 id="微程序设计技术"><a href="#微程序设计技术" class="headerlink" title="微程序设计技术"></a>微程序设计技术</h4><ul><li>如何缩短微指令字长<ul><li>直接控制法（容量太小）<ul><li>编译方法：每一位代表一个控制信号，直接送往相应的控制点</li><li>优点：控制简单</li><li>缺点：微指令字长过大</li></ul></li><li>字段直接编译法<ul><li>选出互斥的微指令</li><li>每个字段都要留出一个代码，表示本段不发出任何指令（000）</li><li>优点：节省微指令的字长</li><li>缺点：增加了额外的硬件开销</li></ul></li><li>字段间接编译法<ul><li>指令之间相互联系的情况</li><li>举例：A为0-7，B为0-3，如果是直接编译——3+2=5，如果是间接编译——3+1=4</li><li>编码方法：在字段直接编译法中，译码输出端要兼由另一字段中的某些微命令配合解释</li><li>优点：减少了微指令长度</li><li>缺点：可能削弱微指令的并行控制能力，同时增加硬件开销</li></ul></li><li>常熟源字段E</li></ul></li><li>如何减少微指令长度<ul><li>现行微指令/微地址<ul><li>现行微指令：当前正在执行的指令</li><li>现行微地址：存放现行微指令的控制器存储单元</li></ul></li><li>后继微指令/微地址<ul><li>后继微指令：下一条要执行的微指令</li><li>后继微地址：存放后继微指令的控制器存储单元</li></ul></li><li>增量与下址字段结合产生后继微指令的方法<ul><li>下址字段分成：转移控制字段BCF和转移地址字段BAF<ul><li>BCF：控制微程序的转移情况</li><li>BAF：转移后的微指令所在地址</li></ul></li><li>BAF有两种情况<ul><li>与uPC的位数相等——转移灵活，但增加微指令长度</li><li>比uPC短——转移地址收到限制，但可缩短微指令长度</li></ul></li><li>优点：微指令的下址字段很短，仅用于选择输入uPC计数器的某条线路有效</li><li>缺点：微程序转移不灵活，使得微程序在控存中的物理空间分配有困难</li></ul></li><li>多路转移方式：一条微指令存在多个转移分支的情况称为多路转移</li><li>微中断<ul><li>微中断请求信号是由程序中断请求信号引起的</li><li>在完成现行指令的微程序后响应该微中断请求</li><li>由硬件产生对应微中断处理程序在控存中的入口地址</li></ul></li></ul></li><li>如何提高微程序的执行速度<ul><li>微指令格式</li><li>水平型微指令——直接控制，字段编译（直接、间接）<ul><li>特点：在一条微指令中定义并并行执行多个微命令</li></ul></li><li>垂直型微指令<ul><li>特点：不强调实现微指令的并行控制功能</li><li>定义：采用微操作码编译法，由操作码规定微指令的功能</li></ul></li><li>微程序控制存储器<ul><li>一般采用ROM存储器</li><li>也可采用RAM，为防止断电后内容消失，则必须开机后将外存中存放的微程序调入控存RAM，然后才能执行程序。</li><li>当前为了能不断扩展指令系统，通常采用ROM+RAM</li></ul></li><li>动态微程序设计<ul><li>定义：能根据用户要求改变微程序</li><li>优点：是计算机能更灵活、有效的适应于各种不同的应用目标</li></ul></li><li>控制存储器的操作<ul><li>串行方式</li><li>并行方式——比串行多了微指令寄存器</li><li>微周期=max(取微指令时间,执行微指令时间)</li><li>由于取微指令、执行微指令同时进行，故对于某些后继微地址的产生根据处理结果而定的微指令，则延迟一个微周期再取微指令</li></ul></li></ul></li></ul><h4 id="硬布线控制的计算机（RISC）——特点快"><a href="#硬布线控制的计算机（RISC）——特点快" class="headerlink" title="硬布线控制的计算机（RISC）——特点快"></a>硬布线控制的计算机（RISC）——特点快</h4><ul><li>形成操作控制信号的逻辑框图</li><li>操作控制信号的产生<ul><li>取值周期cy1所产生的信号对所有指令都是相同的，即与当前执行的指令无关，逻辑式得到最简单的形式</li><li>通常，同一个控制控制信号在若干条指令的某些周期（或再加上一些条件）中都需要，为此需要把它们组合起来</li><li>同种类型的指令所需要的控制信号大部分是相同的，仅有少量区别</li><li>在确定指令的操作码时（即对具体指令赋予二进制操作码），为了便于逻辑表达式的化简以减少逻辑电路数量，往往给予特别关注</li></ul></li><li>设计组合逻辑电路从而产生需要的控制信号的步骤<ol><li>实际逻辑问题</li><li>真值表</li><li>公式化简</li><li>逻辑电路图</li></ol></li><li>设计目标：使用最少的电路元件达到最高的操作速度</li></ul><h4 id="流水线工作原理"><a href="#流水线工作原理" class="headerlink" title="流水线工作原理"></a>流水线工作原理</h4><ul><li>每条指令的执行时间不变</li><li>每条指令处理结果的时间缩短</li><li>流水线处理速率最高时=流水线处于满载的稳定状态</li><li>流水线处理速率最低时=流水线未满载状态</li><li>为了满足在重叠时间段不同指令的机器周期能够完成指定的操作，将时间段=操作完成的最长时间</li><li>为了保证一个周期内流水线的输入信号不变，相邻时间段之间必须设置锁存器或寄存器</li><li>除了指令执行流水线，还有运算操作流水线</li><li>流水线阻塞<ul><li>数据相关产生</li><li>假设第二条指令需要的操作数是第一条指令运算的结果，那么出现了数据相关</li><li>指令执行时间不同产生</li><li>程序转移的影响</li><li>异常情况响应中断</li></ul></li></ul><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><h4 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h4><ul><li>cache-&gt;主存-&gt;辅存</li></ul><h4 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h4><ul><li>cache的工作原理<ul><li>局部性原理</li><li>主存地址和cache地址（P166 图7.2）</li><li>块长：块长一般取一个主存周期所能调出的信息长度（一般为16个字）</li><li>cache的容量和块的大小是影响cache的效率的重要因素</li><li>命中率：CPU所要访问的信息是否在cache中的比率，而将所要访问的信息不在cache中的比率称为失败率</li><li>一致性策略<ul><li>标志交换方式（写回法）</li><li>通过式写入（写通法）</li><li>写操作直接对主存进行，而不写入cache</li></ul></li><li>cache的平均存取时间=h*tc+(1-h)(tc+tm)</li><li>最好替换策略：按照被替换的字块是下一段时间最少使用的，由替换部件实现</li></ul></li><li>cache组织地址映像<ul><li>直接映像<ul><li>cache中许多空的位置被浪费</li><li>主存地址：主存字块标记+cache字块地址+字块内地址</li></ul></li><li>全相联映像<ul><li>成本太高而不能采用</li><li>主存地址：主存字块标记+字块内地址</li><li>优点</li><li>方式灵活，缩小了块发生冲突的概率</li><li>缺点</li><li>增加了标识位位数</li><li>增加了寻找主存块在cache中对应块的时间</li></ul></li><li>组相联映像<ul><li>直接映像和全相联映像的折衷</li><li>主存地址：主存字块标记+组地址+块内地址</li></ul></li></ul></li></ul><h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><ul><li>存储管理部件（MMU）</li><li>现代计算机一般都有辅助存储器，但具有辅存的存储系统不一定是虚拟存储系统</li><li>虚拟存储系统的特点<ul><li>允许用户程序用比主存大的多的空间来访问主存</li><li>每次访存都要进行虚实地址的转换</li></ul></li></ul><h3 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h3><ul><li>半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器</li></ul><h4 id="辅助存储器的种类"><a href="#辅助存储器的种类" class="headerlink" title="辅助存储器的种类"></a>辅助存储器的种类</h4><ul><li>磁表面存储器<ul><li>数字式磁记录：硬盘、软盘和磁带</li><li>模拟式磁记录：录音、录像设备</li></ul></li><li>光存储器：光盘</li></ul><h5 id="串行存储器"><a href="#串行存储器" class="headerlink" title="串行存储器"></a>串行存储器</h5><ul><li>顺序存取存储器</li><li>直接存取存储器</li></ul><h5 id="辅助存储器的技术指标"><a href="#辅助存储器的技术指标" class="headerlink" title="辅助存储器的技术指标"></a>辅助存储器的技术指标</h5><ul><li>存储密度：单位长度或单位面积磁层表面磁层所存储的二进制信息量</li><li>道密度：沿磁盘半径方向单位长度的磁道数称为道密度，单位为道/英寸tpi或道/毫米tpmm</li><li>位密度或线密度：单位长度磁道所能记录二进制信息的位数叫位密度或线密度，单位为位/英寸bpi或位/毫米bpmm</li><li>每个磁道所存储的信息量是一样的</li><li>存储容量：C = n × k × s</li><li>寻址时间：平均寻址时间Ta=平均找道时间Ts+平均等待时间Tw</li><li>数据传输率：Dr = D × V</li><li>误码率</li><li>价格</li></ul><h4 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h4><ul><li>固定磁头和移动磁头</li><li>可换盘和固定盘</li></ul><h4 id="磁盘存储器-1"><a href="#磁盘存储器-1" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h4><ul><li>温彻斯特磁盘简称温盘</li><li>磁盘存储器由驱动器（HDD），控制器（HDC）和盘片组成</li><li>最外面的同心圆叫0磁道，最里面的同心圆假设称为n磁道</li><li>驱动器的定位驱动系统实现快速精准的磁头定位</li><li>主轴系统的作用是带动盘片按额定转速稳定旋转</li><li>数据控制系统的作用是控制数据的写入和读出，包括寻址，磁头旋转，写电流控制，读出放大，数据分离</li><li>磁盘控制器有两个方向的接口<ul><li>与主机的接口</li><li>与驱动器（设备）的接口</li></ul></li></ul><h4 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h4><ul><li>采用光存储技术</li><li>利用激光写入和读出</li><li>第一代光存储技术采用非磁性介质，不可擦写</li><li>第二代光存储技术，采用磁性介质，可擦写</li><li>光盘的存储原理<ul><li>只读型和只写一次型：热作用（物理或化学变化）</li><li>可擦写光盘：热磁效应</li></ul></li></ul><h3 id="输出输出（I-O）设备-系统"><a href="#输出输出（I-O）设备-系统" class="headerlink" title="输出输出（I/O）设备/系统"></a>输出输出（I/O）设备/系统</h3><h4 id="设备控制器（I-O）的基本功能"><a href="#设备控制器（I-O）的基本功能" class="headerlink" title="设备控制器（I/O）的基本功能"></a>设备控制器（I/O）的基本功能</h4><ul><li>实现主机和外部设备之间的数据传送</li><li>实现数据缓冲，以达到主机同外部设备之间的速度匹配</li><li>接受主机的命令，提供设备接口的设备，并按照主机的命令控制设备</li></ul><h4 id="I-O-编址方式"><a href="#I-O-编址方式" class="headerlink" title="I/O 编址方式"></a>I/O 编址方式</h4><ul><li>统一编址：用取数、存数指令</li><li>不统一编址：有专门的 I/O 指令</li></ul><h4 id="I-O-与主机的连接方式"><a href="#I-O-与主机的连接方式" class="headerlink" title="I/O 与主机的连接方式"></a>I/O 与主机的连接方式</h4><ul><li>辐射式连接<ul><li>每台设备都配有一套</li><li>控制线路和一组信号线</li><li>不便于增删设备</li></ul></li><li>总线连接<ul><li>便于增删设备</li></ul></li></ul><h4 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h4><ul><li>人机交互设备：键盘、鼠标等</li><li>计算机信息的驻留设备：硬盘、光盘等</li><li>机——机通信设备：MODEN等</li></ul><h4 id="为什么要设置接口？"><a href="#为什么要设置接口？" class="headerlink" title="为什么要设置接口？"></a>为什么要设置接口？</h4><ul><li>实现设备的选择</li><li>实现数据缓冲达到速度匹配</li><li>实现数据串 并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反映设备的状态（“忙”、“就绪”、“中断请求”）</li></ul><h4 id="中断服务程序的流程"><a href="#中断服务程序的流程" class="headerlink" title="中断服务程序的流程"></a>中断服务程序的流程</h4><ul><li>保护现场<ul><li>程序断点的保护</li><li>寄存器内容的保护</li></ul></li><li>中断服务<ul><li>对不同的 I/O 设备具有不同内容的设备服务</li></ul></li><li>恢复现场：出栈指令</li><li>中断返回：中断返回指令</li></ul><h4 id="单重中断和多重中断"><a href="#单重中断和多重中断" class="headerlink" title="单重中断和多重中断"></a>单重中断和多重中断</h4><ul><li>单重中断：不允许中断 现行的 中断服务程序</li><li>多重中断：允许级别更高 的中断源（现行的 中断服务程序）</li></ul><h4 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h4><ul><li>主存和 I/O 之间有一条直接数据通道</li><li>CPU 和 I/O 并行工作</li><li>DMA 的三种工作方式<ul><li>CPU暂停方式</li><li>CPU周期窃取方式</li><li>直接访问存储器</li></ul></li><li>DMA 接口功能<ul><li>向 CPU 申请 DMA 传送</li><li>处理总线 控制权的转交</li><li>管理 系统总线、控制 数据传送</li><li>确定 数据传送的 首地址和长度，修正 传送过程中的数据地址和长度</li><li>DMA 传送结束时，给出操作完成信号</li></ul></li><li>DMA 传送过程：预处理、数据传送、后处理</li></ul><h4 id="外设接口"><a href="#外设接口" class="headerlink" title="外设接口"></a>外设接口</h4><ul><li>设备与主机相连时，必须按照规定的物理互连特性、电气特性等进行连接，这些特性的技术规范称为接口标准</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="慕课MOOC" scheme="http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-11-09T16:00:00.000Z</published>
    <updated>2022-05-05T12:51:07.604Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。</p></blockquote><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="C-C-语言基础"><a href="#C-C-语言基础" class="headerlink" title="C/C++语言基础"></a>C/C++语言基础</h4><ul><li>数据类型<ul><li>结构型 <code>int a[maxSize];</code></li><li>指针型 <code>int *a;</code></li><li>链表结点<pre><code class="C">typedef struct Node&#123;  int data;  struct Node *next;&#125;Node;</code></pre></li><li>二叉树结点<pre><code class="C">typedef struct BTNode&#123;  int data;  struct BTNode *lchild;  struct BTNode *rchild;&#125;BTNode;</code></pre></li><li>动态申请数组空间<pre><code class="C">int *p;p=(int *)malloc(n * sizeof(int));</code></pre></li></ul></li><li>函数<ul><li>函数参数的引用型定义<pre><code class="cpp">int a=0;void f(int &amp;x)&#123;  ++x;&#125;f(a);</code></pre></li><li>数组作参数的引用型定义<pre><code class="cpp">void f(int x[][maxSize], int n)&#123;···;&#125;</code></pre></li></ul></li></ul><h4 id="算法的时间复杂度和空间复杂度"><a href="#算法的时间复杂度和空间复杂度" class="headerlink" title="算法的时间复杂度和空间复杂度"></a>算法的时间复杂度和空间复杂度</h4><ul><li>时间复杂度 <ul><li>$T(n)=O(f(n)中增长最快的项的系数)$</li><li>将最坏的情况作为算法时间复杂度的度量</li><li>$O(1)≤O(\log_{2}\left(n\right)≤O(n)≤O(n\log_{2}\left(n\right)≤O(n^2)≤O(2^n)$（常对幂指阶）</li><li>取最深层循环内的语句所描述的操作为基本操作，由循环基本执行的次数为规模n，计算函数 $f(n)$</li></ul></li><li>空间复杂度：算法在运行时所需存储空间的度量，主要考虑在算法运行过程中临时占用的存储空间大小<ul><li>空间复杂度 = 函数递归调用的深度</li></ul></li></ul><h4 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h4><ul><li>数据是对客观事物的符号表示</li><li>数据元素是数据的基本单位</li><li>数据对象是性质相同的数据元素的集合</li><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合<ul><li>数据的逻辑结构是对数据之间关系的描述，分为线性结构（一个数据元素的次序集合）和非线性结构（树、图）</li><li>数据的存储（物理）结构是数据的逻辑结构在计算机中的表示（映像），包括数据元素的表示和关系的表示</li></ul></li><li>数据元素之间的关系：顺序映像和非顺序映像</li><li>数据结构中常用储存方法：顺序存储（数组）、链式存储（指针）、索引存储 <code>&lt;关键字, 地址&gt;</code>、散列存储（根据结点的关键字通过散列函数直接计算出该结点的存储地址）</li></ul><h4 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h4><ul><li>算法的特性：有穷性、确定性、输入、输出、可行性</li><li>算法的设计目标：正确性、可读性、健壮性、高效率和低存储量需求</li></ul><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h4 id="线性表的基本概念"><a href="#线性表的基本概念" class="headerlink" title="线性表的基本概念"></a>线性表的基本概念</h4><ul><li>线性表是具有相同特性数据元素的一个有限序列，长度 $n≥0$</li><li>线性表只有一个表头元素，一个表尾元素，除表头表尾元素外其他元素只有一个直接前驱和一个直接后继（有序性）</li><li>顺序表：随机访问特性、要求占用连续的存储空间、做插入操作要移动多个元素</li><li>链表：不支持随机访问、结点的存储空间利用率稍低、支持存储空间的动态分配</li><li>头指针指向链表的第一个结点、头结点指向带头结点链表的第一个结点</li><li>单链表、双链表、循环单链表、循环双链表、静态链表（数据元素分量+指针分量）</li></ul><h4 id="线性表的结构体定义"><a href="#线性表的结构体定义" class="headerlink" title="线性表的结构体定义"></a>线性表的结构体定义</h4><ul><li>顺序表<pre><code class="cpp">typedef struct&#123;  int data[maxSize];   //考试写这两行  int length;         //&#125;Sqlist;</code></pre></li><li>单链表<pre><code class="cpp">typedef struct LNode&#123;  int data;  struct LNode *next;&#125;LNode//构造LNode型结点LNode *A = (LNode*)malloc(sizeof(LNode));</code></pre></li><li>双链表<pre><code class="cpp">typedef struct DLNode&#123;  int data;  struct DLNode *prior;  struct DLNode *next;&#125;DLNode;</code></pre></li></ul><h4 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h4><ul><li><p>插入元素</p><ul><li>1 ≤ i ≤ ListLength(L）</li></ul><pre><code class="cpp">int ListInsert(SeqList *L,int i,ElemType *e)&#123;  int k；  if(L-&gt;length==MAXSIZE)/*顺序线性表已经满*/    return ERROR;  if（i&lt;1 || i&gt;L-&gt;length+1)/*当 i 不在范围内时*/    return ERROR;  if(i&lt;=L-&gt;length)  &#123;            /*若插入数据位置不在表尾*/    for(k=L-&gt;length-1；k&gt;=i-1；k--)    /*将要插入位置后的数据元素向后移动一位*/      L-&gt;data[k+1]=L-&gt;data[k];  &#125;  L-&gt;data[i-1]=e;/*将新元素插入*/  L-&gt;length++;  return OK;&#125;</code></pre></li><li><p>删除元素</p><pre><code class="cpp">int ListDelete(SqList *L,int i,ElemType *e)&#123;  int k;  if (L-&gt;length==0)/*线性表为空*/    return ERROR;  if(i&lt;1|| i&gt;L-&gt;length)/*删除位置不正确*/    return ERROR;  *e=L-&gt;data[i-1];  if(i&lt;L-&gt;1ength)  &#123;    /*如果删除不是最后位置*/    for（k=i；k&lt;L-&gt;length;k++)/*将删除位置后继元素前移*/    L-&gt;data[k-1]=L-&gt;data[k];  &#125;  L-&gt;length--；  return OK;&#125;</code></pre></li><li><p>查找元素</p><pre><code class="cpp">int findElem (Sqlist L, int e)&#123;  int i;  for (i=0; i&lt;L.length; ++i)    if (e==L.data[i])      return i;  return -1;&#125;</code></pre></li><li><p>求指定位置元素</p><pre><code class="cpp">int getElem(Sqlist L, int p, int &amp;e)  if(p&lt;0||p&gt;L.length-1)    return 0;  e=L.data[p];  return 1;</code></pre></li></ul><h4 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h4><ul><li><p>尾插法建立链表C</p><pre><code class="cpp">void createlistR(LNode *&amp;C, int a[], int n)&#123;  LNode *s, *r;  //s指向新申请结点，r指向C的终端结点  int i;  C=(LNode *)malloc(sizeof(LNode));  //申请C的头结点空间  C-&gt;next=NULL;  r=C;  for (i=0; i&lt;n; ++i)  &#123;    s=(LNode *)malloc(sizeof(LNode));    s-&gt;data=a[i];    r-&gt;next=s;    r=r-&gt;next;  &#125;  r-&gt;next=NULL;&#125;</code></pre></li><li><p>归并成递减的单链表</p><pre><code class="cpp">void merge (LNode *A, LNode *B, LNode *C)&#123;  LNode *p=A-&gt;next;  LNode *q=B-&gt;next;  LNode *s;  C=A;  C-&gt;next=NULL;  free(B);  while(p!=NULL&amp;&amp;q!=NULL)  &#123;    /*下面的if else体现了头插法*/    if(p-&gt;data&lt;=q-&gt;data)    &#123;      s=p;p-&gt;next;      s-&gt;next=C-&gt;next;      C-next=s;    &#125;    else    &#123;      s=q;q=q-&gt;next;      s-&gt;next=C-&gt;next;      C-&gt;next=s;    &#125;  &#125;  while(p!=NULL)  &#123;    s=p;    p=p-&gt;next;    s-&gt;next=C-&gt;next;    C-&gt;next=s;  &#125;  while(q!=NULL)  &#123;    s=q;    q=q-&gt;next;    s-&gt;next=C-&gt;next;    C-&gt;next=s;  &#125;&#125;</code></pre></li><li><p>单链表获取元素</p><ul><li>用 e 返回表中第 i 个数据元素的值</li></ul><pre><code class="cpp">int GetElem(LinkList L,int i,ElemType *e)&#123;  int j=1;    /*j 为计数器*/  LinkList p;    /*声明一节点 p*/  p=L-&gt;next;    /*p 指向链表 L 的第一个节点*/  while(p &amp;&amp; j&lt;i)   &#123;     /*当 p 不为空并且计数器不等于 i 时，循环继续*/    p=p-&gt;next； /*p 指向下一个节点*/    ++j;  &#125;  if(!p || j &gt; i)    return ERROR;  *e = p-&gt;data;  return OK;&#125;</code></pre></li><li><p>单链表插入元素</p><pre><code class="cpp">int ListInsert(LinkList *L,int i,ElemType e)&#123;  int j=1；    LinkList p,s;    p=*L；    while (p &amp;&amp; j&lt;i)     /*寻找第 i 个节点*/    &#123;        p=p-&gt;next;        ++j；    &#125;  if (!p || j&gt;i)  return ERROR;     /*第 i 个元素不存在*/  s=(LinkList *) malloc (sizeof(Node));    /*生成新节点（C 标准函数）*/  s-&gt;data=e;  s-&gt;next=p-&gt;next;    //将 p 的后继节点赋值给 s 的后继*）  p-&gt;next=s;       //将 s 赋值给 p 的后继  return OK;&#125;</code></pre></li></ul><h4 id="双链表的操作"><a href="#双链表的操作" class="headerlink" title="双链表的操作"></a>双链表的操作</h4><ul><li><p>尾插法建立双链表</p><pre><code class="cpp">void createDlistR(DLNode *&amp;L, int a[], int n)&#123;  DLNode *s, *r;  //s指向新申请结点，r指向C的终端结点  int i;  L=(DLNode *)malloc(sizeof(DLNode));  L-&gt;prior=NULL;  L-&gt;next=NULL;  r=L;    //和单链表一样，r始终指向终端节点，开始头节点也是尾节点  for (i=0; i&lt;n; ++i)  &#123;    s=(DLNode *)malloc(sizeof(DLNode));    s-&gt;data=a[i];    r-&gt;next=s;    s-&gt;prior=r;    r=s;  &#125;  r-&gt;next=NULL;&#125;</code></pre></li><li><p>双链表寻找结点</p><pre><code class="cpp">DLNoded* findNode(DLNode *C, int x)&#123;  DLNode *p=C-&gt;next;  while(p!=NULL)  &#123;    if(p-&gt;data==x)        break;    p=p-&gt;next;  &#125;  return p;  //如果找到，则P中内容是结点地址，如果没找到，则P中内容是NULL&#125;</code></pre></li><li><p>双链表插入结点</p><pre><code class="cpp">s-&gt;prior = p; s-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = s; p-&gt;next = s; </code></pre></li><li><p>双链表删除结点</p><pre><code class="cpp">p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; free(p)     //释放空间，不要漏掉</code></pre></li><li><p>链表的逆置</p><pre><code class="cpp">ListNode* reverseList(ListNode head)&#123;  if(head == NULL || head-&gt;next == NULL)      return head;      ListNode* newhead = reverseList(head-&gt;next);   //递归到链尾      head-&gt;next-&gt;next = head;    //反转链表      head-&gt;next = NULL;    //将指针置NULL      return newhead;    //newhead始终指向新链表的头&#125;</code></pre></li></ul><h4 id="循环链表的操作"><a href="#循环链表的操作" class="headerlink" title="循环链表的操作"></a>循环链表的操作</h4><ul><li><p>逆置循环链表</p><ul><li>只交换节点中的数据成员 data，其他的前后指针不变</li></ul><pre><code class="cpp">void Reverse () &#123;   LinkList * begin = _head;   LinkList * end = _tail;   while (begin != end &amp;&amp; begin-&gt;_prev != end)   &#123;      swap(begin-&gt;_data, end-&gt;_data);      begin = begin-&gt;_next;      end = end-&gt;_prev;   &#125; &#125; </code></pre></li><li><p>删除顺序表中值在 min 和 max 之间的数</p><ul><li>对顺序表进行遍历查找介于 min 与 max 之间的数然后进行删除</li></ul><pre><code class="cpp">void Delete(Seqlist *L,int min,int max)&#123;  int i=0,n=0;  while(i&lt;L-&gt;length)   &#123;        if(L-&gt;elem[i]&gt;=min &amp;&amp; L-&gt;elem[i]&lt;=max)            n++;         else            L-&gt;elem[i-n]=L-&gt;elem[i];        i++;    &#125;  L-&gt;length -= n;   if(L-&gt;length==0)  printf(&quot;the sqlist ie empty/n&quot;); &#125; </code></pre></li></ul><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="栈和队列的基本概念"><a href="#栈和队列的基本概念" class="headerlink" title="栈和队列的基本概念"></a>栈和队列的基本概念</h4><ul><li>栈是一种只能在一端进行插入或删除操作的线性表（FILO）<ul><li>栈顶（Top）动态变化，栈底固定不变</li></ul></li><li>队列为仅允许在表的一端进行插入，在表的另一端进行删除的线性表（FIFO）<ul><li>队头（Front）可进行删除，队尾（Rear）可进行插入</li></ul></li></ul><h4 id="栈和队列的结构体定义"><a href="#栈和队列的结构体定义" class="headerlink" title="栈和队列的结构体定义"></a>栈和队列的结构体定义</h4><ul><li><p>顺序栈的定义</p><pre><code class="cpp">typedef struct&#123;  int data[maxSize];  int top;&#125; SqStack;</code></pre></li><li><p>链栈结点的定义</p><pre><code class="cpp">typedef struct LNode&#123;  int data;  struct LNode *next;&#125;  LNode;</code></pre></li><li><p>顺序队列的定义</p><pre><code class="cpp">typedef struct&#123;  int data[maxSize];  int front;  int rear;&#125; SqQueue;</code></pre></li><li><p>链队结点的定义</p><pre><code class="cpp">typedef struct QNode&#123;  int data;  struct QNode *next;&#125; QNode;</code></pre></li><li><p>链队类型的定义</p><pre><code class="cpp">typedef struct&#123;  QNode *front;  QNode *rear;&#125; LiQueue;</code></pre></li></ul><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ul><li><p>栈空状态：<code>st.top==-1</code></p></li><li><p>栈满状态：<code>st.top==maxSize-1</code></p></li><li><p>非法状态：栈满后继续入站上溢，栈空继续出栈下溢</p></li><li><p>定义一个栈并初始化：<code>int stack[maxSize]; int top==-1</code></p></li><li><p>进栈：先移动指针再进栈</p><ul><li><code>stack[++top]=x</code>;</li></ul><pre><code class="cpp">int push(SqStack &amp;st,int x)&#123;  if(st.top==maxSize-1)    return 0;  ++(st.top);  st.data[st.top]=x;  return 1;&#125;</code></pre></li><li><p>出栈：先取出元素，再移动指针</p><ul><li><code>x=stack[top--];</code></li></ul><pre><code class="cpp">int pop(SqStack &amp;st,int &amp;x)&#123;  if(st.stop==-1)    return 0;    //栈空不能出栈  x = st.data[st.top];  --(st.top);  return 1;&#125;</code></pre></li></ul><h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><ul><li>栈空状态：<code>lst-&gt;next==NULL</code></li><li>不存在栈满状态</li><li>进栈：头插法建立链表中的插入操作<ul><li><code>p-&gt;next=lst-&gt;next; lst-&gt;next=p;</code></li></ul></li><li>出栈：单链表的删除操作，出栈元素保存在 x 中<ul><li><code>p-lst-&gt;next; x=p-&gt;data; lst-&gt;next=p-&gt;next; free(p);</code></li></ul></li></ul><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ul><li><p>解决假溢出：<code>front=(front+1)%maxSize</code></p></li><li><p>队空状态：<code>qu.rear==qu.front</code></p></li><li><p>队满状态：<code>(qu.rear+1)%maxSize==qu.front</code></p></li><li><p>初始化队列：队首和队尾指针重合，并且指向0</p><ul><li><code>qu.front=qu.rear=0;</code></li></ul></li><li><p>进队算法</p><pre><code class="cpp">int enQueue(SqQueue qu)&#123;  if((qu.rear+1)%maxSize==qu.front)    return 0  qu.rear=(qu.rear+1)%maxSize;    //先移动指针  qu.data[qu.rear]=x;    //再存入元素  return 1;&#125;</code></pre></li><li><p>出队算法</p><pre><code class="cpp">int denQueue(SqQueue &amp;qu, int &amp;x)&#123;  if(qu.rear==qu.front)    return 0;  qu.front=((qu.front+1)%maxSize)    //先移动指针  x=qu.data[qu.front];  return 1;&#125;</code></pre></li></ul><h4 id="链队（尽量避免使用）"><a href="#链队（尽量避免使用）" class="headerlink" title="链队（尽量避免使用）"></a>链队（尽量避免使用）</h4><ul><li><p>队空状态：<code>lqu-&gt;rear==NULL</code> 或者 <code>lqu-&gt;front==NULL</code></p></li><li><p>不存在队满状态</p></li><li><p>初始化链队</p><pre><code class="cpp">void initQueue(LiQueue *&amp;lqu)&#123;  lqu=(LiQueue*)malloc(sizeof(LiQueue));  lqu-&gt;front=lqu-&gt;rear=NULL;&#125;</code></pre></li><li><p>进队操作：<code>lqu-&gt;rear-&gt;next=p;  lqu-&gt;rear=p;</code></p></li><li><p>出队操作：<code>p=lqu-&gt;front; lqu-&gt;front=p-&gt;next; x=p-&gt;data; free(p);</code></p></li></ul><h4 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h4><ul><li><p>入栈：push(x)，除栈顶元素：pop() – 移，获取栈顶元素：top() ，返回栈是否为空：empty()</p><pre><code class="cpp">// Push element x onto stack.void push(int x)&#123;  q1.push(x);&#125;// Removes the element on top of the stack and returns thatint pop()&#123;  int length1 =  q1size();  for(int i-0; i&lt; length1- 1; i++)  &#123;    q2.push(q1.front());    q1. pop();  &#125;  data= q1.front()    int length2= q2size():  for(int j=0;j&lt; length2; j++)  &#123;    q1.push(q2.front());    q2.pop();  &#125;  return data;&#125;// Get the top element. *int top()    int length1 = q1.size();    int data;    for (int i=0; i&lt; length1- 1; i++)  &#123;    q2.push(q1.front());    q1.pop();  &#125;    data= q1.front();    return data;&#125;// Returns whether the stack isemptybool empty()&#123;  if(q1.empty()&amp;&amp;q2.empty())    return true;  else        return false;&#125;</code></pre></li></ul><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="串数据类型的定义"><a href="#串数据类型的定义" class="headerlink" title="串数据类型的定义"></a>串数据类型的定义</h4><ul><li><p>串是限定了元素为字符的线性表，<code>char str[]=&quot;abcdef&quot;;</code></p></li><li><p>空格串不是空串</p></li><li><p>串赋值：对数组中的每个元素进行逐一赋值操作</p><ul><li><code>strassign(str,&quot;cur input&quot;);</code></li></ul></li><li><p>取串长度</p><ul><li><code>return str.length;</code></li></ul></li><li><p>串比较操作</p><pre><code class="cpp">int strcompare(Str s1, Str s2)&#123;  for(int i=0;i&lt;s1.length&amp;&amp;i&lt;s2.length;++i)      if(s1.ch[i]!=s2.ch[i])      return s1.ch[i]-s2.ch[i];  return s1.length - s2.length;&#125;</code></pre></li></ul><h4 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h4><ul><li><p>KMP 算法</p><pre><code class="cpp">void getnext(str substr, int next[])&#123;  int i=1, j=0;    next[1]=0;    while (i&lt;substr.length)  &#123;    if (j==0||substr.ch[i]==substr.ch[j])    &#123;      ++i, ++j;      next[i]=j;    &#125;    else      j=next[j];  &#125;&#125;int KMP (Str str, Str substr, int next[])&#123;   int i=j=1;  while(i&lt;=str.length&amp;&amp;j&lt;=substr.length)  &#123;     if (j==0||str.ch[i]==substr.ch[j])      ++i, ++j;    else      j=next[ j];    if (j&gt;substr.length)       return i-substr.length;    else      return 0;  &#125;&#125;</code></pre><h3 id="矩阵与广义表"><a href="#矩阵与广义表" class="headerlink" title="矩阵与广义表"></a>矩阵与广义表</h3><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><ul><li><p>矩阵的转置</p><pre><code class="cpp">void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            B[j][i] = A[i][j];&#125;</code></pre></li><li><p>矩阵相加</p><pre><code class="cpp">void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            C[i][j] = A[i][j] + B[i][j];&#125;</code></pre></li><li><p>矩阵相乘</p><pre><code class="cpp">void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; k;++j)        &#123;            C[i][j] = 0;            for int(h = 0;h &lt; n;++h)                C[i][j] += A[i][j] * B[i][j];        &#125;&#125;</code></pre></li><li><p>相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵</p><ul><li>对称矩阵、三角阵、对角矩阵</li></ul></li></ul><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><ul><li>表元素可以是原子或者广义表的一种线性表的扩展结构</li><li>广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数</li><li>当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</li><li>原子结点有两个域：标志域和数据域</li><li>广义表结点有三个域：标志域，头指针域与尾指针域</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><ul><li>树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成<ul><li>结点不仅包含数据元素，并且包含指向子树的分支</li><li>结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值</li><li>树的高度是树中结点的最大层次，根结点的高度为树的高度</li></ul></li><li>树的双亲存储结构：<code>int tree[maxSize]</code></li><li>树的链式存储结构<ul><li>邻接表：孩子存储结构</li><li>孩子兄弟存储结构</li></ul></li></ul><h4 id="二叉树的概念和性质"><a href="#二叉树的概念和性质" class="headerlink" title="二叉树的概念和性质"></a>二叉树的概念和性质</h4><ul><li><p>二叉树的定义</p><ul><li>每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2</li><li>子树有左右顺序之分，不能颠倒</li></ul></li><li><p>满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层</p></li><li><p>完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的</p></li><li><p>二叉树的主要性质</p><ol><li><p>非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$</p></li><li><p>在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$</p></li><li><p>二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p><ul><li>若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）</li><li>若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点</li><li>若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点</li></ul></li><li><p>Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac{C_{2n}^{n}}{n+1}$  棵不同的二叉树</p></li><li><p>在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$</p></li></ol></li><li><p>二叉树的顺序存储结构最适用于完全二叉树</p></li><li><p>二叉树的链式存储结构</p><pre><code class="cpp">typedef struct BTNode&#123;    char  data;    //数据域    struct BTNoode* lchild;    struct BTNode* rchild;&#125; BTNode;</code></pre></li></ul><h4 id="二叉树的遍历算法"><a href="#二叉树的遍历算法" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><ul><li><p>先序遍历</p><pre><code class="cpp">/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123;    StackNode* S;   //定义一个栈指针    BitNode* p;   //工作指针    S = NULL;    p = root;    S = InitStack(S);   //初始化栈    if (NULL == p)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;     //end if    while (p || !StackEmpty(S))    &#123;     //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p);    //p 所指节点入栈            printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）            p = p-&gt;lchild ;     //指向 p 的左孩子         &#125;//end if        else        &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树            StackPop(S, p);            p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈        &#125;    //end else    &#125;    //end while    free(S);&#125;    //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123;    if (root)    &#123;        printf(&quot;%d &quot;, root-&gt;data);        preOrder(root-&gt;lchild);        preOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>中序遍历</p><pre><code class="cpp">/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123;    StackNode* S; //定义一个栈指针    BitNode* p; //工作指针    S = NULL;    p = root;    S = InitStack(S); //初始化栈    if (NULL == p) &#123; //如果是空树        printf(&quot;树为空！\n&quot;) ;        return;    &#125;//end if    while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p); //将节点入栈            p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子        &#125;//end if        else        &#123;            StackPop(S, p); //p 左子树为空则出栈            printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点            p = p-&gt;rchild; //向右子树移动        &#125;//end else    &#125;//end while    free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123;    if (root)    &#123;        inOrder(root-&gt;lchild);        printf(&quot;%d &quot;, root-&gt;data);        inOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>后序遍历</p><pre><code class="CPP">/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123;    StackNode* S; BiTNode* cur, * pre;//定义一个栈指针    S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点    if (NULL == root)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;//end if    pre = NULL; cur = NULL;    StackPush(S, T); //根节点入栈    while (!StackEmpty(S))    &#123; //若栈非空        cur = NULL;        StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/        if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||            (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))        &#123;            printf(&quot;%c &quot;, cur-&gt;data);            pre = cur;            StackPop(S, cur);        &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。        else        &#123;            if (cur-&gt;rchild != NULL)                StackPush(S, cur-&gt;rchild);            if (cur-&gt;lchild != NULL)                StackPush(S, cur-&gt;lchild);        &#125;//end else    &#125;//end while    free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123;    if (root)    &#123;        postOrder(root-&gt;lchild);        postOrder(root-&gt;rchild);        printf(&quot;%d &quot;, root-&gt;data);    &#125; &#125;</code></pre></li><li><p>层次遍历：自上而下，自左向右</p><ul><li>首先，将二叉树的祖先节点入队列</li><li>然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队</li></ul><pre><code class="cpp">void LayerOrder(BiTreeNode* head)&#123;    LQueue Q;    Initiate_Queue(&amp;Q);    BiTreeNode* p;    if (head != NULL) AppendQueue(&amp;Q, head);    while (QueueNotEmpty(&amp;Q)) &#123;        p = QueueDelete(&amp;Q);        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);        if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);    &#125;&#125; </code></pre></li></ul><h4 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ul><li><p>哈夫曼树又叫做最优二叉树，它的特点是带权路径最短</p><ul><li>树的路径长度是指从根到每个节点的路径长度之和</li><li>带权路径长度是从该节点到根节之间的路径长度乘以结点的权值</li><li>树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和</li></ul></li><li><p>求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度</p><pre><code class="cpp">ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0  &#123;      if (FBT == NULL) //空树返回0          return 0;      else      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点              return FBT-&gt;data * len;          else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增              return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);      &#125;  &#125;  </code></pre></li><li><p>哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针  </p><pre><code class="cpp">struct BTreeNode* CreateHuffman(ElemType a[], int n)  &#123;      int i, j;      struct BTreeNode **b, *q;      b = malloc(n*sizeof(struct BTreeNode));      for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点      &#123;          b[i] = malloc(sizeof(struct BTreeNode));          b[i]-&gt;data = a[i];          b[i]-&gt;left = b[i]-&gt;right = NULL;      &#125;      for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树      &#123;          //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标          int k1 = -1, k2;          for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵          &#123;              if (b[j] != NULL &amp;&amp; k1 == -1)              &#123;                  k1 = j;                  continue;              &#125;              if (b[j] != NULL)              &#123;                  k2 = j;                  break;              &#125;          &#125;          for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小          &#123;              if (b[j] != NULL)              &#123;                  if (b[j]-&gt;data &lt; b[k1]-&gt;data)                  &#123;                      k2 = k1;                      k1 = j;                  &#125;                  else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                      k2 = j;              &#125;          &#125;          //由最小权值树和次最小权值树建立一棵新树，q指向树根结点          q = malloc(sizeof(struct BTreeNode));          q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;          q-&gt;left = b[k1];          q-&gt;right = b[k2];          b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置          b[k2] = NULL;//k2位置为空      &#125;      free(b); //删除动态建立的数组b      return q; //返回整个哈夫曼树的树根指针  &#125;  </code></pre></li><li><p>哈夫曼编码</p><ul><li>每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树</li><li>将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码</li><li>从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码</li><li>哈夫曼编码产生的是最短前缀码</li></ul><pre><code class="cpp">void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0  &#123;      static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一      if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)          &#123;              int i;              printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);              for (i = 0; i &lt; len; i++)                  printf(&quot;%d&quot;, a[i]);              printf(&quot;\n&quot;);          &#125;          else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a          &#123;   //的对应元素中，向下深入一层时len值增1              a[len] = 0;              HuffManCoding(FBT-&gt;left, len + 1);              a[len] = 1;              HuffManCoding(FBT-&gt;right, len + 1);          &#125;      &#125;  &#125;  </code></pre></li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><ul><li>图由结点的有穷集合的 V 和边的集合  E 组成（<code>G(V,E)</code>）</li><li>图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示</li><li>路径长度：路径上边或者弧的数目</li><li>顶点的度：顶点关联边的数目<ul><li>有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度</li><li>在有向图中，顶点的度就是两者之和</li><li>在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量</li><li>在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量</li></ul></li></ul><h4 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h4><ul><li><p>邻接矩阵</p><ul><li>图的顺序存储结构</li><li>用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息</li><li>无向图中邻接矩阵是个对称矩阵</li><li>0表示无边，1表示有边</li><li>顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 </li><li>邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费</li></ul><pre><code class="cpp">typedef struct&#123;  int no;  char info;&#125; VertexType;typedef struct&#123;  int edges[maxSize][maxSize];    //有权图中int改为float  int n,e;    //顶点数和边数  VertexType vex[maxSize];    //存放结点信息&#125; MGragh;</code></pre></li><li><p>邻接表</p><ul><li>数组和链表相结合的存储方法，图的链式存储结构</li><li>图中顶点用一个一维数组存储</li><li>图中每个顶点 $V_i$ 的所有邻接点构成一个线性表</li><li>顶点表的各个结点由 data 和 Firstedge 两个域表示<ul><li>data 是数据域，存储顶点信息</li><li>firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点</li></ul></li><li>边表结点由 adjvex 和 next 两个域组成<ul><li>adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标</li><li>next 存储边表中下一个结点指针</li></ul></li><li>有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表</li></ul><pre><code class="cpp">typedef struct ArcNode&#123;    int adnex;    //该边所指向的结点的位置    struct ArcNode * nextarc;    //指向下一条边的指针    int info;    //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123;    char data;    //顶点信息    ArcNode* firstarc;    //指向第一条边的指针&#125;VNode;typedef struct&#123;    VNode adjlist[maxSize];    //邻接表    int n, e;    //顶点数和边数&#125; AGraph;    //图的邻接表类型</code></pre></li><li><p>十字链表</p><ul><li>在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表</li><li>定点表<ul><li>firstin：入边表头指针，指向顶点入边表的第一个结点</li><li>firstout：出边表头指针，指向顶点出边表第一个结点</li></ul></li><li>边表<ul><li>tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标</li><li>headlink 入边表指针域，指向终点相同的下一条边</li><li>taillink 是指边表指针域，指向起点相同的下一条边</li></ul></li></ul></li><li><p>邻接多重表</p><ul><li>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标</li><li>ilink 指向依附项点 ivex 的下一条边</li><li>jlink 指向依附顶点 jvex 的下一条边</li></ul></li></ul></li></ul><h4 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h4><ul><li><p>深度优先遍历（DFS，Depth First Search） </p><ul><li>首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了</li><li>若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问</li><li>深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123;    for (v = 0;v &lt; G.vexnum;++v)        visited[v] = false;    //初始化标记数组    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历            DFS(G, v);&#125;void DFS(Graph G, int v)&#123;    visit(v);    visited[v] = true; //定义为已访问    for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))        if (!visited[w])            DFS(G, w);&#125;</code></pre></li><li><p>广度优先遍历（BFS，Breadth First Search）</p><ul><li>首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点</li><li>然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完</li><li>BFS 遍历的方式类似于树的层次遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组void BFSTraverse(Graph G)&#123;    for (i = 0;i &lt; G.vexnum;++i)        visited[v] = false;    //初始化标记数组    InitQueue(Q);    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历            BFS(G, v);&#125;void BFS(Graph G, int v)&#123;    visit(v);    visited[v] = true;    //定义为已访问    while (!isEmpty(Q))    &#123;        DeQueue(Q, v);        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])            &#123;                visit(w);                visited[w] = true;                EnQueue(Q, w)            &#125;    //if    &#125;    //while&#125;</code></pre><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4></li><li><p>Prim 算法</p><ul><li>从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树</li><li>然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树</li><li>以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树</li></ul><pre><code class="cpp">void prim (G,T)&#123;    T = ∅;    U = &#123;w&#125;;    while ((V - U) != ∅  )    &#123; //若图中不含全部顶点        设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;        T = T∪ (u，v); //边归入树        U = U∪ &#123;v&#125;;     //顶点归入树    &#125;&#125;</code></pre></li><li><p>Kruskal 算法</p><ul><li>将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止</li><li>Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图</li><li>普里姆算法和克鲁斯卡尔算法都是针对于无向图的</li><li>判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树<ul><li>通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合</li><li>通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合</li></ul></li></ul><pre><code class="cpp">void kruskal（V，T）&#123;    T = V;    //初始化树，仅含顶点    numS = n;    //不连分量的数目    while (numS &gt; 1)    &#123;        从 E 中取出权值最小的边（v,u）;        if（v 和 u 属于 T 中不同的连通分量）        &#123;            T = T∪（u，v）;//将此边加入到生成树中；            numS--; //不连通的分量减少 1        &#125;    &#125;&#125;</code></pre><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4></li><li><p>Dijkstra 算法</p><ul><li>通常用于求图中某一顶点到其余各顶点的最短路径</li><li>设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组</li><li>第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）</li><li>第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度</li></ul></li><li><p>Dijkstra 算法步骤</p><ol><li>初始时，S 只包含源点，即 S＝{v}，v 的距离为 0，U 包含除 v 外的其他顶点，即:U={其 余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$</li><li>从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）</li><li>以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离</li><li>重复步骤 b 和 c 直到所有顶点都包含在 S 中</li></ol><pre><code class="cpp">void Dijkstra(int v0)&#123;  　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中      int n=MAXNUM;  　　for(int i=1; i&lt;=n; ++i) 　　 &#123;      　　dist[i] = A[v0][i];      　　S[i] = false;                                // 初始都未用过该点      　　if(dist[i] == MAXINT)                　　prev[i] = -1; 　　     else             　　prev[i] = v0;   　　&#125;   　 dist[v0] = 0;   　 S[v0] = true; 　　 　　 for(int i=2; i&lt;=n; i++) 　　 &#123;       　　int mindist = MAXINT;       　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值      　　 for(int j=1; j&lt;=n; ++j)      　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)      　　    &#123;         　　       u = j;                             // u保存当前邻接点中距离最小的点的号码          　 　      mindist = dist[j];       　　   &#125;       　　S[u] = true;        　　for(int j=1; j&lt;=n; j++)       　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)       　　    &#123;           　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径             　    　&#123;                   　　dist[j] = dist[u] + A[u][j];    //更新dist                    　　prev[j] = u;                    //记录前驱顶点             　　    &#125;        　    　&#125;   　　&#125;&#125;</code></pre></li><li><p>Floyd 算法</p><ul><li>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包</li><li>Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$</li><li>Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离</li><li>对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离</li></ul></li><li><p>Floyd 算法步骤</p><ul><li>从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它</li></ul><pre><code class="cpp">for (k = 1;k &lt;= n;k++)    for (i = 1;i &lt;= n;i++)        for (j = 1;j &lt;= n;j++)            if (a[i][j] &gt; a[i][k] + a[k][j])                a[i][j] = a[i][k] + a[k][j];</code></pre><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4></li><li><p>对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边</p><ol><li>从 DAG 图中选择一个没有前驱的节点并输出</li><li>从图中删除该节点和所有以它为起点的有向边</li><li>重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止</li></ol><pre><code class="cpp">bool topologicalSort(Graph GL)&#123;    EdgeNode* e;    int top = 0; //用于栈指针下标     int count = 0; // 用于统计输出顶点的个数     int* stack; // 建栈将入度为 0 的顶点入栈     stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));    for (i = 0; i &lt; GL-&gt;numVertexes; i++)        if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈             stack[++top] = i;    while (top != 0)    &#123;        gettop = stack[top--];        printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);        count++; //输出 i 号顶点，并计数         for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;            k = e-&gt;adjvex;            if (!(--GL-&gt;adjList[k].in))                //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                 stack[++top] = k;        &#125;    &#125;    if (count &lt; GL-&gt;numVertexes) return false;    else return true;&#125;</code></pre><blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构<a href="https://www.icourse163.org/course/ZJU-93001">国家精品课</a>，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的<a href="https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">代码</a>，可供参考。其他部分笔记详见<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A">数据结构（上）</a>和<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B">数据结构（下）</a></p></blockquote><!--more--><h3 id="矩阵与广义表-1"><a href="#矩阵与广义表-1" class="headerlink" title="矩阵与广义表"></a>矩阵与广义表</h3><h4 id="矩阵-1"><a href="#矩阵-1" class="headerlink" title="矩阵"></a>矩阵</h4><ul><li><p>矩阵的转置</p><pre><code class="cpp">void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            B[j][i] = A[i][j];&#125;</code></pre></li><li><p>矩阵相加</p><pre><code class="cpp">void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            C[i][j] = A[i][j] + B[i][j];&#125;</code></pre></li><li><p>矩阵相乘</p><pre><code class="cpp">void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; k;++j)        &#123;            C[i][j] = 0;            for int(h = 0;h &lt; n;++h)                C[i][j] += A[i][j] * B[i][j];        &#125;&#125;</code></pre></li><li><p>相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵</p><ul><li>对称矩阵、三角阵、对角矩阵</li></ul></li></ul><h4 id="广义表-1"><a href="#广义表-1" class="headerlink" title="广义表"></a>广义表</h4><ul><li>表元素可以是原子或者广义表的一种线性表的扩展结构</li><li>广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数</li><li>当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</li><li>原子结点有两个域：标志域和数据域</li><li>广义表结点有三个域：标志域，头指针域与尾指针域</li></ul><h3 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念-1"><a href="#树的基本概念-1" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><ul><li>树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成<ul><li>结点不仅包含数据元素，并且包含指向子树的分支</li><li>结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值</li><li>树的高度是树中结点的最大层次，根结点的高度为树的高度</li></ul></li><li>树的双亲存储结构：<code>int tree[maxSize]</code></li><li>树的链式存储结构<ul><li>邻接表：孩子存储结构</li><li>孩子兄弟存储结构</li></ul></li></ul><h4 id="二叉树的概念和性质-1"><a href="#二叉树的概念和性质-1" class="headerlink" title="二叉树的概念和性质"></a>二叉树的概念和性质</h4><ul><li><p>二叉树的定义</p><ul><li>每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2</li><li>子树有左右顺序之分，不能颠倒</li></ul></li><li><p>满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层</p></li><li><p>完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的</p></li><li><p>二叉树的主要性质</p><ol><li><p>非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$</p></li><li><p>在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$</p></li><li><p>二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p><ul><li>若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）</li><li>若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点</li><li>若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点</li></ul></li><li><p>Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac{C_{2n}^{n}}{n+1}$  棵不同的二叉树</p></li><li><p>在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$</p></li></ol></li><li><p>二叉树的顺序存储结构最适用于完全二叉树</p></li><li><p>二叉树的链式存储结构</p><pre><code class="cpp">typedef struct BTNode&#123;    char  data;    //数据域    struct BTNoode* lchild;    struct BTNode* rchild;&#125; BTNode;</code></pre></li></ul><h4 id="二叉树的遍历算法-1"><a href="#二叉树的遍历算法-1" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><ul><li><p>先序遍历</p><pre><code class="cpp">/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123;    StackNode* S;   //定义一个栈指针    BitNode* p;   //工作指针    S = NULL;    p = root;    S = InitStack(S);   //初始化栈    if (NULL == p)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;     //end if    while (p || !StackEmpty(S))    &#123;     //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p);    //p 所指节点入栈            printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）            p = p-&gt;lchild ;     //指向 p 的左孩子         &#125;//end if        else        &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树            StackPop(S, p);            p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈        &#125;    //end else    &#125;    //end while    free(S);&#125;    //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123;    if (root)    &#123;        printf(&quot;%d &quot;, root-&gt;data);        preOrder(root-&gt;lchild);        preOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>中序遍历</p><pre><code class="cpp">/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123;    StackNode* S; //定义一个栈指针    BitNode* p; //工作指针    S = NULL;    p = root;    S = InitStack(S); //初始化栈    if (NULL == p) &#123; //如果是空树        printf(&quot;树为空！\n&quot;) ;        return;    &#125;//end if    while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p); //将节点入栈            p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子        &#125;//end if        else        &#123;            StackPop(S, p); //p 左子树为空则出栈            printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点            p = p-&gt;rchild; //向右子树移动        &#125;//end else    &#125;//end while    free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123;    if (root)    &#123;        inOrder(root-&gt;lchild);        printf(&quot;%d &quot;, root-&gt;data);        inOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>后序遍历</p><pre><code class="CPP">/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123;    StackNode* S; BiTNode* cur, * pre;//定义一个栈指针    S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点    if (NULL == root)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;//end if    pre = NULL; cur = NULL;    StackPush(S, T); //根节点入栈    while (!StackEmpty(S))    &#123; //若栈非空        cur = NULL;        StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/        if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||            (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))        &#123;            printf(&quot;%c &quot;, cur-&gt;data);            pre = cur;            StackPop(S, cur);        &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。        else        &#123;            if (cur-&gt;rchild != NULL)                StackPush(S, cur-&gt;rchild);            if (cur-&gt;lchild != NULL)                StackPush(S, cur-&gt;lchild);        &#125;//end else    &#125;//end while    free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123;    if (root)    &#123;        postOrder(root-&gt;lchild);        postOrder(root-&gt;rchild);        printf(&quot;%d &quot;, root-&gt;data);    &#125; &#125;</code></pre></li><li><p>层次遍历：自上而下，自左向右</p><ul><li>首先，将二叉树的祖先节点入队列</li><li>然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队</li></ul><pre><code class="cpp">void LayerOrder(BiTreeNode* head)&#123;    LQueue Q;    Initiate_Queue(&amp;Q);    BiTreeNode* p;    if (head != NULL) AppendQueue(&amp;Q, head);    while (QueueNotEmpty(&amp;Q)) &#123;        p = QueueDelete(&amp;Q);        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);        if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);    &#125;&#125; </code></pre></li></ul><h4 id="哈夫曼树和哈夫曼编码-1"><a href="#哈夫曼树和哈夫曼编码-1" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ul><li><p>哈夫曼树又叫做最优二叉树，它的特点是带权路径最短</p><ul><li>树的路径长度是指从根到每个节点的路径长度之和</li><li>带权路径长度是从该节点到根节之间的路径长度乘以结点的权值</li><li>树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和</li></ul></li><li><p>求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度</p><pre><code class="cpp">ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0  &#123;      if (FBT == NULL) //空树返回0          return 0;      else      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点              return FBT-&gt;data * len;          else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增              return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);      &#125;  &#125;  </code></pre></li><li><p>哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针  </p><pre><code class="cpp">struct BTreeNode* CreateHuffman(ElemType a[], int n)  &#123;      int i, j;      struct BTreeNode **b, *q;      b = malloc(n*sizeof(struct BTreeNode));      for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点      &#123;          b[i] = malloc(sizeof(struct BTreeNode));          b[i]-&gt;data = a[i];          b[i]-&gt;left = b[i]-&gt;right = NULL;      &#125;      for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树      &#123;          //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标          int k1 = -1, k2;          for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵          &#123;              if (b[j] != NULL &amp;&amp; k1 == -1)              &#123;                  k1 = j;                  continue;              &#125;              if (b[j] != NULL)              &#123;                  k2 = j;                  break;              &#125;          &#125;          for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小          &#123;              if (b[j] != NULL)              &#123;                  if (b[j]-&gt;data &lt; b[k1]-&gt;data)                  &#123;                      k2 = k1;                      k1 = j;                  &#125;                  else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                      k2 = j;              &#125;          &#125;          //由最小权值树和次最小权值树建立一棵新树，q指向树根结点          q = malloc(sizeof(struct BTreeNode));          q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;          q-&gt;left = b[k1];          q-&gt;right = b[k2];          b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置          b[k2] = NULL;//k2位置为空      &#125;      free(b); //删除动态建立的数组b      return q; //返回整个哈夫曼树的树根指针  &#125;  </code></pre></li><li><p>哈夫曼编码</p><ul><li>每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树</li><li>将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码</li><li>从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码</li><li>哈夫曼编码产生的是最短前缀码</li></ul><pre><code class="cpp">void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0  &#123;      static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一      if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)          &#123;              int i;              printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);              for (i = 0; i &lt; len; i++)                  printf(&quot;%d&quot;, a[i]);              printf(&quot;\n&quot;);          &#125;          else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a          &#123;   //的对应元素中，向下深入一层时len值增1              a[len] = 0;              HuffManCoding(FBT-&gt;left, len + 1);              a[len] = 1;              HuffManCoding(FBT-&gt;right, len + 1);          &#125;      &#125;  &#125;  </code></pre></li></ul><h3 id="图-1"><a href="#图-1" class="headerlink" title="图"></a>图</h3><h4 id="图的基本概念-1"><a href="#图的基本概念-1" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><ul><li>图由结点的有穷集合的 V 和边的集合  E 组成（<code>G(V,E)</code>）</li><li>图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示</li><li>路径长度：路径上边或者弧的数目</li><li>顶点的度：顶点关联边的数目<ul><li>有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度</li><li>在有向图中，顶点的度就是两者之和</li><li>在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量</li><li>在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量</li></ul></li></ul><h4 id="图的存储结构-1"><a href="#图的存储结构-1" class="headerlink" title="图的存储结构"></a>图的存储结构</h4><ul><li><p>邻接矩阵</p><ul><li>图的顺序存储结构</li><li>用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息</li><li>无向图中邻接矩阵是个对称矩阵</li><li>0表示无边，1表示有边</li><li>顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 </li><li>邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费</li></ul><pre><code class="cpp">typedef struct&#123;  int no;  char info;&#125; VertexType;typedef struct&#123;  int edges[maxSize][maxSize];    //有权图中int改为float  int n,e;    //顶点数和边数  VertexType vex[maxSize];    //存放结点信息&#125; MGragh;</code></pre></li><li><p>邻接表</p><ul><li>数组和链表相结合的存储方法，图的链式存储结构</li><li>图中顶点用一个一维数组存储</li><li>图中每个顶点 $V_i$ 的所有邻接点构成一个线性表</li><li>顶点表的各个结点由 data 和 Firstedge 两个域表示<ul><li>data 是数据域，存储顶点信息</li><li>firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点</li></ul></li><li>边表结点由 adjvex 和 next 两个域组成<ul><li>adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标</li><li>next 存储边表中下一个结点指针</li></ul></li><li>有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表</li></ul><pre><code class="cpp">typedef struct ArcNode&#123;    int adnex;    //该边所指向的结点的位置    struct ArcNode * nextarc;    //指向下一条边的指针    int info;    //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123;    char data;    //顶点信息    ArcNode* firstarc;    //指向第一条边的指针&#125;VNode;typedef struct&#123;    VNode adjlist[maxSize];    //邻接表    int n, e;    //顶点数和边数&#125; AGraph;    //图的邻接表类型</code></pre></li><li><p>十字链表</p><ul><li>在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表</li><li>定点表<ul><li>firstin：入边表头指针，指向顶点入边表的第一个结点</li><li>firstout：出边表头指针，指向顶点出边表第一个结点</li></ul></li><li>边表<ul><li>tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标</li><li>headlink 入边表指针域，指向终点相同的下一条边</li><li>taillink 是指边表指针域，指向起点相同的下一条边</li></ul></li></ul></li><li><p>邻接多重表</p><ul><li>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标</li><li>ilink 指向依附项点 ivex 的下一条边</li><li>jlink 指向依附顶点 jvex 的下一条边</li></ul></li></ul></li></ul><pre><code>#### 图的遍历算法- 深度优先遍历（DFS，Depth First Search）   - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了  - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问  - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历  ```cpp  bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问  void DFSTraverse(Graph G)  &#123;      for (v = 0;v &lt; G.vexnum;++v)          visited[v] = false;    //初始化标记数组      for (v = 0;v &lt; G.vexnum;++v)          if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历              DFS(G, v);  &#125;  void DFS(Graph G, int v)  &#123;      visit(v);      visited[v] = true; //定义为已访问      for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))          if (!visited[w])              DFS(G, w);  &#125;  ```- 广度优先遍历（BFS，Breadth First Search）  - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点  - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完  - BFS 遍历的方式类似于树的层次遍历  ```cpp  bool visited[Max_Vex];    //定义访问标记数组  void BFSTraverse(Graph G)  &#123;      for (i = 0;i &lt; G.vexnum;++i)          visited[v] = false;    //初始化标记数组      InitQueue(Q);      for (v = 0;v &lt; G.vexnum;++v)          if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历              BFS(G, v);  &#125;  void BFS(Graph G, int v)  &#123;      visit(v);      visited[v] = true;    //定义为已访问      while (!isEmpty(Q))      &#123;          DeQueue(Q, v);          for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))              if (!visited[w])              &#123;                  visit(w);                  visited[w] = true;                  EnQueue(Q, w)              &#125;    //if      &#125;    //while  &#125;  ```#### 最小生成树- Prim 算法  - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树  - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树  - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树  ```cpp  void prim (G,T)  &#123;      T = ∅;      U = &#123;w&#125;;      while ((V - U) != ∅  )      &#123; //若图中不含全部顶点          设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;          T = T∪ (u，v); //边归入树          U = U∪ &#123;v&#125;;     //顶点归入树      &#125;  &#125;  ```- Kruskal 算法  - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止  - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图  - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的  - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树    - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合    - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合  ```cpp  void kruskal（V，T）  &#123;      T = V;    //初始化树，仅含顶点      numS = n;    //不连分量的数目      while (numS &gt; 1)      &#123;          从 E 中取出权值最小的边（v,u）;          if（v 和 u 属于 T 中不同的连通分量）          &#123;              T = T∪（u，v）;//将此边加入到生成树中；              numS--; //不连通的分量减少 1          &#125;      &#125;  &#125;  ```#### 最短路径- Dijkstra 算法  - 通常用于求图中某一顶点到其余各顶点的最短路径  - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组  - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）  - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度- Dijkstra 算法步骤  1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$  2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）  3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离  4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中  ```cpp  void Dijkstra(int v0)  &#123;    　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中        int n=MAXNUM;    　　for(int i=1; i&lt;=n; ++i)   　　 &#123;        　　dist[i] = A[v0][i];        　　S[i] = false;                                // 初始都未用过该点        　　if(dist[i] == MAXINT)                  　　prev[i] = -1;   　　     else               　　prev[i] = v0;     　　&#125;     　 dist[v0] = 0;     　 S[v0] = true; 　　   　　 for(int i=2; i&lt;=n; i++)   　　 &#123;         　　int mindist = MAXINT;         　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值        　　 for(int j=1; j&lt;=n; ++j)        　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)        　　    &#123;           　　       u = j;                             // u保存当前邻接点中距离最小的点的号码            　 　      mindist = dist[j];         　　   &#125;         　　S[u] = true;          　　for(int j=1; j&lt;=n; j++)         　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)         　　    &#123;             　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径               　    　&#123;                     　　dist[j] = dist[u] + A[u][j];    //更新dist                      　　prev[j] = u;                    //记录前驱顶点               　　    &#125;          　    　&#125;     　　&#125;  &#125;  ```- Floyd 算法  - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包  - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$  - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离  - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离- Floyd 算法步骤  - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　  - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它  ```cpp  for (k = 1;k &lt;= n;k++)      for (i = 1;i &lt;= n;i++)          for (j = 1;j &lt;= n;j++)              if (a[i][j] &gt; a[i][k] + a[k][j])                  a[i][j] = a[i][k] + a[k][j];  ```#### 拓扑排序- 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边  1. 从 DAG 图中选择一个没有前驱的节点并输出  2. 从图中删除该节点和所有以它为起点的有向边  3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止  ```cpp  bool topologicalSort(Graph GL)  &#123;      EdgeNode* e;      int top = 0; //用于栈指针下标       int count = 0; // 用于统计输出顶点的个数       int* stack; // 建栈将入度为 0 的顶点入栈       stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));      for (i = 0; i &lt; GL-&gt;numVertexes; i++)          if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈               stack[++top] = i;      while (top != 0)      &#123;          gettop = stack[top--];          printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);          count++; //输出 i 号顶点，并计数           for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;              k = e-&gt;adjvex;              if (!(--GL-&gt;adjList[k].in))                  //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                   stack[++top] = k;          &#125;      &#125;      if (count &lt; GL-&gt;numVertexes) return false;      else return true;  &#125;  ```  &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下)  &lt;!--more--&gt;  ### 矩阵与广义表  #### 矩阵  - 矩阵的转置    ```cpp    void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                B[j][i] = A[i][j];    &#125;    ```  - 矩阵相加    ```cpp    void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                C[i][j] = A[i][j] + B[i][j];    &#125;    ```  - 矩阵相乘    ```cpp    void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; k;++j)            &#123;                C[i][j] = 0;                for int(h = 0;h &lt; n;++h)                    C[i][j] += A[i][j] * B[i][j];            &#125;    &#125;    ```  - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵    - 对称矩阵、三角阵、对角矩阵  #### 广义表  - 表元素可以是原子或者广义表的一种线性表的扩展结构  - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数  - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾  - 原子结点有两个域：标志域和数据域  - 广义表结点有三个域：标志域，头指针域与尾指针域  ### 树  #### 树的基本概念  - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成    - 结点不仅包含数据元素，并且包含指向子树的分支    - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值    - 树的高度是树中结点的最大层次，根结点的高度为树的高度  - 树的双亲存储结构：`int tree[maxSize]`  - 树的链式存储结构    - 邻接表：孩子存储结构    - 孩子兄弟存储结构  #### 二叉树的概念和性质  - 二叉树的定义    - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2    - 子树有左右顺序之分，不能颠倒  - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层  - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的  - 二叉树的主要性质    1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$    2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$    3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$    4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：       - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）       - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点       - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点    5. Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$  棵不同的二叉树    6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$  - 二叉树的顺序存储结构最适用于完全二叉树  - 二叉树的链式存储结构    ```cpp    typedef struct BTNode    &#123;        char  data;    //数据域        struct BTNoode* lchild;        struct BTNode* rchild;    &#125; BTNode;    ```  #### 二叉树的遍历算法  - 先序遍历    ```cpp    /*二叉树的非递归先序遍历*/    void PreTraverseTree2(BitNode * root)    &#123;        StackNode* S;   //定义一个栈指针        BitNode* p;   //工作指针        S = NULL;        p = root;        S = InitStack(S);   //初始化栈        if (NULL == p)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;     //end if        while (p || !StackEmpty(S))        &#123;     //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p);    //p 所指节点入栈                printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）                p = p-&gt;lchild ;     //指向 p 的左孩子             &#125;//end if            else            &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树                StackPop(S, p);                p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈            &#125;    //end else        &#125;    //end while        free(S);    &#125;    //end PreTraverseTree2    /*二叉树的递归先序遍历*/    void preOrder(BiTNode *root)    &#123;        if (root)        &#123;            printf(&quot;%d &quot;, root-&gt;data);            preOrder(root-&gt;lchild);            preOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 中序遍历    ```cpp    /*二叉树的非递归中序遍历*/    void InOrderTraverseTree2(BitNode* root)    &#123;        StackNode* S; //定义一个栈指针        BitNode* p; //工作指针        S = NULL;        p = root;        S = InitStack(S); //初始化栈        if (NULL == p) &#123; //如果是空树            printf(&quot;树为空！\n&quot;) ;            return;        &#125;//end if        while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p); //将节点入栈                p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子            &#125;//end if            else            &#123;                StackPop(S, p); //p 左子树为空则出栈                printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点                p = p-&gt;rchild; //向右子树移动            &#125;//end else        &#125;//end while        free(S);    &#125;//end InOrderTraverseTree2    /*二叉树的递归中序遍历*/    void inOrder(BiTNode* root)    &#123;        if (root)        &#123;            inOrder(root-&gt;lchild);            printf(&quot;%d &quot;, root-&gt;data);            inOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 后序遍历    ```CPP    /*二叉树非递归后序遍历*/    void LastTraverseTree2(BiTNode* root)    &#123;        StackNode* S; BiTNode* cur, * pre;//定义一个栈指针        S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点        if (NULL == root)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;//end if        pre = NULL; cur = NULL;        StackPush(S, T); //根节点入栈        while (!StackEmpty(S))        &#123; //若栈非空            cur = NULL;            StackGetTop(S, cur); //将栈顶节点赋给 cur    /*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。    如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是    其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/            if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||                (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))            &#123;                printf(&quot;%c &quot;, cur-&gt;data);                pre = cur;                StackPop(S, cur);            &#125;//end if    //若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素    //的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。            else            &#123;                if (cur-&gt;rchild != NULL)                    StackPush(S, cur-&gt;rchild);                if (cur-&gt;lchild != NULL)                    StackPush(S, cur-&gt;lchild);            &#125;//end else        &#125;//end while        free(S);    &#125;//end LastTraverseTree2    /*二叉树递归后序遍历*/    void postOrder(BiTNode* root)    &#123;        if (root)        &#123;            postOrder(root-&gt;lchild);            postOrder(root-&gt;rchild);            printf(&quot;%d &quot;, root-&gt;data);        &#125;     &#125;    ```  - 层次遍历：自上而下，自左向右    - 首先，将二叉树的祖先节点入队列    - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队    ```cpp    void LayerOrder(BiTreeNode* head)    &#123;        LQueue Q;        Initiate_Queue(&amp;Q);        BiTreeNode* p;        if (head != NULL) AppendQueue(&amp;Q, head);        while (QueueNotEmpty(&amp;Q)) &#123;            p = QueueDelete(&amp;Q);            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);            if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);        &#125;    &#125;     ```  #### 哈夫曼树和哈夫曼编码  - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短    - 树的路径长度是指从根到每个节点的路径长度之和    - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值    - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和  - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度    ```cpp    ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0      &#123;          if (FBT == NULL) //空树返回0              return 0;          else          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点                  return FBT-&gt;data * len;              else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增                  return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);          &#125;      &#125;      ```  - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针      ```cpp    struct BTreeNode* CreateHuffman(ElemType a[], int n)      &#123;          int i, j;          struct BTreeNode **b, *q;          b = malloc(n*sizeof(struct BTreeNode));          for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点          &#123;              b[i] = malloc(sizeof(struct BTreeNode));              b[i]-&gt;data = a[i];              b[i]-&gt;left = b[i]-&gt;right = NULL;          &#125;          for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树          &#123;              //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标              int k1 = -1, k2;              for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵              &#123;                  if (b[j] != NULL &amp;&amp; k1 == -1)                  &#123;                      k1 = j;                      continue;                  &#125;                  if (b[j] != NULL)                  &#123;                      k2 = j;                      break;                  &#125;              &#125;              for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小              &#123;                  if (b[j] != NULL)                  &#123;                      if (b[j]-&gt;data &lt; b[k1]-&gt;data)                      &#123;                          k2 = k1;                          k1 = j;                      &#125;                      else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                          k2 = j;                  &#125;              &#125;              //由最小权值树和次最小权值树建立一棵新树，q指向树根结点              q = malloc(sizeof(struct BTreeNode));              q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;              q-&gt;left = b[k1];              q-&gt;right = b[k2];              b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置              b[k2] = NULL;//k2位置为空          &#125;          free(b); //删除动态建立的数组b          return q; //返回整个哈夫曼树的树根指针      &#125;      ```  - 哈夫曼编码    - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树    - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码    - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码    - 哈夫曼编码产生的是最短前缀码    ```cpp    void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0      &#123;          static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一          if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)              &#123;                  int i;                  printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);                  for (i = 0; i &lt; len; i++)                      printf(&quot;%d&quot;, a[i]);                  printf(&quot;\n&quot;);              &#125;              else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a              &#123;   //的对应元素中，向下深入一层时len值增1                  a[len] = 0;                  HuffManCoding(FBT-&gt;left, len + 1);                  a[len] = 1;                  HuffManCoding(FBT-&gt;right, len + 1);              &#125;          &#125;      &#125;      ```  ### 图  #### 图的基本概念  - 图由结点的有穷集合的 V 和边的集合  E 组成（`G(V,E)`）  - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示  - 路径长度：路径上边或者弧的数目  - 顶点的度：顶点关联边的数目    - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度    - 在有向图中，顶点的度就是两者之和    - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量    - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量  #### 图的存储结构  - 邻接矩阵    - 图的顺序存储结构    - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息    - 无向图中邻接矩阵是个对称矩阵    - 0表示无边，1表示有边    - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度     - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费    ```cpp    typedef struct    &#123;      int no;      char info;    &#125; VertexType;    typedef struct    &#123;      int edges[maxSize][maxSize];    //有权图中int改为float      int n,e;    //顶点数和边数      VertexType vex[maxSize];    //存放结点信息    &#125; MGragh;    ```  - 邻接表    - 数组和链表相结合的存储方法，图的链式存储结构    - 图中顶点用一个一维数组存储    - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表    - 顶点表的各个结点由 data 和 Firstedge 两个域表示      - data 是数据域，存储顶点信息      - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点    - 边表结点由 adjvex 和 next 两个域组成      - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标      - next 存储边表中下一个结点指针    - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表    ```cpp    typedef struct ArcNode    &#123;        int adnex;    //该边所指向的结点的位置        struct ArcNode * nextarc;    //指向下一条边的指针        int info;    //该边的相关信息(如权值)    &#125; ArcNode;    typedef struct    &#123;        char data;    //顶点信息        ArcNode* firstarc;    //指向第一条边的指针    &#125;VNode;    typedef struct    &#123;        VNode adjlist[maxSize];    //邻接表        int n, e;    //顶点数和边数    &#125; AGraph;    //图的邻接表类型    ```  - 十字链表    - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表    - 定点表      - firstin：入边表头指针，指向顶点入边表的第一个结点      - firstout：出边表头指针，指向顶点出边表第一个结点    - 边表      - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标      - headlink 入边表指针域，指向终点相同的下一条边      - taillink 是指边表指针域，指向起点相同的下一条边  - 邻接多重表    - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标    - ilink 指向依附项点 ivex 的下一条边    - jlink 指向依附顶点 jvex 的下一条边  #### 图的遍历算法  - 深度优先遍历（DFS，Depth First Search）     - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了    - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问    - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问    void DFSTraverse(Graph G)    &#123;        for (v = 0;v &lt; G.vexnum;++v)            visited[v] = false;    //初始化标记数组        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历                DFS(G, v);    &#125;    void DFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true; //定义为已访问        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])                DFS(G, w);    &#125;    ```  - 广度优先遍历（BFS，Breadth First Search）    - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点    - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完    - BFS 遍历的方式类似于树的层次遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组    void BFSTraverse(Graph G)    &#123;        for (i = 0;i &lt; G.vexnum;++i)            visited[v] = false;    //初始化标记数组        InitQueue(Q);        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历                BFS(G, v);    &#125;    void BFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true;    //定义为已访问        while (!isEmpty(Q))        &#123;            DeQueue(Q, v);            for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))                if (!visited[w])                &#123;                    visit(w);                    visited[w] = true;                    EnQueue(Q, w)                &#125;    //if        &#125;    //while    &#125;    ```  #### 最小生成树  - Prim 算法    - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树    - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树    - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树    ```cpp    void prim (G,T)    &#123;        T = ∅;        U = &#123;w&#125;;        while ((V - U) != ∅  )        &#123; //若图中不含全部顶点            设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;            T = T∪ (u，v); //边归入树            U = U∪ &#123;v&#125;;     //顶点归入树        &#125;    &#125;    ```  - Kruskal 算法    - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止    - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图    - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的    - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树      - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合      - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合    ```cpp    void kruskal（V，T）    &#123;        T = V;    //初始化树，仅含顶点        numS = n;    //不连分量的数目        while (numS &gt; 1)        &#123;            从 E 中取出权值最小的边（v,u）;            if（v 和 u 属于 T 中不同的连通分量）            &#123;                T = T∪（u，v）;//将此边加入到生成树中；                numS--; //不连通的分量减少 1            &#125;        &#125;    &#125;    ```  #### 最短路径  - Dijkstra 算法    - 通常用于求图中某一顶点到其余各顶点的最短路径    - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组    - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）    - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度  - Dijkstra 算法步骤    1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$    2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）    3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离    4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中    ```cpp    void Dijkstra(int v0)    &#123;      　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中          int n=MAXNUM;      　　for(int i=1; i&lt;=n; ++i)     　　 &#123;          　　dist[i] = A[v0][i];          　　S[i] = false;                                // 初始都未用过该点          　　if(dist[i] == MAXINT)                    　　prev[i] = -1;     　　     else                 　　prev[i] = v0;       　　&#125;       　 dist[v0] = 0;       　 S[v0] = true; 　　     　　 for(int i=2; i&lt;=n; i++)     　　 &#123;           　　int mindist = MAXINT;           　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值          　　 for(int j=1; j&lt;=n; ++j)          　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)          　　    &#123;             　　       u = j;                             // u保存当前邻接点中距离最小的点的号码              　 　      mindist = dist[j];           　　   &#125;           　　S[u] = true;            　　for(int j=1; j&lt;=n; j++)           　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)           　　    &#123;               　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径                 　    　&#123;                       　　dist[j] = dist[u] + A[u][j];    //更新dist                        　　prev[j] = u;                    //记录前驱顶点                 　　    &#125;            　    　&#125;       　　&#125;    &#125;    ```  - Floyd 算法    - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包    - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$    - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离    - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离  - Floyd 算法步骤    - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　    - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它    ```cpp    for (k = 1;k &lt;= n;k++)        for (i = 1;i &lt;= n;i++)            for (j = 1;j &lt;= n;j++)                if (a[i][j] &gt; a[i][k] + a[k][j])                    a[i][j] = a[i][k] + a[k][j];    ```  #### 拓扑排序  - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边    1. 从 DAG 图中选择一个没有前驱的节点并输出    2. 从图中删除该节点和所有以它为起点的有向边    3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止    ```cpp    bool topologicalSort(Graph GL)    &#123;        EdgeNode* e;        int top = 0; //用于栈指针下标         int count = 0; // 用于统计输出顶点的个数         int* stack; // 建栈将入度为 0 的顶点入栈         stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));        for (i = 0; i &lt; GL-&gt;numVertexes; i++)            if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈                 stack[++top] = i;        while (top != 0)        &#123;            gettop = stack[top--];            printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);            count++; //输出 i 号顶点，并计数             for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;                k = e-&gt;adjvex;                if (!(--GL-&gt;adjList[k].in))                    //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                     stack[++top] = k;            &#125;        &#125;        if (count &lt; GL-&gt;numVertexes) return false;        else return true;    &#125;    ```  &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下)  &lt;!--more--&gt;  ### 矩阵与广义表  #### 矩阵  - 矩阵的转置    ```cpp    void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                B[j][i] = A[i][j];    &#125;    ```  - 矩阵相加    ```cpp    void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                C[i][j] = A[i][j] + B[i][j];    &#125;    ```  - 矩阵相乘    ```cpp    void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; k;++j)            &#123;                C[i][j] = 0;                for int(h = 0;h &lt; n;++h)                    C[i][j] += A[i][j] * B[i][j];            &#125;    &#125;    ```  - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵    - 对称矩阵、三角阵、对角矩阵  #### 广义表  - 表元素可以是原子或者广义表的一种线性表的扩展结构  - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数  - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾  - 原子结点有两个域：标志域和数据域  - 广义表结点有三个域：标志域，头指针域与尾指针域  ### 树  #### 树的基本概念  - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成    - 结点不仅包含数据元素，并且包含指向子树的分支    - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值    - 树的高度是树中结点的最大层次，根结点的高度为树的高度  - 树的双亲存储结构：`int tree[maxSize]`  - 树的链式存储结构    - 邻接表：孩子存储结构    - 孩子兄弟存储结构  #### 二叉树的概念和性质  - 二叉树的定义    - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2    - 子树有左右顺序之分，不能颠倒  - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层  - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的  - 二叉树的主要性质    1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$    2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$    3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$    4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：       - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）       - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点       - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点    5. Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$  棵不同的二叉树    6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$  - 二叉树的顺序存储结构最适用于完全二叉树  - 二叉树的链式存储结构    ```cpp    typedef struct BTNode    &#123;        char  data;    //数据域        struct BTNoode* lchild;        struct BTNode* rchild;    &#125; BTNode;    ```  #### 二叉树的遍历算法  - 先序遍历    ```cpp    /*二叉树的非递归先序遍历*/    void PreTraverseTree2(BitNode * root)    &#123;        StackNode* S;   //定义一个栈指针        BitNode* p;   //工作指针        S = NULL;        p = root;        S = InitStack(S);   //初始化栈        if (NULL == p)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;     //end if        while (p || !StackEmpty(S))        &#123;     //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p);    //p 所指节点入栈                printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）                p = p-&gt;lchild ;     //指向 p 的左孩子             &#125;//end if            else            &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树                StackPop(S, p);                p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈            &#125;    //end else        &#125;    //end while        free(S);    &#125;    //end PreTraverseTree2    /*二叉树的递归先序遍历*/    void preOrder(BiTNode *root)    &#123;        if (root)        &#123;            printf(&quot;%d &quot;, root-&gt;data);            preOrder(root-&gt;lchild);            preOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 中序遍历    ```cpp    /*二叉树的非递归中序遍历*/    void InOrderTraverseTree2(BitNode* root)    &#123;        StackNode* S; //定义一个栈指针        BitNode* p; //工作指针        S = NULL;        p = root;        S = InitStack(S); //初始化栈        if (NULL == p) &#123; //如果是空树            printf(&quot;树为空！\n&quot;) ;            return;        &#125;//end if        while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p); //将节点入栈                p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子            &#125;//end if            else            &#123;                StackPop(S, p); //p 左子树为空则出栈                printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点                p = p-&gt;rchild; //向右子树移动            &#125;//end else        &#125;//end while        free(S);    &#125;//end InOrderTraverseTree2    /*二叉树的递归中序遍历*/    void inOrder(BiTNode* root)    &#123;        if (root)        &#123;            inOrder(root-&gt;lchild);            printf(&quot;%d &quot;, root-&gt;data);            inOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 后序遍历    ```CPP    /*二叉树非递归后序遍历*/    void LastTraverseTree2(BiTNode* root)    &#123;        StackNode* S; BiTNode* cur, * pre;//定义一个栈指针        S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点        if (NULL == root)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;//end if        pre = NULL; cur = NULL;        StackPush(S, T); //根节点入栈        while (!StackEmpty(S))        &#123; //若栈非空            cur = NULL;            StackGetTop(S, cur); //将栈顶节点赋给 cur    /*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。    如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是    其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/            if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||                (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))            &#123;                printf(&quot;%c &quot;, cur-&gt;data);                pre = cur;                StackPop(S, cur);            &#125;//end if    //若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素    //的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。            else            &#123;                if (cur-&gt;rchild != NULL)                    StackPush(S, cur-&gt;rchild);                if (cur-&gt;lchild != NULL)                    StackPush(S, cur-&gt;lchild);            &#125;//end else        &#125;//end while        free(S);    &#125;//end LastTraverseTree2    /*二叉树递归后序遍历*/    void postOrder(BiTNode* root)    &#123;        if (root)        &#123;            postOrder(root-&gt;lchild);            postOrder(root-&gt;rchild);            printf(&quot;%d &quot;, root-&gt;data);        &#125;     &#125;    ```  - 层次遍历：自上而下，自左向右    - 首先，将二叉树的祖先节点入队列    - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队    ```cpp    void LayerOrder(BiTreeNode* head)    &#123;        LQueue Q;        Initiate_Queue(&amp;Q);        BiTreeNode* p;        if (head != NULL) AppendQueue(&amp;Q, head);        while (QueueNotEmpty(&amp;Q)) &#123;            p = QueueDelete(&amp;Q);            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);            if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);        &#125;    &#125;     ```  #### 哈夫曼树和哈夫曼编码  - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短    - 树的路径长度是指从根到每个节点的路径长度之和    - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值    - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和  - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度    ```cpp    ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0      &#123;          if (FBT == NULL) //空树返回0              return 0;          else          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点                  return FBT-&gt;data * len;              else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增                  return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);          &#125;      &#125;      ```  - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针      ```cpp    struct BTreeNode* CreateHuffman(ElemType a[], int n)      &#123;          int i, j;          struct BTreeNode **b, *q;          b = malloc(n*sizeof(struct BTreeNode));          for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点          &#123;              b[i] = malloc(sizeof(struct BTreeNode));              b[i]-&gt;data = a[i];              b[i]-&gt;left = b[i]-&gt;right = NULL;          &#125;          for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树          &#123;              //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标              int k1 = -1, k2;              for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵              &#123;                  if (b[j] != NULL &amp;&amp; k1 == -1)                  &#123;                      k1 = j;                      continue;                  &#125;                  if (b[j] != NULL)                  &#123;                      k2 = j;                      break;                  &#125;              &#125;              for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小              &#123;                  if (b[j] != NULL)                  &#123;                      if (b[j]-&gt;data &lt; b[k1]-&gt;data)                      &#123;                          k2 = k1;                          k1 = j;                      &#125;                      else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                          k2 = j;                  &#125;              &#125;              //由最小权值树和次最小权值树建立一棵新树，q指向树根结点              q = malloc(sizeof(struct BTreeNode));              q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;              q-&gt;left = b[k1];              q-&gt;right = b[k2];              b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置              b[k2] = NULL;//k2位置为空          &#125;          free(b); //删除动态建立的数组b          return q; //返回整个哈夫曼树的树根指针      &#125;      ```  - 哈夫曼编码    - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树    - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码    - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码    - 哈夫曼编码产生的是最短前缀码    ```cpp    void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0      &#123;          static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一          if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)              &#123;                  int i;                  printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);                  for (i = 0; i &lt; len; i++)                      printf(&quot;%d&quot;, a[i]);                  printf(&quot;\n&quot;);              &#125;              else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a              &#123;   //的对应元素中，向下深入一层时len值增1                  a[len] = 0;                  HuffManCoding(FBT-&gt;left, len + 1);                  a[len] = 1;                  HuffManCoding(FBT-&gt;right, len + 1);              &#125;          &#125;      &#125;      ```  ### 图  #### 图的基本概念  - 图由结点的有穷集合的 V 和边的集合  E 组成（`G(V,E)`）  - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示  - 路径长度：路径上边或者弧的数目  - 顶点的度：顶点关联边的数目    - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度    - 在有向图中，顶点的度就是两者之和    - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量    - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量  #### 图的存储结构  - 邻接矩阵    - 图的顺序存储结构    - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息    - 无向图中邻接矩阵是个对称矩阵    - 0表示无边，1表示有边    - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度     - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费    ```cpp    typedef struct    &#123;      int no;      char info;    &#125; VertexType;    typedef struct    &#123;      int edges[maxSize][maxSize];    //有权图中int改为float      int n,e;    //顶点数和边数      VertexType vex[maxSize];    //存放结点信息    &#125; MGragh;    ```  - 邻接表    - 数组和链表相结合的存储方法，图的链式存储结构    - 图中顶点用一个一维数组存储    - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表    - 顶点表的各个结点由 data 和 Firstedge 两个域表示      - data 是数据域，存储顶点信息      - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点    - 边表结点由 adjvex 和 next 两个域组成      - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标      - next 存储边表中下一个结点指针    - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表    ```cpp    typedef struct ArcNode    &#123;        int adnex;    //该边所指向的结点的位置        struct ArcNode * nextarc;    //指向下一条边的指针        int info;    //该边的相关信息(如权值)    &#125; ArcNode;    typedef struct    &#123;        char data;    //顶点信息        ArcNode* firstarc;    //指向第一条边的指针    &#125;VNode;    typedef struct    &#123;        VNode adjlist[maxSize];    //邻接表        int n, e;    //顶点数和边数    &#125; AGraph;    //图的邻接表类型    ```  - 十字链表    - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表    - 定点表      - firstin：入边表头指针，指向顶点入边表的第一个结点      - firstout：出边表头指针，指向顶点出边表第一个结点    - 边表      - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标      - headlink 入边表指针域，指向终点相同的下一条边      - taillink 是指边表指针域，指向起点相同的下一条边  - 邻接多重表    - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标    - ilink 指向依附项点 ivex 的下一条边    - jlink 指向依附顶点 jvex 的下一条边  #### 图的遍历算法  - 深度优先遍历（DFS，Depth First Search）     - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了    - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问    - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问    void DFSTraverse(Graph G)    &#123;        for (v = 0;v &lt; G.vexnum;++v)            visited[v] = false;    //初始化标记数组        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历                DFS(G, v);    &#125;    void DFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true; //定义为已访问        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])                DFS(G, w);    &#125;    ```  - 广度优先遍历（BFS，Breadth First Search）    - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点    - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完    - BFS 遍历的方式类似于树的层次遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组    void BFSTraverse(Graph G)    &#123;        for (i = 0;i &lt; G.vexnum;++i)            visited[v] = false;    //初始化标记数组        InitQueue(Q);        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历                BFS(G, v);    &#125;    void BFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true;    //定义为已访问        while (!isEmpty(Q))        &#123;            DeQueue(Q, v);            for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))                if (!visited[w])                &#123;                    visit(w);                    visited[w] = true;                    EnQueue(Q, w)                &#125;    //if        &#125;    //while    &#125;    ```  #### 最小生成树  - Prim 算法    - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树    - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树    - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树    ```cpp    void prim (G,T)    &#123;        T = ∅;        U = &#123;w&#125;;        while ((V - U) != ∅  )        &#123; //若图中不含全部顶点            设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;            T = T∪ (u，v); //边归入树            U = U∪ &#123;v&#125;;     //顶点归入树        &#125;    &#125;    ```  - Kruskal 算法    - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止    - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图    - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的    - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树      - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合      - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合    ```cpp    void kruskal（V，T）    &#123;        T = V;    //初始化树，仅含顶点        numS = n;    //不连分量的数目        while (numS &gt; 1)        &#123;            从 E 中取出权值最小的边（v,u）;            if（v 和 u 属于 T 中不同的连通分量）            &#123;                T = T∪（u，v）;//将此边加入到生成树中；                numS--; //不连通的分量减少 1            &#125;        &#125;    &#125;    ```  #### 最短路径  - Dijkstra 算法    - 通常用于求图中某一顶点到其余各顶点的最短路径    - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组    - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）    - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度  - Dijkstra 算法步骤    1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$    2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）    3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离    4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中    ```cpp    void Dijkstra(int v0)    &#123;      　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中          int n=MAXNUM;      　　for(int i=1; i&lt;=n; ++i)     　　 &#123;          　　dist[i] = A[v0][i];          　　S[i] = false;                                // 初始都未用过该点          　　if(dist[i] == MAXINT)                    　　prev[i] = -1;     　　     else                 　　prev[i] = v0;       　　&#125;       　 dist[v0] = 0;       　 S[v0] = true; 　　     　　 for(int i=2; i&lt;=n; i++)     　　 &#123;           　　int mindist = MAXINT;           　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值          　　 for(int j=1; j&lt;=n; ++j)          　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)          　　    &#123;             　　       u = j;                             // u保存当前邻接点中距离最小的点的号码              　 　      mindist = dist[j];           　　   &#125;           　　S[u] = true;            　　for(int j=1; j&lt;=n; j++)           　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)           　　    &#123;               　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径                 　    　&#123;                       　　dist[j] = dist[u] + A[u][j];    //更新dist                        　　prev[j] = u;                    //记录前驱顶点                 　　    &#125;            　    　&#125;       　　&#125;    &#125;    ```  - Floyd 算法    - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包    - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$    - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离    - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离  - Floyd 算法步骤    - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　    - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它    ```cpp    for (k = 1;k &lt;= n;k++)        for (i = 1;i &lt;= n;i++)            for (j = 1;j &lt;= n;j++)                if (a[i][j] &gt; a[i][k] + a[k][j])                    a[i][j] = a[i][k] + a[k][j];    ```  #### 拓扑排序  - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边    1. 从 DAG 图中选择一个没有前驱的节点并输出    2. 从图中删除该节点和所有以它为起点的有向边    3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止    ```cpp    bool topologicalSort(Graph GL)    &#123;        EdgeNode* e;        int top = 0; //用于栈指针下标         int count = 0; // 用于统计输出顶点的个数         int* stack; // 建栈将入度为 0 的顶点入栈         stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));        for (i = 0; i &lt; GL-&gt;numVertexes; i++)            if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈                 stack[++top] = i;        while (top != 0)        &#123;            gettop = stack[top--];            printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);            count++; //输出 i 号顶点，并计数             for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;                k = e-&gt;adjvex;                if (!(--GL-&gt;adjList[k].in))                    //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                     stack[++top] = k;            &#125;        &#125;        if (count &lt; GL-&gt;numVertexes) return false;        else return true;    &#125;    ```  &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下)  &lt;!--more--&gt;  ### 矩阵与广义表  #### 矩阵  - 矩阵的转置    ```cpp    void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                B[j][i] = A[i][j];    &#125;    ```  - 矩阵相加    ```cpp    void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                C[i][j] = A[i][j] + B[i][j];    &#125;    ```  - 矩阵相乘    ```cpp    void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; k;++j)            &#123;                C[i][j] = 0;                for int(h = 0;h &lt; n;++h)                    C[i][j] += A[i][j] * B[i][j];            &#125;    &#125;    ```  - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵    - 对称矩阵、三角阵、对角矩阵  #### 广义表  - 表元素可以是原子或者广义表的一种线性表的扩展结构  - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数  - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾  - 原子结点有两个域：标志域和数据域  - 广义表结点有三个域：标志域，头指针域与尾指针域  ### 树  #### 树的基本概念  - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成    - 结点不仅包含数据元素，并且包含指向子树的分支    - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值    - 树的高度是树中结点的最大层次，根结点的高度为树的高度  - 树的双亲存储结构：`int tree[maxSize]`  - 树的链式存储结构    - 邻接表：孩子存储结构    - 孩子兄弟存储结构  #### 二叉树的概念和性质  - 二叉树的定义    - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2    - 子树有左右顺序之分，不能颠倒  - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层  - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的  - 二叉树的主要性质    1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$    2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$    3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$    4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：       - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）       - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点       - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点    5. Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$  棵不同的二叉树    6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$  - 二叉树的顺序存储结构最适用于完全二叉树  - 二叉树的链式存储结构    ```cpp    typedef struct BTNode    &#123;        char  data;    //数据域        struct BTNoode* lchild;        struct BTNode* rchild;    &#125; BTNode;    ```  #### 二叉树的遍历算法  - 先序遍历    ```cpp    /*二叉树的非递归先序遍历*/    void PreTraverseTree2(BitNode * root)    &#123;        StackNode* S;   //定义一个栈指针        BitNode* p;   //工作指针        S = NULL;        p = root;        S = InitStack(S);   //初始化栈        if (NULL == p)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;     //end if        while (p || !StackEmpty(S))        &#123;     //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p);    //p 所指节点入栈                printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）                p = p-&gt;lchild ;     //指向 p 的左孩子             &#125;//end if            else            &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树                StackPop(S, p);                p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈            &#125;    //end else        &#125;    //end while        free(S);    &#125;    //end PreTraverseTree2    /*二叉树的递归先序遍历*/    void preOrder(BiTNode *root)    &#123;        if (root)        &#123;            printf(&quot;%d &quot;, root-&gt;data);            preOrder(root-&gt;lchild);            preOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 中序遍历    ```cpp    /*二叉树的非递归中序遍历*/    void InOrderTraverseTree2(BitNode* root)    &#123;        StackNode* S; //定义一个栈指针        BitNode* p; //工作指针        S = NULL;        p = root;        S = InitStack(S); //初始化栈        if (NULL == p) &#123; //如果是空树            printf(&quot;树为空！\n&quot;) ;            return;        &#125;//end if        while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p); //将节点入栈                p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子            &#125;//end if            else            &#123;                StackPop(S, p); //p 左子树为空则出栈                printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点                p = p-&gt;rchild; //向右子树移动            &#125;//end else        &#125;//end while        free(S);    &#125;//end InOrderTraverseTree2    /*二叉树的递归中序遍历*/    void inOrder(BiTNode* root)    &#123;        if (root)        &#123;            inOrder(root-&gt;lchild);            printf(&quot;%d &quot;, root-&gt;data);            inOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 后序遍历    ```CPP    /*二叉树非递归后序遍历*/    void LastTraverseTree2(BiTNode* root)    &#123;        StackNode* S; BiTNode* cur, * pre;//定义一个栈指针        S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点        if (NULL == root)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;//end if        pre = NULL; cur = NULL;        StackPush(S, T); //根节点入栈        while (!StackEmpty(S))        &#123; //若栈非空            cur = NULL;            StackGetTop(S, cur); //将栈顶节点赋给 cur    /*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。    如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是    其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/            if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||                (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))            &#123;                printf(&quot;%c &quot;, cur-&gt;data);                pre = cur;                StackPop(S, cur);            &#125;//end if    //若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素    //的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。            else            &#123;                if (cur-&gt;rchild != NULL)                    StackPush(S, cur-&gt;rchild);                if (cur-&gt;lchild != NULL)                    StackPush(S, cur-&gt;lchild);            &#125;//end else        &#125;//end while        free(S);    &#125;//end LastTraverseTree2    /*二叉树递归后序遍历*/    void postOrder(BiTNode* root)    &#123;        if (root)        &#123;            postOrder(root-&gt;lchild);            postOrder(root-&gt;rchild);            printf(&quot;%d &quot;, root-&gt;data);        &#125;     &#125;    ```  - 层次遍历：自上而下，自左向右    - 首先，将二叉树的祖先节点入队列    - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队    ```cpp    void LayerOrder(BiTreeNode* head)    &#123;        LQueue Q;        Initiate_Queue(&amp;Q);        BiTreeNode* p;        if (head != NULL) AppendQueue(&amp;Q, head);        while (QueueNotEmpty(&amp;Q)) &#123;            p = QueueDelete(&amp;Q);            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);            if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);        &#125;    &#125;     ```  #### 哈夫曼树和哈夫曼编码  - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短    - 树的路径长度是指从根到每个节点的路径长度之和    - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值    - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和  - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度    ```cpp    ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0      &#123;          if (FBT == NULL) //空树返回0              return 0;          else          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点                  return FBT-&gt;data * len;              else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增                  return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);          &#125;      &#125;      ```  - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针      ```cpp    struct BTreeNode* CreateHuffman(ElemType a[], int n)      &#123;          int i, j;          struct BTreeNode **b, *q;          b = malloc(n*sizeof(struct BTreeNode));          for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点          &#123;              b[i] = malloc(sizeof(struct BTreeNode));              b[i]-&gt;data = a[i];              b[i]-&gt;left = b[i]-&gt;right = NULL;          &#125;          for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树          &#123;              //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标              int k1 = -1, k2;              for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵              &#123;                  if (b[j] != NULL &amp;&amp; k1 == -1)                  &#123;                      k1 = j;                      continue;                  &#125;                  if (b[j] != NULL)                  &#123;                      k2 = j;                      break;                  &#125;              &#125;              for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小              &#123;                  if (b[j] != NULL)                  &#123;                      if (b[j]-&gt;data &lt; b[k1]-&gt;data)                      &#123;                          k2 = k1;                          k1 = j;                      &#125;                      else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                          k2 = j;                  &#125;              &#125;              //由最小权值树和次最小权值树建立一棵新树，q指向树根结点              q = malloc(sizeof(struct BTreeNode));              q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;              q-&gt;left = b[k1];              q-&gt;right = b[k2];              b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置              b[k2] = NULL;//k2位置为空          &#125;          free(b); //删除动态建立的数组b          return q; //返回整个哈夫曼树的树根指针      &#125;      ```  - 哈夫曼编码    - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树    - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码    - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码    - 哈夫曼编码产生的是最短前缀码    ```cpp    void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0      &#123;          static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一          if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)              &#123;                  int i;                  printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);                  for (i = 0; i &lt; len; i++)                      printf(&quot;%d&quot;, a[i]);                  printf(&quot;\n&quot;);              &#125;              else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a              &#123;   //的对应元素中，向下深入一层时len值增1                  a[len] = 0;                  HuffManCoding(FBT-&gt;left, len + 1);                  a[len] = 1;                  HuffManCoding(FBT-&gt;right, len + 1);              &#125;          &#125;      &#125;      ```  ### 图  #### 图的基本概念  - 图由结点的有穷集合的 V 和边的集合  E 组成（`G(V,E)`）  - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示  - 路径长度：路径上边或者弧的数目  - 顶点的度：顶点关联边的数目    - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度    - 在有向图中，顶点的度就是两者之和    - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量    - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量  #### 图的存储结构  - 邻接矩阵    - 图的顺序存储结构    - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息    - 无向图中邻接矩阵是个对称矩阵    - 0表示无边，1表示有边    - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度     - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费    ```cpp    typedef struct    &#123;      int no;      char info;    &#125; VertexType;    typedef struct    &#123;      int edges[maxSize][maxSize];    //有权图中int改为float      int n,e;    //顶点数和边数      VertexType vex[maxSize];    //存放结点信息    &#125; MGragh;    ```  - 邻接表    - 数组和链表相结合的存储方法，图的链式存储结构    - 图中顶点用一个一维数组存储    - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表    - 顶点表的各个结点由 data 和 Firstedge 两个域表示      - data 是数据域，存储顶点信息      - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点    - 边表结点由 adjvex 和 next 两个域组成      - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标      - next 存储边表中下一个结点指针    - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表    ```cpp    typedef struct ArcNode    &#123;        int adnex;    //该边所指向的结点的位置        struct ArcNode * nextarc;    //指向下一条边的指针        int info;    //该边的相关信息(如权值)    &#125; ArcNode;    typedef struct    &#123;        char data;    //顶点信息        ArcNode* firstarc;    //指向第一条边的指针    &#125;VNode;    typedef struct    &#123;        VNode adjlist[maxSize];    //邻接表        int n, e;    //顶点数和边数    &#125; AGraph;    //图的邻接表类型    ```  - 十字链表    - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表    - 定点表      - firstin：入边表头指针，指向顶点入边表的第一个结点      - firstout：出边表头指针，指向顶点出边表第一个结点    - 边表      - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标      - headlink 入边表指针域，指向终点相同的下一条边      - taillink 是指边表指针域，指向起点相同的下一条边  - 邻接多重表    - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标    - ilink 指向依附项点 ivex 的下一条边    - jlink 指向依附顶点 jvex 的下一条边  #### 图的遍历算法  - 深度优先遍历（DFS，Depth First Search）     - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了    - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问    - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问    void DFSTraverse(Graph G)    &#123;        for (v = 0;v &lt; G.vexnum;++v)            visited[v] = false;    //初始化标记数组        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历                DFS(G, v);    &#125;    void DFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true; //定义为已访问        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])                DFS(G, w);    &#125;    ```  - 广度优先遍历（BFS，Breadth First Search）    - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点    - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完    - BFS 遍历的方式类似于树的层次遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组    void BFSTraverse(Graph G)    &#123;        for (i = 0;i &lt; G.vexnum;++i)            visited[v] = false;    //初始化标记数组        InitQueue(Q);        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历                BFS(G, v);    &#125;    void BFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true;    //定义为已访问        while (!isEmpty(Q))        &#123;            DeQueue(Q, v);            for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))                if (!visited[w])                &#123;                    visit(w);                    visited[w] = true;                    EnQueue(Q, w)                &#125;    //if        &#125;    //while    &#125;    ```  #### 最小生成树  - Prim 算法    - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树    - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树    - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树    ```cpp    void prim (G,T)    &#123;        T = ∅;        U = &#123;w&#125;;        while ((V - U) != ∅  )        &#123; //若图中不含全部顶点            设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;            T = T∪ (u，v); //边归入树            U = U∪ &#123;v&#125;;     //顶点归入树        &#125;    &#125;    ```  - Kruskal 算法    - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止    - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图    - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的    - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树      - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合      - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合    ```cpp    void kruskal（V，T）    &#123;        T = V;    //初始化树，仅含顶点        numS = n;    //不连分量的数目        while (numS &gt; 1)        &#123;            从 E 中取出权值最小的边（v,u）;            if（v 和 u 属于 T 中不同的连通分量）            &#123;                T = T∪（u，v）;//将此边加入到生成树中；                numS--; //不连通的分量减少 1            &#125;        &#125;    &#125;    ```  #### 最短路径  - Dijkstra 算法    - 通常用于求图中某一顶点到其余各顶点的最短路径    - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组    - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）    - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度  - Dijkstra 算法步骤    1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$    2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）    3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离    4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中    ```cpp    void Dijkstra(int v0)    &#123;      　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中          int n=MAXNUM;      　　for(int i=1; i&lt;=n; ++i)     　　 &#123;          　　dist[i] = A[v0][i];          　　S[i] = false;                                // 初始都未用过该点          　　if(dist[i] == MAXINT)                    　　prev[i] = -1;     　　     else                 　　prev[i] = v0;       　　&#125;       　 dist[v0] = 0;       　 S[v0] = true; 　　     　　 for(int i=2; i&lt;=n; i++)     　　 &#123;           　　int mindist = MAXINT;           　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值          　　 for(int j=1; j&lt;=n; ++j)          　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)          　　    &#123;             　　       u = j;                             // u保存当前邻接点中距离最小的点的号码              　 　      mindist = dist[j];           　　   &#125;           　　S[u] = true;            　　for(int j=1; j&lt;=n; j++)           　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)           　　    &#123;               　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径                 　    　&#123;                       　　dist[j] = dist[u] + A[u][j];    //更新dist                        　　prev[j] = u;                    //记录前驱顶点                 　　    &#125;            　    　&#125;       　　&#125;    &#125;    ```  - Floyd 算法    - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包    - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$    - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离    - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离  - Floyd 算法步骤    - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　    - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它    ```cpp    for (k = 1;k &lt;= n;k++)        for (i = 1;i &lt;= n;i++)            for (j = 1;j &lt;= n;j++)                if (a[i][j] &gt; a[i][k] + a[k][j])                    a[i][j] = a[i][k] + a[k][j];    ```  #### 拓扑排序  - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边    1. 从 DAG 图中选择一个没有前驱的节点并输出    2. 从图中删除该节点和所有以它为起点的有向边    3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止    ```cpp    bool topologicalSort(Graph GL)    &#123;        EdgeNode* e;        int top = 0; //用于栈指针下标         int count = 0; // 用于统计输出顶点的个数         int* stack; // 建栈将入度为 0 的顶点入栈         stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));        for (i = 0; i &lt; GL-&gt;numVertexes; i++)            if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈                 stack[++top] = i;        while (top != 0)        &#123;            gettop = stack[top--];            printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);            count++; //输出 i 号顶点，并计数             for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;                k = e-&gt;adjvex;                if (!(--GL-&gt;adjList[k].in))                    //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                     stack[++top] = k;            &#125;        &#125;        if (count &lt; GL-&gt;numVertexes) return false;        else return true;    &#125;    ```  &gt; 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下)  &lt;!--more--&gt;  ### 矩阵与广义表  #### 矩阵  - 矩阵的转置    ```cpp    void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                B[j][i] = A[i][j];    &#125;    ```  - 矩阵相加    ```cpp    void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; n;++j)                C[i][j] = A[i][j] + B[i][j];    &#125;    ```  - 矩阵相乘    ```cpp    void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)    &#123;        for (int i = 0;i &lt; m;++i)            for (int j = 0;j &lt; k;++j)            &#123;                C[i][j] = 0;                for int(h = 0;h &lt; n;++h)                    C[i][j] += A[i][j] * B[i][j];            &#125;    &#125;    ```  - 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵    - 对称矩阵、三角阵、对角矩阵  #### 广义表  - 表元素可以是原子或者广义表的一种线性表的扩展结构  - 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数  - 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾  - 原子结点有两个域：标志域和数据域  - 广义表结点有三个域：标志域，头指针域与尾指针域  ### 树  #### 树的基本概念  - 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成    - 结点不仅包含数据元素，并且包含指向子树的分支    - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值    - 树的高度是树中结点的最大层次，根结点的高度为树的高度  - 树的双亲存储结构：`int tree[maxSize]`  - 树的链式存储结构    - 邻接表：孩子存储结构    - 孩子兄弟存储结构  #### 二叉树的概念和性质  - 二叉树的定义    - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2    - 子树有左右顺序之分，不能颠倒  - 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层  - 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的  - 二叉树的主要性质    1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$    2. 在二叉树的第 $i$ 层上最多有 $2^&#123;i-1&#125;$个节点，$(i&gt;=1)$    3. 二叉树中如果深度为 $k$，那么最多有 $2^&#123;k-1&#125;$ 个节点，$(k&gt;=1)$    4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：       - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）       - 若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点       - 若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点    5. Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac&#123;C_&#123;2n&#125;^&#123;n&#125;&#125;&#123;n+1&#125;$  棵不同的二叉树    6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$  - 二叉树的顺序存储结构最适用于完全二叉树  - 二叉树的链式存储结构    ```cpp    typedef struct BTNode    &#123;        char  data;    //数据域        struct BTNoode* lchild;        struct BTNode* rchild;    &#125; BTNode;    ```  #### 二叉树的遍历算法  - 先序遍历    ```cpp    /*二叉树的非递归先序遍历*/    void PreTraverseTree2(BitNode * root)    &#123;        StackNode* S;   //定义一个栈指针        BitNode* p;   //工作指针        S = NULL;        p = root;        S = InitStack(S);   //初始化栈        if (NULL == p)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;     //end if        while (p || !StackEmpty(S))        &#123;     //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p);    //p 所指节点入栈                printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）                p = p-&gt;lchild ;     //指向 p 的左孩子             &#125;//end if            else            &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树                StackPop(S, p);                p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈            &#125;    //end else        &#125;    //end while        free(S);    &#125;    //end PreTraverseTree2    /*二叉树的递归先序遍历*/    void preOrder(BiTNode *root)    &#123;        if (root)        &#123;            printf(&quot;%d &quot;, root-&gt;data);            preOrder(root-&gt;lchild);            preOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 中序遍历    ```cpp    /*二叉树的非递归中序遍历*/    void InOrderTraverseTree2(BitNode* root)    &#123;        StackNode* S; //定义一个栈指针        BitNode* p; //工作指针        S = NULL;        p = root;        S = InitStack(S); //初始化栈        if (NULL == p) &#123; //如果是空树            printf(&quot;树为空！\n&quot;) ;            return;        &#125;//end if        while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空            if (p)            &#123;                StackPush(S, p); //将节点入栈                p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子            &#125;//end if            else            &#123;                StackPop(S, p); //p 左子树为空则出栈                printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点                p = p-&gt;rchild; //向右子树移动            &#125;//end else        &#125;//end while        free(S);    &#125;//end InOrderTraverseTree2    /*二叉树的递归中序遍历*/    void inOrder(BiTNode* root)    &#123;        if (root)        &#123;            inOrder(root-&gt;lchild);            printf(&quot;%d &quot;, root-&gt;data);            inOrder(root-&gt;rchild);        &#125;    &#125;    ```  - 后序遍历    ```CPP    /*二叉树非递归后序遍历*/    void LastTraverseTree2(BiTNode* root)    &#123;        StackNode* S; BiTNode* cur, * pre;//定义一个栈指针        S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点        if (NULL == root)        &#123;            printf(&quot;树为空！\n&quot;);            return;        &#125;//end if        pre = NULL; cur = NULL;        StackPush(S, T); //根节点入栈        while (!StackEmpty(S))        &#123; //若栈非空            cur = NULL;            StackGetTop(S, cur); //将栈顶节点赋给 cur    /*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。    如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是    其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/            if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||                (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))            &#123;                printf(&quot;%c &quot;, cur-&gt;data);                pre = cur;                StackPop(S, cur);            &#125;//end if    //若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素    //的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。            else            &#123;                if (cur-&gt;rchild != NULL)                    StackPush(S, cur-&gt;rchild);                if (cur-&gt;lchild != NULL)                    StackPush(S, cur-&gt;lchild);            &#125;//end else        &#125;//end while        free(S);    &#125;//end LastTraverseTree2    /*二叉树递归后序遍历*/    void postOrder(BiTNode* root)    &#123;        if (root)        &#123;            postOrder(root-&gt;lchild);            postOrder(root-&gt;rchild);            printf(&quot;%d &quot;, root-&gt;data);        &#125;     &#125;    ```  - 层次遍历：自上而下，自左向右    - 首先，将二叉树的祖先节点入队列    - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队    ```cpp    void LayerOrder(BiTreeNode* head)    &#123;        LQueue Q;        Initiate_Queue(&amp;Q);        BiTreeNode* p;        if (head != NULL) AppendQueue(&amp;Q, head);        while (QueueNotEmpty(&amp;Q)) &#123;            p = QueueDelete(&amp;Q);            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);            if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);        &#125;    &#125;     ```  #### 哈夫曼树和哈夫曼编码  - 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短    - 树的路径长度是指从根到每个节点的路径长度之和    - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值    - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和  - 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度    ```cpp    ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0      &#123;          if (FBT == NULL) //空树返回0              return 0;          else          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点                  return FBT-&gt;data * len;              else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增                  return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);          &#125;      &#125;      ```  - 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针      ```cpp    struct BTreeNode* CreateHuffman(ElemType a[], int n)      &#123;          int i, j;          struct BTreeNode **b, *q;          b = malloc(n*sizeof(struct BTreeNode));          for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点          &#123;              b[i] = malloc(sizeof(struct BTreeNode));              b[i]-&gt;data = a[i];              b[i]-&gt;left = b[i]-&gt;right = NULL;          &#125;          for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树          &#123;              //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标              int k1 = -1, k2;              for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵              &#123;                  if (b[j] != NULL &amp;&amp; k1 == -1)                  &#123;                      k1 = j;                      continue;                  &#125;                  if (b[j] != NULL)                  &#123;                      k2 = j;                      break;                  &#125;              &#125;              for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小              &#123;                  if (b[j] != NULL)                  &#123;                      if (b[j]-&gt;data &lt; b[k1]-&gt;data)                      &#123;                          k2 = k1;                          k1 = j;                      &#125;                      else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                          k2 = j;                  &#125;              &#125;              //由最小权值树和次最小权值树建立一棵新树，q指向树根结点              q = malloc(sizeof(struct BTreeNode));              q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;              q-&gt;left = b[k1];              q-&gt;right = b[k2];              b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置              b[k2] = NULL;//k2位置为空          &#125;          free(b); //删除动态建立的数组b          return q; //返回整个哈夫曼树的树根指针      &#125;      ```  - 哈夫曼编码    - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树    - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码    - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码    - 哈夫曼编码产生的是最短前缀码    ```cpp    void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0      &#123;          static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一          if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码          &#123;              if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)              &#123;                  int i;                  printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);                  for (i = 0; i &lt; len; i++)                      printf(&quot;%d&quot;, a[i]);                  printf(&quot;\n&quot;);              &#125;              else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a              &#123;   //的对应元素中，向下深入一层时len值增1                  a[len] = 0;                  HuffManCoding(FBT-&gt;left, len + 1);                  a[len] = 1;                  HuffManCoding(FBT-&gt;right, len + 1);              &#125;          &#125;      &#125;      ```  ### 图  #### 图的基本概念  - 图由结点的有穷集合的 V 和边的集合  E 组成（`G(V,E)`）  - 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示  - 路径长度：路径上边或者弧的数目  - 顶点的度：顶点关联边的数目    - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度    - 在有向图中，顶点的度就是两者之和    - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量    - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量  #### 图的存储结构  - 邻接矩阵    - 图的顺序存储结构    - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息    - 无向图中邻接矩阵是个对称矩阵    - 0表示无边，1表示有边    - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度     - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费    ```cpp    typedef struct    &#123;      int no;      char info;    &#125; VertexType;    typedef struct    &#123;      int edges[maxSize][maxSize];    //有权图中int改为float      int n,e;    //顶点数和边数      VertexType vex[maxSize];    //存放结点信息    &#125; MGragh;    ```  - 邻接表    - 数组和链表相结合的存储方法，图的链式存储结构    - 图中顶点用一个一维数组存储    - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表    - 顶点表的各个结点由 data 和 Firstedge 两个域表示      - data 是数据域，存储顶点信息      - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点    - 边表结点由 adjvex 和 next 两个域组成      - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标      - next 存储边表中下一个结点指针    - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表    ```cpp    typedef struct ArcNode    &#123;        int adnex;    //该边所指向的结点的位置        struct ArcNode * nextarc;    //指向下一条边的指针        int info;    //该边的相关信息(如权值)    &#125; ArcNode;    typedef struct    &#123;        char data;    //顶点信息        ArcNode* firstarc;    //指向第一条边的指针    &#125;VNode;    typedef struct    &#123;        VNode adjlist[maxSize];    //邻接表        int n, e;    //顶点数和边数    &#125; AGraph;    //图的邻接表类型    ```  - 十字链表    - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表    - 定点表      - firstin：入边表头指针，指向顶点入边表的第一个结点      - firstout：出边表头指针，指向顶点出边表第一个结点    - 边表      - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标      - headlink 入边表指针域，指向终点相同的下一条边      - taillink 是指边表指针域，指向起点相同的下一条边  - 邻接多重表    - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标    - ilink 指向依附项点 ivex 的下一条边    - jlink 指向依附顶点 jvex 的下一条边  #### 图的遍历算法  - 深度优先遍历（DFS，Depth First Search）     - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了    - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问    - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问    void DFSTraverse(Graph G)    &#123;        for (v = 0;v &lt; G.vexnum;++v)            visited[v] = false;    //初始化标记数组        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历                DFS(G, v);    &#125;    void DFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true; //定义为已访问        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])                DFS(G, w);    &#125;    ```  - 广度优先遍历（BFS，Breadth First Search）    - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点    - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完    - BFS 遍历的方式类似于树的层次遍历    ```cpp    bool visited[Max_Vex];    //定义访问标记数组    void BFSTraverse(Graph G)    &#123;        for (i = 0;i &lt; G.vexnum;++i)            visited[v] = false;    //初始化标记数组        InitQueue(Q);        for (v = 0;v &lt; G.vexnum;++v)            if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历                BFS(G, v);    &#125;    void BFS(Graph G, int v)    &#123;        visit(v);        visited[v] = true;    //定义为已访问        while (!isEmpty(Q))        &#123;            DeQueue(Q, v);            for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))                if (!visited[w])                &#123;                    visit(w);                    visited[w] = true;                    EnQueue(Q, w)                &#125;    //if        &#125;    //while    &#125;    ```  #### 最小生成树  - Prim 算法    - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树    - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树    - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树    ```cpp    void prim (G,T)    &#123;        T = ∅;        U = &#123;w&#125;;        while ((V - U) != ∅  )        &#123; //若图中不含全部顶点            设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;            T = T∪ (u，v); //边归入树            U = U∪ &#123;v&#125;;     //顶点归入树        &#125;    &#125;    ```  - Kruskal 算法    - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止    - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图    - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的    - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树      - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合      - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合    ```cpp    void kruskal（V，T）    &#123;        T = V;    //初始化树，仅含顶点        numS = n;    //不连分量的数目        while (numS &gt; 1)        &#123;            从 E 中取出权值最小的边（v,u）;            if（v 和 u 属于 T 中不同的连通分量）            &#123;                T = T∪（u，v）;//将此边加入到生成树中；                numS--; //不连通的分量减少 1            &#125;        &#125;    &#125;    ```  #### 最短路径  - Dijkstra 算法    - 通常用于求图中某一顶点到其余各顶点的最短路径    - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组    - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）    - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度  - Dijkstra 算法步骤    1. 初始时，S 只包含源点，即 S＝&#123;v&#125;，v 的距离为 0，U 包含除 v 外的其他顶点，即:U=&#123;其 余顶点&#125;，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$    2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）    3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离    4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中    ```cpp    void Dijkstra(int v0)    &#123;      　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中          int n=MAXNUM;      　　for(int i=1; i&lt;=n; ++i)     　　 &#123;          　　dist[i] = A[v0][i];          　　S[i] = false;                                // 初始都未用过该点          　　if(dist[i] == MAXINT)                    　　prev[i] = -1;     　　     else                 　　prev[i] = v0;       　　&#125;       　 dist[v0] = 0;       　 S[v0] = true; 　　     　　 for(int i=2; i&lt;=n; i++)     　　 &#123;           　　int mindist = MAXINT;           　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值          　　 for(int j=1; j&lt;=n; ++j)          　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)          　　    &#123;             　　       u = j;                             // u保存当前邻接点中距离最小的点的号码              　 　      mindist = dist[j];           　　   &#125;           　　S[u] = true;            　　for(int j=1; j&lt;=n; j++)           　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)           　　    &#123;               　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径                 　    　&#123;                       　　dist[j] = dist[u] + A[u][j];    //更新dist                        　　prev[j] = u;                    //记录前驱顶点                 　　    &#125;            　    　&#125;       　　&#125;    &#125;    ```  - Floyd 算法    - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包    - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$    - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离    - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离  - Floyd 算法步骤    - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　    - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它    ```cpp    for (k = 1;k &lt;= n;k++)        for (i = 1;i &lt;= n;i++)            for (j = 1;j &lt;= n;j++)                if (a[i][j] &gt; a[i][k] + a[k][j])                    a[i][j] = a[i][k] + a[k][j];    ```  #### 拓扑排序  - 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边    1. 从 DAG 图中选择一个没有前驱的节点并输出    2. 从图中删除该节点和所有以它为起点的有向边    3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止    ```cpp    bool topologicalSort(Graph GL)    &#123;        EdgeNode* e;        int top = 0; //用于栈指针下标         int count = 0; // 用于统计输出顶点的个数         int* stack; // 建栈将入度为 0 的顶点入栈         stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));        for (i = 0; i &lt; GL-&gt;numVertexes; i++)            if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈                 stack[++top] = i;        while (top != 0)        &#123;            gettop = stack[top--];            printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);            count++; //输出 i 号顶点，并计数             for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;                k = e-&gt;adjvex;                if (!(--GL-&gt;adjList[k].in))                    //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                     stack[++top] = k;            &#125;        &#125;        if (count &lt; GL-&gt;numVertexes) return false;        else return true;    &#125;    ```</code></pre><h3 id="矩阵与广义表-2"><a href="#矩阵与广义表-2" class="headerlink" title="矩阵与广义表"></a>矩阵与广义表</h3><h4 id="矩阵-2"><a href="#矩阵-2" class="headerlink" title="矩阵"></a>矩阵</h4><ul><li><p>矩阵的转置</p><pre><code class="cpp">void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            B[j][i] = A[i][j];&#125;</code></pre></li><li><p>矩阵相加</p><pre><code class="cpp">void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            C[i][j] = A[i][j] + B[i][j];&#125;</code></pre></li><li><p>矩阵相乘</p><pre><code class="cpp">void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; k;++j)        &#123;            C[i][j] = 0;            for int(h = 0;h &lt; n;++h)                C[i][j] += A[i][j] * B[i][j];        &#125;&#125;</code></pre></li><li><p>相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵</p><ul><li>对称矩阵、三角阵、对角矩阵</li></ul></li></ul><h4 id="广义表-2"><a href="#广义表-2" class="headerlink" title="广义表"></a>广义表</h4><ul><li>表元素可以是原子或者广义表的一种线性表的扩展结构</li><li>广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数</li><li>当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</li><li>原子结点有两个域：标志域和数据域</li><li>广义表结点有三个域：标志域，头指针域与尾指针域</li></ul><h3 id="树-2"><a href="#树-2" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念-2"><a href="#树的基本概念-2" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><ul><li>树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成<ul><li>结点不仅包含数据元素，并且包含指向子树的分支</li><li>结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值</li><li>树的高度是树中结点的最大层次，根结点的高度为树的高度</li></ul></li><li>树的双亲存储结构：<code>int tree[maxSize]</code></li><li>树的链式存储结构<ul><li>邻接表：孩子存储结构</li><li>孩子兄弟存储结构</li></ul></li></ul><h4 id="二叉树的概念和性质-2"><a href="#二叉树的概念和性质-2" class="headerlink" title="二叉树的概念和性质"></a>二叉树的概念和性质</h4><ul><li><p>二叉树的定义</p><ul><li>每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2</li><li>子树有左右顺序之分，不能颠倒</li></ul></li><li><p>满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层</p></li><li><p>完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的</p></li><li><p>二叉树的主要性质</p><ol><li><p>非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$</p></li><li><p>在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$</p></li><li><p>二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p><ul><li>若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）</li><li>若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点</li><li>若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点</li></ul></li><li><p>Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac{C_{2n}^{n}}{n+1}$  棵不同的二叉树</p></li><li><p>在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$</p></li></ol></li><li><p>二叉树的顺序存储结构最适用于完全二叉树</p></li><li><p>二叉树的链式存储结构</p><pre><code class="cpp">typedef struct BTNode&#123;    char  data;    //数据域    struct BTNoode* lchild;    struct BTNode* rchild;&#125; BTNode;</code></pre></li></ul><h4 id="二叉树的遍历算法-2"><a href="#二叉树的遍历算法-2" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><ul><li><p>先序遍历</p><pre><code class="cpp">/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123;    StackNode* S;   //定义一个栈指针    BitNode* p;   //工作指针    S = NULL;    p = root;    S = InitStack(S);   //初始化栈    if (NULL == p)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;     //end if    while (p || !StackEmpty(S))    &#123;     //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p);    //p 所指节点入栈            printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）            p = p-&gt;lchild ;     //指向 p 的左孩子         &#125;//end if        else        &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树            StackPop(S, p);            p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈        &#125;    //end else    &#125;    //end while    free(S);&#125;    //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123;    if (root)    &#123;        printf(&quot;%d &quot;, root-&gt;data);        preOrder(root-&gt;lchild);        preOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>中序遍历</p><pre><code class="cpp">/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123;    StackNode* S; //定义一个栈指针    BitNode* p; //工作指针    S = NULL;    p = root;    S = InitStack(S); //初始化栈    if (NULL == p) &#123; //如果是空树        printf(&quot;树为空！\n&quot;) ;        return;    &#125;//end if    while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p); //将节点入栈            p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子        &#125;//end if        else        &#123;            StackPop(S, p); //p 左子树为空则出栈            printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点            p = p-&gt;rchild; //向右子树移动        &#125;//end else    &#125;//end while    free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123;    if (root)    &#123;        inOrder(root-&gt;lchild);        printf(&quot;%d &quot;, root-&gt;data);        inOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>后序遍历</p><pre><code class="CPP">/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123;    StackNode* S; BiTNode* cur, * pre;//定义一个栈指针    S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点    if (NULL == root)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;//end if    pre = NULL; cur = NULL;    StackPush(S, T); //根节点入栈    while (!StackEmpty(S))    &#123; //若栈非空        cur = NULL;        StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/        if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||            (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))        &#123;            printf(&quot;%c &quot;, cur-&gt;data);            pre = cur;            StackPop(S, cur);        &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。        else        &#123;            if (cur-&gt;rchild != NULL)                StackPush(S, cur-&gt;rchild);            if (cur-&gt;lchild != NULL)                StackPush(S, cur-&gt;lchild);        &#125;//end else    &#125;//end while    free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123;    if (root)    &#123;        postOrder(root-&gt;lchild);        postOrder(root-&gt;rchild);        printf(&quot;%d &quot;, root-&gt;data);    &#125; &#125;</code></pre></li><li><p>层次遍历：自上而下，自左向右</p><ul><li>首先，将二叉树的祖先节点入队列</li><li>然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队</li></ul><pre><code class="cpp">void LayerOrder(BiTreeNode* head)&#123;    LQueue Q;    Initiate_Queue(&amp;Q);    BiTreeNode* p;    if (head != NULL) AppendQueue(&amp;Q, head);    while (QueueNotEmpty(&amp;Q)) &#123;        p = QueueDelete(&amp;Q);        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);        if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);    &#125;&#125; </code></pre></li></ul><h4 id="哈夫曼树和哈夫曼编码-2"><a href="#哈夫曼树和哈夫曼编码-2" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ul><li><p>哈夫曼树又叫做最优二叉树，它的特点是带权路径最短</p><ul><li>树的路径长度是指从根到每个节点的路径长度之和</li><li>带权路径长度是从该节点到根节之间的路径长度乘以结点的权值</li><li>树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和</li></ul></li><li><p>求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度</p><pre><code class="cpp">ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0  &#123;      if (FBT == NULL) //空树返回0          return 0;      else      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点              return FBT-&gt;data * len;          else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增              return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);      &#125;  &#125;  </code></pre></li><li><p>哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针  </p><pre><code class="cpp">struct BTreeNode* CreateHuffman(ElemType a[], int n)  &#123;      int i, j;      struct BTreeNode **b, *q;      b = malloc(n*sizeof(struct BTreeNode));      for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点      &#123;          b[i] = malloc(sizeof(struct BTreeNode));          b[i]-&gt;data = a[i];          b[i]-&gt;left = b[i]-&gt;right = NULL;      &#125;      for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树      &#123;          //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标          int k1 = -1, k2;          for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵          &#123;              if (b[j] != NULL &amp;&amp; k1 == -1)              &#123;                  k1 = j;                  continue;              &#125;              if (b[j] != NULL)              &#123;                  k2 = j;                  break;              &#125;          &#125;          for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小          &#123;              if (b[j] != NULL)              &#123;                  if (b[j]-&gt;data &lt; b[k1]-&gt;data)                  &#123;                      k2 = k1;                      k1 = j;                  &#125;                  else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                      k2 = j;              &#125;          &#125;          //由最小权值树和次最小权值树建立一棵新树，q指向树根结点          q = malloc(sizeof(struct BTreeNode));          q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;          q-&gt;left = b[k1];          q-&gt;right = b[k2];          b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置          b[k2] = NULL;//k2位置为空      &#125;      free(b); //删除动态建立的数组b      return q; //返回整个哈夫曼树的树根指针  &#125;  </code></pre></li><li><p>哈夫曼编码</p><ul><li>每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树</li><li>将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码</li><li>从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码</li><li>哈夫曼编码产生的是最短前缀码</li></ul><pre><code class="cpp">void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0  &#123;      static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一      if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)          &#123;              int i;              printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);              for (i = 0; i &lt; len; i++)                  printf(&quot;%d&quot;, a[i]);              printf(&quot;\n&quot;);          &#125;          else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a          &#123;   //的对应元素中，向下深入一层时len值增1              a[len] = 0;              HuffManCoding(FBT-&gt;left, len + 1);              a[len] = 1;              HuffManCoding(FBT-&gt;right, len + 1);          &#125;      &#125;  &#125;  </code></pre></li></ul><h3 id="图-2"><a href="#图-2" class="headerlink" title="图"></a>图</h3><h4 id="图的基本概念-2"><a href="#图的基本概念-2" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><ul><li>图由结点的有穷集合的 V 和边的集合  E 组成（<code>G(V,E)</code>）</li><li>图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示</li><li>路径长度：路径上边或者弧的数目</li><li>顶点的度：顶点关联边的数目<ul><li>有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度</li><li>在有向图中，顶点的度就是两者之和</li><li>在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量</li><li>在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量</li></ul></li></ul><h4 id="图的存储结构-2"><a href="#图的存储结构-2" class="headerlink" title="图的存储结构"></a>图的存储结构</h4><ul><li><p>邻接矩阵</p><ul><li>图的顺序存储结构</li><li>用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息</li><li>无向图中邻接矩阵是个对称矩阵</li><li>0表示无边，1表示有边</li><li>顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 </li><li>邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费</li></ul><pre><code class="cpp">typedef struct&#123;  int no;  char info;&#125; VertexType;typedef struct&#123;  int edges[maxSize][maxSize];    //有权图中int改为float  int n,e;    //顶点数和边数  VertexType vex[maxSize];    //存放结点信息&#125; MGragh;</code></pre></li><li><p>邻接表</p><ul><li>数组和链表相结合的存储方法，图的链式存储结构</li><li>图中顶点用一个一维数组存储</li><li>图中每个顶点 $V_i$ 的所有邻接点构成一个线性表</li><li>顶点表的各个结点由 data 和 Firstedge 两个域表示<ul><li>data 是数据域，存储顶点信息</li><li>firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点</li></ul></li><li>边表结点由 adjvex 和 next 两个域组成<ul><li>adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标</li><li>next 存储边表中下一个结点指针</li></ul></li><li>有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表</li></ul><pre><code class="cpp">typedef struct ArcNode&#123;    int adnex;    //该边所指向的结点的位置    struct ArcNode * nextarc;    //指向下一条边的指针    int info;    //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123;    char data;    //顶点信息    ArcNode* firstarc;    //指向第一条边的指针&#125;VNode;typedef struct&#123;    VNode adjlist[maxSize];    //邻接表    int n, e;    //顶点数和边数&#125; AGraph;    //图的邻接表类型</code></pre></li><li><p>十字链表</p><ul><li>在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表</li><li>定点表<ul><li>firstin：入边表头指针，指向顶点入边表的第一个结点</li><li>firstout：出边表头指针，指向顶点出边表第一个结点</li></ul></li><li>边表<ul><li>tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标</li><li>headlink 入边表指针域，指向终点相同的下一条边</li><li>taillink 是指边表指针域，指向起点相同的下一条边</li></ul></li></ul></li><li><p>邻接多重表</p><ul><li>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标</li><li>ilink 指向依附项点 ivex 的下一条边</li><li>jlink 指向依附顶点 jvex 的下一条边</li></ul></li></ul><h4 id="图的遍历算法-1"><a href="#图的遍历算法-1" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h4><ul><li><p>深度优先遍历（DFS，Depth First Search） </p><ul><li>首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了</li><li>若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问</li><li>深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123;    for (v = 0;v &lt; G.vexnum;++v)        visited[v] = false;    //初始化标记数组    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历            DFS(G, v);&#125;void DFS(Graph G, int v)&#123;    visit(v);    visited[v] = true; //定义为已访问    for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))        if (!visited[w])            DFS(G, w);&#125;</code></pre></li><li><p>广度优先遍历（BFS，Breadth First Search）</p><ul><li>首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点</li><li>然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完</li><li>BFS 遍历的方式类似于树的层次遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组void BFSTraverse(Graph G)&#123;    for (i = 0;i &lt; G.vexnum;++i)        visited[v] = false;    //初始化标记数组    InitQueue(Q);    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历            BFS(G, v);&#125;void BFS(Graph G, int v)&#123;    visit(v);    visited[v] = true;    //定义为已访问    while (!isEmpty(Q))    &#123;        DeQueue(Q, v);        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])            &#123;                visit(w);                visited[w] = true;                EnQueue(Q, w)            &#125;    //if    &#125;    //while&#125;</code></pre></li></ul><h4 id="最小生成树-1"><a href="#最小生成树-1" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li><p>Prim 算法</p><ul><li>从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树</li><li>然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树</li><li>以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树</li></ul><pre><code class="cpp">void prim (G,T)&#123;    T = ∅;    U = &#123;w&#125;;    while ((V - U) != ∅  )    &#123; //若图中不含全部顶点        设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;        T = T∪ (u，v); //边归入树        U = U∪ &#123;v&#125;;     //顶点归入树    &#125;&#125;</code></pre></li><li><p>Kruskal 算法</p><ul><li>将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止</li><li>Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图</li><li>普里姆算法和克鲁斯卡尔算法都是针对于无向图的</li><li>判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树<ul><li>通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合</li><li>通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合</li></ul></li></ul><pre><code class="cpp">void kruskal（V，T）&#123;    T = V;    //初始化树，仅含顶点    numS = n;    //不连分量的数目    while (numS &gt; 1)    &#123;        从 E 中取出权值最小的边（v,u）;        if（v 和 u 属于 T 中不同的连通分量）        &#123;            T = T∪（u，v）;//将此边加入到生成树中；            numS--; //不连通的分量减少 1        &#125;    &#125;&#125;</code></pre></li></ul><h4 id="最短路径-1"><a href="#最短路径-1" class="headerlink" title="最短路径"></a>最短路径</h4><ul><li><p>Dijkstra 算法</p><ul><li>通常用于求图中某一顶点到其余各顶点的最短路径</li><li>设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组</li><li>第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）</li><li>第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度</li></ul></li><li><p>Dijkstra 算法步骤</p><ol><li>初始时，S 只包含源点，即 S＝{v}，v 的距离为 0，U 包含除 v 外的其他顶点，即:U={其 余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$</li><li>从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）</li><li>以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离</li><li>重复步骤 b 和 c 直到所有顶点都包含在 S 中</li></ol><pre><code class="cpp">void Dijkstra(int v0)&#123;  　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中      int n=MAXNUM;  　　for(int i=1; i&lt;=n; ++i) 　　 &#123;      　　dist[i] = A[v0][i];      　　S[i] = false;                                // 初始都未用过该点      　　if(dist[i] == MAXINT)                　　prev[i] = -1; 　　     else             　　prev[i] = v0;   　　&#125;   　 dist[v0] = 0;   　 S[v0] = true; 　　 　　 for(int i=2; i&lt;=n; i++) 　　 &#123;       　　int mindist = MAXINT;       　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值      　　 for(int j=1; j&lt;=n; ++j)      　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)      　　    &#123;         　　       u = j;                             // u保存当前邻接点中距离最小的点的号码          　 　      mindist = dist[j];       　　   &#125;       　　S[u] = true;        　　for(int j=1; j&lt;=n; j++)       　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)       　　    &#123;           　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径             　    　&#123;                   　　dist[j] = dist[u] + A[u][j];    //更新dist                    　　prev[j] = u;                    //记录前驱顶点             　　    &#125;        　    　&#125;   　　&#125;&#125;</code></pre></li><li><p>Floyd 算法</p><ul><li>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包</li><li>Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$</li><li>Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离</li><li>对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离</li></ul></li><li><p>Floyd 算法步骤</p><ul><li>从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它</li></ul><pre><code class="cpp">for (k = 1;k &lt;= n;k++)    for (i = 1;i &lt;= n;i++)        for (j = 1;j &lt;= n;j++)            if (a[i][j] &gt; a[i][k] + a[k][j])                a[i][j] = a[i][k] + a[k][j];</code></pre></li></ul><h4 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul><li><p>对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边</p><ol><li>从 DAG 图中选择一个没有前驱的节点并输出</li><li>从图中删除该节点和所有以它为起点的有向边</li><li>重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止</li></ol><pre><code class="cpp">bool topologicalSort(Graph GL)&#123;    EdgeNode* e;    int top = 0; //用于栈指针下标     int count = 0; // 用于统计输出顶点的个数     int* stack; // 建栈将入度为 0 的顶点入栈     stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));    for (i = 0; i &lt; GL-&gt;numVertexes; i++)        if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈             stack[++top] = i;    while (top != 0)    &#123;        gettop = stack[top--];        printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);        count++; //输出 i 号顶点，并计数         for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;            k = e-&gt;adjvex;            if (!(--GL-&gt;adjList[k].in))                //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                 stack[++top] = k;        &#125;    &#125;    if (count &lt; GL-&gt;numVertexes) return false;    else return true;&#125;</code></pre></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><ul><li>排序：将原本无序的序列重新排列成有序序列的过程，这个序列中的每一项可能是单独的数据元素，也可能是一条记录</li><li>记录由多个数据元素组成的，既可以按照记录的主关键字排序（主关键字唯一标识一条记录），也可以按照记录的次关键字排序</li><li>稳定性：当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关键字的相对位置，如果没有发生变化就是稳定的，否则就是不稳定的</li><li>排序算法的分类<ul><li>插入类的排序：直接插入、折半插入、希尔排序</li><li>交换类的排序：冒泡排序、快速排序</li><li>选择类的排序：简单选择、堆选择</li><li>归并类的排序：二路归并</li><li>基数类的排序：多关键字排序</li></ul></li></ul><h4 id="插入类的排序"><a href="#插入类的排序" class="headerlink" title="插入类的排序"></a>插入类的排序</h4><ul><li><p>插入排序</p><pre><code class="cpp">void InsertSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int i,j;    //i是次数，也即排好的个数;j是继续排    for(i=1;i&lt;len;++i)        for(j=i;j&gt;0;--j)            if(h[j]&lt;h[j-1]) Swap(h[j],h[j-1]);            else break;    return;&#125;</code></pre></li><li><p>希尔排序</p><ul><li>缩小增量排序：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序</li><li>随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</li></ul><pre><code class="cpp">void ShellSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    for(int div=len/2;div&gt;=1;div/=2)        for(int k=0;k&lt;div;++k)            for(int i=div+k;i&lt;len;i+=div)                for(int j=i;j&gt;k;j-=div)                    if(h[j]&lt;h[j-div]) Swap(h[j],h[j-div]);                    else break;    return;&#125;</code></pre></li></ul><h4 id="交换类的排序"><a href="#交换类的排序" class="headerlink" title="交换类的排序"></a>交换类的排序</h4><ul><li><p>快速排序</p><pre><code class="cpp">void QuickSort(SeqList R，int low，int high) &#123; //对 R[low..high]快速排序     int pivotpos； //划分后的基准记录的位置         if (low &lt; high) &#123; //仅当区间长度大于 1 时才须排序             pivotpos = Partition(R，low，high)； //对 R[low..high]做划分                 QuickSort(R，low，pivo t   pos-1)； //对左区间递归排序                 QuickSort(R，pivotp o s+1，high)； //对右区间递归排序         &#125;&#125; //QuickSort</code></pre></li><li><p>冒泡排序</p><ul><li>通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置</li></ul><pre><code class="cpp">void BubbleSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    //i是次数，j是具体下标    for(int i=0;i&lt;len-1;++i)        for(int j=0;j&lt;len-1-i;++j)            if(h[j]&gt;h[j+1])                Swap(h[j],h[j+1]);    return;&#125;</code></pre></li></ul><h4 id="选择类的排序"><a href="#选择类的排序" class="headerlink" title="选择类的排序"></a>选择类的排序</h4><ul><li><p>选择排序</p><ul><li>初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</li><li>每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置</li></ul><pre><code class="cpp">void SelectionSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int minindex,i,j;    //i是次数，也即排好的个数;j是继续排    for(i=0;i&lt;len-1;++i)    &#123;        minindex=i;        for(j=i+1;j&lt;len;++j)        &#123;            if(h[j]&lt;h[minindex]) minindex=j;        &#125;        Swap(h[i],h[minindex]);    &#125;    return;&#125;</code></pre></li><li><p>堆排序</p><ul><li>堆实际上是一棵完全二叉树，堆的每一个父节点都大于（或小于）其子节点，堆的每个左子树和右子树也是一个堆</li><li>最大堆（大顶堆）：堆的每个父节点都大于其孩子节点；最小堆（小顶堆）：堆的每个父节点都小于其孩子节点</li><li>堆的第一个元素要么是最大值（大顶堆），要么是最小值（小顶堆），这样在排序的时候（假设共 n 个节点），直接将第一个元素和最后一个元素进行交换，然后从第一个元素开始进行向下调整至第 n-1 个元素。所以，如果需要升序，就建一个大堆，需要降序，就建一个小堆</li></ul><pre><code class="cpp">void HeapSort(SeqIAst R)&#123; //对 R[1..n]进行堆排序，不妨用 R[0]做暂存单元     int i；        BuildHeap(R)； //将 R[1-n]建成初始堆         for (i = n;i &gt; 1；  i  -)        &#123; //对当前无序区 R[1..i]进行堆排序，共做 n-1 趟            R[0] = R[1];            R[1] = R[i];            R[i] = R[0];//将堆顶和堆中最后一个记录交换             Heapify(R，1 ，i-1); //将 R[1..i-1]重新调整为堆，仅有 R[1]可能违反堆性质         &#125; //endfor &#125; //HeapSort</code></pre></li></ul><h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><ul><li><p>MERGE-SORT：利用归并的思想实现的排序方法，采用经典的分治（divide-and-conquer）策略</p></li><li><p>递归拆分子序列，将两个已经有序的子序列合并成一个有序序列</p><pre><code class="cpp">void MergeSortDC(SeqList R，int low，int high) &#123;//用分治法对 R[low..high]进行二路归并排序  int mid；  if(low&lt;high)&#123; //区间长度大于 1  mid=(low+high)/2； //分解  MergeSortDC(R，low，mid); //递归地对 R[low..mid]排序  MergeSortDC(R，mid+1，high)； //递归地对 R[mid+1..high]排序  Merge(R，low，mid，high)； //组合，将两个有序区归并为一个有序区  &#125; &#125;//MergeSortDC </code></pre></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li><p>不需要比较关键字的大小，根据关键字中各位的值，通过对排序的N个元素进行若干趟分配与收集来实现排序的</p></li><li><p>时间复杂度为 $O\left( d\left( n+r_{d}\right) \right)$</p><pre><code class="cpp">int GetMaxDight(int* h, int len)&#123;    if(h==NULL) return 0;    if(len&lt;1) return 0;    int max=h[0];    for(int i=1;i&lt;len;++i)    &#123;        if(h[i]&gt;max) max=h[i];    &#125;    int digit=1;    while(max/10!=0)    &#123;        max/=10;        ++digit;    &#125;    return digit;&#125;int GetReminder(int value,int digit)&#123;    int div=1;    for(int i=1;i&lt;digit;++i)        div*=10;    return value/div%10;&#125;void RadixSort_LSD(int* h, int len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int digit=GetMaxDight(h,len);    //printf(&quot;MaxDigit:%d\n&quot;, digit);    int count[10]=&#123;0&#125;;    int *tmp=(int*)calloc(len,sizeof(int));    for(int d=1;d&lt;=digit;++d)    &#123;        memset(count,0,sizeof(count));        for(int i=0;i&lt;len;++i)        &#123;            count[GetReminder(h[i],d)]++;        &#125;        //求右边界        for(int i=1;i&lt;10;++i)        &#123;            count[i]+=count[i-1];        &#125;        for(int i=len-1;i&gt;=0;--i)        &#123;            int r=GetReminder(h[i],d);            int index=count[r];            tmp[index-1]=h[i];            count[r]--;        &#125;        memcpy(h,tmp,len*sizeof(int));    &#125;    free(tmp);&#125;void RadixSort_LSD_Reverse(int* h, int len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int digit=GetMaxDight(h,len);    //printf(&quot;MaxDigit:%d\n&quot;, digit);    int count[10]=&#123;0&#125;;    int *tmp=(int*)calloc(len,sizeof(int));    for(int d=1;d&lt;=digit;++d)    &#123;        memset(count,0,sizeof(count));        for(int i=0;i&lt;len;++i)        &#123;            count[GetReminder(h[i],d)]++;        &#125;        //printf(&quot;haha\n&quot;);        //求右边界        for(int i=8;i&gt;=0;--i)        &#123;            count[i]+=count[i+1];        &#125;        for(int i=len-1;i&gt;=0;--i)        &#123;            int r=GetReminder(h[i],d);            int index=count[r];            tmp[index-1]=h[i];            count[r]--;        &#125;        memcpy(h,tmp,len*sizeof(int));    &#125;    free(tmp);&#125;</code></pre></li></ul><h4 id="排序知识点总结"><a href="#排序知识点总结" class="headerlink" title="排序知识点总结"></a>排序知识点总结</h4><ul><li>快速排序、希尔排序、归并排序、堆排序的平均时间复杂度都是 $O\left( n\log _{2}n\right)$，其他都是 $O(n^2)$</li><li>快速排序的空间复杂度为 $O\left( \log <em>{2}n\right)$，归并排序的空间复杂度为 $O\left( n\right)$，基数排序的空间复杂度为 $O\left( r</em>{d}\right)$，其他都是 $O(1)$</li><li>快速排序、希尔排序、简单选择排序、堆排序是不稳定的，其他都是稳定的</li><li>交换类和选择类的排序，经过一趟排序能够保证一个关键字到达最终位置</li><li>简单选择排序和折半插入排序的关键字比较次数和原始序列无关</li><li>交换类的排序趟数和原始序列有关</li><li>直接插入按顺序查找的方式，而折半插入按折半查找的方式排序</li><li>借助于比较进行排序的算法在最坏情况下的时间复杂度至少为 $O\left( n\log _{2}n\right)$</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h4><ul><li><p>给定一个值 K，在含有 n 个记录的表中找出关键字等于 K 的记录叫查找，记录即为关键字</p></li><li><p>通常把查找过程中对关键字的平均比较次数（也称平均查找长度）作为衡量一个查找算法优劣的标准</p></li><li><p>平均查找长度 $ASL=\sum ^{n}<em>{i=1}p</em>{i}\times c_{i}$</p><ul><li>$p_{i}$ 为查找第 i 个记录的概率，$c_{i}$ 为找到第 i 个记录所需要进行比较的次数（查找长度）</li></ul></li><li><p>顺序查找</p><ul><li>用待查找的关键字和给定序列中的各元素的关键字从左到右（或从右到左）依次进行比较，直到成功或失败</li><li>存储结构通常是顺序结构，也可是链式结构</li></ul><pre><code class="cpp">//顺序表的查找（不带监视哨）int SeqSearch(SSTable S, DataType x)&#123;    int i = 0;    while (i &gt; s.length &amp; S.list[i].key != x.key)        i++;    if (s.list[i].key == x.key)        return i + 1;    return 0;&#125;//顺序表的查找（带监视哨）int SeqSearch2(SSTable S, DataType x)&#123;    int i = S.length;    //将关键字存放在0位置处,防止越界    /*哨兵的主要作用就是在查找循环中监视下标i是否越界      一旦越界(i=0),因为可以和自己进行比较,循环判定条件      不成立就使得查找循环结束,就可以达到忽略判定边界条件的目的*/    s.list[o].key = x.key;    while (s.list[i].key != x.key)        i--;    return i;    // 实际上,一切为简化边界条件而引入的附加结点(元素)均可称为哨兵&#125;//顺序表的查找（链表实现）Node* Search(Lnode* head, int key)&#123;    LNode* p = head-&gt;next;    while (p != NUll)    &#123;        if (P-&gt;data == key)            return p;        p = p-&gt;next;    &#125;    return NULL;&#125;</code></pre></li><li><p>二分查找</p><ul><li>要求线性表是有序的</li><li>在给定序列是有序表的前提下，将表中间位置处的关键字和查找关键字比较，相 等则查找成功</li><li>否则从中间位置将表分成前后两个子表，如果中间位置处的关键字大于 查找关键字，则进一步查找前子表，否则查找后子表</li><li>重复以上过程，直到找到满足条件的记录，此时查找成功，或直到子表不存在为止，表示查找失败</li></ul><pre><code class="cpp">int BSearch(int arr[], int low, int high, int key) &#123;    while (low &lt;= high) &#123;        int mid = (low + high) / 2;        if (arr[mid == key])            return mid;        else if (arr[mid] &gt; key)            high = mid - 1;        else            low = mid + 1;    &#125;    return -1;&#125;</code></pre></li></ul><h4 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h4><ul><li><p>二叉排序树要么是空树,要么是满足下列要求的树</p><ul><li>若它的左子树不空，则左子树上所有的关键字的值均小于根节点关键字值</li><li>若它的右子树不空，则右子树上所有的关键字的值均大于根节点关键字值</li><li>左右子树又各是一棵二叉排序树</li></ul></li><li><p>Binary Search Tree 又被叫做二叉搜索树 or 二叉查找树</p></li><li><p>在对某个关键字进行查找的时候，首先和二叉排序树的根节点进行比较，若相等则査找成功</p></li><li><p>由于二叉排序树本身的性质，若该关键字小于根节点值，则再与其左子树进行比较,否则和其右子树进行比较，直到找到与之相等的节点，则查找成功</p></li><li><p>若待比较的位置来到空指针处，则表示査找失败，返回失败的标记</p><pre><code class="cpp">//非递归算法BTNode* BSTSearch(BTNode* p, int key) &#123;    while (p != NULL) &#123;        if (key == p-&gt;key)            return p;        else if (key &lt; p-&gt;key)            p = p-&gt;lChild;        else            p = p-&gt;rChild;    &#125;    return NULL;&#125;//递归算法BTNode* BSTSearch2(BTNode* p, int key) &#123;    if (p == NULL)        return NULL;    else&#123;        if (key == p-&gt;key)            return p;        else if (key &lt; p-&gt;key)            return BSTSearch2(p-&gt;lChild, key);        else            return BSTSearch2(p-&gt;rChild, key);    &#125;&#125;</code></pre></li></ul><h4 id="平衡二叉树（AVL-树）"><a href="#平衡二叉树（AVL-树）" class="headerlink" title="平衡二叉树（AVL 树）"></a>平衡二叉树（AVL 树）</h4><ul><li>平衡二叉树是一种特殊的二叉排序树，其左右子树都是平衡二叉树且左右子树高度之差的绝对值不超过1</li><li>一个节点的平衡因子为其左子树的高度减去右子树的高度，对于平衡二叉树，树中所有结点的平衡因子取值只可能是-1、0、1</li><li>若向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性，则首先要找出插入新节点后失去平衡的最小子树，然后再调整这颗子树使之成为平衡子树</li><li>当失去平衡的最小子树被调整为平衡子树后，无需调整原有其他所有的不平衡子树</li><li>最小不平衡子树：是以距离插入结点最近且以平衡因子绝对值大于1的结点作为跟的子树，又称为失去平衡的最小子树</li></ul><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><ul><li><p>Hash：根据给定的关键字来计算出关键字在表中的地址</p></li><li><p>Hash table（哈希表）：是根据关键码值（Key value）而直接进行访问的数据结构，=通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>给定表 M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希表，函数 f(key) 为哈希函数</p></li><li><p>键（key）：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分</p></li><li><p>槽（slot/bucket）：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器</p></li><li><p>哈希函数（hash function）：将 key 映射 map 到数据应该存放的槽 slot 所在位置的函数</p></li><li><p>哈希冲突（hash collision）：哈希函数将两个不同的键映射到同一个索引的情况</p><pre><code class="cpp">int h1(int x)&#123;  return (x%5);&#125;int h2(char* x)&#123;  int i,sum;  for(sum=0, i=0; x[i] != &#39;\0&#39;; i++)    sum += (int)x[i];  return (sum%5);&#125;int ELFhash(char*key)&#123;    unsigned long h=0;    while(*key)    &#123;        h = (h &lt;&lt; 4) + *key++;        unsigned long g = h &amp; 0xF0000000L;        if(g)            h ^= g &gt;&gt; 24;        h &amp;= ~g;    &#125;    return h % MOD;&#125;</code></pre></li><li><p>散列表的性能分析（查找成功时的平均查找长度）：找到表中已有表项的平均次数</p></li><li><p>装填因子是关键字个数和表长度的比值</p></li></ul><h3 id="常用算法补充"><a href="#常用算法补充" class="headerlink" title="常用算法补充"></a>常用算法补充</h3><ul><li><p>动态规划算法</p><ul><li>处理多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态</li><li>这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线）</li><li>动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处</li></ul><pre><code class="cpp">for (j = 1; j &lt;= m; j = j + 1) // 第一个阶段    xn[j] = 初始值;for (i = n - 1; i &gt; = 1; i = i - 1)// 其他n-1个阶段    for (j = 1; j &gt;= f(i); j = j + 1)//f(i)与i有关的表达式        xi[j] = j = max&#123; g(xi - 1[j1:j2]), ...... ,  g(xi - 1[jk:jk + 1]) &#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for (i = 2; i &lt;= n - 1; i = i + 1)&#123;    t = t - xi - 1[ji];    for (j = 1; j &gt;= f(i); j = j + 1)        if (t = xi[ji])            break;&#125;</code></pre></li><li><p>贪心算法</p><ul><li>在对问题求解时，总是做出在当前看来是最好的选择，局部最优解</li><li>整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的</li><li>贪心算法建立哈夫曼树</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct BTreeNode&#123;    int  data;    struct BTreeNode* left;    struct BTreeNode* right;&#125;btreenode;//建立哈夫曼树btreenode *CreateHuffman(int a[],int n)&#123;    int i;    btreenode *s[n+1], *ss;    for(int i = 0;i&lt;n;i++)&#123;        s[i] = new btreenode;  //初始化s指针数组，使每个指针元素指向a数组中对应的元素结点        s[i]-&gt;data = a[i];   //将树拆成森林，每棵树都只有一个根节点        s[i]-&gt;left = s[i]-&gt;right = NULL;    &#125;    for(int i  = 1;i&lt;n;i++)&#123;        //进行 n-1次循环建立哈夫曼树           int k = -1,t;           //k表示森林中具有最小权值的树根结点的下标，t为次最小的下标        for(int j = 0;j&lt;n;j++)&#123;   //k初始指向森林中第一棵树，t指向第二棵                if(s[j]&amp;&amp;k==-1)&#123;                   k = j;                   continue;                &#125;                if(s[j])&#123;                    t =  j;                    break;                &#125;        &#125;        for(int i = t;i&lt;n;i++)&#123;   //从当前森林中求出最小权值树和次最小 ；            if(s[i])&#123;                if(s[i]-&gt;data&lt;s[k]-&gt;data)&#123;        //比最小树小                    t = k;                    k = i;                &#125;                else if(s[i]-&gt;data&lt;s[t]-&gt;data)&#123;  //比次小树小                    t = i;                &#125;                else&#123;                    ;                &#125;            &#125;        &#125;           //由最小权值树和次最小权值树建立一棵新树，ss指向树根结点(以后依次建立)           ss  = new btreenode;     //ss = (btreenode *)malloc(sizeof(btreenode))           ss-&gt;data =   s[k]-&gt;data+s[t]-&gt;data;           ss-&gt;left =   s[k];           ss-&gt;right =  s[t];           s[k] =  ss;  //关键点:将ss赋给s[k](k为上述找到的最小树下标,但这是s[k]代表的值已改变，同时把s[t]失效的置空,                       //在这里起向下一个判断的作用if(s[j])&#123;t = j;break;&#125;           s[t] = NULL;    &#125;        free(s);   //释放分配空间        return ss;&#125;//求哈夫曼树的带权路径长度int WeightPathLength(btreenode* FBT, int len)&#123;          //参数len为树的层数    if(!FBT)&#123;        return 0;    &#125;    else&#123;        if(FBT-&gt;left ==NULL&amp;&amp;FBT-&gt;right ==NULL)//访问到叶子结点            return FBT-&gt;data*len;        else&#123;               //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增            return  WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);//一定要记得加1        &#125;    &#125;&#125;//哈夫曼编码void HuffManCoding(btreenode* FBT, int len)&#123;   //参数len为树的层数    static int a[20];                        //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减1    if(FBT)&#123;                                 //访问到叶子结点时输出其保存在数组a中的0和1序列编码        if(FBT-&gt;left == NULL&amp;&amp;FBT-&gt;right == NULL)&#123;             printf(&quot;结点权值为%d的编码:&quot;,FBT-&gt;data);             for(int i = 0;i&lt;len;i++)&#123;                 printf(&quot;%d&quot;,a[i]);            &#125;                printf(&quot;\n&quot;) ;        &#125;        else&#123;    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组                //a的对应元素中，向下深入一层时len值增1               a[len] = 0;               HuffManCoding(FBT-&gt;left,len+1);               a[len] = 1;               HuffManCoding(FBT-&gt;right,len+1);            &#125;    &#125;&#125;int main()&#123;    btreenode *s;    int n;    printf(&quot;从键盘输入待构造的哈夫曼树中带权叶子结点数n：&quot;);    while(true)&#123;        scanf(&quot;%d&quot;,&amp;n);        if(n&gt;0)&#123;            break;        &#125;        else&#123;            printf(&quot;-------输入不合法,请重新输入!!\n&quot;);        &#125;    &#125;    int *a = (int *)malloc(n *sizeof(int));    printf(&quot;从键盘输入%d个整数作为权值:&quot;,n);    for (int i = 0; i &lt; n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    s = CreateHuffman(a,n);    printf(&quot;哈夫曼树的带权路径长度：&quot;);    printf(&quot;%d\n&quot;, WeightPathLength(s, 0));    printf(&quot;树中每个叶子结点的哈夫曼编码：\n&quot;);    HuffManCoding(s,0);    return 0;&#125;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="慕课MOOC" scheme="http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"/>
    
    
  </entry>
  
  <entry>
    <title>白话机器学习算法</title>
    <link href="http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-30T16:00:00.000Z</published>
    <updated>2022-05-05T09:48:29.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。<a href="https://book.douban.com/subject/30442187/">白话机器学习算法</a>一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。</p></blockquote><a id="more"></a><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><p>我们为何需要数据科学？因为借助现代计算机和高级算法，我们能够从大型数据集中发现隐藏的趋势，能够充分利用发现的趋势做预测，能够计算每种结果出现的概率，能够快速获取准确结果。</p><p>数据科学的研究有 4 个主要步骤：</p><ol><li>准备待分析的数据。</li><li>根据研究需求挑选合适的算法，为数据建立模型。</li><li>对算法的参数进行调优，优化模型。</li><li>根据准确度评价模型。</li></ol><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4><p>数据格式：数据点、数据集。</p><p>变量（variable）：用于描述数据点，又叫属性、特征或维度，变量选择是一个试错的过程，需要根据反馈结果不断更换变量，选取那些最有希望的变量，以待进一步分析。</p><ul><li>二值变量（binary variable）：最简单的变量类型，只有2个可选值</li><li>分类变量（categorical variable）：用来表示有2个以上选择的情况</li><li>整型变量（integer variable）：用来表示整数</li><li>连续变量（continuous variable）：用来表示小数</li></ul><p>特征工程（feature engineering）是将原始数据转化成更好的表达问题本质的特征的过程，使得将这些特征运用到预测模型中能提高对不可见数据的模型预测精度。</p><p>解决数据缺失的方法：近似、计算、移除。</p><h4 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h4><p>无监督学习（unsupervised learning）是依靠算法从数据中找出隐藏的模式，主要有 k 均值聚类、主成分分析、关联规则、社会网络分。通过间接手段，可以对无监督学习模型输出的结果进行验证。</p><p>监督学习（supervised learning）是基于数据中已有的模式做预测，主要有回归分析、k 最近邻、支持向量机、决策树、随机森林（random forest）、神经网络等。</p><p>强化学习（reinforcement learning）使用数据中的模式做预测，并根据越来越多的反馈结果不断改进。</p><p>我们除了要了解算法使用的任务类型外，还要了解各种算法对不同数据类型的分析能力，以及结果的本质。</p><h4 id="参数调优（parameter-tuning）"><a href="#参数调优（parameter-tuning）" class="headerlink" title="参数调优（parameter tuning）"></a>参数调优（parameter tuning）</h4><p>不同的算法有不同的调节参数，即便是同一个算法，如果参数调的不一样，所产生的结果也各不相同。</p><p>过拟合模型：过度敏感，把数据中的随机波动当成持久模式，对当前数据有着很高的预测准确度，但是对未知数据的预测准确度较差（泛化能力不强）。</p><p>欠拟合模型（underfitting）：过于愚钝，很可能会忽视数据中的重要趋势，这会导致模型对当前数据和未知数据的预测准确度下降。</p><p>理想拟合：算法能在识别主要趋势和忽视微小变化之间找到平衡，使最终得到的模型非常适合做预测。</p><p>对于大多数模型而言，过拟合（overfitting）是常见问题，所以增加预测模型的复杂度能最大限度的减少预测误差，但容易出现预测边界过度复杂。可以通过正则化（regularization）引入惩罚参数，通过人为增大预测误差，对模型复杂度的增加进行惩罚，从而使算法同时考虑复杂度和准确度使模型保持简单，有助于提高模型的泛化能力。</p><h4 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h4><p>使用一些评价指标来比较模型的预测准确度：预测准确率、混淆矩阵和均方根误差（root mean squared error）</p><p>分类指标（classification）</p><ul><li>预测准确率：正确预测所占的比率，无法通过预测准确率得知预测误差是如何产生的</li><li>混淆矩阵（confusion matrix）：在预测准确率的基础上添加假正类型和假负类型，辨别预测误差数</li></ul><p>回归指标：由于回归预测使用连续值，因此误差一般被量化成预测值和实际值之差，惩罚随误差大小而不同。</p><ul><li>  均方根误差：将每个误差都取平方，放大大误差，这使得均方根误差对异常值极其敏感，对这些值的惩罚力度也更大，避免较大的误差。</li></ul><p>验证：评估模型对新数据的预测准确度，避免过拟合模型在面对当前数据表现良好而面对新数据时可能表现糟糕的情况。在评估模型时并不一定非要使用新数据，而是可以把当前的数据集划分成训练集（training dataset）和测试集（test dataset）。训练集用来生成和调整预测模型，测试集用来充当新数据并评估模型的预测准确度，最好的模型针对测试集所做的预测一定是最准确的。为了使验证（validation）过程行之有效，需要不带偏差的把数据点随机分派到数据集和测试集中。</p><p>交叉验证（cross-validation）：使用同一个数据集进行训练和测试，避免因为原始数据集很小而无法留出足够的数据形成测试集的情况。把数据集划分成若干组用来对模型进行反复测试，在单次迭代中除了某一组外其他各组都被用来训练预测模型，然后留下来的那组被用来测试模型，这个过程重复进行直到每一个组都测试过模型，并且只测试过一次。</p><h3 id="二、k-均值聚类（k-means-clustering）"><a href="#二、k-均值聚类（k-means-clustering）" class="headerlink" title="二、k 均值聚类（k-means clustering）"></a>二、k 均值聚类（k-means clustering）</h3><h4 id="定义群组"><a href="#定义群组" class="headerlink" title="定义群组"></a>定义群组</h4><p>群组数量要足够大，以便提取有意义的模式用作商业决策参考，还要足够小，能够确保各个群组之间有明显的区别。</p><p>使用陡坡图（scree plot）确定合适的群组数量，陡坡图可以展现群组内散度随群组数量增加而降低的过程。陡坡图曲线的拐弯处表示最佳群组数量，此处的群组内散度较为合理。</p><p>通过检查群组成员与群组中心点的距离判断该群组的有效性，群组最好由密集的数据点组成。</p><ol><li>猜测每个群组的中心点，因为暂时不能确定通过猜测得到的中心点是否正确，所以称它们为伪中心点。</li><li>把每个数据点分配给最近的伪中心点。</li><li>根据群组成员的分布调整为中心点的位置。</li><li>重复步骤 2 和步骤 3 直至群组成员不再发生变化。</li></ol><p>聚类也可以在更多的维度上进行，虽然多维度分析很难进行可视化，但是可以借助程序计算数据点和群组中心点在多维度情形下的距离。</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>每个数据点只能属于一个群组：恰好位于两个群组中间的数据点无法确定应属于哪个群组。</p><p>群组被假定是正圆形的：若群组的实际形状是椭圆形，那么位于椭圆两端的数据点可能被划入邻近的其他群组。</p><p>群组被假定是离散的：k 均值聚类既不允许群组重叠，也不允许它们相互嵌套。</p><p>弥补局限性的方法：先用 k 均值聚类方法大致了解数据结构，再综合运用其他更高级的方法进行深入分析。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>k 均值聚类用于把相似的数据点划入同一个群组，群组数量 k 必须事先指定。给数据点分组时，首先把各个数据点分配到距离最近的群组中，然后调整群组中心点的位置，重复这2个步骤直到群组中的成员不再发生变化。k 均值聚类最适用于正圆形、非重叠的群组。</p><h3 id="三、主成分分析（principal-component-analysis）"><a href="#三、主成分分析（principal-component-analysis）" class="headerlink" title="三、主成分分析（principal component analysis）"></a>三、主成分分析（principal component analysis）</h3><h4 id="主成分"><a href="#主成分" class="headerlink" title="主成分"></a>主成分</h4><p>主成分分析用于找出最能区分数据点的变量，这种变量被称为主成分，数据点会沿着主成分的维度最大限度地分散开。主成分可以用已有的一个或多个变量表示。标准化（standardization）类似于使用百分位数表示每个变量，以此将所有变量统一到一个标准尺度上。采用主成分分析之后，可以不再通过试错法组合变量，而是通过精确计算各个变量的权重来获得最优变量组合。</p><h4 id="确定主成分数量"><a href="#确定主成分数量" class="headerlink" title="确定主成分数量"></a>确定主成分数量</h4><p>由于主成分来源于原始变量，因此用来区分数据点的可用信息会受到原始变量个数的制约，为了让结果更简单、更通用，应该只选择前几个主成分进行可视化和后续分析。将主成分按照其对数据点的区分效果进行排列，随着主成分个数增多，区分数据点的效果会变差，陡坡图曲线的拐弯处往往体现了最佳主成分数量。对当前的数据样本进行解释时，使用的主成分越少，泛化能力就越强。</p><h4 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h4><p>散度最大化：主成分分析有个重要假设，即数据点最分散的维度是最有用的</p><p>解释成分：主成分分析必须对其产生的成分进行解释，但有时可能很难解释变量按某种方式进行组合的原因</p><p>正交成分：主成分分析算法成分之间存在正交关系，然而真实信息维度之间可能不存在正交关系</p><p>弥补局限性的方法：独立成分分析（不需要假设正交关系，在确定成分时还无需考虑数据的散度）</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>主成分分析是一种降维技巧，它使得我们可以使用较小的变量来描述数据，这些变量即为主成分。每个主成分都是原始变量的某种加权组合，最好的主成分可以用来改进数据分析和可视化。当信息最丰富的几个维度拥有最大的数据散度，并且彼此正交时，主成分分析能有最佳效果。</p><h3 id="四、关联规则（association-rule）"><a href="#四、关联规则（association-rule）" class="headerlink" title="四、关联规则（association rule）"></a>四、关联规则（association rule）</h3><h4 id="支持度、置信度和提升度"><a href="#支持度、置信度和提升度" class="headerlink" title="支持度、置信度和提升度"></a>支持度、置信度和提升度</h4><p>识别关联规则的常用指标有3个：支持度、置信度和提升度。支持度是某个项集出现的频率，可以人为设定一个支持度阈值，当某个项集的支持度高于这个阈值时，就把它称为频繁项集。置信度是当 X 项出现时 Y 项同时出现的频率，记为 {X-&gt;Y} ，但它可能会错估某个关联规则的重要性。提升度是 X 项和 Y 项一同出现的频率，同时考虑这两项各自出现的频率。</p><pre><code class="matlab">&#123;X-&gt;Y&#125; 的提升度 = &#123;X-&gt;Y&#125; 的置信度 / &#123;Y&#125; 的支持度</code></pre><h4 id="先验原则（apriori-principal）"><a href="#先验原则（apriori-principal）" class="headerlink" title="先验原则（apriori principal）"></a>先验原则（apriori principal）</h4><p>先验原则是指如果某个项集出现的不频繁那么包含它的任何更大的项集必定也出现的不频繁。</p><p>寻找具有高支持度的项集：</p><ol><li>列出只包含一个元素的项集。</li><li>计算每个项集的支持度，保留那些满足最小支持度阈值条件的项集，淘汰不满足的项集。</li><li>项候选项集中增加一个元素，并利用在步骤2中保留下来的项集产生所有可能的组合。</li><li>重复步骤2和步骤3，为越来越大的项集确定支持度，直到没有待检查的新项集。</li></ol><p>寻找具有高置信度或高提升度的关联规则：因为置信度和提升度都是基于支持度计算出来的，因此一旦识别出具有高支持度的项集，寻找关联规则就不会那么费劲了。</p><h4 id="局限性-2"><a href="#局限性-2" class="headerlink" title="局限性"></a>局限性</h4><p>计算成本高：当库存量很大或者支持度阈值很低时，候选项集仍然会很多。</p><p>假关联：当元素的数量很大时，偶尔会出现假关联，为了确保所发现的关联规则具有普遍性，应该对他们进行验证。</p><p>弥补局限性的方法：使用高级数据结构对候选项集进行更高效的分类，从而减少比较的次数。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>关联规则用于揭示某一元素出现的频率以及它与其他元素的关系。</p><p>识别关联规则的常用指标有3个：</p><ol><li>{X} 的支持度表示 X 项出现的频率。</li><li>{X-&gt;Y} 的置信度表示当 X 项出现时，Y 项同时出现的频率。</li><li>{X-&gt;Y} 的提升度表示 X 项和 Y 项一同出现的频率，并且考虑每项各自出现的频率。</li></ol><p>利用先验原则可以淘汰一大部分非频繁项集，从而大大地加快搜索频繁相机的速度。</p><h3 id="五、社会网络分析"><a href="#五、社会网络分析" class="headerlink" title="五、社会网络分析"></a>五、社会网络分析</h3><h4 id="Louvain-方法（Louvain-method）"><a href="#Louvain-方法（Louvain-method）" class="headerlink" title="Louvain 方法（Louvain method）"></a>Louvain 方法（Louvain method）</h4><p>通过对节点分组可以找出网络中存在的群组，研究这些群组有助于理解网络各部分的区别和联系。</p><p>Louvain 方法用来在网络中找出群组，它会尝试使用不同的聚类配置来做如下两种事：</p><ol><li>同一群组中各个节点间的边数和强度最大化。</li><li>把属于不同群组的节点间的边数和强度最小化。</li></ol><p>模块度用于表示上述两件事的完成程度，模块度越高，群组越理想。</p><p>为了获得理想的聚类配置，Louvain 方法会不断迭代：</p><ol><li>把每个节点看作一个群组，即一开始群组数和节点数相同。</li><li>把一个节点重新分配给对提高模块度有最大帮助的群组，如果无法进一步提高，模块度节点保持不动，针对每个节点重复这个过程直到不能再分配。</li><li>把步骤2中发现的每个群组作为一个节点构建出一个粗粒度网络，并且把以前的群间边合并成连接新结点且带权重的边。</li><li>重复步骤2和步骤3直到无法再重新分配和合并。</li></ol><p>Louvain 方法先发现小群组，然后在适当的情况下合并它们，帮助我们找出更重要的群组，但它有一定的局限性。</p><ul><li>重要但较小的群组可能会被合并：需要检查在中间迭代阶段被发现的群组，如果有必要就把它们保留下来。</li><li>有多种可能的聚类配置：若网络中包含重叠或嵌套的群组，需要依据其他信息源对群组予以验证。</li></ul><h4 id="PageRank-算法（PageRank-algorithm）"><a href="#PageRank-算法（PageRank-algorithm）" class="headerlink" title="PageRank 算法（PageRank algorithm）"></a>PageRank 算法（PageRank algorithm）</h4><p>虽然群组可以反映出相互作用高度集中的区域，但是这些相互作用可能受占主导地位的节点支配，群组则围绕着这些主导节点形成，为了找出占主导地位的节点，需要对节点进行排序。PageRank 算法是谷歌公司最初用来为网页排名的算法之一，以 Larry Page 的姓氏命名。</p><p>在PageRank 算法中，决定一个网页排名的因素有如下3个：</p><ol><li>链接数量：被其他网页链接的次数越多，该网页的访问者可能就越多</li><li>链接强度：这些链接被访问的次数越多，该网页的流量就越大</li><li>链接来源：如果被其他有较高排名的网页链接，那么该网页的排名也会升高</li></ol><p>尽管 PageRank 算法易于使用，但它有偏向于旧节点的局限性：如果一个新网页包含非常棒的内容但一开始访问者人数很少，那么它的排名就比较低，可以定期更新 PageRank 值，让新网页随着自身知名度的提高获得提高排名的机会。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>社会网络分析可用于绘制和分析多个实体之间的关系。Louvain 方法用于在一个网络中找出群组，具体做法是将群组内部的相互作用最大化，同时把群组之间的相互作用最小化，当群组大小相同且相互分离时，该方法的效果最佳。PageRank 算法根据链接的数量强度以及来源对网络中的节点进行排序，这个算法有助于找出网络中占主导地位的节点，但对链接数不太多的新节点并不友好。</p><h3 id="六、回归分析（regression-analysis）"><a href="#六、回归分析（regression-analysis）" class="headerlink" title="六、回归分析（regression analysis）"></a>六、回归分析（regression analysis）</h3><h4 id="趋势线"><a href="#趋势线" class="headerlink" title="趋势线"></a>趋势线</h4><p>趋势线是做预测时常用的工具，他们很容易生成，也很容易理解。一般的趋势往往只涉及单个预测变量，这个变量用来产生预测结果，不过通过添加更多预测变量可以改善预测结果。回归分析不但可以通过考虑更多预测变量改善预测结果，还可以比较各个预测变量的强弱。</p><h4 id="梯度下降法（gradient-decent）"><a href="#梯度下降法（gradient-decent）" class="headerlink" title="梯度下降法（gradient decent）"></a>梯度下降法（gradient decent）</h4><p>在回归分析中预测变量的权重是主要参数，通过解方程可以求得最优权重。梯度下降法先初步猜测合适的权重组合，再通过一个迭代过程，把这些权重应用于每个数据点做预测，然后调整权重以减少整体预测误差。这个过程类似于一步步走到山底下，每走一步梯度下降法都要判断从哪个方向下是最陡峭的，然后朝着那个方向重新校准权重，最终到达最低点，这个点的预测误差最小（经过优化的回归趋势线与梯度上的最低点相对应）。除了回归之外，梯度下降法也能用来优化其他模型中的参数，比如支持向量机和神经网络。</p><p>梯度下降法的结果可能会受到初始参数值（下山起点）的影响，若起点下方恰好有一个小凹坑，那么梯度下降法可能会将其误认为是最优点，为了降低陷入这种凹坑的风险，可以使用随机梯度下降法，每次迭代并不是采用所有的数据点，而是只从其中选取一个来调整参数，引入多变性，有助于算法逃离凹坑。</p><h4 id="回归系数"><a href="#回归系数" class="headerlink" title="回归系数"></a>回归系数</h4><p>在为回归预测变量求得最佳权重之后，需要对它们进行解释。回归系数是回归预测变量权重，它表示某个预测变量相比于其他预测变量的影响大小。预测变量的度量单位不同也会影响对回归系数的解释，因此应该在做回归分析之前先对预测变量的度量单位进行标准化，经过标准化之后预测变量的系数被称为标准化回归系数。</p><h4 id="相关系数（correlation-coefficient）"><a href="#相关系数（correlation-coefficient）" class="headerlink" title="相关系数（correlation coefficient）"></a>相关系数（correlation coefficient）</h4><p>相关系数：当只存在一个预测变量时，该预测变量的标准化回归系数。</p><p>关联方向：相关系数为正表示预测变量和结果变化的方向一致，为负则表示两者变化方向相反。</p><p>关联强度：r 值越接近于 -1 或 1，预测变量的作用就越大，若值为 0 则表示预测变量和结果之间不存在关系。</p><p>因为相关系数表示单个预测变量的绝对强度，所以相比于回归系数，相关系数在对预测变量进行排序时更可靠。</p><h4 id="局限性-3"><a href="#局限性-3" class="headerlink" title="局限性"></a>局限性</h4><p>对异常值敏感：回归分析平等地对待所有的数据点，只要存在几个有异常值的数据点，就会给趋势线造成很大的影响，因此在做进一步分析之前，可以先使用散点图找出异常值。</p><p>多重共线性问题（multicollinearity）：如果回归模型包含高度相关的预测变量，就会造成相关预测变量权重失真，因此可以使用更高级的技术，如套索回归或岭回归。</p><p>弯曲的趋势：需要对预测变量的值进行转换，或使用支持向量机等其他算法。</p><p>并不说明存在因果关系。</p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>回归分析用于寻找最佳拟合线（best-fit line），使得尽可能多的数据点位于这条线上或附近，趋势线由带权重的组合预测变量得到，这些权重被称为回归系数，表示某个预测变量相对于其他预测变量的影响强度。</p><p>以下情况下，回归分析的效果最好：</p><ol><li>预测变量之间的关系不强</li><li>无异常值</li><li>趋势可以用直线表示</li></ol><h3 id="七、k-最近邻算法（k-Nearest-Neighbors）和异常检测"><a href="#七、k-最近邻算法（k-Nearest-Neighbors）和异常检测" class="headerlink" title="七、k 最近邻算法（k-Nearest Neighbors）和异常检测"></a>七、k 最近邻算法（k-Nearest Neighbors）和异常检测</h3><h4 id="k-最近邻算法"><a href="#k-最近邻算法" class="headerlink" title="k 最近邻算法"></a>k 最近邻算法</h4><p>k 最近邻算法根据周围数据点的类型对某个数据点进行分类（物以类聚，人以群分）。在 k 最近邻算法中，参数 k 表示周围数据点的个数，选择 k 值的过程叫做参数调优，它对预测的准确度起着至关重要的作用；</p><p>使用不同的 k 值进行拟合：如果 k 值太小，数据点只与最近的邻居匹配，并且随机造成所产生的误差也会被放大；如果 k 值太大，数据点会尝试与更远的邻居匹配，其中隐含的模式会被忽略；只有当 k 值恰到好处时，数据点才会参考合适数量的邻居，使得误差相互抵消，有利于揭示数据中隐藏的趋势。</p><p>为实现理想拟合并把误差降到最低，可以使用交叉验证法对参数 k 进行调优，对于二分类问题，可以把 k 设置成一个奇数，以避免出现平局的情况，除了用来为数据点分类，k 最近邻算法还可以通过合计周围数据点的值来预测连续值，通过使用加权平均值，能够进一步改善预测结果，离数据点越近的邻居，其值越能反映该数据点的真实值，因此赋给它的权重应该更大。</p><h4 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h4><p>k 最近邻算法不仅可以用来预测数据点的类别和取值，还可以用来识别异常，比如检测欺诈行为。在异常检测的过程中还可能会有新发现，比如发现之前被忽略的预测变量。</p><p>事实上任何能够产生预测模型的算法都可以用来检测异常，比如在回归分析中，如果某个数据点明显偏离最佳拟合线，那么就会被识别为异常点。异常数据点既可能因缺失预测变量所致，也可能因预测模型缺少足够的训练数据所致。一旦找到异常数据点，就要将它们从数据集中移除，然后再训练预测模型，减少数据中包含的噪声，进而提高模型的准确度。</p><h4 id="局限性-4"><a href="#局限性-4" class="headerlink" title="局限性"></a>局限性</h4><p>类别不平衡：可以使用加权投票法来取代少数服从多数原则，确保较近数据点类别的权重比较远的更大。</p><p>预测变量过多：在多个维度上识别和处理近邻会导致你计算量大增，需要降维（dimension reduction）。</p><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>k 最近邻算法根据周围数据点的类型对某个数据点进行分类，k 表示用作参考的数据点的个数，可以使用交叉验证法来确定。当预测变量数目不多，并且类别大小差别不大时，k 最近邻算法才能产生非常好的效果。不准确的分类可能会被标记为潜在异常。</p><h3 id="八、支持向量机（support-vector-machine）"><a href="#八、支持向量机（support-vector-machine）" class="headerlink" title="八、支持向量机（support vector machine）"></a>八、支持向量机（support vector machine）</h3><h4 id="勾画最佳分界线"><a href="#勾画最佳分界线" class="headerlink" title="勾画最佳分界线"></a>勾画最佳分界线</h4><p>支持向量机的主要目标是得到一条能用于分组的最佳分界线，需要注意的是，能用于分组的分界线可能有很多条。为了找出最佳分界线，首先需要从一组中找出距离另一组最近的外围数据点，然后在两组的外围数据点之间画出最佳分界线，由于这些外围数据点在寻找最佳分界线的过程中起了支持作用，因此叫做支持向量。</p><p>支持向量机的一个优点是计算速度很快，仅依靠外围数据点就能找到决策边界，这种对数据点子集的依赖也有缺点，这是因为决策边界对支持向量的位置比较敏感，选取不同的数据点作为训练数据，相应支持向量的位置也不同。</p><p>支持向量机算法有一个关键特征——缓冲带，缓冲带允许一定数量的训练数据点位于错误的一边，由此得到一条更软的分界线。缓冲带对异常值有更强的耐扰性，因此对新数据有更强的泛化能力。缓冲带通过调整惩罚参数得到，这个参数决定了对分类误差的宽容度，惩罚参数越大，宽容度就越大，缓冲带也就越宽。为了让模型对当前数据和新数据有较高的预测准确度，可以使用交叉验证法求得最佳惩罚参数。</p><p>支持向量机的另一个强项是找到决策边界的凸弧，它在发现错综复杂的凸弧时有着更出众的计算效率。支持向量机的秘诀是核技巧（kernel trick），支持向量机不会直接在在数据平面上绘制有凸弧的分界线，而是会首先把数据映射到高维空间，然后在高维空间中将数据点用直线分开，这些直线容易计算，并且当映射回低维空间时，也很容易转化成曲线。</p><p>支持向量机具备在高维空间操纵数据的能力，使得它在分析有多个变量的数据集时大受欢迎。常见应用场景包括遗传信息破译以及文本情感分析。</p><h4 id="局限性-5"><a href="#局限性-5" class="headerlink" title="局限性"></a>局限性</h4><p>小数据集：由于支持向量机依靠支持向量确定决策边界，因此样本量少，用来对分界线进行准确定位的数据也少。</p><p>多组数据：支持向量机每次只能对两组进行分类，如果存在2个以上的组，则需要对每一组都应用支持向量机（多类支持向量机）。</p><p>两组之间存在大量重叠：靠近边界的数据点可能更容易发生分类错误，而且支持向量机没有给出每个数据点遭遇错误分类的概率，但可以通过数据点到决策边界的距离来估计其被正确分类的可能性。</p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>支持向量机用来把数据点分为两组，其方法是在两组的外围数据点（支持向量）的中间画一条分界线，支持向量机对异常值有较好的容忍度，它通过一个缓冲带允许少量数据点位于错误的一边，此外他还通过核技巧高效地求得带凸弧的决策边界。当需要把大样本中的数据点分为两组时，支持向量机能够发挥最佳作用。</p><h3 id="九、决策树（decision-tree）"><a href="#九、决策树（decision-tree）" class="headerlink" title="九、决策树（decision tree）"></a>九、决策树（decision tree）</h3><h4 id="生成决策树"><a href="#生成决策树" class="headerlink" title="生成决策树"></a>生成决策树</h4><p>递归拆分（recursive partitioning）：</p><ol><li>确定一个二元选择题，它能够把数据点拆分成两组，并最大限度地提高每组数据点的同质性。</li><li>针对每个叶结点重复步骤1，直到满足终止条件。</li></ol><p>终止条件可能有多个，可以使用交叉验证法进行选取：每个叶节点的数据全属于同一类或有相同的值，叶节点包含的数据点少于5个，进一步分支会超出阈值并且不能提高同质性。</p><p>由于递归拆分只用最佳二元选择题来生成决策树，因此不显著的变量并不会影响结果，而且二元选择题往往围绕着最重要的值划分数据点，所以决策树对异常值有较强的耐扰性。决策树易于可视化，使我们更容易评估预测变量及其相互作用。</p><h4 id="局限性-6"><a href="#局限性-6" class="headerlink" title="局限性"></a>局限性</h4><p>不稳定：决策树是通过把数据点分组生成的，数据中的细微变化可能影响拆分结果，并导致生成的决策树截然不同。</p><p>容易产生过拟合：决策树每次拆分数据点时都力求找到最佳拆分方式。</p><p>不准确：一开始就是用最佳二元选择题拆分数据点并不能保证结果最准确。</p><p>弥补局限性的方法：每次拆分时可以不采用最佳拆分方式，而是尽量让决策树多样化，然后综合不同的决策树产生的预测结果，让最终预测结果具有更好的稳定性和准确性。</p><h4 id="决策树的多样化方法"><a href="#决策树的多样化方法" class="headerlink" title="决策树的多样化方法"></a>决策树的多样化方法</h4><p>随机森林：随机选择不同的二元选择题，生成多棵决策树，然后综合这些决策树的预测结果。</p><p>梯度提升（gradient boosting）：有策略地选择二元选择题，以逐步提高决策树的预测准确度，然后将所有的预测结果的加权平均数作为最终结果。</p><p>虽然随机森林的和梯度提升能够产生更准确的预测结果，但是它们往往比较复杂并且很难进行可视化（黑盒）。</p><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>决策树通过询问一系列二元选择题来做预测，若想生成决策树，就要不断拆分数据样本以获得同质组，直到满足终止条件，这个过程被称为递归拆分。虽然决策树易于使用和理解，但是容易造成过拟合问题，导致出现不一致的结果，为了尽量避免出现这种情况，可以采用随机森林等替代方法。</p><h3 id="十、随机森林"><a href="#十、随机森林" class="headerlink" title="十、随机森林"></a>十、随机森林</h3><h4 id="集成模型"><a href="#集成模型" class="headerlink" title="集成模型"></a>集成模型</h4><p>集成方法（ensembling）：通过组合有不同优缺点的模型来提高预测准确度的方法。</p><p>集成模型：通过组合许多模型的预测结果得到的预测模型，在组合模型时，既可以遵循少数服从多数的原则，也可以取平均值。随机森林是决策树的集成模型。</p><p>相比于子模型，集成模型的预测准确度更高，这是因为准确的预测模型会彼此强化，错误的则会彼此抵消，为了达到这种效果，集成模型的子模型一定不能犯同类错误，换言之，子模型必须是不相关的。</p><h4 id="自助聚集法（bootstrap-aggregating）"><a href="#自助聚集法（bootstrap-aggregating）" class="headerlink" title="自助聚集法（bootstrap aggregating）"></a>自助聚集法（bootstrap aggregating）</h4><p>自助聚集法是用来生成数千棵不相关的决策树的系统化方法，这些树彼此有明显的不同。为使决策树之间的关联度最小化，每棵树都由训练数据集的一个随机子集产生，并且使用的是预测变量的一个随机子集，这让生成的决策树各不相同，但仍然保留了一定的预测能力。通过限制每次拆分时所用的预测变量，能够生成各不相同的决策树，从而避免发生过拟合问题。为进一步降低发生过拟合问题的可能性，可以增加随机森林中决策树的数量，使模型更通用、更准确。</p><h4 id="局限性-7"><a href="#局限性-7" class="headerlink" title="局限性"></a>局限性</h4><p>随机森林由随机生成的决策树组成，并不存在明确的预测规则，这种不可解释性可能会带来一些伦理问题，因此随机森林适用于那些预测准确度比可解释性更重要的场合。</p><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><p>随机森林的预测结果往往比单棵决策树更准确，这是因为它充分利用了两种技术：自助聚集法和集成方法。自助聚集法通过随机限制数据拆分过程所用的变量来生成一系列不相关的决策树，集成方法则把决策树的预测结果组合在一起。虽然随机森林的预测结果不具有可解释性，但仍然可以根据对预测结果的贡献度大小对各个预测变量进行排序。</p><h3 id="十一、神经网络（neural-network）"><a href="#十一、神经网络（neural-network）" class="headerlink" title="十一、神经网络（neural network）"></a>十一、神经网络（neural network）</h3><h4 id="神经网络的诞生"><a href="#神经网络的诞生" class="headerlink" title="神经网络的诞生"></a>神经网络的诞生</h4><p>数据存储和共享技术取得进步，为训练神经网络提供了海量数据，有助于改善神经网络的性能。计算能力越来越强大，GPU的运行速度最快能达到CPU的150倍，能为在大数据集上训练神经网络提供强大的支持。算法获得改进。</p><h4 id="神经网络的构成"><a href="#神经网络的构成" class="headerlink" title="神经网络的构成"></a>神经网络的构成</h4><p>输入层：该层处理输入图像的每个像素。为提高预测准确度，可以使用卷积层。卷积层并不处理单个像素，而是识别像素组合的特征，这种分析只关注特征是否出现而不关注出现的位置。所以即使某些关键特征偏离了中心，神经网络仍然能够正确识别，这种特性叫做平移不变性（translational invariance）。</p><p>隐藏层：在像素进入神经网络之后，通过层层转换不断提高和那些标签已知的图像的相似度。标签已知是指神经网络以前见过这些图像，虽然转换得越多，预测准确度就会越高，但是处理时间就会明显增加，一般来说几个隐藏层就足够了/每层的神经元数量要和图像的像素数成比例。</p><p>输出层：该层产生最终预测结果，在这一层中神经元可以只有一个，也可以和结果一样多。</p><p>损失层：该层通常位于最后，并提供有关输入是否识别正确的反馈，如果不正确则给出误差量。在训练神经网络的过程中，损失层至关重要，若预测准确，来自于损失层的反馈会强化产生该预测结果的激活路径。若预测错误，则错误会沿着路径逆向返回，这条路径上的神经元的激活条件就会被重新调整，以减少错误，这个过程称为反向传播（back propagation）。</p><p>通过不断重复这个训练过程，神经网络会学习输入信号和正确输出标签之间的联系，并且把这些联系作为激活规则（activation rule）编入每个神经元，因此为了提高神经网络的预测准确度，需要调整管理激活规则的部件。</p><h4 id="激活规则"><a href="#激活规则" class="headerlink" title="激活规则"></a>激活规则</h4><p>为了产生预测结果，需要沿着一条路径依次激活神经元，每个神经元的激活过程都由其激活规则所控制，激活规则指定了输入信号的来源和强度，在神经网络的训练过程中激活规则会不断调整。良好的激活规则有助于产生准确的预测结果，其关键在于确定合适的权重和阈值，另外神经网络的其他参数也需要调整，比如隐藏层的数量、每层的神经元数量等。可以使用梯度下降法优化这些参数。</p><h4 id="局限性-8"><a href="#局限性-8" class="headerlink" title="局限性"></a>局限性</h4><p>需要大样本：神经网络的复杂性使之能够识别带有复杂特征的输入，但前提是我们能为他提供大量训练数据，如果训练集太小就会出现过拟合问题。可以通过以下方法降低过拟合风险：</p><ul><li>二次取样（subsampling）：为了降低神经元对噪声的敏感度，需要对神经网络的输入进行平滑化处理，即针对信号样本取平均值。</li><li>畸变：当缺少训练数据时，可以通过向每幅图像引入畸变，来产生更多数据，每幅畸变图像都可以作为新的输入，以此扩大训练数据的规模，畸变应该能够反映原数据集的特征（弹性变形）。</li><li>丢弃（dropout）：为解决小的神经元集群之间彼此产生过度依赖，可以在训练期间随机丢弃一半的神经元，这些遭丢弃的神经元将处于未激活的状态，剩下的神经元则正常工作，下一次训练丢弃一组不同的神经元，迫使不同的神经元协同工作，从而揭示训练样本所包含的更多特征。</li></ul><p>计算成本高：训练一个由几千个神经元组成的神经网络可能需要很长时间，一个简单的解决方法是升级硬件另一个解决方法是调整算法，用稍低一些的预测准确度换取更快的处理速度：</p><ul><li>随机梯度下降法：为了更新某一个参数，经典的梯度下降法在一次迭代中使用所有的训练样本，当数据集很大时这样做会耗时，随机梯度下降法是在每次迭代中只用一个训练样本来更新参数，虽然使用这个方法得到的最终参数可能不是最优的，但是准确度不会太低。</li><li>小批次梯度下降法：虽然使用随机梯度下降法能够提升速度，但最终参数可能不准确，算法也可能无法收敛，导致某个参数上下波动，小批次梯度下降法是每次迭代使用训练样本的一个子集。</li><li>全连接层：随着加入的神经元越来越多，路径的数量呈指数增长，为避免查看所有可能的组合，可以使初始层（处理更小、更低级的特征）的神经元部分连接，只有最后几层（处理更大、更高级的特征）才对相邻层的神经元进行全连接。</li></ul><p>不可解释：神经网络由多层组成，每层都有几百个神经元，这些神经元有不同的激活规则控制，这使得我们很难准确地找到产生正确预测结果的输入信号组合。但和回归分析不同，回归分析能明确地识别重要的预测变量，并比较它们的强度，神经网络的特性使之难以证明其使用得当，在涉及伦理问题时尤其如此。</p><p>尽管存在上述局限性，但是神经网络本身拥有的强大能力，使之得以应用于虚拟助手、自动驾驶等前沿领域，随着算法不断改进以及计算能力不断提升，神经网络将在物联网时代发挥关键作用。</p><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p>神经网络由多个神经元组成，训练期间，第1层的神经元首先被输入数据激活，然后将激活状态传播到后续各层的神经元，最终在输出层产生预测结果。一个神经元是否被激活取决于输入信号的来源和强度，这由其激活规则指定，激活规则会根据预测结果的反馈不断调整，这个过程被称为反向传播。在大数据集和先进的计算硬件可用的情况下，神经网络的表现最好，然而预测结果在大部分的时候都是无法解释的。</p><h3 id="十二、A-B-测试（A-B-testing）和多臂老虎机（multi-arm-bandit-problem）"><a href="#十二、A-B-测试（A-B-testing）和多臂老虎机（multi-arm-bandit-problem）" class="headerlink" title="十二、A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）"></a>十二、A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）</h3><h4 id="A-B-测试的局限性"><a href="#A-B-测试的局限性" class="headerlink" title="A/B 测试的局限性"></a>A/B 测试的局限性</h4><p>测试结果具有偶然性：为提高测试结果的可信度可以增加受测人数，但是会导致另一个问题。</p><p>潜在的收入损失：如果把受测顾客增加一倍，那么看到糟糕广告的人数也会增加一倍，这有流失的顾客的风险。</p><p>这两个问题体现了 A/B 测试中的两个权衡因素：探索和利用。</p><h4 id="epsilon-递减策略（epsilon-decreasing-strategy）"><a href="#epsilon-递减策略（epsilon-decreasing-strategy）" class="headerlink" title="epsilon 递减策略（epsilon-decreasing strategy）"></a>epsilon 递减策略（epsilon-decreasing strategy）</h4><p>epsilon 指的是探索时间与总时间的比例，随着对效果较好的广告越来越有信心，我们使 epsilon 值递减，这个方法属于强化学习的范畴。</p><p>A/B 测试由探索和利用前后两个阶段组成，而在 epsilon 递减策略中，探索阶段和利用阶段是分散的，并且一开始时探索得多一些，越接近尾声，探索得越少。</p><h4 id="多臂老虎机"><a href="#多臂老虎机" class="headerlink" title="多臂老虎机"></a>多臂老虎机</h4><p>假设有两台老虎机 A 和 B 可供选择，玩2000个回合，每个回合要么赢1美元，要么没有收益，老虎机 A 的返还率为50%，老虎机 B 的则为40%，但我们事先并不知道这些信息，问要怎么玩才能多赢钱？</p><ol><li> 全探索：如果随机选择老虎机，平均会赢900美元。</li><li> A/B 测试：用前200个回合探索哪台老虎机的返还率更高，然后在剩下的1800个回合中选择这台老虎机，平均会赢976美元，但由于两台老虎机的返还率接近，由此存在误判的可能性（误判概率8%）。</li><li> 为降低误判的风险，可以把A/B 测试的探索范围扩大到500个回合，这样做可以把误判概率降到1%，但是平均中奖金额也会减少到963美元。</li><li> epsilon 递减策略：如果采用 epsilon 递减策略边探索边利用，平均会赢984美元，并且误判概率为4%，通过增加探索比例（增加 epsilon 值）能够降低误判概率，但仍会减少平均中奖金额。</li><li> 全利用：如果一开始就掌握内部消息并选择返还率最高的老虎机 A，平均会赢1000美元，但这个假设不现实。</li></ol><p>由此看到，在不掌握内部消息的情况下，采用 epsilon 递减策略的收益最高，而且由于存在收敛性这一数学特征，由此 epsilon 递减策略能确保在回合数足够多的情况下找出返还率最高的老虎机。</p><p>胜者为先：范加尔在曼联采用了一个非常规策略来决定罚点球的球员，第一个被指定罚点球的球员会负责到底，除非他没有打进球，接下来新换的球员继续负责罚点球，如果没有罚进就再换一名球员，依此类推。</p><p>频繁地换老虎机，会导致探索过多而利用过少，只比随机选择老虎机稍好一些，而且胜者为先策略只根据上一次的结果来评估老虎机，这忽略了老虎机之前的表现。</p><h4 id="epsilon-递减策略的局限性"><a href="#epsilon-递减策略的局限性" class="headerlink" title="epsilon 递减策略的局限性"></a>epsilon 递减策略的局限性</h4><p>采用 epsilon 递减策略的关键在于控制好 epsilon 值，如果 epsilon 值递减的过慢，就会失去利用老虎机的机会，而如果递减得过快，就可能会选错老虎机。epsilon 值的最佳递减速度主要取决于两台老虎机返还率的相似程度，采用汤普森取样方法，可以计算 epsilon 值。</p><p>epsilon 递减策略还依赖于如下假设：返还率恒定不变；返还率与上一次游戏无关；玩游戏和观察返还率之间的延迟极小。</p><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><p>多臂老虎机问题的实质是如何以最佳方式分配资源。一种策略是先探索可用选项，然后把所有剩余资源分配给表现最佳的选项，这个策略叫做 A/B 测试，另一个策略是给表现最佳的选项，逐渐分配更多的资源，这个策略叫做 epsilon 递减策略。虽然 epsilon 递减策略在大多数情况下能够提供比 A/B 测试更高的回报，但是确定资源分配的最佳更新速度并非易事。</p><h3 id="十三、更多评价指标"><a href="#十三、更多评价指标" class="headerlink" title="十三、更多评价指标"></a>十三、更多评价指标</h3><h4 id="分类指标"><a href="#分类指标" class="headerlink" title="分类指标"></a>分类指标</h4><p>接受者操作特征曲线下面积（曲线下面积）：这个指标允许我们在最大化正例率和最小化假正例率之间做权衡</p><ul><li>正例率：被模型正确预测为正类别的样本所占的比例</li><li>正例率 = 正例数 / ( 正例数 + 假负例数 )</li><li>假正例率：被模型错误预测为正类别的样本所占的比例</li><li>假正例率 = 假正例数 / ( 假正例数 + 负例数 )</li><li>在极端情况下，可以把所有样本全部预测为正类别，以此实现正例率最大化（正例率为1），虽然这样做可以避免出现假负例但会明显增加假正例</li><li>接受者操作特征曲线（ROC 曲线）体现了最大化正例率和最小化假正例率之间的权衡</li><li>模型性能通过 ROC 曲线下方的面积来衡量，所以该指标被称为曲线下面积，模型的准确度越高，曲线越靠近左上角</li><li>完美的预测模型会产生一条曲线下面积为1的曲线（曲线下面积等于整个图形的面积）</li></ul><p>对数损失指标利用置信度来校正其对预测误差的惩罚，具体来说，模型对错误预测的置信度越高，惩罚就越重，由于对数损失指标根据对预测结果的置信度来调整惩罚程度，因此它通常用于错误预测极其有害的情况。</p><h4 id="回归指标"><a href="#回归指标" class="headerlink" title="回归指标"></a>回归指标</h4><p>平均绝对误差：平等的惩罚所有预测误差，具体做法是对所有数据点的预测值和实际值之差取平均值。除了考虑误差大小之外，还可以通过均方根对数误差把误差方向纳入考虑范围。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。&lt;a href=&quot;https://book.douban.com/subject/30442187/&quot;&gt;白话机器学习算法&lt;/a&gt;一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.zhuangzhihao.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>开发团队调度软件实现</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/</id>
    <published>2021-10-08T16:00:00.000Z</published>
    <updated>2022-05-05T12:51:41.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在学习完 <a href="/Java%E5%9F%BA%E7%A1%80">Java 基础编程</a>的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。</p></blockquote><a id="more"></a><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3><ul><li>软件启动时，根据给定的数据创建公司部分成员列表（数组）</li><li>根据菜单提示，基于现有的公司成员，组建一个开发团队以开发一个新的项目</li><li>组建过程包括将成员插入到团队中，或从团队中删除某成员，还可以列出团队中现有成员的列表</li><li>开发团队成员包括架构师、设计师和程序员</li></ul><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ul><li>软件采用单级菜单方式工作，当软件运行时，主界面显示公司成员的列表</li><li>当选择“添加团队成员”菜单时，将执行从列表中添加指定（通过 ID）成员到开发团队的功能</li><li>如果添加操作因某种原因失败，将显示失败信息（失败原因视具体原因而不同）</li><li>当选择“删除团队成员”菜单时，将执行从开发团队中删除指定（通过 TeamID）成员的功能</li><li>当选择“团队列表”菜单时，将列出开发团队中的现有成员</li></ul><h3 id="软件设计结构"><a href="#软件设计结构" class="headerlink" title="软件设计结构"></a>软件设计结构</h3><ul><li>软件由 view、service、domain 三个模块组成<ul><li><code>com.atguigu.team.view</code> 模块为主控模块，负责菜单的显示和处理用户操作</li><li><code>com.atguigu.team.service</code> 模块为实体对象（Employee 及其子类如程序员等）的管理模块，<code>NameListService</code> 和 <code>TeamService</code> 类分别用各自的数组来管理公司员工和开发团队成员对象</li><li>domain 模块为 Employee 及其子类等 JavaBean 类所在的包</li></ul></li><li><code>com.atguigu.team.domain</code> 模块中包含了所有实体类<ul><li>其中 Programmer 及其子类，均会领用 Equipment</li></ul></li></ul><h3 id="创建项目基本组件"><a href="#创建项目基本组件" class="headerlink" title="创建项目基本组件"></a>创建项目基本组件</h3><ol><li>创建 <code>TeamSchedule</code> 项目，按照设计要求创建所有包，将项目提供的几个类复制到相应的包中<ul><li>view 包中：TSUtility.java</li><li>service包中：Data.java</li></ul></li><li>   按照设计要求，在 com.atguigu.team.domain 包中，创建 Equipment 接口及其各实现子类代码</li><li>   按照设计要求，在 com.atguigu.team.domain 包中，创建 Employee 类及其各子类代码</li><li>   检验代码的正确性</li></ol><h4 id="键盘访问的实现"><a href="#键盘访问的实现" class="headerlink" title="键盘访问的实现"></a>键盘访问的实现</h4><ul><li>项目 view 包中提供了 TSUtility.java 类，提供了以下静态方法，可用来方便地实现键盘访问<ul><li>public static char readMenuSelection()：该方法读取键盘，如果用户键入’1’-’4’中的任意字符，则方法返回。返回值为用户键入字符</li><li>public static void readReturn()：该方法提示并等待，直到用户按回车键后返回</li><li>public static int readInt()：该方法从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值</li><li>public static char readConfirmSelection()：从键盘读取‘Y’或’N’，并将其作为方法的返回值</li></ul></li></ul><h4 id="Equipment-接口及其实现子类的设计"><a href="#Equipment-接口及其实现子类的设计" class="headerlink" title="Equipment 接口及其实现子类的设计"></a>Equipment 接口及其实现子类的设计</h4><ul><li>根据需要提供各属性的 get/set 方法以及重载构造器</li><li>实现类实现接口的方法，返回各自属性的信息</li></ul><h4 id="Employee-类及其子类的设计"><a href="#Employee-类及其子类的设计" class="headerlink" title="Employee 类及其子类的设计"></a>Employee 类及其子类的设计</h4><ul><li>memberId 用来记录成员加入开发团队后在团队中的 ID</li><li>Status 是项目 service 包下自定义的类，声明三个对象属性，分别表示成员的状态<ol><li>FREE-空闲</li><li>BUSY-已加入开发团队</li><li>VOCATION-正在休假</li></ol></li><li>equipment 表示该成员领用的设备</li><li>bonus 表示奖金</li><li>stock 表示公司奖励的股票数量</li><li>可根据需要为类提供各属性的 get/set 方法以及重载构造器</li></ul><h4 id="Status-类"><a href="#Status-类" class="headerlink" title="Status 类"></a>Status 类</h4><ul><li><p>Status 枚举类位于 com.atguigu.team.service 包中，封装员工的状态</p><pre><code class="java">package com.atguigu.team.service;public class Status &#123;    private final String NAME;  private Status(String name) &#123;      this.NAME = name;  &#125;  public static final Status FREE = new Status(&quot;FREE&quot;);  public static final Status VOCATION = new Status(&quot;VOCATION&quot;);   public static final Status BUSY = new Status(&quot;BUSY&quot;);  public String getNAME() &#123;      return NAME;  &#125;  @Override  public String toString() &#123;      return NAME;  &#125;&#125;</code></pre></li></ul><h3 id="实现-service-包中的类"><a href="#实现-service-包中的类" class="headerlink" title="实现 service 包中的类"></a>实现 service 包中的类</h3><ol><li>   按照设计要求编写 NameListService 类</li><li>   在 NameListService 类中临时添加一个 main 方法中，作为单元测试方法</li><li>在方法中创建 NameListService 对象，然后分别用模拟数据调用该对象的各个方法，以测试是否正确<ul><li>测试应细化到包含了所有非正常的情况，以确保方法完全正确</li></ul></li><li>   重复以上3步，完成 TeamService 类的开发</li></ol><h4 id="NameListService-类的设计"><a href="#NameListService-类的设计" class="headerlink" title="NameListService 类的设计"></a>NameListService 类的设计</h4><ul><li>负责将 Data 中的数据封装到 Employee[] 数组中，同时提供相关操作 Employee[] 的方法</li><li>employees 用来保存公司所有员工对象</li><li>NameListService() 构造器<ul><li>根据项目提供的 Data 类构建相应大小的 employees 数组</li><li>再根据 Data 类中的数据构建不同的对象，包括 Employee、Programmer、Designer 和 Architect 对象，以及相关联的 Equipment 子类的对象</li><li>将对象存于数组中</li><li>Data类位于 com.atguigu.team.service 包中</li></ul></li><li>getAllEmployees()：获取当前所有员工<ul><li>返回：包含所有员工对象的数组</li></ul></li><li>getEmployee(id : int)：获取指定ID的员工对象<ul><li>参数：指定员工的 ID</li><li>返回：指定员工对象</li><li>异常：找不到指定的员工</li></ul></li><li>在 service 子包下提供自定义异常类：TeamException</li><li>另外，可根据需要自行添加其他方法或重载构造器</li></ul><h4 id="TeamService-类的设计"><a href="#TeamService-类的设计" class="headerlink" title="TeamService 类的设计"></a>TeamService 类的设计</h4><ul><li>关于开发团队成员的管理：添加、删除等</li><li>counter 为静态变量，用来为开发团队新增成员自动生成团队中的唯一 ID，即 memberId（应使用增1的方式）</li><li>MAX_MEMBER：表示开发团队最大成员数</li><li>team数组：用来保存当前团队中的各成员对象</li><li>total：记录团队成员的实际人数</li><li>getTeam() ：返回当前团队的所有对象<ul><li>返回：包含所有成员对象的数组，数组大小与成员人数一致</li></ul></li><li>addMember(e: Employee)：向团队中添加成员<ul><li>参数：待添加成员的对象</li><li>异常：添加失败，TeamException 中包含了失败原因</li></ul></li><li>removeMember(memberId: int)：从团队中删除成员<ul><li>参数：待删除成员的 memberId</li><li>异常：找不到指定 memberId 的员工，删除失败</li></ul></li><li>另外，可根据需要自行添加其他方法或重载构造器</li></ul><h3 id="实现-view-包中类"><a href="#实现-view-包中类" class="headerlink" title="实现 view 包中类"></a>实现 view 包中类</h3><ol><li>   按照设计要求编写 TeamView 类，逐一实现各个方法，并编译</li><li>   执行 main 方法中，测试软件全部功能</li></ol><h4 id="TeamView-类的设计"><a href="#TeamView-类的设计" class="headerlink" title="TeamView 类的设计"></a>TeamView 类的设计</h4><ul><li>listSvc 和 teamSvc 属性：供类中的方法使用</li><li>enterMainMenu()：主界面显示及控制方法</li><li>以下方法仅供 enterMainMenu() 调用：<ul><li>listAllEmployees()：以表格形式列出公司所有成员</li><li>getTeam()：显示团队成员列表操作</li><li>addMember()：实现添加成员操作</li><li>deleteMember()：实现删除成员操作</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在学习完 &lt;a href=&quot;/Java%E5%9F%BA%E7%A1%80&quot;&gt;Java 基础编程&lt;/a&gt;的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>从 2020 年的视角看线性代数</title>
    <link href="http://blog.zhuangzhihao.top/%E4%BB%8E2020%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://blog.zhuangzhihao.top/%E4%BB%8E2020%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</id>
    <published>2021-09-19T16:00:00.000Z</published>
    <updated>2022-05-05T12:44:43.480Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2020 年 MIT 数学教授 Gilbert Strang 录制了一个关于线性代数的学习和教学的一个新的、启发性的课程，从矩阵 A 的列空间和组合这些列的乘法 Ax 开始，包括了线性代数的概览、正交向量、特征值和特征向量、以及奇异值和奇异向量等方面的内容。</p></blockquote><a id="more"></a><h3 id="矩阵的列空间"><a href="#矩阵的列空间" class="headerlink" title="矩阵的列空间"></a>矩阵的列空间</h3><h4 id="常用矩阵"><a href="#常用矩阵" class="headerlink" title="常用矩阵"></a>常用矩阵</h4><ul><li><p>$A_{0}=\begin{bmatrix}<br>1 &amp; 3 &amp; 2 \<br>4 &amp; 12 &amp; 8 \<br>2 &amp; 6 &amp; 4<br>\end{bmatrix}$</p><ul><li>$A_{0}$ 所有的行向量在同一个方向并且所有的列向量在同一个方向</li></ul></li><li><p>$A_{1}=\begin{bmatrix}<br>1 &amp; 4 &amp; 2 \<br>4 &amp; 1 &amp; 3 \<br>5 &amp; 5 &amp; 5<br>\end{bmatrix}$</p><ul><li>$A_{1}$ 第一行加第二行等于第三行</li></ul></li><li><p>对称矩阵</p><ul><li><p>$S_{2}=\begin{bmatrix}<br>2 &amp; -1 \<br>-1 &amp; 2<br>\end{bmatrix}$</p></li><li><p>$S_{3}=\begin{bmatrix}<br>1 &amp; -1 &amp; 0 \<br>-1 &amp; 2 &amp; -1 \<br>0 &amp; -1 &amp; 1<br>\end{bmatrix}$</p></li><li><p>$S_{4}=\begin{bmatrix}<br>2 &amp; -1 &amp; 0 \<br>-1 &amp; 2 &amp; -1 \<br>0 &amp; -1 &amp; 2<br>\end{bmatrix}$</p></li></ul></li><li><p>正交矩阵</p><ul><li>$Q_{5}=\begin{bmatrix}<br>\cos \theta  &amp; -\sin \theta  \<br>sin\theta  &amp; \cos \theta<br>\end{bmatrix}$</li></ul></li><li><p>$A_{6}=\begin{bmatrix}<br>3 &amp; 0 \<br>4 &amp; 5<br>\end{bmatrix}$</p></li></ul><h4 id="A-的列空间（列的所有线性组合）"><a href="#A-的列空间（列的所有线性组合）" class="headerlink" title="A 的列空间（列的所有线性组合）"></a>A 的列空间（列的所有线性组合）</h4><ul><li><p>将矩阵乘以向量</p><ul><li><p>$Ax=\begin{bmatrix} 1 &amp; 4 &amp; 5 \ 3 &amp; 2 &amp; 5 \ 2 &amp; 1 &amp; 3 \end{bmatrix}\begin{bmatrix} x_{1} \ x_{2} \ x_{3} \end{bmatrix}=\begin{bmatrix} 1 \ 3 \ 2 \end{bmatrix}x_{1}+\begin{bmatrix} x \ 2 \ 1 \end{bmatrix}x_{2}+\begin{bmatrix} 5 \ 5 \ 3 \end{bmatrix}x_{3}$</p></li><li><p>$Ax$ 为一种特殊的列的线性组合</p></li><li><p>$A$ 的列空间 = $C(A)$ = 所有 $Ax$ 向量 = 各列的所有线性组合</p></li><li><p>$C(A)$ 是一个平面</p></li></ul></li></ul><h4 id="列空间的基"><a href="#列空间的基" class="headerlink" title="列空间的基"></a>列空间的基</h4><ul><li><p>$A=CR=\begin{bmatrix}<br>1 &amp; 4 \<br>3 &amp; 2 \<br>2 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br>1 &amp; 0 &amp; 1 \<br>0 &amp; 1 &amp; 1<br>\end{bmatrix}$</p><ul><li><p>行秩 = 列秩 = r = 2</p></li><li><p>C 是平面的两个独立列向量，而 R 则表示了 A 是如何通过 C 中的两个向量重组 A 的</p></li><li><p>R 的 r 行是行空间的一组基</p></li></ul></li><li><p>$A = CR$ 表明 A 的行秩等于列秩 </p><ul><li>C 的 r 列相互线性独立（由定义可知）</li><li>A 的每一列都是（C 的）这 r 列的线性组合（因为 A = CR）</li><li>R 的 r 行相互线性独立（这 r 列包含了 r × r 的矩阵 I ）</li><li>A 的每一行都是（C 的）这 r 行的线性组合（因为 A = CR）</li></ul></li><li><p>核心内容 </p><ul><li>C 的 r 列组成了 A 的列空间的基：维度 r </li><li>R 的 r 列组成了 A 的行空间的基：维度 r</li></ul></li><li><p>基包含两个向量 </p><ul><li>A 的秩等于 r = 2 </li><li>$n − r = 3 − 2 = 1$</li></ul></li><li><p>计数定理 </p><ul><li>$Ax = 0$ 有一组解 $x = (1, 1, −1)$ 有 $n − r$ 组独立解可使 $Ax = 0$ 成立</li></ul></li></ul><h4 id="秩为-1-的矩阵-A"><a href="#秩为-1-的矩阵-A" class="headerlink" title="秩为 1 的矩阵 A"></a>秩为 1 的矩阵 A</h4><ul><li>如果 A 的任意一列均为第一列的若干倍，那么 A 的每一行均为某行的若干倍</li><li>用 A = CR 来证明<ul><li>C 当中的一列 $v$ ⇒ R 当中的一行 $w$</li><li>$A=\left[ v\right] ^{\left[ w\right] }$ ⇒ 每一行都是 $w$ 的倍数</li></ul></li></ul><h4 id="A-CR-的优良性质"><a href="#A-CR-的优良性质" class="headerlink" title="A = CR 的优良性质"></a>A = CR 的优良性质</h4><ul><li>C 的列直接来源于 A：体现了此公式的内涵</li><li>R 变成了A 的行化简阶梯形</li><li>“行秩 = 列秩”这一结论变得显然：C = 列的基，R = 行的基</li></ul><h4 id="A-CR-不好的性质"><a href="#A-CR-不好的性质" class="headerlink" title="A = CR 不好的性质"></a>A = CR 不好的性质</h4><ul><li>C 和 R 可能是病态矩阵</li><li>如果 A 是可逆的，则有 C = A 和 R = I ⇒ A = AI，原地打转</li></ul><h3 id="线性代数概览"><a href="#线性代数概览" class="headerlink" title="线性代数概览"></a>线性代数概览</h3><h4 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h4><ul><li>若 $Ax = 0$ 则有 $\begin{bmatrix} 1 \ \vdots \ m \end{bmatrix}\left[ x\right]=\begin{bmatrix} 0 \ \vdots \ 0 \end{bmatrix}$，x 与 A 的各列均正交<ul><li>每个处于 A 的零空间当中的 x 都与 A 的行空间正交 </li><li>每个处于 $A^T$ 的零空间当中的 y 都与 A 的列空间正交</li></ul></li><li>$N\left( A\right) \bot C\left( A^{T}\right) $ 与 $N\left( A^{T}\right) \bot C\left( A\right) $<ul><li>两对正交子空间，其中一对子空间的维度之和等于 n，另一对等于 m</li></ul></li></ul><h4 id="宏观视角下的线性代数"><a href="#宏观视角下的线性代数" class="headerlink" title="宏观视角下的线性代数"></a>宏观视角下的线性代数</h4><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B001.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B001.png" srcset="data:image/png;base64,666" style="zoom:67%;"></li><li>一对子空间处于 $R_{n}$ 之中，另一对处于$R_{m}$ 当中</li><li>从行空间变换为列空间——由此可知 A 是可逆的</li></ul><h4 id="列与行相乘（六组因式）"><a href="#列与行相乘（六组因式）" class="headerlink" title="列与行相乘（六组因式）"></a>列与行相乘（六组因式）</h4><ul><li>A = BC = 秩为 1 的矩阵之和（列乘以行：外积）</li><li>对矩阵相乘的全新理解（高层次），每次拿一列乘以一行是低层次的<ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B002.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B002.png" srcset="data:image/png;base64,666" style="zoom:67%;"></li></ul></li><li>$A=\begin{bmatrix} 2 &amp; 3 \ 4 &amp; 7 \end{bmatrix}=\begin{bmatrix} 1 &amp; 0 \ 2 &amp; 1 \end{bmatrix}\begin{bmatrix} 2 &amp; 3 \ 0 &amp; 1 \end{bmatrix}=LU$ （将矩阵拆分成上下两个三角矩阵）<ul><li>$2x+3y=7$ ， $4x+7y=15$  ⇒ $x=2,y=1$</li><li>若两行发生交换，则 $PA = LU$ （P 指的是排列矩阵）</li></ul></li></ul><h4 id="用消元来解Ax-b（因式-A-LU）"><a href="#用消元来解Ax-b（因式-A-LU）" class="headerlink" title="用消元来解Ax = b（因式 A = LU）"></a>用消元来解Ax = b（因式 A = LU）</h4><ul><li>下三角矩阵 L 乘以上三角矩阵 U</li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B003.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B003.png" srcset="data:image/png;base64,666" style="zoom:67%;"></li></ul><h3 id="正交向量"><a href="#正交向量" class="headerlink" title="正交向量"></a>正交向量</h3><h4 id="正交向量-–-矩阵-–-子空间"><a href="#正交向量-–-矩阵-–-子空间" class="headerlink" title="正交向量 – 矩阵 – 子空间"></a>正交向量 – 矩阵 – 子空间</h4><ul><li>$X^{T}y=0,y^{T}x=0,\left( x+y\right) ^{T}\left( x+y\right)=x^{T}<em>{x}+y^{T}</em>{y}$ （直角三角形）</li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B004.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B004.png" srcset="data:image/png;base64,666" style="zoom:67%;"></li><li>$Q=\dfrac{1}{3}\begin{bmatrix} -1 &amp; 2 \ 2 &amp; -1 \ 2 &amp; 2 \end{bmatrix}$ ，$Q^{T}Q=I,QQ^{T}\neq I$ ，$QQ^TQQ^T = QQ^T$</li></ul><h4 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h4><h3 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h3><h3 id="奇异值和奇异向量"><a href="#奇异值和奇异向量" class="headerlink" title="奇异值和奇异向量"></a>奇异值和奇异向量</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2020 年 MIT 数学教授 Gilbert Strang 录制了一个关于线性代数的学习和教学的一个新的、启发性的课程，从矩阵 A 的列空间和组合这些列的乘法 Ax 开始，包括了线性代数的概览、正交向量、特征值和特征向量、以及奇异值和奇异向量等方面的内容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="慕课MOOC" scheme="http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"/>
    
    
  </entry>
  
  <entry>
    <title>微分学重点</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BE%AE%E5%88%86%E5%AD%A6%E9%87%8D%E7%82%B9/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BE%AE%E5%88%86%E5%AD%A6%E9%87%8D%E7%82%B9/</id>
    <published>2021-09-04T16:00:00.000Z</published>
    <updated>2022-05-05T12:45:09.227Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微分学重点的十二章关于导数的课程深入挖掘了微积分的子领域，“微分”。 与微积分重点的课程一样，MIT 数学教授 Gilbert Strang 解释了每个主题如何应用于现实生活中，是对微积分重点的补充，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。</p></blockquote><a id="more"></a><h3 id="极限和连续"><a href="#极限和连续" class="headerlink" title="极限和连续"></a>极限和连续</h3><ul><li><p> 极限定义：当 $n\rightarrow \infty$ 时，$a_{n}\rightarrow A$</p></li><li><p>洛必达法则：假设 $f(x)$ 和 $g(x)$ 都收敛于 0</p><ul><li> $\dfrac{f\left( x\right) }{g\left( x\right) }=\dfrac{\dfrac{\Delta f}{\Delta x}}{\dfrac{\Delta g}{\Delta x}}\rightarrow \dfrac{s}{t}$</li></ul></li><li><p> 可导必然连续，连续不一定可导</p></li><li><p> 连续定义：对任取 $\varepsilon$，都能找到 $\delta$，满足如果 $\left| x-a\right| &lt;\delta$，则 $\left| f\left( x\right) -f\left( a\right) \right| &lt;\varepsilon$</p></li></ul><h3 id="sinx-和-cosx-的导数"><a href="#sinx-和-cosx-的导数" class="headerlink" title="$sinx$ 和 $cosx$ 的导数"></a>$sinx$ 和 $cosx$ 的导数</h3><ul><li><p>用 $sin$ 和 $cos$ 表示勾股定理</p><ul><li><p>$a^2+b^2=c^2$ $\rightarrow$ $\dfrac{a^{2}}{c^{2}}+\dfrac{b^{2}}{c^{2}}=1$ </p></li><li><p>$\left( \cos \theta \right) ^{2}+\left( \sin \theta \right) ^{2}=1$</p></li></ul></li><li><p>$\dfrac{d}{dx}\sin x=\dfrac{\Delta \left( \sin x\right) }{\Delta x}=\dfrac{\sin \left( x+\Delta x\right) -\sin x}{\Delta x}$</p><ul><li><p>因为 $\sin \left( x+\Delta x\right) =\sin x\cos \Delta x+\cos x\sin \Delta x$</p></li><li><p>所以原式 = $\dfrac{sinx\left( \cos \Delta x-1\right) }{\Delta x}+\dfrac{\cos x\sin \Delta x}{\Delta x}$</p></li><li><p>又因为 $\dfrac{\cos \left( \Delta x-1\right) }{\Delta x}\rightarrow 0$ 且 $\dfrac{\sin \Delta x}{\Delta x}\rightarrow 1$</p></li><li><p>所以 $\dfrac{d}{dx}\sin x=\cos x$</p></li></ul></li><li><p>$\dfrac{d}{dx}\cos x=\dfrac{\Delta \left( \cos x\right) }{\Delta x}=\dfrac{\cos \left( x+\Delta x\right) -\cos x}{\Delta x}$</p><ul><li><p>因为 $\cos \left( x+\Delta x\right) =\cos x\cos \Delta x-\sin x\sin \Delta x$</p></li><li><p>所以原式 = $\dfrac{cos\left( \cos \Delta x-1\right) }{\Delta x}-\dfrac{\sin x\sin \Delta x}{\Delta x}$</p></li><li><p>所以 $\dfrac{d}{dx}\cos x=-\sin x$</p></li></ul></li><li><p>$sinx$ 和 $cosx$ 的导数</p><ul><li><p>$\dfrac{d}{dx}\sin x=\cos x$</p></li><li><p>$\dfrac{d}{dx}\cos x=-\sin x$</p></li></ul></li></ul><h3 id="乘法法则和除法法则"><a href="#乘法法则和除法法则" class="headerlink" title="乘法法则和除法法则"></a>乘法法则和除法法则</h3><ul><li><p>$p(x)=f(x)g(x)$</p><ul><li><p>$\dfrac{\Delta p}{\Delta x}=\dfrac{f\Delta g}{\Delta x}+\dfrac{g\Delta f}{\Delta x}+\dfrac{\Delta f{\Delta }g}{\Delta x}$</p></li><li><p>乘法法则：$\dfrac{dp}{dx}=f\left( x\right) \dfrac{dg}{dx}+g\left( x\right) \dfrac{df}{dx}$</p></li><li><p>$\dfrac{d}{dx}x^{n}=nx^{n-1}$</p></li><li><p>$y=x^2sinx$：$\dfrac{dy}{dx}=x^{2}\cos x+2xsinx$</p></li></ul></li><li><p>$q(x)=\dfrac{f(x)}{g(x)}$</p><ul><li><p>$f(x)=g(x)q(x)$</p></li><li><p>$\dfrac{df}{dx}=g\left( x\right) \dfrac{dq}{dx}+q\left( x\right) \dfrac{dg}{dx}=g\left( x\right) \dfrac{dq}{dx}+\dfrac{f\left( x\right) }{g\left( x\right) }\dfrac{dg}{dx}$</p></li><li><p>$g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}=g(x)^{2}\dfrac{dq}{dx}$</p></li><li><p>除法法则：$\dfrac{dq}{dx}=\dfrac{g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}}{g\left( x\right) ^{2}}$</p></li></ul></li></ul><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><ul><li><p>函数链（复合函数）：$y=g(x)$，$z=f(y)$</p><ul><li>求导：$\dfrac{dz}{dx}=\dfrac{dz}{dy}\dfrac{dy}{dx}$</li></ul></li><li><p>$sin(3x)$ 的导数：$3cos(3x)$</p></li><li><p>$\dfrac{1}{\sqrt{1-x^{2}}}$ 的导数：$\left( -\dfrac{1}{2}\left( 1-x^{2}\right) ^{-3}\right) -2x=x\left( 1-x^{2}\right) ^{-\dfrac{3}{2}}$</p></li><li><p>$e^{-\dfrac{x^{2}}{2}}$ 的导数：$-x\cdot e^{-\dfrac{x^{2}}{2}}$</p><ul><li>二阶导数：$\left( -x\right) \left( -xe^{-\dfrac{x^{2}}{2}}\right) +\left( e^{-\dfrac{x^{2}}{2}}\right) \left( -1\right)=(x^2-1)\cdot e^{-\dfrac{x^{2}}{2}}$</li></ul></li></ul><h3 id="反函数-f-1-left-y-right-与对数函数-x-lny"><a href="#反函数-f-1-left-y-right-与对数函数-x-lny" class="headerlink" title="反函数 $f^{-1}\left( y\right)$ 与对数函数 $x=lny$"></a>反函数 $f^{-1}\left( y\right)$ 与对数函数 $x=lny$</h3><ul><li><p>$y=f(x)$ 的反函数：$x=f^{-1}(y)$，原函数和反函数关于 $y=x$ 对称</p></li><li><p>$y=e^{x}$ 的反函数：$x=lny$</p></li><li><p>对数函数的性质</p><ul><li><p>$\ln(xy) =\ln x+\ln y$</p></li><li><p>$ln(y^n)=nlny$</p></li></ul></li><li><p>$\dfrac{d}{dy}\left( \ln y\right) =\dfrac{1}{y}$</p></li></ul><h3 id="对数函数-lny-和反三角函数-sin-1-y-的导数"><a href="#对数函数-lny-和反三角函数-sin-1-y-的导数" class="headerlink" title="对数函数 $lny$ 和反三角函数 $sin^{-1}(y)$ 的导数"></a>对数函数 $lny$ 和反三角函数 $sin^{-1}(y)$ 的导数</h3><ul><li><p>令 $y=e^x$</p><ul><li><p>$\ln \left( e^{x}\right) =x$ 两边求导 $\dfrac{d}{dy}\left( \ln y\right) e^{x}=1$</p></li><li><p>$\dfrac{d}{dy}\left( \ln y\right) =\dfrac{1}{e^{x}}=\dfrac{1}{y}$</p></li></ul></li><li><p>$x=\sin ^{-1}y=\arcsin y$</p><ul><li><p>$y=\sin \left( \sin ^{-1}y\right)$ 两边求导 $1=\cos \left( \sin ^{-1}y\right) \dfrac{d\sin ^{-1}y}{dy}$</p></li><li><p>$1=\sqrt{1-y^{2}}\dfrac{d}{dy}\sin ^{-1}y$</p></li><li><p>$\dfrac{d}{dy}\sin ^{-1}y=\dfrac{1}{\sqrt{1-y^{2}}}$</p></li></ul></li><li><p>同理：$\dfrac{d}{dy}\cos ^{-1}y=\dfrac{-1}{\sqrt{1-y^{2}}}$，$\dfrac{d}{dy}\tan ^{-1}\left( y\right) =\dfrac{1}{1+y^{2}}$</p></li></ul><h3 id="增长率和对数图"><a href="#增长率和对数图" class="headerlink" title="增长率和对数图"></a>增长率和对数图</h3><ul><li><p>线性增长：$cx,x^{2},x^{3},\ldots$</p></li><li><p>指数增长：$2^{x},e^{x},10^{x},\ldots$</p></li><li><p>阶乘：$2^{x},e^{x},10^{x},\ldots$</p></li><li><p>对数图</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/微积分重点04.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/微积分重点04.png" srcset="data:image/png;base64,666" style="zoom: 50%;"></li></ul></li><li><p>线性拟合</p><ul><li><p>$y=Ax^{n}\rightarrow \log y=\log A+n\log x$</p></li><li><p>$y=B\cdot 10^{cx}\rightarrow \log y=\log B+cx$</p></li></ul></li></ul><h3 id="线性近似和牛顿法"><a href="#线性近似和牛顿法" class="headerlink" title="线性近似和牛顿法"></a>线性近似和牛顿法</h3><ul><li><p>取 $x=a$，已知 $\dfrac{df}{dx}=f’\left( a\right) =\lim _{x\rightarrow a}\dfrac{f\left( x\right) -f\left( a\right) }{x-a}$，求 $f(x)$</p></li><li><p>线性近似：函数在 a 点一阶泰勒展开</p><ul><li><p>$f’\left( a\right) \approx \dfrac{f\left( x\right) -f\left( a\right) }{x-a}$</p></li><li><p>$f\left( x\right) \approx f\left( a\right) +\left( x-a\right) f’\left( a\right)$</p></li></ul></li><li><p>牛顿法</p><ul><li><p>令 $F(x)=0$</p></li><li><p>$x-a\approx \dfrac{-F\left( a\right) }{F’\left( a\right) }$</p></li></ul></li><li><p>近似法求 $\sqrt{9.06}$</p><ul><li><p>$f\left( x\right) =\sqrt{x}=x^{\dfrac{1}{2}}$</p></li><li><p>$f’\left( x\right) =\dfrac{1}{2}x^{-\dfrac{1}{2}}=\dfrac{1}{\sqrt[2] {x}}$</p></li><li><p>取 $a=9$，$f(a)=\sqrt9=3$，$f’(a)=\dfrac{1}{6}$</p></li><li><p>$\sqrt{9.06}\approx 3+\left( 9.06-9\right) \dfrac{1}{6}=3.01$</p></li></ul></li><li><p>近似法求 $e^{0.01}$</p><ul><li><p>$f\left( x\right) =e^{x}$（$x=0.01$）</p></li><li><p>取 $a=0$，$f(a)=e^0=1$，$f’(a)=e^0=1$</p></li><li><p>$e^{x}=e^{0=01}=1+\left( 0.d-0\right) \cdot 1=1.01=1+x$</p></li></ul></li><li><p>牛顿法求 $\sqrt{9.06}$</p><ul><li><p>$F\left( x\right) =x^{2}-9.06=0$</p></li><li><p>取 $a=3$，$F(a)=9-9.06=-0.06$，$F’(a)=2a=6$</p></li><li><p>$x-3\approx \dfrac{0.06}{6}=0.01$</p></li></ul></li></ul><h3 id="幂级数和欧拉公式"><a href="#幂级数和欧拉公式" class="headerlink" title="幂级数和欧拉公式"></a>幂级数和欧拉公式</h3><ul><li><p>泰勒级数：$f\left( x\right) =f\left( 0\right) +f’\left( 0\right) \dfrac{x}{1}+f’’\left( 0\right) \dfrac{x^{2}}{2}+\ldots +f^{\left( n\right) }\left( 0\right) \dfrac{x^{n}}{n!}$</p><ul><li>$x^n$ 的 n 阶导：$n!$</li></ul></li><li><p>使用泰勒级数展开的幂级数</p><ul><li><p>$e^{x}=1+x+\dfrac{1}{2}x^{2}+\dfrac{1}{6}x^{3}+\ldots +\dfrac{1}{n!}x^{n}$</p></li><li><p>$\sin x=x-\dfrac{x^{3}}{3!}+\dfrac{x^{5}}{5!}\ldots$ 奇级数</p></li><li><p>$\cos x=1-\dfrac{x^{2}}{2!}+\dfrac{x^{4}}{4!}\ldots$ 偶级数</p></li></ul></li><li><p>欧拉公式：将 $e^x$ 级数中的 $x$ 考虑为虚数 $i$</p><ul><li><p>$e^{ix}=1+ix+\dfrac{1}{2!}\left( ix\right) ^{2}+\dfrac{1}{3!}\left( ix\right) ^{3}+\ldots$</p></li><li><p>实数、虚数分离：$e^{ix}=\left( 1-\dfrac{1}{2!}x^{2}+\ldots \right) +i\left( x-\dfrac{1}{3!}x^{3}+\ldots \right)$</p></li><li><p>因此：$e^{ix}=\cos x+i\sin x$</p></li><li><p>同理：$e^{-ix}=\cos x-i\sin x$</p></li></ul></li><li><p>几何级数：$\dfrac{1}{1-x}=1+x+x^{2}+x^{3}+\ldots ( \left| x\right| &lt; 1)$</p></li><li><p>将几何级数逐项积分：$-ln \left( 1-x\right) =x+\dfrac{x^{2}}{2}+\dfrac{x^{3}}{3}+\dfrac{x^{4}}{4}+\ldots ( \left| x\right| &lt; 1)$</p></li></ul><h3 id="关于运动的微分方程"><a href="#关于运动的微分方程" class="headerlink" title="关于运动的微分方程"></a>关于运动的微分方程</h3><ul><li><p>微分方程就是函数的导数和函数本身之间存在的关系</p></li><li><p>常系数二阶线性微分方程：$m\dfrac{d^{2}y}{dt^{2}}+2r\dfrac{dy}{dt}+ky=0$</p><ul><li><p>$m=0$ 时，$\dfrac{dy}{dt}=ay\rightarrow y=ce^{at}$</p></li><li><p>$r=0$ 时，$\dfrac{d^{2}y}{dt^{2}}=-\omega ^{2}y$ （$\omega ^{2}= \dfrac{k}{m}$）$\rightarrow y=C\cos \omega t+D\sin \omega t$</p></li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B905.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B905.png" srcset="data:image/png;base64,666" style="zoom: 50%;"></li></ul></li><li><p>令 $y=e^{\lambda t}$ 满足方程 $m\lambda ^{2}e^{\lambda t}+2r\lambda e^{\lambda t}+ke^{\lambda t}=0$</p><ul><li><p>$m\lambda ^{2}+2r\lambda +k=0$</p></li><li><p>$\lambda =\dfrac{-r\pm \sqrt{r^{2}-km}}{m}$</p></li><li><p>$y=Ce^{\lambda _{1}t}+De^{\lambda _{2}t}$</p></li><li><p>若 $\lambda _{1}=\lambda _{2}$，$y=Ce^{\lambda t}+Dte^{\lambda t}$</p></li></ul></li><li><p>当 $m=1,r=3,k=10$ 时，$1y’’+6y’+10y=0$</p><ul><li><p>$\lambda ^{2}+6\lambda +10=0$</p></li><li><p>$\lambda =-3\pm i$</p></li><li><p>$y\left( t\right) =Ce^{\left( -3+i\right) t}+De^{\left( -3-i\right) t}$</p></li><li><p>由欧拉公式：$y\left( t\right) =Ae^{-3t}\cos t+Be^{-3t}\sin t$</p></li></ul></li></ul><h3 id="关于增长的微分方程"><a href="#关于增长的微分方程" class="headerlink" title="关于增长的微分方程"></a>关于增长的微分方程</h3><ul><li><p>微分方程 $\dfrac{dy}{dt}=cy$，对于任意 A 有解 $y\left( t\right) =Ae^{ct}$</p><ul><li>$y\left( t\right) =y\left( 0\right) e^{ct}$</li></ul></li><li><p>增加初始常数：$\dfrac{dy}{dt}=cy+s$</p><ul><li><p>$\dfrac{d}{dt}\left( y+\dfrac{s}{c}\right) =c\left( y+\dfrac{s}{c}\right)$</p></li><li><p>$y\left( t\right) =-\dfrac{s}{c}+\left( y\left( 0\right) +\dfrac{s}{c}\right) e^{ct}$</p></li></ul></li><li><p>人口增长方程：$\dfrac{dP}{dt}=cP-sP^{2}$，$c$ 为增长率而 $s$ 为竞争因素</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B906.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B906.png" srcset="data:image/png;base64,666" style="zoom: 50%;"></li><li><p>令 $y=\dfrac{1}{P}$，$\dfrac{dy}{dt}=-\dfrac{\dfrac{dP}{dt}}{P^{2}}=\dfrac{\left( cP+sP^{2}\right) }{P^{2}}=s-cP=s-cy$</p></li><li><p>$y\left( t\right) =\dfrac{s}{c}+Ae^{-ct}=\dfrac{s}{c}+\left( y\left( 0\right) -\dfrac{s}{c}\right) e^{-ct}$</p></li><li><p>$\dfrac{1}{p\left( t\right) }-\dfrac{s}{c}=\left( \dfrac{1}{p(0)}-\dfrac{s}{c}\right) e^{-ct}$</p></li></ul></li><li><p>人口增长方程二阶导数：$\dfrac{d^{2}P}{dt^{2}}=\dfrac{d}{dt}\left( cP-sP^{2}\right) =\left( c-2sP\right) \dfrac{dP}{dt}$</p><ul><li>$p=\dfrac{c}{2s}$ 时，$\dfrac{d^{2}P}{dt^{2}}=0$（拐点，增长率开始放缓）</li></ul></li></ul><h3 id="微分学总结"><a href="#微分学总结" class="headerlink" title="微分学总结"></a>微分学总结</h3><h4 id="六函数"><a href="#六函数" class="headerlink" title="六函数"></a>六函数</h4><table><thead><tr><th align="center">积分</th><th align="center"></th><th align="center">导数</th></tr></thead><tbody><tr><td align="center">$\dfrac{x^{n+1}}{\left( n+1\right) },n\neq -1$</td><td align="center">$x^n$</td><td align="center">$nx^{n-1}$</td></tr><tr><td align="center">$-cosx$</td><td align="center">$sinx$</td><td align="center">$cosx$</td></tr><tr><td align="center">$sinx$</td><td align="center">$cosx$</td><td align="center">$-sinx$</td></tr><tr><td align="center">$\dfrac{e^{cx}}{c}$</td><td align="center">$e^{cx}$</td><td align="center">$ce^{cx}$</td></tr><tr><td align="center">$x\ln x-x$</td><td align="center">$lnx$</td><td align="center">$\dfrac{1}{x}$</td></tr><tr><td align="center">斜坡函数</td><td align="center">分段函数</td><td align="center">$\delta$ 函数</td></tr></tbody></table><h4 id="六法则"><a href="#六法则" class="headerlink" title="六法则"></a>六法则</h4><ul><li><p>加法法则：和的导数等于导数的和</p><ul><li>$af\left( x\right) +bg\left( x\right) \rightarrow a\dfrac{df}{dx}+b\dfrac{dg}{dx}$</li></ul></li><li><p>乘法法则：上乘下导加下乘上导</p><ul><li>$f\left( x\right) g\left( x\right) \rightarrow f\left( x\right) \dfrac{dg}{dx}+g\left( x\right) \dfrac{df}{dx}$</li></ul></li><li><p>除法法则：下平方分之下乘上导减上乘下导</p><ul><li>$\dfrac{f\left( x\right) }{g\left( x\right) }\rightarrow  \dfrac{g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}}{g\left( x\right) ^{2}}$</li></ul></li><li><p>链式法则</p><ul><li>$f\left( g\left( x\right) \right) \rightarrow \dfrac{df}{dy}\dfrac{dy}{dx}$</li></ul></li><li><p>反函数的导数等于原函数的导数分之一</p><ul><li>$x=f^{-1}\left( y\right) \rightarrow \dfrac{dx}{dy}=\dfrac{1}{\dfrac{dy}{dx}}$</li></ul></li><li><p>洛必达法则：$\dfrac{0}{0}$ 或 $\dfrac{\infty }{\infty }$</p><ul><li>$\dfrac{f\left( x\right) }{g\left( x\right) }\rightarrow \dfrac{\dfrac{dt}{dx}}{\dfrac{dg}{dx}}$</li></ul></li></ul><h4 id="六定理"><a href="#六定理" class="headerlink" title="六定理"></a>六定理</h4><ul><li><p>微积分基本定理</p><ul><li><p>如果函数 $f(x)=\int _{a}^{x}s\left( t\right) dt$，那么函数的导数为 $\dfrac{df}{dx}=s\left( x\right) $</p></li><li><p>如果函数的导数为 $\dfrac{df}{dx}=s\left( x\right) $，那么导数的积分（原函数）为 $\int _{a}^{b}s\left( x\right) dx=f\left( b\right) -f\left( a\right) $</p></li></ul></li><li><p>介值定理（全值定理）</p><ul><li><p>对于 $a\leq x\leq b$ 区间上的连续函数</p></li><li><p>一定能取到最大值 $M$ 和最小值 $m$，使得 $[M,m]$ 中的任意值都存在函数上的点与之对应</p></li><li><p>连续函数的一个区间内的函数值肯定介于最大值 $M$ 和最小值 $m$之间</p></li></ul></li><li><p>中值定理</p><ul><li>如果函数 $f(x)$ 在闭区间 $[a,b]$ 上连续，在开区间 $(a,b)$ 内可导，那么在 $(a,b)$ 内至少有一点 $\varepsilon $，使 $f\left( b\right) -f\left( a\right) =f\left( \varepsilon \right) \left( b-a\right) $ 成立</li></ul></li><li><p>泰勒级数</p><ul><li><p>$f\left( x\right) =f\left( a\right) +f’\left( a\right) \left( x-a\right) +\dfrac{1}{2}f’’\left( a\right) \left( x-a\right) ^{2}+\ldots =\sum ^{\infty }_{n=0}\dfrac{1}{n!}f^{\left( n\right) }\left( a\right) \left( x-a\right) ^{n}$</p></li><li><p>若级数截断于 $\left( x-a\right) ^{n}$ 项，余项为：$\dfrac{1}{\left( n+1\right) !}f^{\left( n+1\right) }\left( c\right) \left( x-a\right) ^{\left( n+1\right) }$</p></li><li><p>当 $a=0$ 时，$f\left( x\right)=\sum ^{\infty }_{n=0}\dfrac{1}{n!}f^{\left( n\right) }\left( 0\right) \left( x\right) ^{n}$</p></li></ul></li><li><p>二项式定理</p><ul><li><p>帕斯卡三角：<img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B907.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B907.png" srcset="data:image/png;base64,666" style="zoom:80%;"></p></li><li><p>$(1+x)^p=1+px+\dfrac{P\left( p-1\right) }{\left( 2\right) \left( 1\right) }x^{2}+\dfrac{p\left( p-1\right) \left( p-2\right) }{\left( 3\right) \left( 2\right) \left( 1\right) }x^{3}+\ldots $</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;微分学重点的十二章关于导数的课程深入挖掘了微积分的子领域，“微分”。 与微积分重点的课程一样，MIT 数学教授 Gilbert Strang 解释了每个主题如何应用于现实生活中，是对微积分重点的补充，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="慕课MOOC" scheme="http://blog.zhuangzhihao.top/categories/%E6%85%95%E8%AF%BEMOOC/"/>
    
    
  </entry>
  
</feed>
